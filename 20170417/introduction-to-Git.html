<!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="Merrier说"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><link rel="dns-prefetch" href="http://merrier.wang"><meta name="description" content="Merrier的个人博客"><meta name="keywords" content=""><meta name="robots" content="all"><meta name="google" content="all"><meta name="googlebot" content="all"><meta name="verify" content="all"><meta name="google-site-verification" content="UkMBUrF2qTuMWfmPXWFFmc_pnqCRAxHQY1ndE0Zu1p0"><link rel="apple-touch-icon" href="/images/hexo_others_10.png"><title>一篇绝对能看懂的Git入门教程 | Merrier说</title><link rel="alternate" href="/atom.xml" title="Merrier说" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=9be54fca751d321cf4cde53fe170f6d6"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=d13d6f6bf3dcbaccb347c89baa7f4bd0"><link rel="stylesheet" href="/css/style.css?rev=9a689f858f6a74dab8e5254940cc5a3b"><div class="hide"><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan class='cnzz_stat_icon_1264342320 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s19.cnzz.com/z_stat.php%3Fid%3D1264342320%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"))</script></div><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></head></html><!--[if lte IE 8]><style>
    html{ font-size: 1em }
</style><![endif]--><!--[if lte IE 9]><div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div><![endif]--><body><header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="Merrier"><img src="/images/hexo_others_8.jpeg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>叩首问路，码梦为生</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span><i class="fa fa-bars"></i></span> <a class="navbar-brand" href="http://merrier.wang">Merrier说</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa fa-home"></i> Home</a></li><li role="presentation" class="text-center"><a href="/categories/frontend/"><i class="fa fa-tablet"></i> 前端</a></li><li role="presentation" class="text-center"><a href="/categories/summary/"><i class="fa fa-diamond"></i> 总结</a></li><li role="presentation" class="text-center"><a href="/categories/talk/"><i class="fa fa-coffee"></i> 杂谈</a></li><li role="presentation" class="text-center"><a href="/categories/series/"><i class="fa fa-shopping-cart"></i> 系列专栏</a></li><li role="presentation" class="text-center"><a href="/archives/"><i class="fa fa-archive"></i> 文章归档</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="一篇绝对能看懂的Git入门教程">一篇绝对能看懂的Git入门教程</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a href="/categories/Git">Git</a></span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a href="/tags/git" title="git">git</a> <a href="/tags/教程" title="教程">教程</a></span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2017/04/17</span></span><span class="fa-wrap"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="post-body post-content"><p>不管你是从事什么方面的程序猿，只要你属于这个神秘组织，就必须要对 SVN 或 Git 这种版本控制系统有所了解；和大部分人一样，当初项目负责人告诉我需要学 Git 的时候，只说了这样一句话：“网上很多教程，自己看着学吧”，当然，这句话直到今天我也无力反驳，因为对于一个新鲜的程序猿来说，只需要懂一些 Git 的基本指令就可以了，一些高端指令可能永远都用不到，所以，我就查阅了一些 Git 的教程和手册，整理出这篇对于新手很友好的 Git 入门教程</p><h2 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h2><p>很多 Git 教程都把这一部分的讲解放到很靠后的位置，所以我当初学习的时候并没有把这一部分放在心上；但是现在我觉得，这一部分才是最需要明白的，因为这一部分是非常“真实”的，对于一个之前从来没接触过命令行或一直在 windows 上打游戏、看直播的程序猿来说，这一部分也是最容易理解的</p><p><strong>工作区</strong>：通俗易懂的来说就是你电脑里面的能看到的目录，比如 learngit 的目录。<br><strong>版本库</strong>：工作区有一个隐藏的目录 .git，这是 Git 的版本库。版本库中存了很多东西，其中最重要的就是stage(index)的 <strong>暂存区</strong>。 下面这张图非常清晰的表明了这三者的关系，我就不多说了：</p><div align="center"><img src="/images/hexo_post_237.png" alt="" width="400"></div><p><strong>请牢牢记住这三个概念，因为下面会经常用到</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="生成-ssh"><a href="#生成-ssh" class="headerlink" title="生成 ssh"></a>生成 ssh</h3><p>通过下面的指令可以生成 id_rsa 和 id_rsa.pub 两个文件，不同操作系统这两个文件所在位置不同，id_rsa.pub 里面的所有内容就是你的公钥，直接复制到 GitHub 的 Add SSH key 页面就可以愉快的进行玩耍了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ras -C <span class="string">"email@xxx"</span></span><br></pre></td></tr></table></figure><p>ssh 是一种协议，而 Git 目前支持<a href="http://www.cnblogs.com/lzxianren/p/git2.html" target="_blank" rel="noopener">4种协议</a>——ssh协议，http/s协议，git 协议，本地协议，ssh 协议配置简单，权限管理也比较全面，更重要的是无需密码和 linux 内置（git 是 linus 写的软件，linus 是 linux的作者，所以你懂得），至于 ssh 究竟怎么做的就不在本文介绍了，可以去阮一峰的博客中查找相关资料</p><h3 id="设置用户名"><a href="#设置用户名" class="headerlink" title="设置用户名"></a>设置用户名</h3><p>和现实世界类似，你想和别人进行数据通信，首先得让别人知道你是谁，你的联系方式吧，而和现实世界不同的是，这里的联系方式只能填写邮箱，填写微信或者 QQ 号是木有用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"cc"</span></span><br><span class="line">git config --global user.email <span class="string">"cc@xx"</span></span><br></pre></td></tr></table></figure><h3 id="初始化当前目录的项目"><a href="#初始化当前目录的项目" class="headerlink" title="初始化当前目录的项目"></a>初始化当前目录的项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>还记得上面我们提到的三个概念吗，这里的初始化就是为了在本地目录中添加本地版本库，然后才可以后续的 git 操作。比如初始化之前你的目录是这样的（当前目录为空是因为我是在一个空文件夹的基础上进行初始化的，而实际情况是这里面会有你的项目文件）：</p><div align="center"><img src="/images/hexo_post_189.png" alt="" width="700"></div><p>而执行初始化操作之后：</p><div align="center"><img src="/images/hexo_post_190.png" alt="" width="700"></div><p>从上图可以看到，当前目录中多了 .git 文件夹，这个文件夹就是你的本地的版本库了，里面存储着很多东西，其中包括暂存区；通过短短的一行命令，初始化操作就已经完成了，同时 Git 也为我们创建了第一个分支 master，和一个指向 master 的指针 HEAD，接下来就是一些常用的命令</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>这是一条需要经常使用的命令，因为有时候工作区的改变可能会是“隐性”的，比如你的编辑器自己添加的文件或者其他类型的隐藏文件，而经常查看状态也是检验某些 git 命令是否执行的方法。通过执行这一命令，我们在终端中可能会看到：</p><div align="center"><img src="/images/QQ20170417-153116@2x.png" alt="" width="700"></div><p>从终端的第四行我们可以看到，当我们查看状态时，Git 告诉我们当前分支为 master；第八行的意思是我们没有什么可以 commit 的，说明我们在当前目录下并没有进行修改，所以我们需要进行修改之后再进行后续操作：</p><div align="center"><img src="/images/hexo_post_192.png" alt="" width="700"></div><p>从上图我们可以看到，我在当前目录中新添加了一个文件 octocat.txt，然后我们再通过 <code>git status</code> 查看一下当前工作区的状态：</p><div align="center"><img src="/images/hexo_post_193.png" alt="" width="700"></div><p>这次好像和上次不一样了，Git 告诉我们有一个文件 untracked files 叫做 octocat.txt，同时还提醒你通过 <code>git add &lt;file&gt;...</code> 进行提交，那这里就稍微提一下 git status 时可能看到的当前工作区的文件的状态</p><ul><li>staged：已经添加到暂存区，等待提交的文件</li><li>unstaged：已经发生了改变，但是还没有提交</li><li>untracked：Git 都不知道还有这个文件，所以说明这是一个新添加的文件（就像上面的 octocat.txt）</li><li>deleted：已经从本地删除的文件</li></ul><h3 id="提交工作区修改到暂存区"><a href="#提交工作区修改到暂存区" class="headerlink" title="提交工作区修改到暂存区"></a>提交工作区修改到暂存区</h3><ul><li>git add . // 将工作区所有修改添加到暂存区</li><li>git add filename // 将指定文件添加到暂存区</li></ul><p>还是一开始我们提到的那三个概念，我们在本地进行了修改（新建、修改、删除），但是此时还只是我们自己知道发生了哪些改变，Git 根本都不知道（本地的 Git 都不知道，更别提远程），所以需要进行提交；那么你可能有疑问了，为什么提交到暂存区？直接提交给远程不就完了吗？这里就是 Git 设计的巧妙之处，通过暂存区可以防止你的错误提交（事实证明，这一点很重要）。经过 git add 后，我们再通过 git status 查看一下状态：</p><div align="center"><img src="/images/hexo_post_194.png" alt="" width="700"></div><p>Git 告诉我们它看到了一个新的文件 octocat.txt，并且 to be committed，那么你可能会问了，假如我当前的目录里有好多文件都需要 add 怎么办，难道一次次执行命令吗？当然不需要，从上面的代码块中可以看到，我们可以通过 <code>git add .</code> 提交所有修改，但是<strong>不推荐这种操作</strong>，因为有可能会将一些不想提交的隐藏文件也提交到暂存区了；假如我们当前目录下有很多 .txt 文件等待提交：</p><div align="center"><img src="/images/hexo_post_195.png" alt="" width="700"></div><p>我们可以使用 “*.txt” 匹配到所有的 txt 文件，然后就可以将它们全部提交了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="string">'*.txt'</span></span><br></pre></td></tr></table></figure><h3 id="将暂存区修改添加到本地仓库"><a href="#将暂存区修改添加到本地仓库" class="headerlink" title="将暂存区修改添加到本地仓库"></a>将暂存区修改添加到本地仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'备注信息'</span></span><br></pre></td></tr></table></figure><p>经过多次的 git add，此时的暂存区有好多本地的修改，通过上面的 commit 可以将所有的暂存区的修改添加到本地仓库，所以你可以简单理解为：需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h3 id="push-到远程"><a href="#push-到远程" class="headerlink" title="push 到远程"></a>push 到远程</h3><p>经过上面的一顿折腾，仍然只有本地的 “Git” 知道了我们都做了些什么，如果想让远程仓库也知道，我们需要先和远程仓库建立联系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/try-git/try_git.git</span><br></pre></td></tr></table></figure><p>在这里遇到一个问题：每次 push 都要输入用户名和密码，原因是我们是通过 https 方式进行 push，解决方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin      // 移除</span><br><span class="line">git remote add origin git@github.com:try-git/test.git       // 添加</span><br></pre></td></tr></table></figure><p>此后就不用再输入用户名和密码了，同时我们和远程建立联系以后就不用再 git remote add 了，这就好比你去别人家串门，第一次可能需要你需要查一下地图，第二次的话就直接去找他就行了。接下来就是 push 到远程了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>第一次 push 是需要加 -u 参数的，这个参数是告诉远程我是谁（<a href="https://www.zhihu.com/question/20019419" target="_blank" rel="noopener">git push的-u参数具体含义</a>），还是刚才串门的例子，第一次去别人家串门肯定需要表明身份的，第二次就不再需要了，因为已经知道你是谁了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h3 id="从远程-pull"><a href="#从远程-pull" class="headerlink" title="从远程 pull"></a>从远程 pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>如果别人提交了他们的修改到远程仓库，我们需要从远程 pull 修改到我们的本地，从而保证大家的进度保持同步，比如别人提交了一个 yellow_octocat.txt 文件到远程，我们 git pull 之后：</p><div align="center"><img src="/images/hexo_post_197.png" alt="" width="700"></div><p>Git 告诉我们，你 pull 成功了，新增加了一个文件叫做 yellow_octocat.txt，此时我们的当前目录就多了一个 yellow_octocat.txt（.git 也就是本地版本库也知道了这个文件）</p><div align="center"><img src="/images/hexo_post_198.png" alt="" width="700"></div><h3 id="查看修改的内容"><a href="#查看修改的内容" class="headerlink" title="查看修改的内容"></a>查看修改的内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>有可能别人和我对同一文件进行了修改，所以在 pull 之后需要查看一下都发生了哪些修改:</p><div align="center"><img src="/images/hexo_post_199.png" alt="" width="700"></div><p>其实，git diff 的用法不仅只有这一种，还可以查看暂存区的修改都有哪些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h4><p>假如我们对之前的一个文件 readme.txt 进行了修改，但是现在我发现对这个文件进行的修改都是错的（经常会发生），此时我不想要我对这个文件的修改了，就可以执行下面的命令，然后 readme.txt 就可以回退到我修改之前的样子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout readme.txt</span><br></pre></td></tr></table></figure><h4 id="丢弃暂存区的修改"><a href="#丢弃暂存区的修改" class="headerlink" title="丢弃暂存区的修改"></a>丢弃暂存区的修改</h4><p>和刚才不一样的是，我已经将我的修改提交到暂存区了（也就是说已经执行了 git add readme.txt 命令），此时我想把这个文件的修改从暂存区放回到工作区，就需要执行下面的命令，然后此时的暂存区就不再有 readme.txt 的修改，就像没 git add 过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><p>除了 Git，其他版本控制系统如 SVN 中也有分支管理，但是 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。但是截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即<code>master</code> 分支。<code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<strong><code>HEAD</code> 指向的就是当前分支</strong>。每次提交，<code>master</code> 分支都会向前移动一步，这样，随着你不断提交，<code>master</code> 分支的线也越来越长。</p><div align="center"><img src="/images/hexo_post_1.png" alt="" width="300"></div><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch clean_up</span><br></pre></td></tr></table></figure><p>此时我们在本地创建了一个分支叫做 clean_up，对于 Git 来说，相当于新建了一个指针叫 clean_up，指向和 master 相同的提交，但是此时的 HEAD 仍然指向 master，因为此时我们只是新建了一个分支，并没有切换到 clean_up 分支</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout clean_up</span><br></pre></td></tr></table></figure><p>我们新创建了 clean_up 分支后，可以通过上面的命令将本地的分支切换到 clean_up，此时的 HEAD 就会指向 clean_up</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>为了后面的分支命令展示，我们通过下面的命令将 .txt 文件（注意此时所在的分支仍然是 clean_up）删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm <span class="string">'*.txt'</span></span><br></pre></td></tr></table></figure><p>然后，我们将删除这些文件的修改进行提交（add + commit），此时本地的 clean_up 分支就没有这些 .txt 文件了：</p><div align="center"><img src="/images/hexo_post_200.png" alt="" width="700"></div><p>此时我们再切换到 master 分支（git checkout master）：</p><div align="center"><img src="/images/hexo_post_201.png" alt="" width="700"></div><p>通过上面两张图片，我们可以清晰的看到分支的作用，其实相当于两个平行世界（branch），而你所扮演的就是上帝的角色，想让哪个世界继续进行，就 checkout 哪个分支就可以了。此时如果我们想让 clean_up 分支上做出的改变合并到 master 分支该怎么办呢？</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge clean_up</span><br></pre></td></tr></table></figure><p>上面这段命令执行的前提是你当前的分支是 master，而通过 git merge 某分支可以将某分支的改变合并到当前分支：</p><div align="center"><img src="/images/hexo_post_202.png" alt="" width="700"></div><p>我们通过上面的结果可以看到此时的 master 分支已经没有了 .txt 文件</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d clean_up</span><br></pre></td></tr></table></figure><p>既然我们已经把 clean_up 分支的改变合并到了 master 分支，所以此时我们就不再需要 clean_up 分支了，通过上面的命令可以将该分支删除</p><h2 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h2><p>较为复杂的分支命令的介绍就告一段落了，下面介绍一下和版本相关的一些常用命令</p><h3 id="查看提交的历史记录"><a href="#查看提交的历史记录" class="headerlink" title="查看提交的历史记录"></a>查看提交的历史记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>我们可以通过 git log 查看提交的历史记录（每一次 commit 都是一次记录）：</p><div align="center"><img src="/images/hexo_post_196.png" alt="" width="700"></div><p>从上面的图片可以看到，我们有两次 commit 记录，他们的 id 是很长的黄色字符串，这个 id 和每次提交是一一对应的，同时也对应着相应的版本，而除了 commit id，我们还可以看到提交的作者、日期以及备注信息（这里就体现出了备注信息是多么的重要）</p><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>通过上面的命令，我们可以回退到上个版本，<code>HEAD</code> 为当前版本，<code>HEAD^</code> 为上一个版本，<code>HEAD^^</code> 为上上个版本，如果有 100 个版本 <code>HEAD~100</code>。当然，我们也可以通过上面提到的 commit id 来回到过去的某个版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><p>是不是更感觉自己像是一个上帝了，在 Git 中，你可以随意控制平行世界的发展，需要做的只是输出一行命令而已</p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>上面就是一些我们最常用的 Git 命令，但是 Git 的强大之处远不止这些，下面就简单介绍几种我们可能会用到的命令：</p><h3 id="建立本地分支与远程分支的追踪关系"><a href="#建立本地分支与远程分支的追踪关系" class="headerlink" title="建立本地分支与远程分支的追踪关系"></a>建立本地分支与远程分支的追踪关系</h3><p>当在本地新建分支的时候，可能远程并没有这个分支，所以你需要建立追踪关系，这样你 push 的时候才不会 push 到别的分支上去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream-to=&lt;remote&gt;/branchName  // 建立本地分支与远程分支的追踪关系</span><br><span class="line">git branch --track branchName [remote branch]   // 新建一个分支，并与远程建立追踪关系</span><br></pre></td></tr></table></figure><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><p>这是 Git 的又一神奇命令，它可以让你将任何一次 commit 的修改合并到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick commitId  // 将与 commitId 对应的提交合进当前分支</span><br></pre></td></tr></table></figure><h3 id="bug-分支"><a href="#bug-分支" class="headerlink" title="bug 分支"></a>bug 分支</h3><p>当我们修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除分支；但是如果我们的手头工作没有完成呢，就需要暂时放弃当前没有提交的修改，然后去修复bug，修复完之后再回来恢复原样继续做刚才的工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash     // 暂时放弃未提交的修改</span><br><span class="line">git stash pop    // 恢复</span><br></pre></td></tr></table></figure><h2 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h2><table><thead><tr><th>步骤</th><th>git操作</th></tr></thead><tbody><tr><td>克隆代码</td><td>git clone远端代码</td></tr><tr><td>创建分支</td><td>git checkout -b branch_name</td></tr><tr><td>在分支中开发</td><td>无</td></tr><tr><td>review代码</td><td>无</td></tr><tr><td>第一轮测试</td><td>无</td></tr><tr><td>添加代码至分支</td><td>git add somefile</td></tr><tr><td>提交代码至分支</td><td>“git commit -m “”本次提交注释”””</td></tr><tr><td>切换至主分支</td><td>git checkout master</td></tr><tr><td>获取远端最新代码</td><td>git pull origin master</td></tr><tr><td>合并分支至master分支</td><td>git merge branch_name</td></tr><tr><td>解决合并时产生的冲突</td><td></td></tr><tr><td>第二轮测试</td><td>无</td></tr><tr><td>获取远端最新代码</td><td>git pull origin master</td></tr><tr><td>推送至master分支</td><td>git push origin master</td></tr><tr><td>若无问题，删除本地分支</td><td>git branch -d branch_name</td></tr></tbody></table><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解Git</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰-Git教程</a></li><li><a href="https://try.github.io/levels/1/challenges/1" target="_blank" rel="noopener">在线练习git命令</a></li><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a></li><li><a href="http://www.jianshu.com/p/50892fac6cbc" target="_blank" rel="noopener">实用Git Workflow</a></li><li><a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="noopener">Git Community Book 中文版</a></li></ul><h2 id="另外一些关于-Git-Github-入门的文章"><a href="#另外一些关于-Git-Github-入门的文章" class="headerlink" title="另外一些关于 Git / Github 入门的文章"></a>另外一些关于 Git / Github 入门的文章</h2><ul><li><a href="http://blog.jobbole.com/111187/" target="_blank" rel="noopener">大白话解释 Git 和 GitHub</a></li><li><a href="http://rogerdudler.github.io/git-guide/" target="_blank" rel="noopener">git - the simple guide</a></li><li><a href="https://www.pluralsight.com/blog/software-development/github-tutorial" target="_blank" rel="noopener">GitHub: the beginner’s guide</a></li></ul></div><div class="reward"><div class="reward-wrap">赏<div class="reward-box"><span class="reward-type"><img class="alipay" src="/images/hexo_others_5.png"><b>支付宝打赏</b></span> <span class="reward-type"><img class="wechat" src="/images/hexo_others_6.png"><b>微信打赏</b></span></div></div><p class="reward-tip">听说赞过就能年薪百万</p></div><div class="post-footer"><div>转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="//merrier.wang" target="_blank">Merrier说</a></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="/20170420/imap-smtp-pop3-addresses-for-some-common-mailboxes.html" class="pre-post btn btn-default" title="一些常用邮箱的IMAP&SMTP&POP3地址"><i class="fa fa-angle-left fa-fw"></i> <span class="hidden-lg">上一篇</span> <span class="hidden-xs">一些常用邮箱的IMAP&SMTP&POP3地址</span></a> <a href="/20170416/front-end-performance-optimization.html" class="next-post btn btn-default" title="前端面试系列（12）——前端性能优化"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">前端面试系列（12）——前端性能优化</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><script id="dsq-count-scr" src="https://merrier.disqus.com/count.js" async></script><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script type="text/javascript">if(document.getElementById("disqus_thread")){var disqus_config=function(){this.page.url="http://merrier.wang/20170417/introduction-to-Git.html",this.page.identifier="20170417/introduction-to-Git.html",this.page.title="一篇绝对能看懂的Git入门教程"};!function(){var t=document,e=t.createElement("script");e.async=!0,e.src="https://merrier.disqus.com/embed.js",e.setAttribute("data-timestamp",""+ +new Date),(t.head||t.body).appendChild(e)}()}</script></div></main><aside id="article-toc" role="navigation" class="col-md-4"><div class="widget"><h3 class="title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#工作区与暂存区"><span class="toc-text">工作区与暂存区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成-ssh"><span class="toc-text">生成 ssh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置用户名"><span class="toc-text">设置用户名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化当前目录的项目"><span class="toc-text">初始化当前目录的项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用命令"><span class="toc-text">常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看工作区状态"><span class="toc-text">查看工作区状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提交工作区修改到暂存区"><span class="toc-text">提交工作区修改到暂存区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将暂存区修改添加到本地仓库"><span class="toc-text">将暂存区修改添加到本地仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-到远程"><span class="toc-text">push 到远程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从远程-pull"><span class="toc-text">从远程 pull</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看修改的内容"><span class="toc-text">查看修改的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#撤销修改"><span class="toc-text">撤销修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#丢弃工作区的修改"><span class="toc-text">丢弃工作区的修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#丢弃暂存区的修改"><span class="toc-text">丢弃暂存区的修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分支相关"><span class="toc-text">分支相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#新建分支"><span class="toc-text">新建分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切换分支"><span class="toc-text">切换分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除文件"><span class="toc-text">删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合并分支"><span class="toc-text">合并分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除分支"><span class="toc-text">删除分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#版本相关"><span class="toc-text">版本相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看提交的历史记录"><span class="toc-text">查看提交的历史记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回退版本"><span class="toc-text">回退版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他命令"><span class="toc-text">其他命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#建立本地分支与远程分支的追踪关系"><span class="toc-text">建立本地分支与远程分支的追踪关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cherry-pick"><span class="toc-text">cherry-pick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bug-分支"><span class="toc-text">bug 分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实践步骤"><span class="toc-text">实践步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-text">扩展阅读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#另外一些关于-Git-Github-入门的文章"><span class="toc-text">另外一些关于 Git / Github 入门的文章</span></a></li></ol></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi">访问量:<strong id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></strong> &nbsp; | &nbsp; 访客数:<strong id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></strong></div></div><div class="col-sm-12"><span>Copyright &copy; 2018</span> | <span>Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a></span> | <span>Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a></span></div></div></div></div><script src="/assets/tagcanvas.min.js?rev=d3e34a34636b6f4c81d2b43b153907bb"></script><script>var tagOption={textColour:"#444",outlineMethod:"block",outlineColour:"#FFDAB9",interval:30,textHeight:13,outlineRadius:3,freezeActive:!0,frontSelect:!0,initial:[.1,-.1],depth:.5,decel:.95,maxSpeed:.03,reverse:!0,fadeIn:500,wheelZoom:!0};TagCanvas.Start("tag-cloud-3d","",tagOption)</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/app.js?rev=26a1b6fecd389c0121b7027a299aa7c0"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!0,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},log:!1})</script></body>