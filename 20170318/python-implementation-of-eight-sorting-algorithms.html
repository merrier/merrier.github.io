<!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="Merrier说"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><link rel="dns-prefetch" href="http://merrier.wang"><meta name="description" content="Merrier的个人博客"><meta name="keywords" content="merrier 博客 前端 北邮人"><meta name="robots" content="all"><meta name="google" content="all"><meta name="googlebot" content="all"><meta name="verify" content="all"><meta name="google-site-verification" content="UkMBUrF2qTuMWfmPXWFFmc_pnqCRAxHQY1ndE0Zu1p0"><title>八大排序算法的python实现 | Merrier说</title><link rel="alternate" href="/atom.xml" title="Merrier说" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=6873d58798f32fd038a4e4936f7abcd9"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=a535f7d3a1cf8ee14d9efdd0c97c8085"><link rel="stylesheet" href="/css/style.css?rev=ce78cccc258fdce8aa532fd1dc1cb45c"><div class="hide"><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan class='cnzz_stat_icon_1264342320 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s19.cnzz.com/z_stat.php%3Fid%3D1264342320%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"))</script></div><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></head></html><!--[if lte IE 8]><style>
    html{ font-size: 1em }
</style><![endif]--><!--[if lte IE 9]><div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div><![endif]--><body><header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="Merrier"><img src="/images/hexo_others_8.jpeg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>叩首问路，码梦为生</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span><i class="fa fa-bars"></i></span> <a class="navbar-brand" href="http://merrier.wang">Merrier说</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i> 首页</a></li><li role="presentation" class="text-center"><a href="/categories/frontend/"><i class="fa"></i> 前端</a></li><li role="presentation" class="text-center"><a href="/categories/algorithm/"><i class="fa"></i> 算法</a></li><li role="presentation" class="text-center"><a href="/categories/series/"><i class="fa"></i> 系列专栏</a></li><li role="presentation" class="text-center"><a href="/archives/"><i class="fa"></i> 文章归档</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="八大排序算法的python实现">八大排序算法的python实现</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a href="/categories/算法">算法</a></span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a href="/tags/python" title="python">python</a> <a href="/tags/排序" title="排序">排序</a> <a href="/tags/算法" title="算法">算法</a></span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2017/03/18</span></span><span class="fa-wrap"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="post-body post-content"><p>其实我的python的水平相当于初学者，但是由于要找实习，所以刷算法是必然的，而经常刷leetcode的小伙伴应该知道，用javascript实现各种复杂算法的人比较少（排序算法还好，尤其是那些比较知名的排序算法，想看Javascript代码实现排序算法的可以点下面那个链接），所以就导致没有思路的时候也看不到别人是如何用js代码实现的，所以必须要懂其他一种语言才能行，而python同样作为一种脚本语言，其语法简单到丧尽天良，而代码库却很庞大，同时也很适合算法的实现，所以就决定在学习js的同时兼顾python的学习。 这篇文章当然不是我的原创，而是在逛伯乐在线的时候看到的，感觉总结的很好，代码也很规范，故抄至此处，如果作者不允许转载，将及时处理（可以点击来源链接查看原文）；如果没弄明白排序算法的步骤，想理解的更生动的话，可以查看我的另外一篇文章：<a href="https://merrier.wang/archives/244">十大排序算法的Javascript实现</a>。</p><h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h1><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><p>def insert_sort(lists):</p><pre><code># 插入排序
count = len(lists)
for i in range(1, count):
    key = lists\[i\]
    j = i - 1
    while j &gt;= 0:
        if lists\[j\] &gt; key:
            lists\[j + 1\] = lists\[j\]
            lists\[j\] = key
        j -= 1
return lists
</code></pre><h1 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h1><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p>def shell_sort(lists):</p><pre><code># 希尔排序
count = len(lists)
step = 2
group = count / step
while group &gt; 0:
    for i in range(0, group):
        j = i + group
        while j &lt; count:
            k = j - group
            key = lists\[j\]
            while k &gt;= 0:
                if lists\[k\] &gt; key:
                    lists\[k + group\] = lists\[k\]
                    lists\[k\] = key
                k -= group
            j += group
    group /= step
return lists
</code></pre><h1 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h1><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>def bubble_sort(lists):</p><pre><code># 冒泡排序
count = len(lists)
for i in range(0, count):
    for j in range(i + 1, count):
        if lists\[i\] &gt; lists\[j\]:
            lists\[i\], lists\[j\] = lists\[j\], lists\[i\]
return lists
</code></pre><h1 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h1><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>def quick_sort(lists, left, right):</p><pre><code># 快速排序
if left &gt;= right:
    return lists
key = lists\[left\]
low = left
high = right
while left &lt; right:
    while left &lt; right and lists\[right\] &gt;= key:
        right -= 1
    lists\[left\] = lists\[right\]
    while left &lt; right and lists\[left\] &lt;= key:
        left += 1
    lists\[right\] = lists\[left\]
lists\[right\] = key
quick_sort(lists, low, left - 1)
quick_sort(lists, left + 1, high)
return lists
</code></pre><h1 id="5-直接选择排序"><a href="#5-直接选择排序" class="headerlink" title="5.直接选择排序"></a>5.直接选择排序</h1><p>基本思想：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</p><p>def select_sort(lists):</p><pre><code># 选择排序
count = len(lists)
for i in range(0, count):
    min = i
    for j in range(i + 1, count):
        if lists\[min\] &gt; lists\[j\]:
            min = j
    lists\[min\], lists\[i\] = lists\[i\], lists\[min\]
return lists
</code></pre><h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h1><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p><p>def adjust_heap(lists, i, size):<br>lchild = 2 <em>i + 1<br>rchild = 2</em> i + 2<br>max = i<br>if i &lt; size / 2:<br>if lchild &lt; size and lists[lchild] &gt; lists[max]:<br>max = lchild<br>if rchild &lt; size and lists[rchild] &gt; lists[max]:<br>max = rchild<br>if max != i:<br>lists[max], lists[i] = lists[i], lists[max]<br>adjust_heap(lists, max, size)</p><p>def build_heap(lists, size):<br>for i in range(0, (size/2))[::-1]:<br>adjust_heap(lists, i, size)</p><p>def heap_sort(lists):<br>size = len(lists)<br>build_heap(lists, size)<br>for i in range(0, size)[::-1]:<br>lists[0], lists[i] = lists[i], lists[0]<br>adjust_heap(lists, 0, i)</p><h1 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h1><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p><p>def merge(left, right):<br>i, j = 0, 0<br>result = []<br>while i &lt; len(left) and j &lt; len(right):<br>if left[i] &lt;= right[j]:<br>result.append(left[i])<br>i += 1<br>else:<br>result.append(right[j])<br>j += 1<br>result += left[i:]<br>result += right[j:]<br>return result</p><p>def merge_sort(lists):</p><pre><code># 归并排序
if len(lists) &lt;= 1:
    return lists
num = len(lists) / 2
left = merge_sort(lists\[:num\])
right = merge_sort(lists\[num:\])
return merge(left, right)
</code></pre><h1 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8.基数排序"></a>8.基数排序</h1><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p><p>import math<br>def radix_sort(lists, radix=10):<br>k = int(math.ceil(math.log(max(lists), radix)))<br>bucket = [[] for i in range(radix)]<br>for i in range(1, k+1):<br>for j in lists:<br>bucket[j/(radix<strong>(i-1)) % (radix</strong>i)].append(j)<br>del lists[:]<br>for z in bucket:<br>lists += z<br>del z[:]<br>return lists</p></div><div class="reward"><div class="reward-wrap">赏<div class="reward-box"><span class="reward-type"><img class="alipay" src="/images/hexo_others_5.png"><b>支付宝打赏</b></span> <span class="reward-type"><img class="wechat" src="/images/hexo_others_6.png"><b>微信打赏</b></span></div></div><p class="reward-tip">赞赏是不耍流氓的鼓励</p></div><div class="post-footer"><div>转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="//merrier.wang" target="_blank">Merrier说</a></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="/20170318/javascript-implementation-of-ten-sorting-algorithms.html" class="pre-post btn btn-default" title="十大排序算法的Javascript实现"><i class="fa fa-angle-left fa-fw"></i> <span class="hidden-lg">上一篇</span> <span class="hidden-xs">十大排序算法的Javascript实现</span></a> <a href="/20170318/new-features-of-css3.html" class="next-post btn btn-default" title="前端面试系列（2）——CSS3新特性"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">前端面试系列（2）——CSS3新特性</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><script id="dsq-count-scr" src="https://merrier.disqus.com/count.js" async></script><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script type="text/javascript">if(document.getElementById("disqus_thread")){var disqus_config=function(){this.page.url="http://merrier.wang/20170318/python-implementation-of-eight-sorting-algorithms.html",this.page.identifier="20170318/python-implementation-of-eight-sorting-algorithms.html",this.page.title="八大排序算法的python实现"};!function(){var t=document,e=t.createElement("script");e.async=!0,e.src="https://merrier.disqus.com/embed.js",e.setAttribute("data-timestamp",""+ +new Date),(t.head||t.body).appendChild(e)}()}</script></div></main><aside id="article-toc" role="navigation" class="col-md-4"><div class="widget"><h3 class="title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-插入排序"><span class="toc-text">1.插入排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-希尔排序"><span class="toc-text">2.希尔排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-冒泡排序"><span class="toc-text">3.冒泡排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-快速排序"><span class="toc-text">4.快速排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-直接选择排序"><span class="toc-text">5.直接选择排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-堆排序"><span class="toc-text">6.堆排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-归并排序"><span class="toc-text">7.归并排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-基数排序"><span class="toc-text">8.基数排序</span></a></li></ol></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi">访问量:<strong id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></strong> &nbsp; | &nbsp; 访客数:<strong id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></strong></div></div><div class="col-sm-12"><span>Copyright &copy; 2018</span> | <span>Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a></span> | <span>Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a></span></div></div></div></div><script src="/assets/tagcanvas.min.js?rev=d3e34a34636b6f4c81d2b43b153907bb"></script><script>var tagOption={textColour:"#444",outlineMethod:"block",outlineColour:"#FFDAB9",interval:30,textHeight:13,outlineRadius:3,freezeActive:!0,frontSelect:!0,initial:[.1,-.1],depth:.5,decel:.95,maxSpeed:.03,reverse:!0,fadeIn:500,wheelZoom:!0};TagCanvas.Start("tag-cloud-3d","",tagOption)</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/app.js?rev=f25479a641009e7423ae98c6f819957f"></script></body>