{"name":"ES6","postlist":[{"title":"Blue老师ES6视频笔记","slug":"Blue老师ES6视频笔记","date":"2017-12-12T14:10:42.000Z","updated":"2019-03-29T10:17:04.612Z","comments":true,"path":"api/articles/Blue老师ES6视频笔记.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>请容许我吐槽一下，我发现中国很多前端的大神的英文真的差啊。。</p>\n<h2 id=\"ES6-兼容性\"><a href=\"#ES6-兼容性\" class=\"headerlink\" title=\"ES6 兼容性\"></a>ES6 兼容性</h2><p>可以在线查看兼容性：</p>\n<ul>\n<li>ES5：<a href=\"https://kangax.github.io/compat-table/es5/\" target=\"_blank\" rel=\"noopener\">kangax.github.io/compat-table/es5/</a></li>\n<li>ES6：<a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"noopener\">kangax.github.io/compat-table/es6/</a></li>\n</ul>\n<h3 id=\"在线编译\"><a href=\"#在线编译\" class=\"headerlink\" title=\"在线编译\"></a>在线编译</h3><p><strong>babel === browser.js</strong>，只不过叫法不同 可以通过如下方式实现在线编译 ES6，只不过会多出额外的编译时间，用户体验稍差：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"browser.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/babel\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> a = <span class=\"number\">12</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> b = <span class=\"number\">5</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    alert(a+b);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"ES5-中-var-的缺点：\"><a href=\"#ES5-中-var-的缺点：\" class=\"headerlink\" title=\"ES5 中 var 的缺点：\"></a>ES5 中 var 的缺点：</h3><ul>\n<li>可以重复声明</li>\n<li>无法限制修改，即没有常量的概念</li>\n<li>没有块级作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert a; <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"块级作用域有什么用？\"><a href=\"#块级作用域有什么用？\" class=\"headerlink\" title=\"块级作用域有什么用？\"></a>块级作用域有什么用？</h3><p>可以限定变量在块中起作用，而不像ES5一样在函数块中起作用，最常见的是 for 循环中的索引值</p>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ol>\n<li>如果只有一个参数，()可以省略</li>\n<li>如果只有一个 return，{}可以省略</li>\n</ol>\n<h2 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h2><p>ES6新增：</p>\n<h3 id=\"参数扩展（…args必须为最后一个形参）\"><a href=\"#参数扩展（…args必须为最后一个形参）\" class=\"headerlink\" title=\"参数扩展（…args必须为最后一个形参）\"></a>参数扩展（…args必须为最后一个形参）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b, ...args</span>)</span>&#123;</span><br><span class=\"line\">  alert(a);</span><br><span class=\"line\">  alert(b);</span><br><span class=\"line\">  alert(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">show(<span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"展开一个数组\"><a href=\"#展开一个数组\" class=\"headerlink\" title=\"展开一个数组\"></a>展开一个数组</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\];</span><br><span class=\"line\">\\[...arr\\] = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\];</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b=<span class=\"number\">5</span>, c=<span class=\"number\">12</span></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b, c\\] = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[&#123;a, b&#125;, \\[n1, n2, n3\\], num, str\\] = \\[&#123;<span class=\"attr\">a</span>: <span class=\"number\">12</span>, <span class=\"attr\">b</span>: <span class=\"number\">5</span>&#125;, \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>\\], <span class=\"number\">8</span>, <span class=\"string\">'cxzcv'</span>\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, n1, n2, n3, num, str);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b\\] = &#123;<span class=\"attr\">a</span>: <span class=\"number\">12</span>, <span class=\"attr\">b</span>: <span class=\"number\">45</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// undefined is not a function, 前提1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125; = &#123;<span class=\"number\">12</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// unexpected token, 前提2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b\\];</span><br><span class=\"line\">\\[a, b\\] = \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>\\]; <span class=\"comment\">// XXXX error, 前提3</span></span><br></pre></td></tr></table></figure>\n<p>前提：</p>\n<ol>\n<li>左右两边解构必须一样</li>\n<li>右边必须是个东西</li>\n<li>声明和赋值不能分开（必须在一句话中完成）</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>新增四个方法：</p>\n<ul>\n<li>map：映射</li>\n<li>reduce：汇总</li>\n<li>filter：过滤器</li>\n<li>forEach：循环（迭代）</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result); <span class=\"comment\">// 24, 10, 16</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><p>经常用来算总数、平均数等指标</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">69</span>, <span class=\"number\">180</span>, <span class=\"number\">8763</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tmp, item, index</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp + item;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result);</span><br></pre></td></tr></table></figure>\n<p>求平均数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">69</span>, <span class=\"number\">180</span>, <span class=\"number\">8763</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\">(<span class=\"params\">tmp, item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index != arr.length - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp+item;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (tmp+item)/arr.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result);</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>filter 中 return true 就留下来，return false 就不保留</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>类似于传统的 for 循环，参数为 item, index</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>新增：</p>\n<ol>\n<li>多了两个新方法，startsWith，endsWith</li>\n<li>字符串模板</li>\n</ol>\n<h3 id=\"字符串模板\"><a href=\"#字符串模板\" class=\"headerlink\" title=\"字符串模板\"></a>字符串模板</h3><p>普通字符串无法折行，字符串模板可以折行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = \\<span class=\"string\">`a<span class=\"subst\">$&#123;a&#125;</span>bc\\`;</span></span><br><span class=\"line\"><span class=\"string\">alert(str); // a12bc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p>ES5 中的面向对象：类和构造函数不分，混为一谈；ES6 中的面向对象：</p>\n<ol>\n<li>class 关键字，构造器和类分开了</li>\n<li>class 里面直接加方法</li>\n<li>extends-继承</li>\n</ol>\n<h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2><p>json 的标准写法：</p>\n<ol>\n<li>只能用双引号</li>\n<li>所有的名字（key）都必须用引号包起来</li>\n</ol>\n<p>在 ES 中，当名字和值相同时，可以只写其中一个；方法可以省掉: function</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>异步会让代码更复杂，而同步的代码简单，而 Promise 用同步的方式来书写异步代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">  $.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'arr.txt'</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    success(arr)&#123;</span><br><span class=\"line\">      resolve(arr);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error(err)&#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'成功'</span>)&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'失败'</span>)&#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise.all([promise1, promise2, …]) =&gt; 都 resolve 的时候才算成功，只要有一个 reject 就算失败<br>Promise.\brace([promise1, promise2, …]) =&gt; 只要有一个 resolve 的时候就算成功，全部 reject 才算失败 在高版本 jQuery 中，$.ajax 的返回值就是一个 Promise 对象</p>\n<h2 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h2><p>和普通函数相比，中间能暂停，需要和 yield 配合使用 generator 并不会直接执行，而是会创建一个 generator 对象，其中该对象的 next 方法用于继续执行，碰到 yield 就会停</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  alert(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = show();</span><br><span class=\"line\">genObj.next(); <span class=\"comment\">// a</span></span><br><span class=\"line\">genObj.next(); <span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><p>yield 既可以传参，又可以返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">show</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">`<span class=\"subst\">$&#123;num1&#125;</span>, <span class=\"subst\">$&#123;num2&#125;</span>`</span>);</span><br><span class=\"line\">  alert(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  alert(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  alert(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = show(<span class=\"number\">99</span>, <span class=\"number\">88</span>);</span><br><span class=\"line\">gen.next(<span class=\"number\">12</span>); <span class=\"comment\">// 第一个next没法给yield传参</span></span><br><span class=\"line\">gen.next(<span class=\"number\">5</span>); <span class=\"comment\">// 会传给上面的yield，所以a=5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-的局限性\"><a href=\"#Promise-的局限性\" class=\"headerlink\" title=\"Promise 的局限性\"></a>Promise 的局限性</h3><p>其实 generator 之所以出现也是因为纯 Promise 也有其自身的缺陷，并不能完全避免“回调陷阱”，而网上对于 Promise 的局限性解释很多，建议大家直接去看相关博客就可以了，而在我理解就是<strong>Promise 在解决数据依赖问题时避免不了“回调陷阱”</strong>，比如我需要根据数据 A 去请求数据 B，然后再根据数据 B 请求数据 C，然后再……，如果你自己用 Promis e实现一下的话就会发现这时候它的局限性所在；这也再一次证明了那句话：<strong>懒惰是最大生产力</strong></p>\n<h2 id=\"ES7-预览\"><a href=\"#ES7-预览\" class=\"headerlink\" title=\"ES7 预览\"></a>ES7 预览</h2><p>ES6 还没掌握，ES7 都定稿了。。ES8 都有草案了。。，不过现在浏览器对 ES7 的支持很惨</p>\n<ul>\n<li>数组 includes -&gt; 检查数组是否包含某元素</li>\n<li>数组 keys/values/entries -&gt; 一般配合 for…of 使用，for…of 即对 value 的循环，entries 是对键值对的循环</li>\n<li>求幂新操作符 -&gt; 3**8 === Math.pow(3, 8)</li>\n<li>字符串的 padStart/padEnd 方法 -&gt; 补充空格或其他字符串</li>\n<li>增加了函数容忍度 function show(a, b, c, ) -&gt; 不报错</li>\n<li>async 和 await，这基本上是 ES7 最好用的。。用于替代 generator 和 yield</li>\n<li>……</li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"ES6","path":"api/tags/ES6.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"Promise入门","slug":"Promise入门","date":"2018-02-26T14:14:10.000Z","updated":"2019-03-29T10:17:04.616Z","comments":true,"path":"api/articles/Promise入门.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>幕课网上的视频——<a href=\"https://www.imooc.com/learn/949\" target=\"_blank\" rel=\"noopener\">Promise入门</a>笔记，Promise 作为 ES6 中最重要的特性之一，对其进行了解和学习是非常有必要的，课程的源码已经上传至<a href=\"https://github.com/merrier/imooc-promise-sample\" target=\"_blank\" rel=\"noopener\">我的github</a>。</p>\n<h2 id=\"Promise是什么\"><a href=\"#Promise是什么\" class=\"headerlink\" title=\"Promise是什么\"></a>Promise是什么</h2><h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><blockquote>\n<ul>\n<li>The Promise object is used for asynchronous computations.</li>\n<li>A Promise represents a value which may be available now, or in the future, or never.</li>\n</ul>\n</blockquote>\n<h3 id=\"MDN中文\"><a href=\"#MDN中文\" class=\"headerlink\" title=\"MDN中文\"></a>MDN中文</h3><blockquote>\n<ul>\n<li>Promise对象用于异步计算。</li>\n<li>一个Promise表示一个现在、将来或永不可能可用的值。</li>\n</ul>\n</blockquote>\n<h3 id=\"按照用途来解释\"><a href=\"#按照用途来解释\" class=\"headerlink\" title=\"按照用途来解释\"></a>按照用途来解释</h3><ul>\n<li>主要用于异步计算</li>\n<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。</li>\n<li>可以在对象之间传递和操作Promise，帮助我们处理队列。</li>\n</ul>\n<h2 id=\"回调存在的问题\"><a href=\"#回调存在的问题\" class=\"headerlink\" title=\"回调存在的问题\"></a>回调存在的问题</h2><ol>\n<li>嵌套层次很深，难以维护</li>\n<li>无法正常使用 return 和 throw</li>\n<li>无法正常检索堆栈信息</li>\n<li>多个回调之间难以建立联系</li>\n</ol>\n<h2 id=\"Promise-详解\"><a href=\"#Promise-详解\" class=\"headerlink\" title=\"Promise 详解\"></a>Promise 详解</h2><ul>\n<li>Promise 是一个代理对象，它和原先要进行的操作并无关系</li>\n<li>它通过引入一个回调，避免更多的回调</li>\n</ul>\n<h3 id=\"Promise-有-3-个状态\"><a href=\"#Promise-有-3-个状态\" class=\"headerlink\" title=\"Promise 有 3 个状态\"></a>Promise 有 3 个状态</h3><ol>\n<li>pending[待定]——初始状态</li>\n<li>fulfilled[实现\\——操作成功</li>\n<li>rejected[被否决]——操作失败</li>\n</ol>\n<p>当 Promise 的状态发生改变，就会触发 .then() 里的响应函数处理后续步骤；Promise 状态一经改变，不会再变；只有在连续多个回调顺序执行的时候，Promise才会显示出其威力</p>\n<h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\".then()\"></a>.then()</h3><ul>\n<li>.then() 接受两个函数作为参数，分别代表 fulfilled 和 rejected</li>\n<li>.then() 返回一个新的 Promise 实例，所以它可以链式调用</li>\n<li>当前面的 Promise 状态改变时，.then() 根据其最终状态，选择特定的状态响应函数执行</li>\n<li>状态响应函数可以返回新的 Promise，或其它值</li>\n<li>如果返回新的 Promise，那么下一级 .then() 会在新的 Promise 状态改变之后执行</li>\n<li>如果返回其它任何值，则会立刻执行下一级 .then()</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>Promise 会自动捕获内部异常，并交给 rejected 响应函数处理 最好是在语句的最后通过 catch 捕获错误，因为 catch 可以捕获 resolve 回调中发生的错误，而 reject 回调无法捕获；catch 也会返回一个 Promise 实例，并且它返回的 Promise 实例如果没有错误的话也是 fulfilled 状态，所以 catch() 后面的 .then() 也都会触发，但是 catch() 后面的 .catch() 不会触发（<strong>如果在第一个catch()中没有抛出错误</strong>）</p>\n<p><strong>强烈建议在所有队列最后都加上.catch()，以避免漏掉错误处理造成意想不到的问题：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething()</span><br><span class=\"line\">  .doAnotherThing()</span><br><span class=\"line\">  .doMoreThing()</span><br><span class=\"line\">  .catch( <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现队列\"><a href=\"#实现队列\" class=\"headerlink\" title=\"实现队列\"></a>实现队列</h3><p>有时候我们不希望所有动作一起发生，而是按照一定顺序，逐个进行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = doSomething();</span><br><span class=\"line\">promise = promise.then(doSomethingElse);</span><br><span class=\"line\">promise = promise.then(doSomethingElse2);</span><br><span class=\"line\">promise = promise.then(doSomethingElse3);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-forEach\"><a href=\"#使用-forEach\" class=\"headerlink\" title=\"使用.forEach()\"></a>使用.forEach()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">queue</span>(<span class=\"params\">things</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  things.forEach( <span class=\"function\"><span class=\"params\">thing</span> =&gt;</span> &#123;</span><br><span class=\"line\">    promise = promise.then( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>( <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        doThing(thing, () =&gt; &#123;</span><br><span class=\"line\">          resolve();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(\\[<span class=\"string\">'lots'</span>, <span class=\"string\">'of'</span>, <span class=\"string\">'things'</span>, ....\\]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-reduce\"><a href=\"#使用-reduce\" class=\"headerlink\" title=\"使用.reduce()\"></a>使用.reduce()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">queue</span>(<span class=\"params\">things</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> things.reduce( <span class=\"function\">(<span class=\"params\">promise, thing</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    promise = promise.then( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>( <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        doThing(thing, () =&gt; &#123;</span><br><span class=\"line\">          resolve();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, <span class=\"built_in\">Promise</span>.resolve());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(\\[<span class=\"string\">'lots'</span>, <span class=\"string\">'of'</span>, <span class=\"string\">'things'</span>, ....\\]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise常用函数\"><a href=\"#Promise常用函数\" class=\"headerlink\" title=\"Promise常用函数\"></a>Promise常用函数</h2><h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h3><p>返回一个 fulfilled 的 Promise 实例，或原始 Promise 实例</p>\n<ul>\n<li>参数为空，返回一个状态为 fulfilled 的 Promise 实例</li>\n<li>参数是一个跟 Promise 无关的值，同上，不过 fulfilled 响应函数会得到这个参数</li>\n<li>参数为 Promise 实例，则返回该实例，不做任何修改</li>\n<li>参数为 thenable（有 then 方法），立刻执行它的 .then()</li>\n</ul>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h3><p>返回一个 rejected 的 Promise 实例</p>\n<ul>\n<li><strong>Promise.reject()不认thenable</strong></li>\n<li>其他和 Promise.resolve() 类似</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h3><p><code>Promise.all(\\[p1, p2, p3, ...\\])</code> 用于将多个 Promise 实例包装成一个新的 Promise 实例 当所有子 Promise 都完成，该 Promise 完成，返回值是<strong>全部值的数组</strong>；有任何一个失败，该 Promise 失败，返回值是<strong>第一个失败的子Promise的结果</strong>，最常见的是和 .map() 连用</p>\n<p>###Promise.race()</p>\n<p>类似 Promise.all() ，区别在于它有任意一个完成就算完成。</p>\n<h3 id=\"常见用法：\"><a href=\"#常见用法：\" class=\"headerlink\" title=\"常见用法：\"></a>常见用法：</h3><ul>\n<li>把异步操作和定时器放在一起</li>\n<li>如果定时器先触发，就认为超时，告知用户</li>\n</ul>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2><p>ES2017 新增运算符，新的语言元素</p>\n<ul>\n<li>赋予 JavaScript 以顺序手法编写异步脚本的能力！</li>\n<li>既保留异步运算的无阻赛特性，还继续使用同步写法。</li>\n<li>还能正常使用 return/try/catch</li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"ES6","path":"api/tags/ES6.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"慕课网","path":"api/tags/慕课网.json"}]},{"title":"let和var到底有什么区别？","slug":"let和var到底有什么区别？","date":"2017-08-04T08:10:14.000Z","updated":"2019-03-29T10:17:04.616Z","comments":true,"path":"api/articles/let和var到底有什么区别？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>问题来自于stackoverflow：<a href=\"https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var-to-declare-a-variable\" target=\"_blank\" rel=\"noopener\">What’s the difference between using “let” and “var” to declare a variable?</a> 我们都知道 ES6 中引入了 let 声明，而 let 也一直被认为是声明“局部变量”，那么 let 和 var 到底有什么区别呢？</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>首先，从其定义本身，其区别之一是起作用的范围： var 起作用的范围是其最近的方法体，而 let 起作用的范围是其最近的包围块，所谓的“包围块”是有可能比方法体小的。但是<strong>如果都是全局作用域上声明的话，var 和 let 起作用的范围其实是一样的</strong> 除此之外，用 let 声明的变量在它们被声明之前是无法访问到的（有点类似于严格模式），举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'globalVar: '</span> + globalVar);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'globalLet: '</span> + globalLet);</span><br><span class=\"line\"><span class=\"keyword\">var</span> globalVar = <span class=\"string\">'globalVar'</span>;  <span class=\"comment\">//globalVar: undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> globalLet = <span class=\"string\">'globalLet'</span>;  <span class=\"comment\">//Uncaught ReferenceError: globalLet is not defined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"作为全局变量\"><a href=\"#作为全局变量\" class=\"headerlink\" title=\"作为全局变量\"></a>作为全局变量</h2><p>和 var 不同，用 let 声明的“全局变量”将不会作为属性赋给 window，简单的栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'go'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"string\">'able'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.me); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.i); <span class=\"comment\">// 'able'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在函数中声明\"><a href=\"#在函数中声明\" class=\"headerlink\" title=\"在函数中声明\"></a>在函数中声明</h2><p>当它们在函数体中声明时是一样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ingWithinEstablishedParameters</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> funclet = <span class=\"string\">'funclet'</span>; <span class=\"comment\">//作用域为函数体内部</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> funcvar = <span class=\"string\">'funcvar'</span>; <span class=\"comment\">//作用域为函数体内部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在循环体中声明\"><a href=\"#在循环体中声明\" class=\"headerlink\" title=\"在循环体中声明\"></a>在循环体中声明</h2><p>当我们在循环体中声明变量（例如 for）时，var 和 let 是有显著区别的：let 只在循环体内部可访问，而 var 在整个方法体中都可访问。还是个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allyIlliterate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//tuce在这里不可访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> tuce = <span class=\"number\">0</span>; tuce &lt; <span class=\"number\">5</span>; tuce++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//tuce只能在这里访问得到</span></span><br><span class=\"line\">        <span class=\"comment\">//所以每次循环之后tuce的值都会变</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//tuce在这里也不可访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">byE40</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//nish在这里可以访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">var</span> nish = <span class=\"number\">0</span>; nish &lt; <span class=\"number\">5</span>; nish++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//nish在整个方法体中都可以访问得到</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//nish在这里也可以访问</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明覆盖\"><a href=\"#声明覆盖\" class=\"headerlink\" title=\"声明覆盖\"></a>声明覆盖</h2><p>在严格模式下，var 允许你重新给一个变量赋值，但是 let 不允许：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'bar'</span>; <span class=\"comment\">// SyntaxError: Identifier 'me' has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"string\">'bar'</span>; <span class=\"comment\">// 没毛病，现在me就是bar了</span></span><br></pre></td></tr></table></figure>\n<p>虽然 let 和 var 在某些情况下是一样的行为表现，但还是推荐大家多使用 let，逐渐放弃 var 的使用。</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"ES6","path":"api/tags/ES6.json"}]}]}