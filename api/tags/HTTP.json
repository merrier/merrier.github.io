{"name":"HTTP","postlist":[{"title":"前端面试系列（6）——HTTP请求的状态码","slug":"前端面试系列（6）——HTTP请求的状态码","date":"2017-04-04T13:38:16.000Z","updated":"2019-06-03T05:19:21.691Z","comments":true,"path":"api/articles/前端面试系列（6）——HTTP请求的状态码.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>首先说一下 HTTP，超文本传输协议（HTTP）是一种通信协议，它允许将超文本标记语言（HTML）文档从 Web 服务器传送到客户端的浏览器；而状态码在 Response 消息中的第一行（状态行），用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p>HTTP/1.1 中定义了 5 类状态码，状态码由三位数字组成，第一个数字定义了响应的类别</p>\n<ul>\n<li>1XX  提示信息 - 表示请求已被成功接收，继续处理</li>\n<li>2XX  成功 - 表示请求已被成功接收，理解，接受</li>\n<li>3XX  重定向 - 要完成请求必须进行更进一步的处理</li>\n<li>4XX  客户端错误 - 请求有语法错误或请求无法实现</li>\n<li>5XX  服务器端错误 - 服务器未能实现合法的请求</li>\n</ul>\n<h2 id=\"状态码含义\"><a href=\"#状态码含义\" class=\"headerlink\" title=\"状态码含义\"></a>状态码含义</h2><p><strong>粗体为常见状态码，需要多留意</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">状态码</th>\n<th style=\"text-align:center\">英文解释</th>\n<th style=\"text-align:left\">中文解释</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">Continue</td>\n<td style=\"text-align:left\">初始的请求已经接受，客户应当继续发送请求的其余部分</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">101</td>\n<td style=\"text-align:center\">Switching Protocols</td>\n<td style=\"text-align:left\">服务器将遵从客户的请求转换到另外一种协议</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>200</strong></td>\n<td style=\"text-align:center\"><strong>OK</strong></td>\n<td style=\"text-align:left\"><strong>一切正常，对GET和POST请求的应答文档跟在后面</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">201</td>\n<td style=\"text-align:center\">Created</td>\n<td style=\"text-align:left\">服务器已经创建了文档，Location头给出了它的URL</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">202</td>\n<td style=\"text-align:center\">Accepted</td>\n<td style=\"text-align:left\">已经接受请求，但处理尚未完成</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">203</td>\n<td style=\"text-align:center\">Non-Authoritative Information</td>\n<td style=\"text-align:left\">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">204</td>\n<td style=\"text-align:center\">No Content</td>\n<td style=\"text-align:left\">没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而 Servlet 可以确定用户文档足够新，这个状态代码是很有用的</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">205</td>\n<td style=\"text-align:center\">Reset Content</td>\n<td style=\"text-align:left\">没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">206</td>\n<td style=\"text-align:center\">Partial Content</td>\n<td style=\"text-align:left\">客户发送了一个带有Range头的GET请求，服务器完成了它</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">300</td>\n<td style=\"text-align:center\">Multiple Choices</td>\n<td style=\"text-align:left\">客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>301</strong></td>\n<td style=\"text-align:center\"><strong>Moved Permanently</strong></td>\n<td style=\"text-align:left\"><strong>客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>302</strong></td>\n<td style=\"text-align:center\"><strong>Found</strong></td>\n<td style=\"text-align:left\"><strong>类似于 301，但新的URL应该被视为临时性的替代，而不是永久性的</strong></td>\n<td style=\"text-align:left\"><strong>在 HTTP1.0 中对应的状态信息是 “Moved Temporatily”</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">303</td>\n<td style=\"text-align:center\">See Other</td>\n<td style=\"text-align:left\">类似于301/302，不同之处在于，如果原来的请求是 POST，Location 头指定的重定向目标文档应该通过 GET 提取</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>304</strong></td>\n<td style=\"text-align:center\"><strong>Not Modified</strong></td>\n<td style=\"text-align:left\"><strong>客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">305</td>\n<td style=\"text-align:center\">Use Proxy</td>\n<td style=\"text-align:left\">客户请求的文档应该通过 Location 头所指明的代理服务器提取</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">307</td>\n<td style=\"text-align:center\">Temporary Redirect</td>\n<td style=\"text-align:left\">和 302 相同。许多浏览器会错误地响应 302 应答进行重定向，即使原来的请求是 POST，即使它实际上只能在 POST 请求的应答是 303 时才能重定向。由于这个原因，HTTP 1.1 新增了 307，以便更加清除地区分几个状态代码：当出现 303 应答时，浏览器可以跟随重定向的 GET 和 POST 请求；如果是 307 应答，则浏览器只能跟随对 GET 请求的重定向</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">400</td>\n<td style=\"text-align:center\">Bad Request</td>\n<td style=\"text-align:left\">请求出现语法错误</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">401</td>\n<td style=\"text-align:center\">Unauthorized</td>\n<td style=\"text-align:left\">客户试图未经授权访问受密码保护的页面。应答中会包含一个 WWW-Authenticate 头，浏览器据此显示用户名字/密码对话框，然后在填写合适的 Authorization 头后再次发出请求</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>403</strong></td>\n<td style=\"text-align:center\"><strong>Forbidden</strong></td>\n<td style=\"text-align:left\"><strong>资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>404</strong></td>\n<td style=\"text-align:center\"><strong>Not Found</strong></td>\n<td style=\"text-align:left\"><strong>无法找到指定位置的资源。这也是一个常用的应答</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">405</td>\n<td style=\"text-align:center\">Method Not Allowed</td>\n<td style=\"text-align:left\">请求方法（GET、POST、HEAD、Delete、PUT、TRACE 等）对指定的资源不适用。</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">406</td>\n<td style=\"text-align:center\">Not Acceptable</td>\n<td style=\"text-align:left\">指定的资源已经找到，但它的 MIME 类型和客户在 Accpet 头中所指定的不兼容</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">407</td>\n<td style=\"text-align:center\">Proxy Authentication Required</td>\n<td style=\"text-align:left\">类似于 401，表示客户必须先经过代理服务器的授权</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">408</td>\n<td style=\"text-align:center\">Request Timeout</td>\n<td style=\"text-align:left\">在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">409</td>\n<td style=\"text-align:center\">Conflict</td>\n<td style=\"text-align:left\">通常和 PUT 请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">410</td>\n<td style=\"text-align:center\">Gone</td>\n<td style=\"text-align:left\">所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">411</td>\n<td style=\"text-align:center\">Length Required</td>\n<td style=\"text-align:left\">服务器不能处理请求，除非客户发送一个 Content-Length 头</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">412</td>\n<td style=\"text-align:center\">Precondition Failed</td>\n<td style=\"text-align:left\">请求头中指定的一些前提条件失败</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">413</td>\n<td style=\"text-align:center\">Request Entity Too Large</td>\n<td style=\"text-align:left\">目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个 Retry-After 头</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">414</td>\n<td style=\"text-align:center\">Request URI Too Long</td>\n<td style=\"text-align:left\">URI 太长</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">Internal Server Error</td>\n<td style=\"text-align:left\">服务器遇到了意料不到的情况，不能完成客户的请求</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">501</td>\n<td style=\"text-align:center\">Not Implemented</td>\n<td style=\"text-align:left\">服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>502</strong></td>\n<td style=\"text-align:center\"><strong>Bad Gateway</strong></td>\n<td style=\"text-align:left\"><strong>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>503</strong></td>\n<td style=\"text-align:center\"><strong>Service Unavailable</strong></td>\n<td style=\"text-align:left\"><strong>服务器由于维护或者负载过重未能应答。例如，Servlet 可能在数据库连接池已满的情况下返回503。服务器返回 503 时可以提供一个 Retry-After 头</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>504</strong></td>\n<td style=\"text-align:center\"><strong>Gateway Timeout</strong></td>\n<td style=\"text-align:left\"><strong>由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答</strong></td>\n<td style=\"text-align:left\"><strong>HTTP 1.1 新</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">505</td>\n<td style=\"text-align:center\">HTTP Version Not Supported</td>\n<td style=\"text-align:left\">服务器不支持请求中所指明的 HTTP 版本</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li>[一篇学习HTTP状态码的神文]（<a href=\"http://www.codeceo.com/article/http-code.html）\" target=\"_blank\" rel=\"noopener\">http://www.codeceo.com/article/http-code.html）</a></li>\n</ul>\n","raw":null,"categories":[{"name":"HTTP","path":"api/categories/HTTP.json"}],"tags":[{"name":"面试","path":"api/tags/面试.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"浏览器中输入url后发生了什么","slug":"浏览器中输入url后发生了什么","date":"2017-04-24T13:18:56.000Z","updated":"2019-06-03T05:19:21.691Z","comments":true,"path":"api/articles/浏览器中输入url后发生了什么.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_34.png","content":"<p>本文转载自<a href=\"http://www.jianshu.com/p/c1dfc6caa520\" target=\"_blank\" rel=\"noopener\">简书-浏览器中输入url后发生了什么</a>，其实这个问题在前端面试中经常遇到，所以网上有很多关于这个问题的文章，但是我感觉这篇文章是表达的最清晰的，感兴趣的童鞋可以点击上面的链接查看原文，不过在本文中，我又补充了一些其他文章中的相关内容，同时加入了一些我自己的理解，争取让初学者更容易看懂 先上一张思维导图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_34.png\" alt=\"\" width=\"900\"></div>\n\n<p>上面这张图用非常简练的语言总结了浏览器中输入 url 后发生的事情以及顺序，下面按照执行顺序分为六步进行描述：</p>\n<h2 id=\"1-DNS-域名解析\"><a href=\"#1-DNS-域名解析\" class=\"headerlink\" title=\"1. DNS 域名解析\"></a>1. DNS 域名解析</h2><ul>\n<li>在浏览器 DNS 缓存中搜索</li>\n<li>在操作系统 DNS 缓存中搜索</li>\n<li>读取系统 hosts 文件，查找其中是否有对应的 ip</li>\n<li>向本地配置的首选 DNS 服务器发起域名解析请求</li>\n</ul>\n<p>以上四个步骤其实都是 DNS 的解析过程，总结一下就是先看有没有缓存，如果没有就发起DNS域名解析请求，具体过程其实比较复杂，可以查看<a href=\"http://www.cnblogs.com/vincently/p/4670597.html\" target=\"_blank\" rel=\"noopener\">DNS原理及解析过程</a>进行更深入的了解</p>\n<h2 id=\"2-建立-TCP-连接\"><a href=\"#2-建立-TCP-连接\" class=\"headerlink\" title=\"2.建立 TCP 连接\"></a>2.建立 TCP 连接</h2><p>为了准确地传输数据，TCP 协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有 SYN/ACK(acknowledegment) 标志的数据包以示传达确认信息。最后发送方再回传一个带 ACK 标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP 会再次发送相同的数据包。TCP 是一个端到端的可靠的面向连接的协议，所以 HTTP 基于传输层 TCP 协议不用担心数据的传输的各种问题。当然，TCP 三次握手也是一个可以展开的问题，而且为什么使用三次握手也是大有学问，可以去我的另外一篇文章：<a href=\"/20170405/tcp-three-handshakes-and-four-breakups.html\">前端面试系列（8）——TCP的三次握手与四次分手</a>中寻找答案</p>\n<h2 id=\"3-发起-HTTP-请求\"><a href=\"#3-发起-HTTP-请求\" class=\"headerlink\" title=\"3. 发起 HTTP 请求\"></a>3. 发起 HTTP 请求</h2><p>HTTP 的请求方法（method）有以下几种：</p>\n<ul>\n<li>GET: 获取资源</li>\n<li>POST: 传输实体主体</li>\n<li>HEAD: 获取报文首部</li>\n<li>PUT: 传输文件</li>\n<li>DELETE: 删除文件</li>\n<li>OPTIONS: 询问支持的方法</li>\n<li>TRACE: 追踪路径</li>\n</ul>\n<p>其中最常用的就是 GET 和 POST 了，请求报文格式如下所示（HTTP/1.1）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_33.png\" alt=\"\" width=\"900\"></div>\n\n<h2 id=\"4-接受响应结果\"><a href=\"#4-接受响应结果\" class=\"headerlink\" title=\"4. 接受响应结果\"></a>4. 接受响应结果</h2><p>客户端在发出请求之后，服务器会在接收到请求之后返回客户端响应结果，该结果就是服务器告知客户端的当前状态，下面是状态码的分类，更多关于状态码的详细内容请移步<a href=\"/20170404/status-code-of-http-request.html\">前端面试系列（6）——HTTP请求的状态码</a>：</p>\n<ul>\n<li>1**：信息性状态码</li>\n<li>2**：成功状态码</li>\n<li>3**：重定向状态码</li>\n<li>4**：客户端错误状态码</li>\n<li>5**：服务器错误状态码</li>\n</ul>\n<p>响应报文：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_35.png\" alt=\"\" width=\"900\"></div>\n\n<h2 id=\"5-浏览器解析-html\"><a href=\"#5-浏览器解析-html\" class=\"headerlink\" title=\"5. 浏览器解析 html\"></a>5. 浏览器解析 html</h2><p>浏览器按顺序解析 html 文件，构建 DOM 树，在解析到外部的 css 和 js 文件时，向服务器发起请求下载资源，若是下载 css 文件，则解析器会在下载的同时继续解析后面的 html 来构建 DOM 树，但是在下载 js 文件和执行它时，解析器会停止对 html 的解析。这便出现了 js 阻塞问题。</p>\n<h3 id=\"预加载器：\"><a href=\"#预加载器：\" class=\"headerlink\" title=\"预加载器：\"></a>预加载器：</h3><p>当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的 html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索 HTML 标签中的 URL，无法检测到使用脚本添加的 URL，这些资源要等脚本代码执行时才会获取。（注: 预解析并不改变 Dom 树，它将这个工作留给主解析过程），浏览器解析 css，形成 CSSOM 树，当 DOM 树构建完成后，浏览器引擎通过 DOM 树和 CSSOM 树构造出渲染树（Render 树）。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head 元素和 display 值为 none 的元素）</p>\n<blockquote>\n<p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n</blockquote>\n<h2 id=\"6-浏览器布局渲染\"><a href=\"#6-浏览器布局渲染\" class=\"headerlink\" title=\"6. 浏览器布局渲染\"></a>6. 浏览器布局渲染</h2><ul>\n<li>布局（Layout）：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。</li>\n<li>绘制（Paint）：将计算好的每个像素点信息绘制在屏幕上</li>\n</ul>\n<p>在页面显示的过程中会多次进行 Reflow 和 Repaint 操作，而 Reflow 的成本比 Repaint 的成本高得多的多。因为 Repaint 只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的 display 属性由 block 改为 none 则需要 Reflow。如何减少 rpaint 和 reflow 也是<a href=\"/20170416/front-end-performance-optimization.html\">前端优化</a>需要考虑的问题：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_36.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/c1dfc6caa520\" target=\"_blank\" rel=\"noopener\">浏览器中输入url后发生了什么</a></li>\n<li><a href=\"http://coolshell.cn/articles/9666.html\" target=\"_blank\" rel=\"noopener\">浏览器的渲染原理简介</a></li>\n<li><a href=\"http://www.cnblogs.com/yuezk/archive/2013/01/11/2855698.html\" target=\"_blank\" rel=\"noopener\">了解html页面的渲染过程</a></li>\n<li><a href=\"https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/\" target=\"_blank\" rel=\"noopener\">老生常谈-从输入url到页面展示到底发生了什么</a></li>\n<li><a href=\"http://harttle.com/2016/05/18/async-javascript-loading.html\" target=\"_blank\" rel=\"noopener\">异步脚本载入提高页面性能</a></li>\n</ul>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://blog.codingplayboy.com/2017/03/29/webpage_render/\" target=\"_blank\" rel=\"noopener\">浅谈前端页面渲染机制</a></li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"前端面试系列（3）——HTTP/2新特性","slug":"前端面试系列（3）——HTTP2新特性","date":"2017-03-19T13:18:57.000Z","updated":"2019-06-03T05:19:21.691Z","comments":true,"path":"api/articles/前端面试系列（3）——HTTP2新特性.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_37.png","content":"<p>如果你认为前端不需要了解 HTTP 的话你就大错特错了，根据师兄师姐们的面试经验反馈，前端面试时关于 HTTP 的问题提问的几率也很大，而且对于更高一层的 tcp/ip 协议的认知也是前端开发者需要掌握的，所以我打算把关于 HTTP/2 新特性的文章作为前端面试系列的第三篇文章，如果想对 HTTP/2 协议有更深入的了解，可以点击文末的扩展阅读链接。</p>\n<h2 id=\"HTTP-2-源自-SPDY2\"><a href=\"#HTTP-2-源自-SPDY2\" class=\"headerlink\" title=\"HTTP/2 源自 SPDY2\"></a>HTTP/2 源自 SPDY2</h2><p>SPDY 系列协议由谷歌开发，于 2009 年公开。它的设计目标是降低 50% 的页面加载时间。当下很多著名的互联网公司，例如百度、淘宝、<a href=\"https://www.upyun.com/\" target=\"_blank\" rel=\"noopener\">UPYUN</a> 都在自己的网站或 APP 中采用了 SPDY 系列协议（当前最新版本是 SPDY/3.1），因为它对性能的提升是显而易见的。主流的浏览器（谷歌、火狐、Opera）也都早已经支持 SPDY，它已经成为了工业标准，HTTP Working-Group 最终决定以 SPDY/2 为基础，开发 HTTP/2。 但是，HTTP/2 跟 SPDY 仍有不同的地方，主要是以下两点：</p>\n<ol>\n<li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>\n<li>HTTP/2 消息头的压缩算法采用 <a href=\"http://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"noopener\">HPACK</a>，而非 SPDY 采用的 <a href=\"http://zh.wikipedia.org/wiki/DEFLATE\" target=\"_blank\" rel=\"noopener\">DELEFT</a></li>\n</ol>\n<h2 id=\"HTTP-2-的优势\"><a href=\"#HTTP-2-的优势\" class=\"headerlink\" title=\"HTTP/2 的优势\"></a>HTTP/2 的优势</h2><h3 id=\"1-HTTP-是一个二进制协议\"><a href=\"#1-HTTP-是一个二进制协议\" class=\"headerlink\" title=\"1. HTTP 是一个二进制协议\"></a>1. HTTP 是一个二进制协议</h3><p>基于二进制的 HTTP/2 可以使成帧的使用变得更为便捷。在 HTTP1.1 和其他基于文本的协议中，对帧的起始和结束识别起来相当复杂。而另一方面，这项决议同样使得我们可以更加便捷的从帧结构中分离出那部分协议本身的内容。而在 HTTP1 中，各个部分相互交织，犹如一团乱麻。</p>\n<p>HTTP/2 会发送有着不同类型的二进制帧，但他们都有如下的公共字段：Type, Length, Flags, Steam Identifier 和 frame payload；规范中一共定义了 10 种不同的帧，其中最基础的两种分别对应于 HTTP 1.1 的 DATA 和 HEADERS。之后我会更详细的介绍它们其中的一部分。</p>\n<p>二进制协议的优势显而易见：解析开销更小，描述协议也更高效。</p>\n<h3 id=\"2-多路复用的流\"><a href=\"#2-多路复用的流\" class=\"headerlink\" title=\"2. 多路复用的流\"></a>2. 多路复用的流</h3><p>流是一个逻辑上的联合，一个独立的，双向的帧序列可以通过一个 HTTP/2 的连接在服务端与客户端之间不断的交换数据。</p>\n<p>每个单独的 HTTP/2 连接都可以包含多个并发的流，这些流中<strong>交错</strong>的包含着来自两端的帧。流既可以被客户端/服务器端单方面的建立和使用，也可以被双方共享，或者被任意一边关闭。在流里面，<strong>每一帧发送的顺序非常关键</strong>。接收方会按照收到帧的顺序来进行处理。</p>\n<p>流的多路复用意味着在同一连接中来自各个流的数据包会被混合在一起。就好像两个（或者更多）独立的“数据列车”被拼凑到了一辆列车上，但它们最终会在终点站被分开。</p>\n<h3 id=\"3-优先级和依赖性\"><a href=\"#3-优先级和依赖性\" class=\"headerlink\" title=\"3. 优先级和依赖性\"></a>3. 优先级和依赖性</h3><p>每个流都包含一个优先级（也就是“权重”），它被用来告诉对端哪个流更重要。当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流。</p>\n<p>借助于 PRIORITY 帧（关于 HTTP/2 中帧的介绍可以查看文末扩展阅读），客户端同样可以告知服务器当前的流依赖于其他哪个流。该功能让客户端能建立一个优先级“树”，所有“子流”会依赖于“父流”的传输完成情况。</p>\n<p>优先级和依赖关系可以在传输过程中被动态的改变。这样当用户滚动一个全是图片的页面的时候，浏览器就能够指定哪个图片拥有更高的优先级。或者是在你切换标签页的时候，浏览器可以提升新切换到的页面所包含流的优先级。</p>\n<h3 id=\"4-头压缩\"><a href=\"#4-头压缩\" class=\"headerlink\" title=\"4. 头压缩\"></a>4. 头压缩</h3><p>HTTP 是一种无状态的协议。简而言之，这意味着每个请求必须要携带服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。因为 HTTP/2 并没有改变这个范式，所以它也需要这样（携带所有细节）。</p>\n<p>这也保证了 HTTP 可重复性。当一个客户端从同一服务器请求了大量资源（例如页面的图片）的时候，所有这些请求看起来几乎都是一致的，而这些大量一致的东西则正好值得被压缩。</p>\n<p>当每个页面资源的个数上升的时候，cookies 和请求的大小都会增加，而每个请求都会包含的 cookie 几乎是一模一样的。</p>\n<p>HTTP 1.1 请求的大小正变得越来越大，有时甚至会大于 TCP 窗口的初始大小，这会严重拖累发送请求的速度。因为它们需要等待带着 ACK 的响应回来以后，才能继续被发送。这也是另一个需要压缩的理由。</p>\n<p>HTTP/2 对消息头采用 <strong>HPACK</strong> 进行压缩传输，能够节省消息头占用的网络的流量。如果我们约定将常用的请求头的参数用一些特殊的编号来表示，比如 GET /index.html 用一个 1 来表示，POST /index.html 用 2 来表示。那么是不是可以节省很多字节？ 为 HTTP/2 的专门量身打造的 HPACK 便是类似这样的思路延伸。它使用一份索引表来定义常用的 HTTP Header。把常用的 HTTP Header 存放在表里。请求的时候便只需要发送在表里的索引位置即可。例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示。</p>\n<h3 id=\"5-重置\"><a href=\"#5-重置\" class=\"headerlink\" title=\"5. 重置\"></a>5. 重置</h3><p>HTTP 1.1 有一个缺点是：当一个含有确切值的 Content-Length 的 HTTP 消息被送出之后，你就很难中断它了。当然，通常你可以断开整个 TCP 链接（但也不总是可以这样），但这样导致的代价就是需要通过三次握手来重新建立一个新的 TCP 连接。</p>\n<p>一个更好的方案是只终止当前传输的消息并重新发送一个新的。在 HTTP/2 里面，我们可以通过发送 RST_STREAM 帧来实现这种需求，从而避免浪费带宽和中断已有的连接。</p>\n<h3 id=\"6-服务器推送\"><a href=\"#6-服务器推送\" class=\"headerlink\" title=\"6.服务器推送\"></a>6.服务器推送</h3><p>这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源 X，而服务器知道它很可能也需要资源 Z 的情况下，服务器可以在客户端发送请求前，主动将资源 Z 推送给客户端。这个功能帮助客户端将 Z 放进缓存以备将来之需。</p>\n<p>服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否需要中断该推送的流。如果不需要的话，客户端可以通过发送一个 RST_STREAM 帧来中止。</p>\n<h3 id=\"7-流量控制\"><a href=\"#7-流量控制\" class=\"headerlink\" title=\"7. 流量控制\"></a>7. 流量控制</h3><p>HTTP/2 上面每个流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有更多的空间来接受新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p>\n<p>而只有数据帧会受到流量控制。</p>\n<h3 id=\"8-HTTP-2-的基石-Frame\"><a href=\"#8-HTTP-2-的基石-Frame\" class=\"headerlink\" title=\"8. HTTP/2 的基石-Frame\"></a>8. HTTP/2 的基石-Frame</h3><p>Frame 是 HTTP/2 二进制格式的基础，基本可以把它理解为它 TCP 里面的数据包一样。HTTP/2 之所以能够有如此多的新特性，正是因为底层数据格式的改变。 Frame 的基本格式如下（图中的数字表示所占位数，内容摘自  <a href=\"https://tools.ietf.org/html/draft-ietf-httpbis-http2-17\" target=\"_blank\" rel=\"noopener\">http2-draft-17</a>）:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------------------------------------+</span><br><span class=\"line\">| Length (24) |</span><br><span class=\"line\">+---------------+---------------+---------------+</span><br><span class=\"line\">| Type (8) | Flags (8) |</span><br><span class=\"line\">+-+-------------+---------------+-------------------+</span><br><span class=\"line\">|R| Stream Identifier (31) |</span><br><span class=\"line\">+=+=================================================+</span><br><span class=\"line\">| Frame Payload (0...) ...</span><br><span class=\"line\">+---------------------------------------------------+</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>Length</strong>：表示 Frame Payload 部分的长度，另外 Frame Header 的长度是固定的 9 字节（Length + Type + Flags + R + Stream Identifier = 72 bit）。</li>\n<li><strong>Type</strong>：区分这个 Frame Payload 存储的数据是属于 HTTP Header 还是 HTTP Body；另外 HTTP/2 新定义了一些其他的 Frame Type，例如，这个字段为 0 时，表示 DATA 类型（即 HTTP/1.x 里的 Body 部分数据）</li>\n<li><strong>Flags</strong>：共 8 位， 每位都起标记作用。每种不同的 Frame Type 都有不同的 Frame Flags。例如发送最后一个 DATA 类型的 Frame 时，就会将 Flags 最后一位设置 1（<code>flags &amp;= 0x01</code>），表示 END_STREAM，说明这个 Frame 是流的最后一个数据包。</li>\n<li><strong>R</strong>：保留位。</li>\n<li><strong>Stream Identifier</strong>：流 ID，当客户端和服务端建立 TCP 链接时，就会先发送一个 Stream ID = 0 的流，用来做些初始化工作。之后客户端和服务端从 1 开始发送请求/响应。</li>\n</ul>\n<p>Frame 由 Frame Header 和 Frame Payload 两部分组成。不论是原来的 HTTP Header 还是 HTTP Body，在 HTTP/2 中，都将这些数据存储到 Frame Payload，组成一个个 Frame，再发送响应 / 请求。通过 Frame Header 中的 Type 区分这个 Frame 的类型。由此可见语义并没有太大变化，而是数据的格式变成二进制的 Frame。二者的转换和关系如下图:</p>\n<div align=\"center\"><img src=\"/images/hexo_post_37.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"9-HTTP-2-对-web-开发的影响\"><a href=\"#9-HTTP-2-对-web-开发的影响\" class=\"headerlink\" title=\"9.HTTP/2 对 web 开发的影响\"></a>9.HTTP/2 对 web 开发的影响</h3><p>到目前为止，HTTP/2 还没被大范围部署使用，我们也无法确定到底会发生什么变化。</p>\n<p>HTTP/2 减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了 head of line blocking（线头阻塞）的困扰。它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p>\n<p>所有这些加起来，页面载入时间和站点的响应速度都会更快。简而言之，它们都代表着更好的 web 体验。</p>\n<p>然而这里的问题在于：对于网站的开发者而言，在短期内开发和部署同一套前端来支持 HTTP 1.1 和 HTTP/2 的客户端访问并获得最大性能将会是一个挑战。考虑到这些问题，<strong>彻底发掘 HTTP/2 的潜力还有很长一段路要走</strong>。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://bagder.gitbooks.io/http2-explained/content/zh/\" target=\"_blank\" rel=\"noopener\">http2讲解（中文）</a></li>\n<li><a href=\"https://http2.github.io/\" target=\"_blank\" rel=\"noopener\">HTTP/2 官网</a></li>\n<li><a href=\"https://http2.akamai.com/demo\" target=\"_blank\" rel=\"noopener\">官方给出的关于 HTTP/2 性能的例子</a></li>\n<li><a href=\"http://blog.csdn.net/jianfyun/article/details/48549939\" target=\"_blank\" rel=\"noopener\">HTTP/2 的各种帧定义</a></li>\n</ul>\n","raw":null,"categories":[{"name":"HTTP","path":"api/categories/HTTP.json"}],"tags":[{"name":"面试","path":"api/tags/面试.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"影响Cache的几个HTTP头信息","slug":"影响Cache的几个HTTP头信息","date":"2017-08-20T13:12:54.000Z","updated":"2019-06-03T05:19:21.691Z","comments":true,"path":"api/articles/影响Cache的几个HTTP头信息.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>HTTP 协议是前端工程师接触最多的一种协议，而它的内容又多的要命，所以很多前端童鞋在遇到 HTTP 的时候都会产生“畏惧”的心理，其实对于这种内容非常多又难以理解的知识点，我的建议是用到的时候再详查，而我接下来要介绍的这几个头信息则是非常重要的知识点，是每一个称职的前端工程师都需要掌握的~</p>\n<h2 id=\"HTTP-的-cache-机制\"><a href=\"#HTTP-的-cache-机制\" class=\"headerlink\" title=\"HTTP 的 cache 机制\"></a>HTTP 的 cache 机制</h2><p>HTTP 的 cache 机制总共有4个组成部分：<strong>Cache-Control、Last-Modified（If-Modified-Since）、Etag（If-None-Match）、Expires</strong></p>\n<ul>\n<li><strong>服务器响应头</strong>：Last-Modified、Etag</li>\n<li><strong>浏览器请求头</strong>：If-Modified-Since、If-None-Match</li>\n</ul>\n<p><strong>流程</strong>：服务器发出 Etag，Last-Modified 头后，下次浏览器再进行同样的请求，则会发出 If-None-Match，If-Modified-Since头，而后服务器根据这些信息来判断是否需要发送数据，如果没有更新，服务器就简单的发送一个 304 状态告诉浏览器用缓存就OK了，不用下载数据了，从而节约了带宽。</p>\n<h3 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified / If-Modified-Since\"></a>Last-Modified / If-Modified-Since</h3><p>Last-Modified 是响应头，If-Modified-Since 是请求头。Last-Modified 把 Web 组件的最后修改时间告诉客户端，客户端在下次请求此Web组件的时候，会把上次服务端响应的最后修改时间作为 If-Modified-Since 的值发送给服务器，服务器可以通过这个值来判断是否需要重新发送，如果不需要，就简单的发送一个 304 状态码，客户端将从缓存里直接读取所需的Web组件。如果有更新，返回 HTTP 200 和更新的页面内容，并且携带新的 ETag 和 LastModified。</p>\n<blockquote>\n<p>使用这个机制，能够避免重复发送文件给浏览器，不过仍然会产生一个 HTTP 请求。</p>\n</blockquote>\n<h3 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag / If-None-Match\"></a>ETag / If-None-Match</h3><p>ETag 是响应头，If-None-Match 是请求头。Last-Modified / If-Modified-Since 的主要缺点就是它只能精确到秒的级别，一旦在一秒的时间里出现了多次修改，那么 Last-Modified / If-Modified-Since 是无法体现的。相比较，ETag / If-None-Match 没有使用时间作为判断标准，而是使用一个特征串。Etag 把 Web 组件的特征串告诉客户端，客户端在下次请求此 Web 组件的时候，会把上次服务端响应的特征串作为 If-None-Match 的值发送给服务端，服务端可以通过这个值来判断是否需要从重新发送，如果不需要，就简单的发送一个 304 状态码，客户端将从缓存里直接读取所需的 Web 组件。 因此，HTTP/1.1 利用 Entity Tag 头提供了更加严格的验证。</p>\n<h3 id=\"当服务器发出响应的时候，可以通过两种方式来告诉客户端缓存请求：\"><a href=\"#当服务器发出响应的时候，可以通过两种方式来告诉客户端缓存请求：\" class=\"headerlink\" title=\"当服务器发出响应的时候，可以通过两种方式来告诉客户端缓存请求：\"></a>当服务器发出响应的时候，可以通过两种方式来告诉客户端缓存请求：</h3><p><strong>第一种是Expires</strong>，比如：<code>Expires: Sun, 16 Oct 2016 05:43:02 GMT</code>，在此日期之前，客户端都会认为缓存是有效的。 不过 Expires 有缺点，比如说，服务端和客户端的时间设置可能不同，这就会使缓存的失效可能并不能精确的按服务器的预期进行。<br><strong>第二种是Cache-Control</strong>，比如：<code>Cache-Control: max-age=3600</code>，这里声明的是一个相对的秒数，表示从现在起，3600 秒内缓存都是有效的，这样就避免了服务端和客户端时间不一致的问题。 但是 Cache-Control 是 HTTP1.1 才有的，不适用与 HTTP1.0，而 Expires 既适用于 HTTP1.0，也适用于 HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，会优先使用 Cache-Control。</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"什么是-Last-Modified\"><a href=\"#什么是-Last-Modified\" class=\"headerlink\" title=\"什么是 Last-Modified?\"></a>什么是 Last-Modified?</h3><p>在浏览器第一次请求某一个 URL 时，服务器端的返回状态会是 200，内容是你请求的资源，同时有一个 Last-Modified 的属性标记 (<strong>Http Reponse Header</strong>），此文件在服务期端最后被修改的时间，格式类似这样：<code>Last-Modified: Fri, 12 May 2006 18:53:33 GMT</code>，客户端第二次请求此 URL 时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头（<strong>Http Request Header</strong>），询问该时间之后文件是否有被修改过：<code>If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT</code>，如果服务器端的资源没有变化，则自动返回 <strong>HTTP 304 （Not Changed.）</strong> 状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p>\n<blockquote>\n<p>如果 If-Modified-Since 的时间比服务器当前时间（当前的请求时间 request_time）还晚，Apache 会认为是个非法请求</p>\n</blockquote>\n<h4 id=\"Last-Modified-和-Expires-的区别\"><a href=\"#Last-Modified-和-Expires-的区别\" class=\"headerlink\" title=\"Last-Modified 和 Expires 的区别\"></a>Last-Modified 和 Expires 的区别</h4><p>让我们回过头来比较一下 Expires 和 Last-Modified 这两个东西，似乎 Last-Modified 比不上 Expires，因为虽然它能够节省一点带宽，但是还是逃不掉发一个 HTTP 请求出去，而 Expires 却使得浏览器干脆连 HTTP 请求都不用发，岂不痛快！那还要 Last- Modified 这个东西干什么？理想状况的确是这样，不过当用户在 IE 或者 Firefox 里面按 F5 或者点击 Refresh 按钮的时候（不是在 URL 栏里重新输入一遍 URL 然后回车），就算对于有 Expires 的 URI，一样也会发一个 HTTP 请求出去，所以，Last-Modified 还是要用的，而且要和 Expires 一起用。</p>\n<h3 id=\"什么是-Etag？\"><a href=\"#什么是-Etag？\" class=\"headerlink\" title=\"什么是 Etag？\"></a>什么是 Etag？</h3><p>HTTP 协议规格说明定义 ETag 为“<strong>被请求变量的实体值</strong>” 。另一种说法是，ETag 是一个可以与 Web 资源关联的记号（token）。典型的 Web 资源可以是一个 Web 页，但也可能是 JSON 或 XML 文档。服务器单独负责判断记号是什么及其含义，并在 HTTP 响应头中将其传送到客户端，以下是服务器端返回的格式：</p>\n<p><code>ETag: &quot;50b1c1d4f775c61:df3&quot;</code> </p>\n<p>客户端的查询更新格式是这样的：</p>\n<p><code>If-None-Match: &quot;50b1c1d4f775c61:df3&quot;</code> </p>\n<p>如果 ETag 没改变，则返回状态 304，这也和 Last-Modified 一样。本人测试 <strong>Etag 主要在断点下载时比较有用。</strong></p>\n<h4 id=\"Last-Modified和Etags如何帮助提高性能\"><a href=\"#Last-Modified和Etags如何帮助提高性能\" class=\"headerlink\" title=\"Last-Modified和Etags如何帮助提高性能?\"></a>Last-Modified和Etags如何帮助提高性能?</h4><p>聪明的开发者会把 Last-Modified 和 ETags 请求的 HTTP 报头一起使用，这样可利用客户端（例如浏览器）的缓存。因为服务器首先产生 Last-Modified / Etag 标记，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。过程如下:</p>\n<ol>\n<li>客户端请求一个页面（A）。</li>\n<li>服务器返回页面 A，并再给 A 加上一个 Last-Modified / ETag。</li>\n<li>客户端展现该页面，并将页面连同 Last-Modified / ETag 一起缓存。</li>\n<li>客户再次请求页面 A，并将上次请求时服务器返回的 Last-Modified / ETag 一起传递给服务器。</li>\n<li>服务器检查该 Last-Modified 或 ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应 304 和一个空的响应体。</li>\n</ol>\n<p><strong>注意：</strong></p>\n<ol>\n<li>Last-Modified 和 Etag 头都是由 Web Server 发出的 Http Reponse Header，Web Server 应该同时支持这两种头。</li>\n<li>Web Server 发送完 Last-Modified / Etag 头给客户端后，客户端会缓存这些头；</li>\n<li>客户端再次发起相同页面的请求时，将分别发送与 Last-Modified / Etag 对应的 Http Request Header:If-Modified-Since 和 If-None-Match。我们可以看到这两个 Header 的值和 Web Server 发出的 Last-Modified，Etag 值完全一样；</li>\n<li>通过上述值到服务器端检查，判断文件是否继续缓存；</li>\n</ol>\n<h4 id=\"Etag的弊端\"><a href=\"#Etag的弊端\" class=\"headerlink\" title=\"Etag的弊端\"></a>Etag的弊端</h4><p>不过 ETag / If-None-Match 这点功能实在是个鸡肋，首先，Server 端的资源不大可能 Roll Back，更重要的是，有可能造成 Client Performance 下降。对于只有一个 Server 的网站，没什么问题，但是现在稍微上点规模的网站都需要 Scale Out，也就是说需要前端一个 Load Balancer，后面接多台 Server 来处理请求，俗称 Cluster，既然是 Cluster，那么每个请求到底返回什么结果应该和分配到哪个 Server 无关，不过这个 ETag 可能就坏事了。<br>假如用户的第一次请求分配给 Server A，返回 <code>ETag: &quot;abcdefg1234:0001&quot;</code>，但是第二次请求分配给了Server B，Server B 上这个资源和 Server A 上的一模一样，但是计算出这个资源的 ETag 是”abcdefg1234:0002”，这下麻烦了，虽然内容一样，但是 ETag 不匹配，还是浪费了带宽把资源发送了一遍，冤枉啊！而事实上，不同 Server 上的 ETag 很有可能不同，对于 Apache，ETag 的计算考虑了 inode；对于 IIS，ETag 考虑了 metabase 的修改版本，要保证不同 server 上的这些信息一致，有点小难。不过不是有 Last-Modified / If- Not-Modified 吗？Server 端看到 If-Modified-Since，对照一下时间对得上，不管 If-None-Match，可以直接返回 304(Not Modified) 呀，很不幸， <a href=\"HTTP://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4\" target=\"_blank\" rel=\"noopener\">RFC2616对这种情况做了规定</a>，如果既有 If-None-Match 又有 If-Modified-Since，除非两者不冲突，不然不会返回 304。</p>\n<h4 id=\"Apache-中的-Etag-设置\"><a href=\"#Apache-中的-Etag-设置\" class=\"headerlink\" title=\"Apache 中的 Etag 设置\"></a>Apache 中的 Etag 设置</h4><p>Apache 默认开启 Etag，可以使用 FileEtag 来设置</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"HTTP://www.alloyteam.com/2016/03/discussion-on-web-caching/\" target=\"_blank\" rel=\"noopener\">浅谈Web缓存</a></li>\n<li><a href=\"HTTP://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">浅谈浏览器HTTP的缓存机制</a></li>\n<li><a href=\"HTTP://louiszhai.github.io/2017/04/07/HTTP-cache/\" target=\"_blank\" rel=\"noopener\">浏览器缓存机制剖析</a></li>\n</ul>\n","raw":null,"categories":[{"name":"HTTP","path":"api/categories/HTTP.json"}],"tags":[{"name":"HTTP","path":"api/tags/HTTP.json"},{"name":"cache","path":"api/tags/cache.json"}]},{"title":"网站配置HTTPS踩坑记","slug":"网站配置HTTPS踩坑记","date":"2018-04-16T06:36:36.000Z","updated":"2019-06-03T05:19:21.695Z","comments":true,"path":"api/articles/网站配置HTTPS踩坑记.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_290.png","content":"<p>近两年来 HTTPS 取代 HTTP 已经成为大势所趋。早在 2014 年 Google Chromium 安全团队提议将所有的 HTTP 协议网站标注为不安全。现在，Chrome 浏览器已经开始执行这一标准了。从 Chrome 56 开始，任何网页，如果有输入密码或者信用卡资料的，却没有使用 HTTPS，将被 Chrome 浏览器标识为不安全；逐步的，任何没有使用 HTTPS 协议的网页 Chrome 浏览器都会被标识为”不安全”，或者 “Not Secure”。所以处女座的我打算将 merrier.wang 升级成 HTTPS，以下对升级过程中遇到的问题和坑进行一下总结，如果你也有类似需求，希望这篇文章能够帮到你一二~</p>\n<h2 id=\"SSL证书选择\"><a href=\"#SSL证书选择\" class=\"headerlink\" title=\"SSL证书选择\"></a>SSL证书选择</h2><p>1、对于国内用户来说，可以使用与百度云、腾讯云、阿里云合作的赛门铁克签署的证书，一年免费，申请和使用都很方便。 （<strong>不过我一开始用腾讯云的免费证书，发现chrome浏览器还是标记不安全，所以我就放弃用国内的证书- -</strong>） 2、自从 <a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a> 免费签发证书后，SSL 证书的价格就开始平民化了，有不少免费和收费的 SSL 可以选择。Let’s Encrypt 的证书虽然只有90的天，不过自动续期也很方便，对于小站来说，是很不错的选择。而我使用的就是 Lets Encrypt 颁发的证书，下面就主要记录一下申请证书，配置证书到 apache，以及自动续期的实现步骤，供有兴趣的童鞋参考。</p>\n<h2 id=\"申请证书\"><a href=\"#申请证书\" class=\"headerlink\" title=\"申请证书\"></a>申请证书</h2><p>Certbot 是一个简单易用的 SSL 证书部署工具，由 EFF 开发，前身即 Let’s Encrypt 官方（Python）客户端。简单来说，certbot 就是一个简化 Let’s Encrypt 部署，和管理 Let’s Encrypt 证书的工具。所以我们可以通过 Certbot 非常方便的生成证书并借助脚本实现自动续费。 首先来到 <a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot官网</a>，在下面的蓝色箭头处选择操作系统和服务器型号：</p>\n<div align=\"center\"><br><img src=\"/images/hexo_post_290.png\" alt=\"\"><br></div>\n\n<p>以我的阿里云 ECS 举例，操作系统是 CentOS 6，服务器是 Apache，选择完之后页面下方会出现指引；按照其指引，我们首先需要安装 certbot-auto，在你想要安装的目录（这个目录最好是一个简单好找的目录，比如 <code>/etc/httpd/conf</code>，因为后面还要用到）下执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://dl.eff.org/certbot-auto</span><br><span class=\"line\">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>\n<p>然后我们通过certbot获取证书：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ./path/to/certbot-auto --apache</span><br></pre></td></tr></table></figure>\n<p>期间会让你填一些自己的信息，比如个人邮箱等等，按照自己的实际情况填写即可，然后过程中可能会遇到下面这条信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.</span><br><span class=\"line\">\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-</span><br><span class=\"line\">1: No redirect - Make no further changes to the webserver configuration.</span><br><span class=\"line\">2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for</span><br><span class=\"line\">new sites, or if you&apos;re confident your site works on HTTPS. You can undo this</span><br><span class=\"line\">change by editing your web server&apos;s configuration.</span><br></pre></td></tr></table></figure>\n<p>这里我强烈建议选择第二个 Redirect 选项，因为这样 Certbot 会对 apache 配置文件进行修改，当用户访问 HTTP 链接时，强制重定向到 HTTPS 链接，就不需要我们自己进行修改了。 如果一切顺利的话，当我们看到下面的提示信息时，就证明我们的证书已经申请成功并配置成功了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-</span><br><span class=\"line\">Congratulations! You have successfully enabled https://merrier.wang</span><br><span class=\"line\"></span><br><span class=\"line\">You should test your configuration at:</span><br><span class=\"line\">https://www.ssllabs.com/ssltest/analyze.html?d=merrier.wang</span><br><span class=\"line\">\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-</span><br></pre></td></tr></table></figure>\n<h2 id=\"自动续费\"><a href=\"#自动续费\" class=\"headerlink\" title=\"自动续费\"></a>自动续费</h2><p>此时我们可以访问一下 HTTPS 的链接，看看证书是否生效，如果不生效，可以尝试一下重启 apache：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service httpd restart</span><br></pre></td></tr></table></figure>\n<p>Let’s Encrypt 的证书，默认的有效期是 90 天，不过官方推荐每 60 天续期。到期之后，我们需要用命令来为证书续期，不过我们是懒人，这种体力活还是交给机器来完成比较合适。所以，我们可以用 Linux 的 cron job 来完成这类的任务。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>如果服务器上没有安装 crontabs，需要手动安装，centos 系统建议通过 yum 安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install crontabs</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service crond start</span><br><span class=\"line\">chkconfig crond start</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加新的任务\"><a href=\"#添加新的任务\" class=\"headerlink\" title=\"添加新的任务\"></a>添加新的任务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab \\[-u user\\] -e</span><br></pre></td></tr></table></figure>\n<p>其中：-u user：用来设定某个用户的 crontab 服务，例如，“-u ixdba”表示设定 ixdba 用户的 crontab 服务，此参数一般由 root 用户来运行。即执行 <code>crontab -u root -e</code> 来添加任务，此时会打开一个新的文件，填入以下脚本信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 0,12 * * * python -c &apos;import random; import time; time.sleep(random.random() * 3600)&apos; &amp;&amp; ./path/to/certbot-auto renew --post-hook &quot;service httpd restart&quot;</span><br></pre></td></tr></table></figure>\n<p>如果出现 crontab: installing new crontab 就说明我们的脚本已经生效了，自动续费就配置好了。关于更多 crontab 的内容可以<a href=\"https://www.jianshu.com/p/838db0269fd0\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看，你可以利用他做更多有意思的事情。如果你不确定自己的定时任务是否设置成功，可以通过执行 <code>crontab -l</code> 进行查看，如果出现上面的那段 python 代码，说明定时任务已经设置成功；有时候可能 crond 服务莫名的挂掉，我们可以通过上面的命令手动启动，同时也可以通过下面的命令手动更新证书：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/httpd/conf/certbot-auto renew</span><br></pre></td></tr></table></figure>\n<h2 id=\"Wordpress配置https\"><a href=\"#Wordpress配置https\" class=\"headerlink\" title=\"Wordpress配置https\"></a>Wordpress配置https</h2><p>如果你的网站是通过 wordpress 搭建的，除了进行上面的流程之外，还需要进行额外的配置：</p>\n<h3 id=\"修改wordpress后台配置中的地址改为https版本\"><a href=\"#修改wordpress后台配置中的地址改为https版本\" class=\"headerlink\" title=\"修改wordpress后台配置中的地址改为https版本\"></a>修改wordpress后台配置中的地址改为https版本</h3><div align=\"center\"><br><img src=\"/images/hexo_post_291.png\" alt=\"\"><br></div>\n\n<p><strong>注意：一定要保证https和http两种方式都能正常访问网站，才能改这个配置，否则可能导致网站无法访问。</strong>通过上面的设置，绝大部分导航中的链接就由 wordpress 系统会自动改为 HTTPS 版本。</p>\n<h3 id=\"替换正文的内部链接和其他静态资源\"><a href=\"#替换正文的内部链接和其他静态资源\" class=\"headerlink\" title=\"替换正文的内部链接和其他静态资源\"></a>替换正文的内部链接和其他静态资源</h3><p>对于这部分链接需要手工修改，修改的方法有两种：</p>\n<h4 id=\"（1）直接在数据库中更新，更新的sql如下：\"><a href=\"#（1）直接在数据库中更新，更新的sql如下：\" class=\"headerlink\" title=\"（1）直接在数据库中更新，更新的sql如下：\"></a>（1）直接在数据库中更新，更新的sql如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update wp\\_posts set post\\_content = replace(post_content, ‘http://your-website-name/’,‘https://your-website-name/’)</span><br></pre></td></tr></table></figure>\n<p>对于数据库不熟悉的童鞋不推荐这种方法，对数据库错误的更新对网站可能是毁灭性的打击，建议<strong>更新前最好备份数据库</strong>。</p>\n<h4 id=\"（2）利用wordpress提供的api来重写链接\"><a href=\"#（2）利用wordpress提供的api来重写链接\" class=\"headerlink\" title=\"（2）利用wordpress提供的api来重写链接\"></a>（2）利用wordpress提供的api来重写链接</h4><p>在使用的主题（themes）的目录下的 functions.php 加入如下代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"function\"><span class=\"keyword\">function</span>\\<span class=\"title\">_exists</span><span class=\"params\">(<span class=\"string\">'add\\_theme\\_support'</span>)</span> )<span class=\"title\">add</span>\\<span class=\"title\">_theme_support</span><span class=\"params\">(<span class=\"string\">'post-thumbnails'</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">add\\_filter(<span class=\"string\">'script\\_loader\\_src'</span>, <span class=\"string\">'agnostic\\_script\\_loader\\_src'</span>, <span class=\"number\">20</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">agnostic</span>\\<span class=\"title\">_script</span>\\<span class=\"title\">_loader_src</span><span class=\"params\">($src, $handle)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> preg_replace(<span class=\"string\">'/^(http|https):/'</span>, <span class=\"string\">''</span>, $src);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add\\_filter(<span class=\"string\">'style\\_loader\\_src'</span>, <span class=\"string\">'agnostic\\_style\\_loader\\_src'</span>, <span class=\"number\">20</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">agnostic</span>\\<span class=\"title\">_style</span>\\<span class=\"title\">_loader_src</span><span class=\"params\">($src, $handle)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> preg_replace(<span class=\"string\">'/^(http|https):/'</span>, <span class=\"string\">''</span>, $src);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法优点是可逆，不会对网站的数据库有什么影响，推荐使用这种方法。 调整完内部链接后，检查整个网站的页面，包括首页，栏目页，内容页，sitemap，页面head部分内容，比如：css，js，canonical 等，是否都转换成了 HTTPS 版本。</p>\n<h2 id=\"可能会遇到的问题\"><a href=\"#可能会遇到的问题\" class=\"headerlink\" title=\"可能会遇到的问题\"></a>可能会遇到的问题</h2><h3 id=\"Apache配置文件找不到\"><a href=\"#Apache配置文件找不到\" class=\"headerlink\" title=\"Apache配置文件找不到\"></a>Apache配置文件找不到</h3><p>可能某些童鞋的 apache 配置文件不在 <code>/etc/httpd/conf</code> 目录下，可以通过 find 命令进行查找：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name httpd.conf</span><br></pre></td></tr></table></figure>\n<p>其中“/”是指在根目录下进行查找，如果你知道在哪个目录下，可以自行修改，节省查找的时间</p>\n<h3 id=\"Invalid-command-‘SSLEngine’-perhaps-misspelled-or-defined-by-a-module-not-included-in-the-server-configuration\"><a href=\"#Invalid-command-‘SSLEngine’-perhaps-misspelled-or-defined-by-a-module-not-included-in-the-server-configuration\" class=\"headerlink\" title=\"Invalid command ‘SSLEngine’, perhaps misspelled or defined by a module not included in the server configuration\"></a>Invalid command ‘SSLEngine’, perhaps misspelled or defined by a module not included in the server configuration</h3><p>不管是在证书申请过程中还是在自己修改配置过程中遇到次报错，一般情况下是因为在 modules 文件夹下并没有 ssl 模块，那就需要自己安装了，我在<a href=\"https://stackoverflow.com/questions/5257974/how-to-install-mod-ssl-for-apache-httpd\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>上搜到了解决方案，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install mod_ssl</span><br></pre></td></tr></table></figure>\n<p>当我们安装完毕之后，就可以看到 modules 文件夹下多了一个 mod_ssl.so 文件了，此时我们再重启 apache 就应该不报错了。</p>\n<h3 id=\"warn-module-ssl-module-is-already-loaded-skipping-Address-already-in-use-make-sock-could-not-bind-to-address-0-0-0-0-443-no-listening-sockets-available-shutting-down\"><a href=\"#warn-module-ssl-module-is-already-loaded-skipping-Address-already-in-use-make-sock-could-not-bind-to-address-0-0-0-0-443-no-listening-sockets-available-shutting-down\" class=\"headerlink\" title=\"[warn] module ssl_module is already loaded, skipping Address already in use: make_sock: could not bind to address 0.0.0.0:443 no listening sockets available, shutting down\"></a>[warn] module ssl_module is already loaded, skipping Address already in use: make_sock: could not bind to address 0.0.0.0:443 no listening sockets available, shutting down</h3><p>出现该警告说明 ssl module 被多处使用，可以用如下命令检查：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep ssl_module -rI /etc/httpd/*</span><br></pre></td></tr></table></figure>\n<p>此时会出现：</p>\n<div align=\"center\"><br><img src=\"/images/hexo_post_289.png\" alt=\"\"><br></div>\n\n<p>其中 <code>httpd.bk.conf</code> 是我自己建的备份，所以有两种解决方法：</p>\n<ol>\n<li>httpd.conf 中去掉 <code>LoadModule ssl\\_module modules/mod\\_ssl.so</code>、去掉 <code>Listen 443</code></li>\n<li>直接删除 <code>/etc/httpd/conf.d/ssl.conf</code>，推荐直接删除 ssl.conf</li>\n</ol>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://www.watch-life.net/wordpress/wordpress-https-link.html\" target=\"_blank\" rel=\"noopener\">WordPress整站轻松开启HTTPS</a></p>\n<p><a href=\"https://www.jianshu.com/p/909adc612fd4\" target=\"_blank\" rel=\"noopener\">apache服务器添加https（针对ios10 https）</a></p>\n<p><a href=\"https://stringblog.com/%E9%80%9A%E8%BF%87certbot%E9%85%8D%E7%BD%AElets-encrypt%E7%9A%84ssl%EF%BC%88apache%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">通过Certbot配置Let’s Encrypt的SSL（Apache）</a></p>\n","raw":null,"categories":[{"name":"HTTP","path":"api/categories/HTTP.json"}],"tags":[{"name":"指南","path":"api/tags/指南.json"},{"name":"Wordpress","path":"api/tags/Wordpress.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]}]}