{"name":"排序","postlist":[{"title":"八大排序算法的python实现","slug":"八大排序算法的python实现","date":"2017-03-18T14:17:57.000Z","updated":"2019-07-04T08:09:14.549Z","comments":true,"path":"api/articles/八大排序算法的python实现.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>其实我的 python 水平相当于初学者，但是由于要找实习，所以刷算法是必然的，而经常刷 leetcode 的小伙伴应该知道，用 javascript 实现各种复杂算法的人比较少（排序算法还好，尤其是那些比较知名的排序算法，想看 Javascript 代码实现排序算法的可以点下面那个链接），所以就导致没有思路的时候也看不到别人是如何用 JS 代码实现的，所以必须要懂其他一种语言才能行，而 python 同样作为一种脚本语言，其语法非常简单，也很适合算法的实现，所以就决定在学习 JS 的同时兼顾 python 的学习。<br>这篇文章当然不是我的原创，而是在逛伯乐在线的时候看到的，感觉总结的很好，代码也很规范，故转载至此处，如果作者不允许转载，将及时处理；如果没弄明白排序算法的步骤，想理解的更生动的话，可以查看我的另外一篇文章：<a href=\"/20170318/js-implementation-of-ten-sorting-algorithms.html\">十大排序算法的Javascript实现</a>。</p>\n<h2 id=\"1-插入排序\"><a href=\"#1-插入排序\" class=\"headerlink\" title=\"1. 插入排序\"></a>1. 插入排序</h2><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 插入排序</span></span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, count):</span><br><span class=\"line\">        key = lists[i]</span><br><span class=\"line\">        j = i - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt; key:</span><br><span class=\"line\">                lists[j + <span class=\"number\">1</span>] = lists[j]</span><br><span class=\"line\">                lists[j] = key</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-希尔排序\"><a href=\"#2-希尔排序\" class=\"headerlink\" title=\"2. 希尔排序\"></a>2. 希尔排序</h2><p>希尔排序（Shell Sort）是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因 DL．Shell 于 1959 年提出而得名。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 希尔排序</span></span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    step = <span class=\"number\">2</span></span><br><span class=\"line\">    group = count / step</span><br><span class=\"line\">    <span class=\"keyword\">while</span> group &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, group):</span><br><span class=\"line\">            j = i + group</span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; count:</span><br><span class=\"line\">                k = j - group</span><br><span class=\"line\">                key = lists[j]</span><br><span class=\"line\">                <span class=\"keyword\">while</span> k &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> lists[k] &gt; key:</span><br><span class=\"line\">                        lists[k + group] = lists[k]</span><br><span class=\"line\">                        lists[k] = key</span><br><span class=\"line\">                    k -= group</span><br><span class=\"line\">                j += group</span><br><span class=\"line\">        group /= step</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-冒泡排序\"><a href=\"#3-冒泡排序\" class=\"headerlink\" title=\"3. 冒泡排序\"></a>3. 冒泡排序</h2><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 冒泡排序</span></span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, count):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + <span class=\"number\">1</span>, count):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[i] &gt; lists[j]:</span><br><span class=\"line\">                lists[i], lists[j] = lists[j], lists[i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-快速排序\"><a href=\"#4-快速排序\" class=\"headerlink\" title=\"4. 快速排序\"></a>4. 快速排序</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(lists, left, right)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 快速排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &gt;= right:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lists</span><br><span class=\"line\">    key = lists[left]</span><br><span class=\"line\">    low = left</span><br><span class=\"line\">    high = right</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> lists[right] &gt;= key:</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">        lists[left] = lists[right]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> lists[left] &lt;= key:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        lists[right] = lists[left]</span><br><span class=\"line\">    lists[right] = key</span><br><span class=\"line\">    quick_sort(lists, low, left - <span class=\"number\">1</span>)</span><br><span class=\"line\">    quick_sort(lists, left + <span class=\"number\">1</span>, high)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-直接选择排序\"><a href=\"#5-直接选择排序\" class=\"headerlink\" title=\"5. 直接选择排序\"></a>5. 直接选择排序</h2><p>基本思想：第 1 趟，在待排序记录 r1 ~ r[n] 中选出最小的记录，将它与 r1 交换；第 2 趟，在待排序记录 r2 ~ r[n] 中选出最小的记录，将它与 r2 交换；以此类推，第 i 趟在待排序记录 r[i] ~ r[n] 中选出最小的记录，将它与 r[i] 交换，使有序序列不断增长直到全部排序完毕。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 选择排序</span></span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, count):</span><br><span class=\"line\">        min = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + <span class=\"number\">1</span>, count):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[min] &gt; lists[j]:</span><br><span class=\"line\">                min = j</span><br><span class=\"line\">        lists[min], lists[i] = lists[i], lists[min]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-堆排序\"><a href=\"#6-堆排序\" class=\"headerlink\" title=\"6. 堆排序\"></a>6. 堆排序</h2><p>堆排序（Heapsort）是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即 A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">adjust_heap</span><span class=\"params\">(lists, i, size)</span>:</span></span><br><span class=\"line\">    lchild = <span class=\"number\">2</span> * i + <span class=\"number\">1</span></span><br><span class=\"line\">    rchild = <span class=\"number\">2</span> * i + <span class=\"number\">2</span></span><br><span class=\"line\">    max = i</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &lt; size / <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lchild &lt; size <span class=\"keyword\">and</span> lists[lchild] &gt; lists[max]:</span><br><span class=\"line\">            max = lchild</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rchild &lt; size <span class=\"keyword\">and</span> lists[rchild] &gt; lists[max]:</span><br><span class=\"line\">            max = rchild</span><br><span class=\"line\">        <span class=\"keyword\">if</span> max != i:</span><br><span class=\"line\">            lists[max], lists[i] = lists[i], lists[max]</span><br><span class=\"line\">            adjust_heap(lists, max, size)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_heap</span><span class=\"params\">(lists, size)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, (size/<span class=\"number\">2</span>))[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        adjust_heap(lists, i, size)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    size = len(lists)</span><br><span class=\"line\">    build_heap(lists, size)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, size)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        lists[<span class=\"number\">0</span>], lists[i] = lists[i], lists[<span class=\"number\">0</span>]</span><br><span class=\"line\">        adjust_heap(lists, <span class=\"number\">0</span>, i)</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-归并排序\"><a href=\"#7-归并排序\" class=\"headerlink\" title=\"7. 归并排序\"></a>7. 归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>归并过程为：比较 a[i] 和 a[j] 的大小，若 a[i] ≤ a[j]，则将第一个有序表中的元素 a[i] 复制到 r[k] 中，并令 i 和 k 分别加上 1；否则将第二个有序表中的元素 a[j] 复制到 r[k] 中，并令 j 和 k 分别加上 1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到 r 中从下标 k 到下标 t 的单元。归并排序的算法我们通常用递归实现，先把待排序区间 [s,t] 以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间 [s,t]。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(left, right)</span>:</span></span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; len(left) <span class=\"keyword\">and</span> j &lt; len(right):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left[i] &lt;= right[j]:</span><br><span class=\"line\">            result.append(left[i])</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result.append(right[j])</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    result += left[i:]</span><br><span class=\"line\">    result += right[j:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 归并排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(lists) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lists</span><br><span class=\"line\">    num = len(lists) / <span class=\"number\">2</span></span><br><span class=\"line\">    left = merge_sort(lists[:num])</span><br><span class=\"line\">    right = merge_sort(lists[num:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(left, right)</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-基数排序\"><a href=\"#8-基数排序\" class=\"headerlink\" title=\"8. 基数排序\"></a>8. 基数排序</h2><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为 O(nlog(r)m)，其中 r 为所采取的基数，而 m 为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">radix_sort</span><span class=\"params\">(lists, radix=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class=\"line\">    bucket = [[] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(radix)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            bucket[j/(radix**(i<span class=\"number\">-1</span>)) % (radix**i)].append(j)</span><br><span class=\"line\">        <span class=\"keyword\">del</span> lists[:]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> z <span class=\"keyword\">in</span> bucket:</span><br><span class=\"line\">            lists += z</span><br><span class=\"line\">            <span class=\"keyword\">del</span> z[:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"algorithm","path":"api/categories/algorithm.json"}],"tags":[{"name":"python","path":"api/tags/python.json"},{"name":"排序","path":"api/tags/排序.json"},{"name":"算法","path":"api/tags/算法.json"}]},{"title":"十大排序算法的Javascript实现","slug":"十大排序算法的Javascript实现","date":"2017-03-18T15:13:55.000Z","updated":"2019-07-04T08:09:14.553Z","comments":true,"path":"api/articles/十大排序算法的Javascript实现.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_220.png","content":"<p>我是在微信公众号-前端大全上面看到这篇文章的，大概过去半年时间了，之前看过好多关于排序算法的 JS 版，但是这篇文章是内容最全的，而且还有动图演示，对于算法“白痴”来说理解起来会更容易，所以强烈推荐这篇文章；前端开发者也可以关注一下这个微信公众号，基本上每天都会更新，而且有很多原创的文章，其中不乏面试经验以及关于 JS 和 CSS 的技巧规范以及前端未来发展趋势等等，是一个很好的前端学习工具。 原作者是伯乐在线专栏作者，而十大排序算法的 JS 代码在作者的 github 上也有一个库，想看源码的可以<a href=\"https://github.com/damonare/Sorts\" target=\"_blank\" rel=\"noopener\">戳这里</a>，配合文章会加深对这些排序算法的理解</p>\n<h2 id=\"排序算法说明\"><a href=\"#排序算法说明\" class=\"headerlink\" title=\"排序算法说明\"></a>排序算法说明</h2><h3 id=\"对于评述算法优劣术语的说明\"><a href=\"#对于评述算法优劣术语的说明\" class=\"headerlink\" title=\"对于评述算法优劣术语的说明\"></a>对于评述算法优劣术语的说明</h3><p><strong>稳定</strong>：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；<br><strong>不稳定</strong>：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；<br><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；<br><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>\n<h3 id=\"排序算法图片总结\"><a href=\"#排序算法图片总结\" class=\"headerlink\" title=\"排序算法图片总结\"></a>排序算法图片总结</h3><div align=\"center\"><img src=\"/images/hexo_post_220.png\" alt=\"\" width=\"550\"></div>\n\n<p>图片名词解释：</p>\n<ul>\n<li>n：数据规模</li>\n<li>k：“桶”的个数</li>\n<li>In-place：占用常熟内存，不占用额外内存</li>\n<li>Out-place：占用额外内存</li>\n</ul>\n<h3 id=\"排序分类\"><a href=\"#排序分类\" class=\"headerlink\" title=\"排序分类\"></a>排序分类</h3><div align=\"center\"><img src=\"/images/hexo_post_139.png\" alt=\"\" width=\"450\"></div>\n\n<h2 id=\"1-冒泡排序（bubble-Sort）\"><a href=\"#1-冒泡排序（bubble-Sort）\" class=\"headerlink\" title=\"1. 冒泡排序（bubble Sort）\"></a>1. 冒泡排序（bubble Sort）</h2><h3 id=\"算法简介\"><a href=\"#算法简介\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<h3 id=\"算法具体描述\"><a href=\"#算法具体描述\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤 1~3，直到排序完成。</li>\n</ol>\n<h3 id=\"动画演示\"><a href=\"#动画演示\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_90.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码\"><a href=\"#Javascript-源代码\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：该方法为原始算法*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; len - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;        <span class=\"comment\">//相邻元素两两对比</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> temp = arr[j+<span class=\"number\">1</span>];        <span class=\"comment\">//元素交换</span></span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bubbleSort(arr1));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：该方法为改进算法（设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort2</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = arr.length<span class=\"number\">-1</span>;  <span class=\"comment\">//初始时,最后位置保持不变</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( i&gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> pos= <span class=\"number\">0</span>; <span class=\"comment\">//每趟开始时,无记录交换</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j= <span class=\"number\">0</span>; j&lt; i; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                pos= j; <span class=\"comment\">//记录交换的位置</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> tmp = arr[j]; arr[j]=arr[j+<span class=\"number\">1</span>];arr[j+<span class=\"number\">1</span>]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        i= pos; <span class=\"comment\">//为下一趟排序作准备</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bubbleSort2(arr2));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：该方法为改进算法（传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort3</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> high= arr.length<span class=\"number\">-1</span>; <span class=\"comment\">//设置变量的初始值</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp,j;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'2.改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j= low; j&lt; high; ++j) <span class=\"comment\">//正向冒泡,找到最大者</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                tmp = arr[j]; arr[j]=arr[j+<span class=\"number\">1</span>];arr[j+<span class=\"number\">1</span>]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        --high;                 <span class=\"comment\">//修改high值, 前移一位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=high; j&gt;low; --j) <span class=\"comment\">//反向冒泡,找到最小者</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&lt;arr[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                tmp = arr[j]; arr[j]=arr[j<span class=\"number\">-1</span>];arr[j<span class=\"number\">-1</span>]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ++low;                  <span class=\"comment\">//修改low值,后移一位</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'2.改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bubbleSort3(arr3));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析\"><a href=\"#算法复杂度分析\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(n) =&gt; 当输入的数据已经是正序时</li>\n<li>最差情况：T(n)=O(n2) =&gt; 当输入的数据是反序时</li>\n<li>平均情况：T(n)=O(n2)</li>\n</ul>\n<h2 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2. 选择排序\"></a>2. 选择排序</h2><h3 id=\"算法简介-1\"><a href=\"#算法简介-1\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>选择排序（Selection-sort）是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h3 id=\"算法具体描述-1\"><a href=\"#算法具体描述-1\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>初始状态：无序区为 R[1..n]，有序区为空；</li>\n<li>第 i 趟排序 (i=1,2,3…n-1) 开始时，当前有序区和无序区分别为 R[1..i-1] 和 R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i] 和 R[i+1..n) 分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；</li>\n<li>n-1 趟结束，数组有序化了。</li>\n</ol>\n<h3 id=\"动画演示-1\"><a href=\"#动画演示-1\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_219.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-1\"><a href=\"#Javascript-源代码-1\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：选择排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> minIndex, temp;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'选择排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class=\"comment\">//寻找最小的数</span></span><br><span class=\"line\">                minIndex = j;                 <span class=\"comment\">//将最小数的索引保存</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'选择排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(selectionSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度排序\"><a href=\"#算法复杂度排序\" class=\"headerlink\" title=\"算法复杂度排序\"></a>算法复杂度排序</h3><ul>\n<li>最佳情况：T(n)=O(n2)</li>\n<li>最差情况：T(n)=O(n2)</li>\n<li>平均情况：T(n)=O(n2)</li>\n</ul>\n<h2 id=\"3-插入排序\"><a href=\"#3-插入排序\" class=\"headerlink\" title=\"3. 插入排序\"></a>3. 插入排序</h2><h3 id=\"算法简介-2\"><a href=\"#算法简介-2\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>\n<h3 id=\"算法具体描述-2\"><a href=\"#算法具体描述-2\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>将新元素插入到该位置后；</li>\n<li>重复步骤 2~5。</li>\n</ol>\n<h3 id=\"动画演示-2\"><a href=\"#动画演示-2\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_110.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-2\"><a href=\"#Javascript-源代码-2\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：插入排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.time(<span class=\"string\">'插入排序耗时：'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> key = array[i];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">                array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'插入排序耗时：'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(insertionSort(arr1));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：插入排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：改进后的算法（查找插入位置时使用二分查找的方式）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binaryInsertionSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.time(<span class=\"string\">'二分插入排序耗时：'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> key = array[i], left = <span class=\"number\">0</span>, right = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> middle = <span class=\"built_in\">parseInt</span>((left + right) / <span class=\"number\">2</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key &lt; array[middle]) &#123;</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>; j &gt;= left; j--) &#123;</span><br><span class=\"line\">                array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[left] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'二分插入排序耗时：'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryInsertionSort(arr2));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-1\"><a href=\"#算法复杂度分析-1\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(n) =&gt; 输入数组按升序排列</li>\n<li>最差情况：T(n)=O(n2) =&gt; 输入数组按降序排列</li>\n<li>平均情况：T(n)=O(n2)</li>\n</ul>\n<h2 id=\"4-希尔排序\"><a href=\"#4-希尔排序\" class=\"headerlink\" title=\"4. 希尔排序\"></a>4. 希尔排序</h2><h3 id=\"算法简介-3\"><a href=\"#算法简介-3\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者 Robert Sedgewick 提出的。</p>\n<h3 id=\"算法具体描述-3\"><a href=\"#算法具体描述-3\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1；</li>\n<li>按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ol>\n<h3 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h3><div align=\"center\"><img src=\"/images/hexo_post_225.jpeg\" alt=\"\" width=\"550\"></div>\n\n<h3 id=\"Javascript-源代码-3\"><a href=\"#Javascript-源代码-3\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：希尔排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length,</span><br><span class=\"line\">        temp,</span><br><span class=\"line\">        gap = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(gap &lt; len/<span class=\"number\">5</span>) &#123;          <span class=\"comment\">//动态定义间隔序列</span></span><br><span class=\"line\">        gap =gap*<span class=\"number\">5</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (gap; gap &gt; <span class=\"number\">0</span>; gap = <span class=\"built_in\">Math</span>.floor(gap/<span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i-gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class=\"line\">                arr[j+gap] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j+gap] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shellSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-2\"><a href=\"#算法复杂度分析-2\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n) = O(nlog2n)</li>\n<li>最差情况：T(n) = O(nlog2n)</li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<h2 id=\"5-归并排序\"><a href=\"#5-归并排序\" class=\"headerlink\" title=\"5. 归并排序\"></a>5. 归并排序</h2><h3 id=\"算法简介-4\"><a href=\"#算法简介-4\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。</p>\n<h3 id=\"算法具体描述-4\"><a href=\"#算法具体描述-4\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。</li>\n</ol>\n<h3 id=\"动画演示-3\"><a href=\"#动画演示-3\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_119.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-4\"><a href=\"#Javascript-源代码-4\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：归并排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">arr</span>) </span>&#123;  <span class=\"comment\">//采用自上而下的递归方法</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> middle = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>),</span><br><span class=\"line\">        left = arr.slice(<span class=\"number\">0</span>, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[<span class=\"number\">0</span>] &lt;= right[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mergeSort(arr));</span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-3\"><a href=\"#算法复杂度分析-3\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(n)</li>\n<li>最差情况：T(n)=O(nlogn)</li>\n<li>平均情况：T(n)=O(nlogn)</li>\n</ul>\n<h2 id=\"6-快速排序\"><a href=\"#6-快速排序\" class=\"headerlink\" title=\"6. 快速排序\"></a>6. 快速排序</h2><h3 id=\"算法简介-5\"><a href=\"#算法简介-5\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<h3 id=\"算法具体描述-5\"><a href=\"#算法具体描述-5\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ol>\n<h3 id=\"动画演示-4\"><a href=\"#动画演示-4\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_217.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-5\"><a href=\"#Javascript-源代码-5\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><h4 id=\"方法一-2\"><a href=\"#方法一-2\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：快速排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：方法一*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array, left, right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'1.快速排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span> &amp;&amp; <span class=\"keyword\">typeof</span> left === <span class=\"string\">'number'</span> &amp;&amp; <span class=\"keyword\">typeof</span> right === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> x = array[right],</span><br><span class=\"line\">                i = left - <span class=\"number\">1</span>,</span><br><span class=\"line\">                temp;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = left; j &lt;= right; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt;= x) &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    temp = array[i];</span><br><span class=\"line\">                    array[i] = array[j];</span><br><span class=\"line\">                    array[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            quickSort(array, left, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            quickSort(array, i - <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'1.快速排序耗时'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array or left or right is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-2\"><a href=\"#方法二-2\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：快速排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：方法二*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort2</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'2.快速排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pivotIndex = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pivot = arr.splice(pivotIndex, <span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'2.快速排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> quickSort2(left).concat([pivot], quickSort2(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">47</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">50</span>, <span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(quickSort(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(quickSort2(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-4\"><a href=\"#算法复杂度分析-4\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(nlogn)</li>\n<li>最差情况：T(n)=O(n2)</li>\n<li>平均情况：T(n)=O(nlogn)</li>\n</ul>\n<h2 id=\"7-堆排序\"><a href=\"#7-堆排序\" class=\"headerlink\" title=\"7. 堆排序\"></a>7. 堆排序</h2><h3 id=\"算法简介-6\"><a href=\"#算法简介-6\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<h3 id=\"算法具体描述-6\"><a href=\"#算法具体描述-6\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1,R2,……Rn-1) 和新的有序区 (Rn),且满足 R[1,2…n-1]&lt;=R[n]；</li>\n<li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 R1,R2,……Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。</li>\n</ol>\n<h3 id=\"动画演示-5\"><a href=\"#动画演示-5\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_106.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-6\"><a href=\"#Javascript-源代码-6\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：堆排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'堆排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//建堆</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> heapSize = array.length, temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(heapSize / <span class=\"number\">2</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            heaping(array, i, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//堆排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = heapSize - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            temp = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">            array[<span class=\"number\">0</span>] = array[j];</span><br><span class=\"line\">            array[j] = temp;</span><br><span class=\"line\">            heaping(array, <span class=\"number\">0</span>, --heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'堆排序耗时'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 方法说明：维护堆的性质</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> x-数组下标</span></span><br><span class=\"line\"><span class=\"comment\"> len-堆大小</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heaping</span>(<span class=\"params\">arr, x, len</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(arr).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span> &amp;&amp; <span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> l = <span class=\"number\">2</span> * x + <span class=\"number\">1</span>,</span><br><span class=\"line\">            r = <span class=\"number\">2</span> * x + <span class=\"number\">2</span>,</span><br><span class=\"line\">            largest = x,</span><br><span class=\"line\">            temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heaping(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">47</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">50</span>, <span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(heapSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-5\"><a href=\"#算法复杂度分析-5\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(nlogn)</li>\n<li>最差情况：T(n)=O(nlogn)</li>\n<li>平均情况：T(n)=O(nlogn)</li>\n</ul>\n<h2 id=\"8-计数排序\"><a href=\"#8-计数排序\" class=\"headerlink\" title=\"8. 计数排序\"></a>8. 计数排序</h2><h3 id=\"算法简介-7\"><a href=\"#算法简介-7\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。</p>\n<h3 id=\"算法具体描述-7\"><a href=\"#算法具体描述-7\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>\n<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</li>\n</ol>\n<h3 id=\"动画演示-6\"><a href=\"#动画演示-6\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_95.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-7\"><a href=\"#Javascript-源代码-7\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：计数排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = array.length,</span><br><span class=\"line\">        B = [],</span><br><span class=\"line\">        C = [],</span><br><span class=\"line\">        min = array[<span class=\"number\">0</span>],</span><br><span class=\"line\">        max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'计数排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i =<span class=\"number\">0</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        min= min&lt;=array[i] ? min:array[i];</span><br><span class=\"line\">        max = max &gt;=array[i] ? max : array[i];</span><br><span class=\"line\">        C[array[i]] = C[array[i]] ? C[array[i]] +<span class=\"number\">1</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = min; j&lt; max;j++)&#123;</span><br><span class=\"line\">        C[j+<span class=\"number\">1</span>] = (C[j+<span class=\"number\">1</span>] || <span class=\"number\">0</span>) + (C[j] || <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = len <span class=\"number\">-1</span> ;k &gt;=<span class=\"number\">0</span>; k--)&#123;</span><br><span class=\"line\">        B[C[array[k]] - <span class=\"number\">1</span>] = array[k];</span><br><span class=\"line\">        C[array[k]] --;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'计数排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(countingSort(arr));<span class=\"comment\">//[1,1,2,2,2,2,2,2,2,2,3,3,4,4,6,7,7,8,8,9,9]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-6\"><a href=\"#算法复杂度分析-6\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>\n<ul>\n<li>最佳情况：T(n)=O(n+k)</li>\n<li>最差情况：T(n)=O(n+k)</li>\n<li>平均情况：T(n)=O(n+k)</li>\n</ul>\n<h2 id=\"9-桶排序\"><a href=\"#9-桶排序\" class=\"headerlink\" title=\"9. 桶排序\"></a>9. 桶排序</h2><h3 id=\"算法简介-8\"><a href=\"#算法简介-8\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>桶排序（Bucket sort）的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p>\n<h3 id=\"算法具体描述-8\"><a href=\"#算法具体描述-8\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶进行排序；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。</li>\n</ol>\n<h3 id=\"图示-1\"><a href=\"#图示-1\" class=\"headerlink\" title=\"图示\"></a>图示</h3><div align=\"center\"><img src=\"/images/hexo_post_318.jpeg\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-8\"><a href=\"#Javascript-源代码-8\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：桶排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> num-桶的数量</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">array, num</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = array.length,</span><br><span class=\"line\">        buckets = [],</span><br><span class=\"line\">        result = [],</span><br><span class=\"line\">        min = array[<span class=\"number\">0</span>],</span><br><span class=\"line\">        max = array[<span class=\"number\">0</span>],</span><br><span class=\"line\">        regex = <span class=\"string\">'/^[1-9]+[0-9]*$/'</span>,</span><br><span class=\"line\">        space,</span><br><span class=\"line\">        n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    num = num || ((num &gt; <span class=\"number\">1</span> &amp;&amp; regex.test(num)) ? num : <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'桶排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        min = min &lt;= array[i] ? min : array[i];</span><br><span class=\"line\">        max = max &gt;= array[i] ? max : array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    space = (max - min + <span class=\"number\">1</span>) / num;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"built_in\">Math</span>.floor((array[j] - min) / space);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buckets[index]) &#123; <span class=\"comment\">//非空桶，插入排序</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> k = buckets[index].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</span><br><span class=\"line\">                buckets[index][k + <span class=\"number\">1</span>] = buckets[index][k];</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            buckets[index][k + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//空桶，初始化</span></span><br><span class=\"line\">            buckets[index] = [];</span><br><span class=\"line\">            buckets[index].push(array[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &lt; num) &#123;</span><br><span class=\"line\">        result = result.concat(buckets[n]);</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'桶排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">47</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">50</span>, <span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bucketSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-7\"><a href=\"#算法复杂度分析-7\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>\n<ul>\n<li>最佳情况：T(n)=O(n+k)</li>\n<li>最差情况：T(n)=O(n+k)</li>\n<li>平均情况：T(n)=O(n2)</li>\n</ul>\n<h2 id=\"10-基数排序\"><a href=\"#10-基数排序\" class=\"headerlink\" title=\"10. 基数排序\"></a>10. 基数排序</h2><h3 id=\"算法简介-9\"><a href=\"#算法简介-9\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>\n<h3 id=\"算法具体描述-9\"><a href=\"#算法具体描述-9\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr 为原始数组，从最低位开始取每个位组成 radix 数组；</li>\n<li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</li>\n</ol>\n<h3 id=\"动画演示-7\"><a href=\"#动画演示-7\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_218.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-9\"><a href=\"#Javascript-源代码-9\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：基数排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> maxDigit-最大位数</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：基数排序适用于：</span></span><br><span class=\"line\"><span class=\"comment\"> （1）数据范围较小，建议小于1000</span></span><br><span class=\"line\"><span class=\"comment\"> （2）每个数值都要大于等于0*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">radixSort</span>(<span class=\"params\">arr, maxDigit</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mod = <span class=\"number\">10</span>,</span><br><span class=\"line\">        dev = <span class=\"number\">1</span>,</span><br><span class=\"line\">        counter = [];</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'基数排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; maxDigit; i++, dev *= <span class=\"number\">10</span>, mod *= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bucket = <span class=\"built_in\">parseInt</span>((arr[j] % mod) / dev);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (counter[bucket] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                counter[bucket] = [];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            counter[bucket].push(arr[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; counter.length; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (counter[k] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((value = counter[k].shift()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                arr[pos++] = value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'基数排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">47</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">50</span>, <span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(radixSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-8\"><a href=\"#算法复杂度分析-8\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(n*k)</li>\n<li>最差情况：T(n)=O(n*k)</li>\n<li>平均情况：T(n)=O(n*k)</li>\n</ul>\n","raw":null,"categories":[{"name":"algorithm","path":"api/categories/algorithm.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"排序","path":"api/tags/排序.json"},{"name":"算法","path":"api/tags/算法.json"}]}]}