{"name":"笔记","postlist":[{"title":"Blue老师ES6视频笔记","slug":"Blue老师ES6视频笔记","date":"2017-12-12T14:10:42.000Z","updated":"2019-03-29T10:17:04.612Z","comments":true,"path":"api/articles/Blue老师ES6视频笔记.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>请容许我吐槽一下，我发现中国很多前端的大神的英文真的差啊。。</p>\n<h2 id=\"ES6-兼容性\"><a href=\"#ES6-兼容性\" class=\"headerlink\" title=\"ES6 兼容性\"></a>ES6 兼容性</h2><p>可以在线查看兼容性：</p>\n<ul>\n<li>ES5：<a href=\"https://kangax.github.io/compat-table/es5/\" target=\"_blank\" rel=\"noopener\">kangax.github.io/compat-table/es5/</a></li>\n<li>ES6：<a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"noopener\">kangax.github.io/compat-table/es6/</a></li>\n</ul>\n<h3 id=\"在线编译\"><a href=\"#在线编译\" class=\"headerlink\" title=\"在线编译\"></a>在线编译</h3><p><strong>babel === browser.js</strong>，只不过叫法不同 可以通过如下方式实现在线编译 ES6，只不过会多出额外的编译时间，用户体验稍差：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"browser.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/babel\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> a = <span class=\"number\">12</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> b = <span class=\"number\">5</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    alert(a+b);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"ES5-中-var-的缺点：\"><a href=\"#ES5-中-var-的缺点：\" class=\"headerlink\" title=\"ES5 中 var 的缺点：\"></a>ES5 中 var 的缺点：</h3><ul>\n<li>可以重复声明</li>\n<li>无法限制修改，即没有常量的概念</li>\n<li>没有块级作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert a; <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"块级作用域有什么用？\"><a href=\"#块级作用域有什么用？\" class=\"headerlink\" title=\"块级作用域有什么用？\"></a>块级作用域有什么用？</h3><p>可以限定变量在块中起作用，而不像ES5一样在函数块中起作用，最常见的是 for 循环中的索引值</p>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ol>\n<li>如果只有一个参数，()可以省略</li>\n<li>如果只有一个 return，{}可以省略</li>\n</ol>\n<h2 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h2><p>ES6新增：</p>\n<h3 id=\"参数扩展（…args必须为最后一个形参）\"><a href=\"#参数扩展（…args必须为最后一个形参）\" class=\"headerlink\" title=\"参数扩展（…args必须为最后一个形参）\"></a>参数扩展（…args必须为最后一个形参）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b, ...args</span>)</span>&#123;</span><br><span class=\"line\">  alert(a);</span><br><span class=\"line\">  alert(b);</span><br><span class=\"line\">  alert(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">show(<span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"展开一个数组\"><a href=\"#展开一个数组\" class=\"headerlink\" title=\"展开一个数组\"></a>展开一个数组</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\];</span><br><span class=\"line\">\\[...arr\\] = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\];</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b=<span class=\"number\">5</span>, c=<span class=\"number\">12</span></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b, c\\] = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[&#123;a, b&#125;, \\[n1, n2, n3\\], num, str\\] = \\[&#123;<span class=\"attr\">a</span>: <span class=\"number\">12</span>, <span class=\"attr\">b</span>: <span class=\"number\">5</span>&#125;, \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>\\], <span class=\"number\">8</span>, <span class=\"string\">'cxzcv'</span>\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, n1, n2, n3, num, str);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b\\] = &#123;<span class=\"attr\">a</span>: <span class=\"number\">12</span>, <span class=\"attr\">b</span>: <span class=\"number\">45</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// undefined is not a function, 前提1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125; = &#123;<span class=\"number\">12</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// unexpected token, 前提2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b\\];</span><br><span class=\"line\">\\[a, b\\] = \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>\\]; <span class=\"comment\">// XXXX error, 前提3</span></span><br></pre></td></tr></table></figure>\n<p>前提：</p>\n<ol>\n<li>左右两边解构必须一样</li>\n<li>右边必须是个东西</li>\n<li>声明和赋值不能分开（必须在一句话中完成）</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>新增四个方法：</p>\n<ul>\n<li>map：映射</li>\n<li>reduce：汇总</li>\n<li>filter：过滤器</li>\n<li>forEach：循环（迭代）</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result); <span class=\"comment\">// 24, 10, 16</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><p>经常用来算总数、平均数等指标</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">69</span>, <span class=\"number\">180</span>, <span class=\"number\">8763</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tmp, item, index</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp + item;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result);</span><br></pre></td></tr></table></figure>\n<p>求平均数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">69</span>, <span class=\"number\">180</span>, <span class=\"number\">8763</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\">(<span class=\"params\">tmp, item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index != arr.length - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp+item;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (tmp+item)/arr.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result);</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>filter 中 return true 就留下来，return false 就不保留</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>类似于传统的 for 循环，参数为 item, index</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>新增：</p>\n<ol>\n<li>多了两个新方法，startsWith，endsWith</li>\n<li>字符串模板</li>\n</ol>\n<h3 id=\"字符串模板\"><a href=\"#字符串模板\" class=\"headerlink\" title=\"字符串模板\"></a>字符串模板</h3><p>普通字符串无法折行，字符串模板可以折行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = \\<span class=\"string\">`a<span class=\"subst\">$&#123;a&#125;</span>bc\\`;</span></span><br><span class=\"line\"><span class=\"string\">alert(str); // a12bc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p>ES5 中的面向对象：类和构造函数不分，混为一谈；ES6 中的面向对象：</p>\n<ol>\n<li>class 关键字，构造器和类分开了</li>\n<li>class 里面直接加方法</li>\n<li>extends-继承</li>\n</ol>\n<h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2><p>json 的标准写法：</p>\n<ol>\n<li>只能用双引号</li>\n<li>所有的名字（key）都必须用引号包起来</li>\n</ol>\n<p>在 ES 中，当名字和值相同时，可以只写其中一个；方法可以省掉: function</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>异步会让代码更复杂，而同步的代码简单，而 Promise 用同步的方式来书写异步代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">  $.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'arr.txt'</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    success(arr)&#123;</span><br><span class=\"line\">      resolve(arr);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error(err)&#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'成功'</span>)&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'失败'</span>)&#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise.all([promise1, promise2, …]) =&gt; 都 resolve 的时候才算成功，只要有一个 reject 就算失败<br>Promise.\brace([promise1, promise2, …]) =&gt; 只要有一个 resolve 的时候就算成功，全部 reject 才算失败 在高版本 jQuery 中，$.ajax 的返回值就是一个 Promise 对象</p>\n<h2 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h2><p>和普通函数相比，中间能暂停，需要和 yield 配合使用 generator 并不会直接执行，而是会创建一个 generator 对象，其中该对象的 next 方法用于继续执行，碰到 yield 就会停</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  alert(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = show();</span><br><span class=\"line\">genObj.next(); <span class=\"comment\">// a</span></span><br><span class=\"line\">genObj.next(); <span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><p>yield 既可以传参，又可以返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">show</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">`<span class=\"subst\">$&#123;num1&#125;</span>, <span class=\"subst\">$&#123;num2&#125;</span>`</span>);</span><br><span class=\"line\">  alert(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  alert(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  alert(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = show(<span class=\"number\">99</span>, <span class=\"number\">88</span>);</span><br><span class=\"line\">gen.next(<span class=\"number\">12</span>); <span class=\"comment\">// 第一个next没法给yield传参</span></span><br><span class=\"line\">gen.next(<span class=\"number\">5</span>); <span class=\"comment\">// 会传给上面的yield，所以a=5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-的局限性\"><a href=\"#Promise-的局限性\" class=\"headerlink\" title=\"Promise 的局限性\"></a>Promise 的局限性</h3><p>其实 generator 之所以出现也是因为纯 Promise 也有其自身的缺陷，并不能完全避免“回调陷阱”，而网上对于 Promise 的局限性解释很多，建议大家直接去看相关博客就可以了，而在我理解就是<strong>Promise 在解决数据依赖问题时避免不了“回调陷阱”</strong>，比如我需要根据数据 A 去请求数据 B，然后再根据数据 B 请求数据 C，然后再……，如果你自己用 Promis e实现一下的话就会发现这时候它的局限性所在；这也再一次证明了那句话：<strong>懒惰是最大生产力</strong></p>\n<h2 id=\"ES7-预览\"><a href=\"#ES7-预览\" class=\"headerlink\" title=\"ES7 预览\"></a>ES7 预览</h2><p>ES6 还没掌握，ES7 都定稿了。。ES8 都有草案了。。，不过现在浏览器对 ES7 的支持很惨</p>\n<ul>\n<li>数组 includes -&gt; 检查数组是否包含某元素</li>\n<li>数组 keys/values/entries -&gt; 一般配合 for…of 使用，for…of 即对 value 的循环，entries 是对键值对的循环</li>\n<li>求幂新操作符 -&gt; 3**8 === Math.pow(3, 8)</li>\n<li>字符串的 padStart/padEnd 方法 -&gt; 补充空格或其他字符串</li>\n<li>增加了函数容忍度 function show(a, b, c, ) -&gt; 不报错</li>\n<li>async 和 await，这基本上是 ES7 最好用的。。用于替代 generator 和 yield</li>\n<li>……</li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"ES6","path":"api/tags/ES6.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"Promise入门","slug":"Promise入门","date":"2018-02-26T14:14:10.000Z","updated":"2019-03-29T10:17:04.616Z","comments":true,"path":"api/articles/Promise入门.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>幕课网上的视频——<a href=\"https://www.imooc.com/learn/949\" target=\"_blank\" rel=\"noopener\">Promise入门</a>笔记，Promise 作为 ES6 中最重要的特性之一，对其进行了解和学习是非常有必要的，课程的源码已经上传至<a href=\"https://github.com/merrier/imooc-promise-sample\" target=\"_blank\" rel=\"noopener\">我的github</a>。</p>\n<h2 id=\"Promise是什么\"><a href=\"#Promise是什么\" class=\"headerlink\" title=\"Promise是什么\"></a>Promise是什么</h2><h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><blockquote>\n<ul>\n<li>The Promise object is used for asynchronous computations.</li>\n<li>A Promise represents a value which may be available now, or in the future, or never.</li>\n</ul>\n</blockquote>\n<h3 id=\"MDN中文\"><a href=\"#MDN中文\" class=\"headerlink\" title=\"MDN中文\"></a>MDN中文</h3><blockquote>\n<ul>\n<li>Promise对象用于异步计算。</li>\n<li>一个Promise表示一个现在、将来或永不可能可用的值。</li>\n</ul>\n</blockquote>\n<h3 id=\"按照用途来解释\"><a href=\"#按照用途来解释\" class=\"headerlink\" title=\"按照用途来解释\"></a>按照用途来解释</h3><ul>\n<li>主要用于异步计算</li>\n<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。</li>\n<li>可以在对象之间传递和操作Promise，帮助我们处理队列。</li>\n</ul>\n<h2 id=\"回调存在的问题\"><a href=\"#回调存在的问题\" class=\"headerlink\" title=\"回调存在的问题\"></a>回调存在的问题</h2><ol>\n<li>嵌套层次很深，难以维护</li>\n<li>无法正常使用 return 和 throw</li>\n<li>无法正常检索堆栈信息</li>\n<li>多个回调之间难以建立联系</li>\n</ol>\n<h2 id=\"Promise-详解\"><a href=\"#Promise-详解\" class=\"headerlink\" title=\"Promise 详解\"></a>Promise 详解</h2><ul>\n<li>Promise 是一个代理对象，它和原先要进行的操作并无关系</li>\n<li>它通过引入一个回调，避免更多的回调</li>\n</ul>\n<h3 id=\"Promise-有-3-个状态\"><a href=\"#Promise-有-3-个状态\" class=\"headerlink\" title=\"Promise 有 3 个状态\"></a>Promise 有 3 个状态</h3><ol>\n<li>pending[待定]——初始状态</li>\n<li>fulfilled[实现\\——操作成功</li>\n<li>rejected[被否决]——操作失败</li>\n</ol>\n<p>当 Promise 的状态发生改变，就会触发 .then() 里的响应函数处理后续步骤；Promise 状态一经改变，不会再变；只有在连续多个回调顺序执行的时候，Promise才会显示出其威力</p>\n<h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\".then()\"></a>.then()</h3><ul>\n<li>.then() 接受两个函数作为参数，分别代表 fulfilled 和 rejected</li>\n<li>.then() 返回一个新的 Promise 实例，所以它可以链式调用</li>\n<li>当前面的 Promise 状态改变时，.then() 根据其最终状态，选择特定的状态响应函数执行</li>\n<li>状态响应函数可以返回新的 Promise，或其它值</li>\n<li>如果返回新的 Promise，那么下一级 .then() 会在新的 Promise 状态改变之后执行</li>\n<li>如果返回其它任何值，则会立刻执行下一级 .then()</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>Promise 会自动捕获内部异常，并交给 rejected 响应函数处理 最好是在语句的最后通过 catch 捕获错误，因为 catch 可以捕获 resolve 回调中发生的错误，而 reject 回调无法捕获；catch 也会返回一个 Promise 实例，并且它返回的 Promise 实例如果没有错误的话也是 fulfilled 状态，所以 catch() 后面的 .then() 也都会触发，但是 catch() 后面的 .catch() 不会触发（<strong>如果在第一个catch()中没有抛出错误</strong>）</p>\n<p><strong>强烈建议在所有队列最后都加上.catch()，以避免漏掉错误处理造成意想不到的问题：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething()</span><br><span class=\"line\">  .doAnotherThing()</span><br><span class=\"line\">  .doMoreThing()</span><br><span class=\"line\">  .catch( <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现队列\"><a href=\"#实现队列\" class=\"headerlink\" title=\"实现队列\"></a>实现队列</h3><p>有时候我们不希望所有动作一起发生，而是按照一定顺序，逐个进行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = doSomething();</span><br><span class=\"line\">promise = promise.then(doSomethingElse);</span><br><span class=\"line\">promise = promise.then(doSomethingElse2);</span><br><span class=\"line\">promise = promise.then(doSomethingElse3);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-forEach\"><a href=\"#使用-forEach\" class=\"headerlink\" title=\"使用.forEach()\"></a>使用.forEach()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">queue</span>(<span class=\"params\">things</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  things.forEach( <span class=\"function\"><span class=\"params\">thing</span> =&gt;</span> &#123;</span><br><span class=\"line\">    promise = promise.then( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>( <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        doThing(thing, () =&gt; &#123;</span><br><span class=\"line\">          resolve();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(\\[<span class=\"string\">'lots'</span>, <span class=\"string\">'of'</span>, <span class=\"string\">'things'</span>, ....\\]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-reduce\"><a href=\"#使用-reduce\" class=\"headerlink\" title=\"使用.reduce()\"></a>使用.reduce()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">queue</span>(<span class=\"params\">things</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> things.reduce( <span class=\"function\">(<span class=\"params\">promise, thing</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    promise = promise.then( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>( <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        doThing(thing, () =&gt; &#123;</span><br><span class=\"line\">          resolve();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, <span class=\"built_in\">Promise</span>.resolve());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(\\[<span class=\"string\">'lots'</span>, <span class=\"string\">'of'</span>, <span class=\"string\">'things'</span>, ....\\]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise常用函数\"><a href=\"#Promise常用函数\" class=\"headerlink\" title=\"Promise常用函数\"></a>Promise常用函数</h2><h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h3><p>返回一个 fulfilled 的 Promise 实例，或原始 Promise 实例</p>\n<ul>\n<li>参数为空，返回一个状态为 fulfilled 的 Promise 实例</li>\n<li>参数是一个跟 Promise 无关的值，同上，不过 fulfilled 响应函数会得到这个参数</li>\n<li>参数为 Promise 实例，则返回该实例，不做任何修改</li>\n<li>参数为 thenable（有 then 方法），立刻执行它的 .then()</li>\n</ul>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h3><p>返回一个 rejected 的 Promise 实例</p>\n<ul>\n<li><strong>Promise.reject()不认thenable</strong></li>\n<li>其他和 Promise.resolve() 类似</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h3><p><code>Promise.all(\\[p1, p2, p3, ...\\])</code> 用于将多个 Promise 实例包装成一个新的 Promise 实例 当所有子 Promise 都完成，该 Promise 完成，返回值是<strong>全部值的数组</strong>；有任何一个失败，该 Promise 失败，返回值是<strong>第一个失败的子Promise的结果</strong>，最常见的是和 .map() 连用</p>\n<p>###Promise.race()</p>\n<p>类似 Promise.all() ，区别在于它有任意一个完成就算完成。</p>\n<h3 id=\"常见用法：\"><a href=\"#常见用法：\" class=\"headerlink\" title=\"常见用法：\"></a>常见用法：</h3><ul>\n<li>把异步操作和定时器放在一起</li>\n<li>如果定时器先触发，就认为超时，告知用户</li>\n</ul>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2><p>ES2017 新增运算符，新的语言元素</p>\n<ul>\n<li>赋予 JavaScript 以顺序手法编写异步脚本的能力！</li>\n<li>既保留异步运算的无阻赛特性，还继续使用同步写法。</li>\n<li>还能正常使用 return/try/catch</li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"ES6","path":"api/tags/ES6.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"慕课网","path":"api/tags/慕课网.json"}]},{"title":"机器学习概念入门","slug":"机器学习概念入门","date":"2017-11-02T14:23:08.000Z","updated":"2019-03-29T10:17:04.620Z","comments":true,"path":"api/articles/机器学习概念入门.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_287.png","content":"<p>最近在做毕设，需要用到一些机器学习的内容（不要问我为什么，做前端根本没办法毕业！），这篇文章是我看 bilibili 上<a href=\"https://www.bilibili.com/video/av12556478/\" target=\"_blank\" rel=\"noopener\">莫烦系列教程-Tensorflow教程</a>时候做的笔记，都是一些机器学习入门概念，如果你和我一样都是入门选手，我相信这些概念能够帮助到你~</p>\n<h2 id=\"什么是机器学习\"><a href=\"#什么是机器学习\" class=\"headerlink\" title=\"什么是机器学习\"></a>什么是机器学习</h2><p>机器学习是一帮计算机科学家想让计算机像人一样思考，所研发出来的计算机理论</p>\n<h2 id=\"机器学习分类\"><a href=\"#机器学习分类\" class=\"headerlink\" title=\"机器学习分类\"></a>机器学习分类</h2><h3 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h3><p>有数据和标签</p>\n<h3 id=\"非监督学习\"><a href=\"#非监督学习\" class=\"headerlink\" title=\"非监督学习\"></a>非监督学习</h3><p>只有数据，没有标签</p>\n<h3 id=\"半监督学习\"><a href=\"#半监督学习\" class=\"headerlink\" title=\"半监督学习\"></a>半监督学习</h3><p>结合了监督学习和非监督学习</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>从经验中总结提升</p>\n<h3 id=\"遗传算法\"><a href=\"#遗传算法\" class=\"headerlink\" title=\"遗传算法\"></a>遗传算法</h3><p>和强化学习类似，有着适者生存，不适者淘汰准则</p>\n<h2 id=\"什么是神经网络\"><a href=\"#什么是神经网络\" class=\"headerlink\" title=\"什么是神经网络\"></a>什么是神经网络</h2><p>神经网络是一种数学模型，是存在于计算机的神经系统，由大量的神经元相连接并进行计算，在外界信息的基础上，改变内部的结构，常用来对输入和输出间复杂的关系进行建模。</p>\n<p>神经网络由大量的节点和之间的联系构成，负责传递信息和加工信息，神经元也可以通过训练而被强化。</p>\n<h2 id=\"怎么检验神经网络\"><a href=\"#怎么检验神经网络\" class=\"headerlink\" title=\"怎么检验神经网络\"></a>怎么检验神经网络</h2><p>为了检验、评价神经网络，并努力改善这些问题，我们常会把收集到的数据分为<strong>训练数据</strong>和<strong>测试数据</strong>，一般用于训练的数据可以是全部数据的百分之 70，剩下的百分之 30 可以用来测试学习结果。接着，对于神经网络的评价，基本上基于这百分之 30 的测试结果。</p>\n<ul>\n<li>评价机器学习可以从误差这个值开始，随着训练时间的变长，优秀的神经网络能够预测到更精准的答案，预测的误差也会越小；</li>\n<li>除了误差曲线，我们也可以看它的精确度曲线，最好的精度是趋向于百分之百的精度；</li>\n<li>对于回归问题，我们可以采用 R2 score 作为评分标准；</li>\n<li>还有 F1 score 用来测量不均衡数据的精度。</li>\n</ul>\n<h2 id=\"什么叫过拟合\"><a href=\"#什么叫过拟合\" class=\"headerlink\" title=\"什么叫过拟合\"></a>什么叫过拟合</h2><p>如下图，训练时的误差比测试误差小，神经网络虽然学习到了知识，但是对于训练数据太过依赖，所以测试数据产生的误差会产生波谷，后面会变大。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_287.png\" alt=\"\" width=\"400\"></div>\n\n<p>在机器学习中，解决过拟合的方法也有很多，比如 <strong>L1，L2正规化</strong>和 <strong>Dropout方法</strong></p>\n<h2 id=\"什么是交叉验证\"><a href=\"#什么是交叉验证\" class=\"headerlink\" title=\"什么是交叉验证\"></a>什么是交叉验证</h2><p>交叉验证不仅可以用于神经网络的调参，还可以用于其他机器学习方法的调参，同样是选择你想观看的误差值或者精确度，不过横坐标不再是学习时间，而是你要测试的某一参数，比如说神经网络的层数。。</p>\n<h2 id=\"为什么要特征标准化\"><a href=\"#为什么要特征标准化\" class=\"headerlink\" title=\"为什么要特征标准化\"></a>为什么要特征标准化</h2><p>我们在机器学习训练之前, 先对数据预先处理一下, 取值跨度大的特征数据, 我们浓缩一下, 跨度小的括展一下, 使得他们的跨度尽量统一，这样可以<strong>提升学习效率</strong> 通常用于 特征标准化的途径有两种, 一种叫做 min max normalization, 他会将所有特征数据按比例缩放到 0-1 的这个取值区间. 有时也可以是 -1 到 1 的区间. 还有一种叫做 standard deviation normalization, 他会将所有特征数据缩放成平均值为 0, 方差为 1. 使用这些标准化手段. 我们不仅可以快速推进机器学习的学习速度, 还可以<strong>避免机器学习学得特扭曲</strong>.</p>\n<h2 id=\"区分好用的特征\"><a href=\"#区分好用的特征\" class=\"headerlink\" title=\"区分好用的特征\"></a>区分好用的特征</h2><p>在选择特征的时候,我们得要时刻回想起这三点.：</p>\n<ol>\n<li>避免无意义的信息</li>\n<li>避免重复性的信息</li>\n<li>避免复杂的信息</li>\n</ol>\n<p>这就是我们这次机器学习简介中所聊到的如何区分好用的特征</p>\n<h2 id=\"为什么需要激励函数\"><a href=\"#为什么需要激励函数\" class=\"headerlink\" title=\"为什么需要激励函数\"></a>为什么需要激励函数</h2><p>因为现实中的问题往往不是线性的，所以需要一个激励函数<strong>来扭曲原来的线性结果</strong> 你甚至可以创造自己的激励函数来处理自己的问题, 不过要确保的是这些激励函数必须是可以微分的, 因为在 backpropagation 误差反向传递的时候, 只有这些可微分的激励函数才能把误差传递回去. 在少量层结构中, 我们可以尝试很多种不同的激励函数. 在卷积神经网络 Convolutional neural networks 的卷积层中, 推荐的激励函数是 relu. 在循环神经网络中 recurrent neural networks, 推荐的是 tanh 或者是 relu</p>\n<h2 id=\"如何加速神经网络训练\"><a href=\"#如何加速神经网络训练\" class=\"headerlink\" title=\"如何加速神经网络训练\"></a>如何加速神经网络训练</h2><p>越复杂的神经网络，越多的数据，我们需要在训练神经网络的过程上花费的时间也就越多；原因很简单，就是因为计算量太大了。可是往往有时候为了解决复杂的问题, 复杂的结构和大数据又是不能避免的, 所以我们需要寻找一些方法, 让神经网络聪明起来, 快起来. 包括以下几种模式:</p>\n<ul>\n<li>Stochastic Gradient Descent (SGD)</li>\n<li>Momentum</li>\n<li>AdaGrad</li>\n<li>RMSProp</li>\n<li>Adam</li>\n</ul>\n<p>关于这几种方法的具体原理，可以<a href=\"https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-06-speed-up-learning/\" target=\"_blank\" rel=\"noopener\">点击这里</a>观看莫烦的讲解</p>\n<h2 id=\"如何处理不均衡数据\"><a href=\"#如何处理不均衡数据\" class=\"headerlink\" title=\"如何处理不均衡数据\"></a>如何处理不均衡数据</h2><p>不均衡的数据预测起来很简单. 永远都猜多的那一方面准没错. 没错, 机器也懂这个小伎俩. 所以机器学到最后, 学乖了, 每次都预测多数派. 解决的方法有几种, 我们来谈谈.</p>\n<h3 id=\"方法一：想办法获取更多数据\"><a href=\"#方法一：想办法获取更多数据\" class=\"headerlink\" title=\"方法一：想办法获取更多数据\"></a>方法一：想办法获取更多数据</h3><h3 id=\"方法二：更换评判方式\"><a href=\"#方法二：更换评判方式\" class=\"headerlink\" title=\"方法二：更换评判方式\"></a>方法二：更换评判方式</h3><p>通常, 我们会用到准确率 accuracy, 或者误差 cost 来判断机器学习的成果. 可是这些评判方法在不均衡数据面前, 高的准确率和低的误差变得没那么重要. 所以我们得换一种方式评判. 通过 confusion matrix 来计算 precision 和 recall, 然后通过 precision 和 recall 再计算f1 score.这种方式能成功地区分不均衡数据, 给出更好的评判分数.</p>\n<h3 id=\"方法三：重组数据\"><a href=\"#方法三：重组数据\" class=\"headerlink\" title=\"方法三：重组数据\"></a>方法三：重组数据</h3><p>这是最简单粗暴的方法之一，重新组合不均衡数据，使之均衡。有两种方式：</p>\n<ol>\n<li>复制或者合成少数部分的样本, 使之和多数部分差不多数量</li>\n<li>砍掉一些多数部分, 使两者数量差不多</li>\n</ol>\n<h3 id=\"方法四：使用其他机器学习方法\"><a href=\"#方法四：使用其他机器学习方法\" class=\"headerlink\" title=\"方法四：使用其他机器学习方法\"></a>方法四：使用其他机器学习方法</h3><p>如果使用的机器学习方法像神经网络等, 在面对不均衡数据时, 通常是束手无策. 不过有些机器学习方法, 像决策树, decision trees 就不会受到不均很数据的影响.</p>\n<h3 id=\"方法五：修改算法\"><a href=\"#方法五：修改算法\" class=\"headerlink\" title=\"方法五：修改算法\"></a>方法五：修改算法</h3><p>最后一种方法是让自己变得有创造力, 尝试修改算法. 如果你用的是 Sigmoid 的激励函数, activation function, 他会有一个<strong>预测门槛</strong>, 一般如果输出结果落在门槛的这一段,预测结果为梨, 如果落在这一段, 预测结果为苹果, 不过因为现在的梨是多数派, 我们得<strong>调整一下门槛的位置，</strong>使得门槛偏向苹果这边, 只有很自信的时候, 模型才会预测这是苹果. 让机器学习,学习到更好的效果.</p>\n<h2 id=\"什么是批标准化\"><a href=\"#什么是批标准化\" class=\"headerlink\" title=\"什么是批标准化\"></a>什么是批标准化</h2><p>和普通的数据标准化类似, 是将分散的数据统一的一种做法, 也是优化神经网络的一种方法. Batch normalization 的 batch 是批数据, <strong>把数据分成小批小批进行 stochastic gradient descent. 而且在每批数据进行前向传递 forward propagation 的时候, 对每一层都进行 normalization 的处理</strong> Batch normalization 也可以被看做一个层面. 在一层层的添加神经网络的时候, 我们先有数据 X, 再添加全连接层, 全连接层的计算结果会经过 激励函数 成为下一层的输入, 接着重复之前的操作. Batch Normalization (BN) 就被添加在每一个全连接和激励函数之间。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/e112012a4b2d\" target=\"_blank\" rel=\"noopener\">一文学会用 Tensorflow 搭建神经网络</a></li>\n</ul>\n","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"机器学习","path":"api/tags/机器学习.json"}]},{"title":"简单聊一下服务端渲染","slug":"简单聊一下服务端渲染","date":"2018-09-18T08:07:53.000Z","updated":"2019-03-29T10:17:04.620Z","comments":true,"path":"api/articles/简单聊一下服务端渲染.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p><code>Server Slide Rendering</code> 服务端渲染,又简写为 <code>SSR</code>，他一般被用在我们的 <code>SPA（Single-Page Application）</code> 中，即单页应用。</p>\n<h2 id=\"为什么要用SSR？\"><a href=\"#为什么要用SSR？\" class=\"headerlink\" title=\"为什么要用SSR？\"></a>为什么要用SSR？</h2><p>首先我们需要知道 SSR 对于 SPA 的<code>好处</code>，<code>优势</code>是什么。</p>\n<ul>\n<li>更好的 <code>SEO（Search Engine Optimization）</code>，<code>SEO</code> 是搜索引擎优化，简而言之就是针对百度这些搜索引擎，可以让他们搜索到我们的应用。这里可能会有误区，就是我也可以在 <code>index.html</code> 上写 <code>SEO</code> ，为什么会不起作用。因为 React、Vue 的原理是<strong>客户端渲染</strong>，通过浏览器去加载 js、css，有一个时间上的<code>延迟</code>，而搜索引擎不会管你的<code>延迟</code>，他就觉得你如果没加载出来就是没有的，所以是搜不到的。</li>\n<li>解决一开始的<code>白屏渲染</code>，上面讲了 React 的渲染原理，而<strong>SSR服务端渲染</strong>是通过服务端请求数据，因为服务端内网的请求快，性能好所以会更快的加载所有的文件，最后把下载渲染后的页面返回给客户端。</li>\n</ul>\n<h2 id=\"服务端渲染VS客户端渲染\"><a href=\"#服务端渲染VS客户端渲染\" class=\"headerlink\" title=\"服务端渲染VS客户端渲染\"></a>服务端渲染VS客户端渲染</h2><h3 id=\"客户端渲染路线：\"><a href=\"#客户端渲染路线：\" class=\"headerlink\" title=\"客户端渲染路线：\"></a>客户端渲染路线：</h3><ol>\n<li>请求一个 html</li>\n<li>服务端返回一个 html</li>\n<li>浏览器下载 html 里面的 js/css 文件</li>\n<li>等待 js 文件下载完成</li>\n<li>等待 js 加载并初始化完成</li>\n<li>js 代码终于可以运行，由js代码向后端请求数据( ajax/fetch )</li>\n<li>等待后端数据返回</li>\n<li>react-dom ( 客户端 )从无到完整地，把数据渲染为响应页面</li>\n</ol>\n<h3 id=\"服务端渲染路线：\"><a href=\"#服务端渲染路线：\" class=\"headerlink\" title=\"服务端渲染路线：\"></a>服务端渲染路线：</h3><ol>\n<li>请求一个 html</li>\n<li>服务端请求数据( 内网请求快 )</li>\n<li>服务器初始渲染（服务端性能好，较快）</li>\n<li>服务端返回已经有正确内容的页面</li>\n<li>客户端请求 js/css 文件</li>\n<li>等待 js 文件下载完成</li>\n<li>等待 js 加载并初始化完成</li>\n<li>react-dom ( 客户端 )把剩下一部分渲染完成( 内容小，渲染快 )</li>\n</ol>\n<p>从上面两者的渲染路线可以看到，其主要区别就在于，客户端从<code>无到有的</code>渲染，服务端是先在服务端<code>渲染一部分</code>，在再客户端<code>渲染一小部分</code>。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://juejin.im/post/5b55e6a96fb9a04fcf59d754\" target=\"_blank\" rel=\"noopener\">React服务端渲染+pm2自动化部署</a></p>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"渲染","path":"api/tags/渲染.json"}]},{"title":"读书笔记系列","slug":"读书笔记系列","date":"2017-04-06T07:39:34.000Z","updated":"2019-03-29T10:17:04.620Z","comments":true,"path":"api/articles/读书笔记系列.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>“书中自有黄金屋”，这里汇集了我所读过的书的笔记，在闲下来的时候与其打游戏还不如看会书：</p>\n<ul>\n<li><a href=\"/20170406/html5-mobile-web-development-guide.html\">HTML5移动Web开发指南</a></li>\n<li><a href=\"/20170406/object-oriented-analysis-and-design.html\">面向对象的分析与设计</a></li>\n<li><a href=\"/20170406/excellent-css.html\">精彩绝伦的CSS</a></li>\n<li><a href=\"/20170406/the-way-to-practice-web-front-end-development.html\">编写高质量代码-Web前端开发修炼之道</a></li>\n<li><a href=\"/20170406/html5-and-css3-actual-warfare.html\">响应式Web设计-HTML5和CSS3实战</a></li>\n<li><a href=\"/20170408/dahua-data-structure.html\">大话数据结构</a></li>\n<li><a href=\"/20170706/css-secrets.html\">CSS Secrets</a></li>\n<li><a href=\"/20171010/you-dont-know-js-volume1.html\">你不知道的JavaScript（上卷）</a></li>\n</ul>\n","raw":null,"categories":[{"name":"series","path":"api/categories/series.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（1）——HTML5移动Web开发指南","slug":"读书笔记系列（1）——HTML5移动Web开发指南","date":"2017-04-06T07:41:14.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（1）——HTML5移动Web开发指南.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h2><h3 id=\"包含匹配选择器\"><a href=\"#包含匹配选择器\" class=\"headerlink\" title=\"包含匹配选择器\"></a>包含匹配选择器</h3><p>包含匹配比完全匹配范围更广。只要元素中的属性包含有指定的字符串，元素就使用该样式。其语法是：<code>[attribute*=value]</code>。</p>\n<p>其中 attribute 指的是属性名，value 指的是属性值，包含匹配采用 “ *=” 符号。</p>\n<h3 id=\"首字符匹配选择器\"><a href=\"#首字符匹配选择器\" class=\"headerlink\" title=\"首字符匹配选择器\"></a>首字符匹配选择器</h3><p>首字符匹配就是匹配属性值开头字符，只要开头字符符合匹配，则元素使用该样式。其语法是：<code>[attribute^=value]</code>。</p>\n<p>其中 attribute 指的是属性名，value 指的是属性值，首字符匹配采用“ ^=”符号。</p>\n<h3 id=\"尾字符匹配选择器\"><a href=\"#尾字符匹配选择器\" class=\"headerlink\" title=\"尾字符匹配选择器\"></a>尾字符匹配选择器</h3><p>尾字符匹配跟首字符匹配原理一样。尾字符只匹配结尾的字符串，只要结尾字符串符合匹配，则元素使用该样式。其语法是：<code>[attribute$=value]</code>。其中 attribute 指的是属性名，value 指的是属性值，尾字符匹配采用 “ $=”符号。</p>\n<h2 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h2><h3 id=\"before\"><a href=\"#before\" class=\"headerlink\" title=\"before\"></a>before</h3><p>before 伪类元素选择器主要的作用是在选择某个元素之前插入内容，一般用于清除浮动。before 选择器的语法是：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素标签<span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">\"插入的内容\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例如，在 p 元素之前插入“文字”：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-class\">.before</span>&#123; <span class=\"attribute\">content</span>: <span class=\"string\">\"文字\"</span> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\"after\"></a>after</h3><p>after 伪类元素选择器和 before 伪类元素选择器原理一样，但 after 是在选择某个元素之后插入内容。after 选择器的语法是：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素标签<span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"插入的内容\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"first-child\"><a href=\"#first-child\" class=\"headerlink\" title=\"first-child\"></a>first-child</h3><p>指定元素列表中第一个元素的样式。语法：<code>li:first-child</code></p>\n<h3 id=\"last-child\"><a href=\"#last-child\" class=\"headerlink\" title=\"last-child\"></a>last-child</h3><p>和 first-child 是同类型的选择器。last-child 指定元素列表中最后一个元素的样式。语法：<code>li:last-child</code></p>\n<h3 id=\"nth-child-和-nth-last-child\"><a href=\"#nth-child-和-nth-last-child\" class=\"headerlink\" title=\"nth-child 和 nth-last-child\"></a>nth-child 和 nth-last-child</h3><p>指定某个元素的样式或从后数起某个元素的样式。</p>\n<h2 id=\"阴影\"><a href=\"#阴影\" class=\"headerlink\" title=\"阴影\"></a>阴影</h2><h3 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h3><blockquote>\n<p>box-shadow: <code>&lt;length&gt; &lt;length&gt; &lt;length&gt;</code> || color</p>\n</blockquote>\n<p>第一个 length 值是阴影水平偏移值；第二个 length 值是阴影垂直偏移值；第三个 length 值是阴影模糊值。水平和垂直偏移值都可取正负值。</p>\n<p>基于 Webkit 的 Chrome 和 Safari 等浏览器：-webkit-box-shadow</p>\n<p>Firebox 浏览器：-moz-box-shadow</p>\n<h3 id=\"text-shadow\"><a href=\"#text-shadow\" class=\"headerlink\" title=\"text-shadow\"></a>text-shadow</h3><blockquote>\n<p>text-shadow: <code>&lt;length&gt; &lt;length&gt; &lt;length&gt;</code> || color</p>\n</blockquote>\n<p>第一个 length 值是阴影水平偏移值；第二个 length 值是阴影垂直偏移值；第三个 length 值是阴影模糊值。水平和垂直偏移值都可取正负值。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size**\"></a>background-size**</h3><p>背景图像的大小</p>\n<h3 id=\"background-clip\"><a href=\"#background-clip\" class=\"headerlink\" title=\"background-clip\"></a>background-clip</h3><p>背景的裁剪区域</p>\n<blockquote>\n<p>background-clip: border-box | padding-box | content-box | no-clip</p>\n</blockquote>\n<p>其中：</p>\n<ul>\n<li>border-box 是从 border 区域向外裁剪背景；</li>\n<li>padding-box 是从 padding 区域向外裁剪背景；</li>\n<li>content-box 是从内容区域向外裁剪背景；</li>\n<li>no-clip 是从 border 区域向外裁剪背景。</li>\n</ul>\n<h3 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h3><p>background-origin 属性是指定 background-position 属性的参考坐标的起始位置。 background-origin 属性有三种值可以选择，border 值指定从边框的左上角坐标开始；content 值指定从内容区域的左上角坐标开始；padding 值指定从 padding 区域开始。</p>\n<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>可以使用 Webkit 的其中一种特性对背景采用颜色渐变，而非采用图片方式。</p>\n<blockquote>\n<p>-webkit-gradient(<code>&lt;type&gt;, &lt;port&gt;[, &lt;radius&gt;]?,&lt;point&gt; [, &lt;radius&gt;]? [, &lt;stop&gt;]*</code>)</p>\n</blockquote>\n<p>type 类型是指采用渐变类型，如线性渐变 linear 或径向渐变 radial。如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">-webkit-gradient</span>(<span class=\"selector-tag\">linear</span>, 0 0, 0 100%, <span class=\"selector-tag\">form</span>(<span class=\"selector-id\">#FFF</span>), <span class=\"selector-tag\">to</span>(<span class=\"selector-id\">#000</span>));</span><br></pre></td></tr></table></figure>\n<p>上述代码的含义是定义一个渐变背景色，该渐变色是线性渐变并且是由白色向黑色渐变的。其中前两个 0 表示的是渐变开始 <strong>X</strong> 和 <strong>Y</strong> 坐标位置；0 和 100%表示的是渐变结束 <strong>X</strong> 和 <strong>Y</strong> 坐标位置。</p>\n<h2 id=\"Media-Queries-移动设备样式\"><a href=\"#Media-Queries-移动设备样式\" class=\"headerlink\" title=\"Media Queries 移动设备样式\"></a>Media Queries 移动设备样式</h2><h3 id=\"viewport设置适应移动设备屏幕大小\"><a href=\"#viewport设置适应移动设备屏幕大小\" class=\"headerlink\" title=\"viewport设置适应移动设备屏幕大小\"></a>viewport设置适应移动设备屏幕大小</h3><p>Android Browser 浏览器的默认值是 800 像素；IE 浏览器的默认值是 974 像素；Opera 浏览器的默认值是 850 像素。viewport 虚拟窗口是在 meta 元素中定义的，其主要作用是设置 Web 页面适应移动设备的屏幕大小。 如以下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1,user-scalable=0\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>代码中的 content 属性内共定义三种参数。实际上 content 属性允许设置 6 种不同的 参数，分别如下：</p>\n<ul>\n<li>width：指定虚拟窗口的屏幕宽度大小。</li>\n<li>height：指定虚拟窗口的屏幕高度大小。</li>\n<li>initial-scale：指定初始缩放比例。</li>\n<li>maximum-scale：指定允许用户缩放的最大比例。</li>\n<li>minimum-scale：指定允许用户缩放的最小比例。</li>\n<li>user-scalable：指定是否允许手动缩放。</li>\n</ul>\n<h3 id=\"Media-Queries-如何工作\"><a href=\"#Media-Queries-如何工作\" class=\"headerlink\" title=\"Media Queries 如何工作\"></a>Media Queries 如何工作</h3><p>要实现 Media Queries 样式模块，需要在 head 标签内导入一个 CSS 样式文件，例如，下面代码使用 media 属性定义当前屏幕可视区域的宽度最大值是 600 像素时应用该样式文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"screen and(max-width:600px)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"small.css\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在 small.css 样式文件内，需要定义 media 类型的样式，例如： </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> screen and (max-width:<span class=\"number\">600px</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.demo</span>&#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#CCC</span>; &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样也可以判断当移动设备（如 iPad）的方向发生变化时应用该样式。以下代码是当移动设备处于纵向（portrait）模式下时，应用 portrait 样式文件；当移动设备处于横向（landscape）模式下时，应用 landscape 样式文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"all and(orientation:portrait)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"portrait.css\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"all and(orientation:landscape)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"landscape.css\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Media-Queries-语法总结\"><a href=\"#Media-Queries-语法总结\" class=\"headerlink\" title=\"Media Queries 语法总结\"></a>Media Queries 语法总结</h3><p>Media Queries 的语法如下所示：</p>\n<blockquote>\n<p>@media [media_query] media_type and media_feature</p>\n</blockquote>\n<p>使用 Media Queries 样式模块时都必须以 “@media” 方式开头。media_query 表示查询关键字，在这里可以使用 not 关键字和 only 关键字。not 关键字表示对后面的样式表达式执行取反操作。例如如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> not screen and (max-device-width:<span class=\"number\">480px</span>)</span><br></pre></td></tr></table></figure>\n<p>only 关键字的作用是，让不支持 Media Queries 的设备但能读取 Media Type 类型的浏览器忽略这个样式。例如如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> only screen and (max-device-width:<span class=\"number\">480px</span>)</span><br></pre></td></tr></table></figure>\n<p>对于支持 Media Queries 的移动设备来说，如果存在 only 关键字，移动设备的 Web 浏览器会忽略 only 关键字并直接根据后面的表达式应用样式文件。对于不支持 Media Queries 的设备但能够读取 Media Type 类型的 Web 浏览器，遇到 only 关键字时会忽略这个样式文件。</p>\n<p>media_type 参数的作用是指定设备类型，通常称为媒体类型。实际上在 CSS2.1 版本时已经定义了该媒体类型。</p>\n<ul>\n<li><strong>all</strong>                 所有设备</li>\n<li><strong>aural</strong>               听觉设备</li>\n<li><strong>braille</strong>             点字触觉设备</li>\n<li><strong>handled</strong>             便携设备，如手机、平板电脑</li>\n<li><strong>print</strong>               打印预览图等</li>\n<li><strong>projection</strong>          投影设备</li>\n<li><strong>screen</strong>              显示器、笔记本、移动端等设备</li>\n<li><strong>tty</strong>                 如打字机或终端等设备</li>\n<li><strong>tv</strong>                  电视机等设备类型</li>\n<li><strong>embossed</strong>            盲文打印机</li>\n</ul>\n<p>media_feature 的主要作用是定义 CSS 中的设备特性，大部分移动设备特性都允许接受 min/max 的前缀。 例如，min-width 表示指定大于等于该值；max-width 表示指定小于等于该值。</p>\n","raw":null,"categories":[{"name":"html","path":"api/categories/html.json"}],"tags":[{"name":"HTML","path":"api/tags/HTML.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","slug":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","date":"2017-04-06T09:17:52.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_297.png","content":"<h2 id=\"1-一句话概括响应式设计\"><a href=\"#1-一句话概括响应式设计\" class=\"headerlink\" title=\"1. 一句话概括响应式设计\"></a>1. 一句话概括响应式设计</h2><p>如果要用一句话概括响应式网页设计，我觉得它是针对任意设备对网页内容进行完美布局的一种显示机制.相反，如果需要根据不同设备提供特定的内容和功能，那就需要一个真正的“手机版”网站.这种情况下，手机版网站会提供与桌面版网站完全不同的用户体验.</p>\n<h2 id=\"2-CSS-reset-网站\"><a href=\"#2-CSS-reset-网站\" class=\"headerlink\" title=\"2. CSS reset 网站\"></a>2. CSS reset 网站</h2><ul>\n<li><a href=\"http://meyerweb.com/eric/tools/css/reset/\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/css/reset/</a>，Eric Meyer的原版，主要针对HTML4</li>\n<li><a href=\"http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/</a>，针对HTML5</li>\n</ul>\n<h2 id=\"3-CSS-网格系统\"><a href=\"#3-CSS-网格系统\" class=\"headerlink\" title=\"3. CSS 网格系统\"></a>3. CSS 网格系统</h2><div align=\"center\"><img src=\"/images/hexo_post_297.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"4-地标角色属性\"><a href=\"#4-地标角色属性\" class=\"headerlink\" title=\"4. 地标角色属性\"></a>4. 地标角色属性</h2><p>role=”” 针对文档结构的各部分分别有如下的地标角色：</p>\n<ul>\n<li>application：用来定义用作网页应用的区域；</li>\n<li>banner：用来定义一个站点级别(而不是某个特定文档的)的区域.如网站的头部和logo；</li>\n<li>complementary：一个对页面主要区域进行补充说明的区域；</li>\n<li>contentinfo：与页面主要内容相关的信息区域，例如页脚的网站版权信息区域；</li>\n<li>form：定义表单，但是如果表单用于搜索，请使用search来替代；</li>\n<li>main：页面的主体内容；</li>\n<li>navigation：链向当前文档或相关文档的导航链接；</li>\n<li>search：一个用于搜索的区域。</li>\n</ul>\n<h2 id=\"5-导航栏使用-table-显示模式\"><a href=\"#5-导航栏使用-table-显示模式\" class=\"headerlink\" title=\"5. 导航栏使用 table 显示模式\"></a>5. 导航栏使用 table 显示模式</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-row;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做可以保证如果有另外的列表项追加进来，同样会自动地调整它们之间的间距。最后，使用 CSS3 选择器将最后一个列表项的文字置为右对齐，将第一个列表项的文字置为左对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:last-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-在响应式设计中使用自定义-font-face-字体的注意事项\"><a href=\"#6-在响应式设计中使用自定义-font-face-字体的注意事项\" class=\"headerlink\" title=\"6. 在响应式设计中使用自定义 @font-face 字体的注意事项\"></a>6. 在响应式设计中使用自定义 @font-face 字体的注意事项</h2><p>唯一需要注意的，是在响应式设计中使用该技术时要考虑到字体文件大小。有些字体可能会非常庞大，如果你想保持网站的高性能，请注意控制自定义字体的文件尺寸。</p>\n<h2 id=\"7-浮雕文字效果\"><a href=\"#7-浮雕文字效果\" class=\"headerlink\" title=\"7. 浮雕文字效果\"></a>7. 浮雕文字效果</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 1<span class=\"selector-tag\">px</span> 0 <span class=\"selector-tag\">hsla</span>(0， 0%， 100%， 0<span class=\"selector-class\">.75</span>);</span><br></pre></td></tr></table></figure>\n<p>不要模糊，不要水平阴影，仅在垂直方向设置 1 或 2 像素的”白影”即可。</p>\n<h2 id=\"8-让整个屏幕飞舞\"><a href=\"#8-让整个屏幕飞舞\" class=\"headerlink\" title=\"8. 让整个屏幕飞舞\"></a>8. 让整个屏幕飞舞</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123; <span class=\"attribute\">transition</span>: all <span class=\"number\">1s</span>; &#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_298.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"9-CSS3-实现-3D-变形效果\"><a href=\"#9-CSS3-实现-3D-变形效果\" class=\"headerlink\" title=\"9. CSS3 实现 3D 变形效果\"></a>9. CSS3 实现 3D 变形效果</h2><h3 id=\"在父级元素上设置透视，这样就开启了-3D-场景\"><a href=\"#在父级元素上设置透视，这样就开启了-3D-场景\" class=\"headerlink\" title=\"在父级元素上设置透视，这样就开启了 3D 场景\"></a>在父级元素上设置透视，这样就开启了 3D 场景</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123; <span class=\"attribute\">-webkit-perspective</span>: <span class=\"number\">200</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>透视的值越大，就表示你的视点与 3D 场景之间的景深越大。因此，如果想要一点隐约的 3D 效果，就增大透视值；如果想要非常明显的 3D 效果，则减小透视值。</p>\n<h3 id=\"延续父元素的透视\"><a href=\"#延续父元素的透视\" class=\"headerlink\" title=\"延续父元素的透视\"></a>延续父元素的透视</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son</span>&#123; <span class=\"attribute\">-webkit-transform-style</span>: perserve-<span class=\"number\">3</span>d; <span class=\"attribute\">-webkit-transition</span>: <span class=\"number\">1s</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>.father 类中添加的透视声明只会应用到其第一个子元素上。因此，为了延续父元素的透视，我们给 .son 元素设定了 preserve-3d (这样可以设置一个 3D 场景)。</p>\n<h3 id=\"当鼠标悬停在-father-模块上时，我们给-son-这个-div-添加一个翻转效果\"><a href=\"#当鼠标悬停在-father-模块上时，我们给-son-这个-div-添加一个翻转效果\" class=\"headerlink\" title=\"当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果\"></a>当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.son</span>&#123; <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"当海报翻转之后隐藏在其背面内容\"><a href=\"#当海报翻转之后隐藏在其背面内容\" class=\"headerlink\" title=\"当海报翻转之后隐藏在其背面内容\"></a>当海报翻转之后隐藏在其背面内容</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.face</span> &#123; <span class=\"attribute\">position</span>: absolute; <span class=\"attribute\">-webkit-backface-visibility</span>: hidden; &#125;</span><br></pre></td></tr></table></figure>\n<p>.face 必须使用绝对定位，这样海报才能盖在 .back 这个 div 的上面</p>\n<h3 id=\"给-back-加上-rotateY\"><a href=\"#给-back-加上-rotateY\" class=\"headerlink\" title=\"给 .back 加上 rotateY\"></a>给 .back 加上 rotateY</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.back</span> &#123; <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg); &#125;</span><br></pre></td></tr></table></figure>\n<p>不加这句的话，.back 这个 div 就会显示在正面海报之上。最终的 HTML 结构以及 CSS 样式如下:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"Qcontainer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"film\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"face front\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/goonies.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"The Goonies\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"face back\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>HOT!<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.Qcontainer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">28%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-perspective</span>: <span class=\"number\">800</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">2%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.film</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">15em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transition</span>: <span class=\"number\">1s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.Qcontainer</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.film</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.face</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-backface-visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.back</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">66%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">127%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg);</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#3b3b3b</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(top，</span><br><span class=\"line\">  rgba(0，0，0，0.65) <span class=\"number\">0%</span>，</span><br><span class=\"line\">  <span class=\"built_in\">rgba</span>(0，0，0，0) <span class=\"number\">100%</span>);</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">15%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-list-及对应的-datalist-元素\"><a href=\"#10-list-及对应的-datalist-元素\" class=\"headerlink\" title=\"10. list(及对应的 datalist 元素)\"></a>10. list(及对应的 datalist 元素)</h2><p>list 属性以及对应的 datalist 元素可以让用户在输入框中开始输入值的时候，显示一组备选值。下面是一个包含在 div 中的使用 list 属性及对应 datalist 元素的代码示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"awardWon\"</span>&gt;</span>Award Won<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"awardWon\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"awardWon\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">list</span>=<span class=\"string\">\"awards\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">datalist</span> <span class=\"attr\">id</span>=<span class=\"string\">\"awards\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Picture\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Director\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Adapted Screenplay\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Original Screenplay\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">datalist</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>list 属性中的值（awards）同时也是 datalist 元素的 id。这样就可以让 datalist 与输入项关联起来。虽然将 option 包裹在 select 中不是必需的，但这样做便于为老版本浏览器提供降级方案。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_299.png\" alt=\"\" width=\"550\"></div>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"HTML","path":"api/tags/HTML.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（2）——面向对象的分析与设计","slug":"读书笔记系列（2）——面向对象的分析与设计","date":"2017-04-06T08:09:41.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（2）——面向对象的分析与设计.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>面向对象不仅是一些具体的软件开发技术与策略，而且是一整套关于如何看待软件系统与现实世界的关系，用什么观点来研究问题并进行求解，以及如何进行系统构造的软件方法学。面向对象方法比以往的方法更接近人类的日常思维方式。</p>\n<h2 id=\"2-面向对象方法有如下一些主要特点：\"><a href=\"#2-面向对象方法有如下一些主要特点：\" class=\"headerlink\" title=\"2. 面向对象方法有如下一些主要特点：\"></a>2. 面向对象方法有如下一些主要特点：</h2><ol>\n<li>从问题域中客观存在的事物出发来构造软件系统，用对象作为对这些事物的抽象表示，并以此作为系统的基本构成单位。</li>\n<li>用对象的属性表示事物的静态特征（即可以用一些数据来表达的特征），用对象的操作表示事物的动态特征（即事物的行为）</li>\n<li>对象的属性与操作结合在一起构成一个独立的实体，对外屏蔽其内部细节（封装）。</li>\n<li>对事物进行分类，把具有相同属性和相同操作的对象归为一类，类是这些对象的抽象描述，每个对象是它的类的一个实例。</li>\n<li>通过在不同程度上运用抽象的原则，可以得到较一般的类和较特殊的类。特殊类继承一般类的属性与操作，从而简化了系统的构造过程。</li>\n<li>复杂的对象可以用简单的对象作为其构成部分（聚合）。</li>\n<li>对象之间通过消息进行通信，以实现对象之间的动态联系。</li>\n<li>用关联表达某些类之间对用户业务有特定意义的关系。</li>\n</ol>\n<h2 id=\"3-每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\"><a href=\"#3-每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\" class=\"headerlink\" title=\"3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\"></a>3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。</h2><h2 id=\"4-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\"><a href=\"#4-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\" class=\"headerlink\" title=\"4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\"></a>4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。</h2><h2 id=\"5-一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\"><a href=\"#5-一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\" class=\"headerlink\" title=\"5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\"></a>5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。</h2><h2 id=\"6-一般类和特殊类也常常习惯地称为父类和子类。\"><a href=\"#6-一般类和特殊类也常常习惯地称为父类和子类。\" class=\"headerlink\" title=\"6. 一般类和特殊类也常常习惯地称为父类和子类。\"></a>6. 一般类和特殊类也常常习惯地称为父类和子类。</h2><ul>\n<li>特殊类的每个对象实例也都属于它的一般类，然而一般类含有其特殊类所没有的对象实例。</li>\n<li>特殊类拥有其一般类的全部属性与操作，称为特殊类对一般类的继承。</li>\n</ul>\n<h2 id=\"7-聚合的含义\"><a href=\"#7-聚合的含义\" class=\"headerlink\" title=\"7. 聚合的含义\"></a>7. 聚合的含义</h2><p>聚合的含义：一个复杂的对象以若干比较简单的对象作为其组成部分。另一方面，聚合也是对象之间的一种关系，即整体对象和部分对象之间的关系。聚合是两个类之间的一个二元关系，它表示一个类的对象实例以另一个类的对象实例作为其组成部分。</p>\n<h2 id=\"8-用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\"><a href=\"#8-用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\" class=\"headerlink\" title=\"8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\"></a>8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。</h2><h2 id=\"9-消息是向对象发出的服务请求。\"><a href=\"#9-消息是向对象发出的服务请求。\" class=\"headerlink\" title=\"9. 消息是向对象发出的服务请求。\"></a>9. 消息是向对象发出的服务请求。</h2><p>消息的实现手段，在顺序程序中主要是函数调用，或者其他类似于函数调用的机制。</p>\n<h2 id=\"10-对象的多态性\"><a href=\"#10-对象的多态性\" class=\"headerlink\" title=\"10. 对象的多态性\"></a>10. 对象的多态性</h2><p>对象的多态性通常是指一般-特殊结构中的对象所体现的多态性，即：在一般类中定义的属性或操作被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。</p>\n<h2 id=\"11-功能分解法\"><a href=\"#11-功能分解法\" class=\"headerlink\" title=\"11. 功能分解法\"></a>11. 功能分解法</h2><p>首先定义各项功能，然后把较大的功能分解为子功能，直到这些功能或子功能的大小比较适当，并能给出明确的定义。</p>\n<h2 id=\"12-结构化方法\"><a href=\"#12-结构化方法\" class=\"headerlink\" title=\"12. 结构化方法\"></a>12. 结构化方法</h2><p>研究问题域中数据如何流动以及在各个环节上如何进行处理，从而发现数据流和加工。最终得到的分析模型是数据流图。</p>\n<h2 id=\"13-数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\"><a href=\"#13-数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\" class=\"headerlink\" title=\"13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\"></a>13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。</h2><h2 id=\"14-实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\"><a href=\"#14-实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\" class=\"headerlink\" title=\"14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\"></a>14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。</h2><h2 id=\"15-信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\"><a href=\"#15-信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\" class=\"headerlink\" title=\"15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\"></a>15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。</h2><h2 id=\"16-先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\"><a href=\"#16-先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\" class=\"headerlink\" title=\"16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\"></a>16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。</h2><h2 id=\"17-面向对象建模方法具有如下优点：\"><a href=\"#17-面向对象建模方法具有如下优点：\" class=\"headerlink\" title=\"17. 面向对象建模方法具有如下优点：\"></a>17. 面向对象建模方法具有如下优点：</h2><ol>\n<li>对问题域和系统责任的复杂性具有较强的处理能力；</li>\n<li>提供了便于各类相关人员交流的共同语言；</li>\n<li>对需求的变化具有较强的适应性；</li>\n<li>为实现分析与设计级别的软件复用提供了强有力的支持。</li>\n</ol>\n<h2 id=\"18-UML是一种建模语言，而不是一种建模方法。\"><a href=\"#18-UML是一种建模语言，而不是一种建模方法。\" class=\"headerlink\" title=\"18. UML是一种建模语言，而不是一种建模方法。\"></a>18. UML是一种建模语言，而不是一种建模方法。</h2><h2 id=\"19-属性有类属性和实例属性之分，必要时要加以区别。\"><a href=\"#19-属性有类属性和实例属性之分，必要时要加以区别。\" class=\"headerlink\" title=\"19. 属性有类属性和实例属性之分，必要时要加以区别。\"></a>19. 属性有类属性和实例属性之分，必要时要加以区别。</h2><h2 id=\"20-数据抽象是面向对象方法的核心原则。\"><a href=\"#20-数据抽象是面向对象方法的核心原则。\" class=\"headerlink\" title=\"20. 数据抽象是面向对象方法的核心原则。\"></a>20. 数据抽象是面向对象方法的核心原则。</h2><h2 id=\"21-没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\"><a href=\"#21-没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\" class=\"headerlink\" title=\"21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\"></a>21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。</h2><h2 id=\"22-消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\"><a href=\"#22-消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\" class=\"headerlink\" title=\"22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\"></a>22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。</h2><h2 id=\"23-在面向对象的软件系统中，所有的对象都是通过类描述的。\"><a href=\"#23-在面向对象的软件系统中，所有的对象都是通过类描述的。\" class=\"headerlink\" title=\"23. 在面向对象的软件系统中，所有的对象都是通过类描述的。\"></a>23. 在面向对象的软件系统中，所有的对象都是通过类描述的。</h2><h2 id=\"24-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\"><a href=\"#24-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\" class=\"headerlink\" title=\"24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\"></a>24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。</h2><h2 id=\"25-可用以下-4-句话来概括对象和类这两个概念在面向对象建模中的应用规则：\"><a href=\"#25-可用以下-4-句话来概括对象和类这两个概念在面向对象建模中的应用规则：\" class=\"headerlink\" title=\"25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则：\"></a>25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则：</h2><ol>\n<li>从对象出发认识问题域，将问题域中的事物抽象为对象；</li>\n<li>将具有共同特征的对象抽象为类，用类以及它们之间的关系构成整个系统模型；</li>\n<li>模型中不包含实例级的元素，用类来表示属于该类的任何对象实例；</li>\n<li>在类的规约中说明这个类将创建哪些对象实例。</li>\n</ol>\n<h2 id=\"26-如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\"><a href=\"#26-如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\" class=\"headerlink\" title=\"26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\"></a>26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。</h2><h2 id=\"27-属性是用来描述对象静态特征的一个数据项-操作是用来描述对象动态特征（行为）的一个动作序列。\"><a href=\"#27-属性是用来描述对象静态特征的一个数据项-操作是用来描述对象动态特征（行为）的一个动作序列。\" class=\"headerlink\" title=\"27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。\"></a>27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。</h2><h2 id=\"28-确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\"><a href=\"#28-确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\" class=\"headerlink\" title=\"28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\"></a>28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。</h2><h2 id=\"29-一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\"><a href=\"#29-一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\" class=\"headerlink\" title=\"29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\"></a>29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。</h2><p>通过接口进行衔接，则接口在它的使用者和提供者之间起到了隔离作用，二者可以分别实现，并且可以有多种不同的实现，只要都遵守接口所规定的合约，就可以通过该接口相互衔接。</p>\n<h2 id=\"30-接口由某些类提供，为另外某些类所需要。\"><a href=\"#30-接口由某些类提供，为另外某些类所需要。\" class=\"headerlink\" title=\"30. 接口由某些类提供，为另外某些类所需要。\"></a>30. 接口由某些类提供，为另外某些类所需要。</h2><h2 id=\"31-接口与对象类相比，有以下几点不同：\"><a href=\"#31-接口与对象类相比，有以下几点不同：\" class=\"headerlink\" title=\"31. 接口与对象类相比，有以下几点不同：\"></a>31. 接口与对象类相比，有以下几点不同：</h2><ol>\n<li>类既有属性又有操作；接口只是声明了一组操作，没有属性。</li>\n<li>在一个类中定义了一个操作，就要在这个类中真正地实现它的功能；接口中的操作只是一个声明，不需要在接口中加以实现。</li>\n<li>类可以创建对象实例；接口则没有任何实例。</li>\n</ol>\n<h2 id=\"32-对象之间的-4-种重要关系，即继承、聚合、关联和信息。\"><a href=\"#32-对象之间的-4-种重要关系，即继承、聚合、关联和信息。\" class=\"headerlink\" title=\"32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。\"></a>32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。</h2><h2 id=\"33-系统中的一般类应该符合下述3个条件之一才有存在的价值：\"><a href=\"#33-系统中的一般类应该符合下述3个条件之一才有存在的价值：\" class=\"headerlink\" title=\"33. 系统中的一般类应该符合下述3个条件之一才有存在的价值：\"></a>33. 系统中的一般类应该符合下述3个条件之一才有存在的价值：</h2><ol>\n<li>它有两个或两个以上的特殊类；</li>\n<li>需要用它创建对象实例；</li>\n<li>它的存在有助于软件复用。</li>\n</ol>\n<h2 id=\"34-聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\"><a href=\"#34-聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\" class=\"headerlink\" title=\"34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\"></a>34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。</h2><h2 id=\"35-如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\"><a href=\"#35-如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\" class=\"headerlink\" title=\"35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\"></a>35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。</h2><h2 id=\"36-关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\"><a href=\"#36-关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\" class=\"headerlink\" title=\"36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\"></a>36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。</h2><h2 id=\"37-消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\"><a href=\"#37-消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\" class=\"headerlink\" title=\"37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\"></a>37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。</h2><h2 id=\"38-在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0-到多个），即接收消息的操作要求的输入参数；返回参数（0-到多个），即接收消息的操作提供的输出参数。\"><a href=\"#38-在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0-到多个），即接收消息的操作要求的输入参数；返回参数（0-到多个），即接收消息的操作提供的输出参数。\" class=\"headerlink\" title=\"38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。\"></a>38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。</h2>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（3）——精彩绝伦的CSS","slug":"读书笔记系列（3）——精彩绝伦的CSS","date":"2017-04-06T08:13:16.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（3）——精彩绝伦的CSS.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_309.png","content":"<h2 id=\"1-特殊性\"><a href=\"#1-特殊性\" class=\"headerlink\" title=\"1. 特殊性\"></a>1. 特殊性</h2><p>特殊性是一个选择器“特殊程度”的数字表示，有 3 样东西经常被用来确定选择器的特殊性：</p>\n<ul>\n<li>每个元素描述符贡献 0，0，0，1；</li>\n<li>每个类、伪类或者属性描述符贡献 0，0，1，0；</li>\n<li>每个 ID 描述符贡献 0，1，0，0.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>权重</th>\n<th>描述符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>div ul ul li</td>\n<td>0,0,0,4</td>\n<td>4个元素描述符</td>\n</tr>\n<tr>\n<td>div.aside ul li</td>\n<td>0,0,1,3</td>\n<td>1个类描述符，3个元素描述符</td>\n</tr>\n<tr>\n<td>a:hover</td>\n<td>0,0,1,1</td>\n<td>1个伪类描述符，1个元素描述符</td>\n</tr>\n<tr>\n<td>div.navlinks a:hover</td>\n<td>0,0,2,2</td>\n<td>1个伪类描述符，1个类描述符，2个元素描述符</td>\n</tr>\n<tr>\n<td>#title em</td>\n<td>0,1,0,1</td>\n<td>1个ID描述符，1个元素描述符</td>\n</tr>\n<tr>\n<td>h1#title em</td>\n<td>0,1,0,2</td>\n<td>1个ID描述符，2个元素描述符</td>\n</tr>\n</tbody>\n</table>\n<p>当特殊性相等时后声明的规则会胜出。特殊性标识符第一位的 0 是用于行内样式的，且仅用于行内样式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-id\">#header</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: purple;  <span class=\"comment\">/* 0，1，0，0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"header\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background: blue;\"</span>&gt;</span>  /* 1，0，0，0 */</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-重要性\"><a href=\"#2-重要性\" class=\"headerlink\" title=\"2. 重要性\"></a>2. 重要性</h2><p>任何标记为重要的声明都需要有自己的 <code>!important</code><br>任何重要的声明都会覆盖非重要的声明</p>\n<h2 id=\"3-通用选择\"><a href=\"#3-通用选择\" class=\"headerlink\" title=\"3. 通用选择\"></a>3. 通用选择</h2><p><code>*</code> 作用是选择文档中的全部元素并对其应用样式<br><code>div *</code> 作用是选择这个 div 中的全部子元素</p>\n<h2 id=\"4-简单的属性选择\"><a href=\"#4-简单的属性选择\" class=\"headerlink\" title=\"4. 简单的属性选择\"></a>4. 简单的属性选择</h2><p><code>a[href]</code> 会选择所有含有 href 属性的 a 元素<br><code>a[href=&quot;http://w3.org/&quot;]</code> 选择指向某个特定地址的全部超链接</p>\n<h2 id=\"5-部分属性值选择\"><a href=\"#5-部分属性值选择\" class=\"headerlink\" title=\"5. 部分属性值选择\"></a>5. 部分属性值选择</h2><p><code>a[href*=&quot;w3.org&quot;]</code> 属性值中包含该字符序列，应该区分属性值的大小写。</p>\n<p><code>img[src*=&quot;mainlogo.png&quot;]</code> 它会选择任何指向 mainlogo.png 文件的图像（img）元素，或者是 src 属性值中包含 mainlogo.png 这些字符的图像元素。因此，它将同时选择：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/img/2010/mainlogo.png.gif\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"ConHugoCo Inc.\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/img/2010/mainlogo.pngdir/big.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"ConHugoCo Inc.\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-更多部分属性值选择\"><a href=\"#6-更多部分属性值选择\" class=\"headerlink\" title=\"6. 更多部分属性值选择\"></a>6. 更多部分属性值选择</h2><p>a[href^=”http”] 选取任何 href 属性值是以 http 开头的链接元素<br>a[href$=”.pdf”] 选择 href 属性值是以 .pdf 结尾的链接元素</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>选取对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a[href^=”https”]</td>\n<td>安全服务器链接</td>\n</tr>\n<tr>\n<td>a[href^=”mailto”]</td>\n<td>电子邮件联系链接</td>\n</tr>\n<tr>\n<td>a[href^=”aim”]</td>\n<td>AOL即时通信服务链接</td>\n</tr>\n<tr>\n<td>a[href^=”.doc”]</td>\n<td>微软Word文档</td>\n</tr>\n<tr>\n<td>a[href^=”.xls”]</td>\n<td>微软Excel文档</td>\n</tr>\n<tr>\n<td>a[href^=”.zip”]</td>\n<td>压缩文档</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"7-兄弟选择\"><a href=\"#7-兄弟选择\" class=\"headerlink\" title=\"7. 兄弟选择\"></a>7. 兄弟选择</h2><p>h2 + p 紧跟在 h2 后的 p 元素<br>h1 ~ ul 位于 h1 元素后面且与之共享父元素的 ul 元素，不包括直接相邻的兄弟元素</p>\n<h2 id=\"8-调整字体值的顺序\"><a href=\"#8-调整字体值的顺序\" class=\"headerlink\" title=\"8. 调整字体值的顺序\"></a>8. 调整字体值的顺序</h2><blockquote>\n<p>font: <code>&lt;font-size&gt; &lt;font-family&gt;</code>;</p>\n</blockquote>\n<p>必须同时包含这两个值并且按照既定的顺序进行书写。如果颠倒了顺序，或者漏掉了其中的一个，则任何现代浏览器都会完全忽略这条声明。此外，如果在声明中包含了其他关键字，则它们全部都得放在这两个必备的值前面。</p>\n<h2 id=\"9-玩转行高\"><a href=\"#9-玩转行高\" class=\"headerlink\" title=\"9. 玩转行高\"></a>9. 玩转行高</h2><blockquote>\n<p>font: 100%/2.5 Helvetica， sans-serif;</p>\n</blockquote>\n<p>为 font 声明添加行高值得操作总是可选的，但是如果已经包含了行高值，则它的放置位置就是固定的了，必须紧跟在字号后面加一个斜杠再加上行高值才行。</p>\n<h2 id=\"10-无单位的行高值\"><a href=\"#10-无单位的行高值\" class=\"headerlink\" title=\"10. 无单位的行高值\"></a>10. 无单位的行高值</h2><p>无单位的行高值表示后代元素所使用的一个换算系数（比如一个乘数）<br>所有继承了行高值为 1 的元素会把这个值同它们自身的字号计算值相乘。声明了 font-size: 10px 的列表项元素会有一个 10px 的计算后的行高值。</p>\n<h2 id=\"11-抑制元素的可见性\"><a href=\"#11-抑制元素的可见性\" class=\"headerlink\" title=\"11. 抑制元素的可见性\"></a>11. 抑制元素的可见性</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">span&#123; visibility：hidden； &#125;  /* 被设置成 visibility: hidden 的元素仍然参与页面布局 */</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-将元素移出屏幕\"><a href=\"#12-将元素移出屏幕\" class=\"headerlink\" title=\"12. 将元素移出屏幕\"></a>12. 将元素移出屏幕</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.hide</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">10000em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">10000em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">**已经从页面上移除，但是屏幕阅读器也能识别**</span><br><span class=\"line\"></span><br><span class=\"line\">## 13. 图像替换</span><br><span class=\"line\"></span><br><span class=\"line\">使用负的文本缩进把文本移到元素的左侧</span><br><span class=\"line\"></span><br><span class=\"line\">```<span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">140px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">9999px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(page-hader.gif);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们没有移动元素框的情况下将元素的文本内容移动到了屏幕之外。</p>\n<h2 id=\"14-打印样式\"><a href=\"#14-打印样式\" class=\"headerlink\" title=\"14. 打印样式\"></a>14. 打印样式</h2><p>有 3 种方式可以将打印样式关联到页面：</p>\n<ul>\n<li><code>&lt;style type=&quot;text/css&quot; media=&quot;print&quot;&gt;...&lt;/style&gt;</code></li>\n<li><code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot; href=&quot;print.css&quot;&gt;</code></li>\n<li><code>@import url(print.css) print</code>;</li>\n</ul>\n<p>几乎所有人都会使用 link 的方式，这是因为在每个页面中都嵌入打印样式表的效率非常低。</p>\n<h2 id=\"15-凸排列表\"><a href=\"#15-凸排列表\" class=\"headerlink\" title=\"15. 凸排列表\"></a>15. 凸排列表</h2><p>使列表项的第一行悬挂在左侧，并使其他行保持在原位的一种技术。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_309.png\" alt=\"\" width=\"700\"></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">2em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>list-style: none 这条规则很重要，如果没有这个的话，每个列表项的第一行就不会被凸排，并且文本会跟列表标记重合。因此，不要把凸排和列表标记混着用。</p>\n<h2 id=\"16-为列表添加标记\"><a href=\"#16-为列表添加标记\" class=\"headerlink\" title=\"16. 为列表添加标记\"></a>16. 为列表添加标记</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-sytle-image</span>: <span class=\"built_in\">url</span>(star.gif);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>潜在的缺点是你完全无法掌控图像的放置位置。可以将每个列表项的内容用一个元素包裹一下，这个元素可以是 div 或者 span。就可以定制列表标记的样式。</p>\n<h2 id=\"17-生成列表标记\"><a href=\"#17-生成列表标记\" class=\"headerlink\" title=\"17. 生成列表标记\"></a>17. 生成列表标记</h2><p>通过混合凸排和生成内容来实现的。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"built_in\">url</span>(star.gif);</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">8px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"18-用轮廓代替边框\"><a href=\"#18-用轮廓代替边框\" class=\"headerlink\" title=\"18. 用轮廓代替边框\"></a>18. 用轮廓代替边框</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123; <span class=\"attribute\">outline</span>: <span class=\"number\">1px</span> dashed red; &#125;</span><br></pre></td></tr></table></figure>\n<p>边框是参与布局的，而轮廓并不参与。轮廓必然是环绕着元素的，并且在元素的四周永远保持一致。你不能只设置左轮廓或者上轮廓。<br>轮廓只有两种情况：环绕元素四周的简单轮廓，或者干脆没有轮廓。元素是可以同时具有边框和轮廓的。在这种情况下，轮廓会绘制在边框之外，所有轮廓的内边缘会紧挨着边框的外边缘。如果元素具有外边距的话，则轮廓将绘制在外边距所在区域之上，但是外边距并不会被轮廓改变或者替换掉。</p>\n<h2 id=\"19-框冲切\"><a href=\"#19-框冲切\" class=\"headerlink\" title=\"19. 框冲切\"></a>19. 框冲切</h2><p>是一种可以在视觉上将元素框的一部分移除的技术。它仅在单色或固定图像背景上起作用。框冲切的最简单形式就是把一个框放在另一个框的角落里，并确保它的背景与周围的内容一致，而不是与它的父元素一致。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_310.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"20-CSS-精灵\"><a href=\"#20-CSS-精灵\" class=\"headerlink\" title=\"20. CSS 精灵\"></a>20. CSS 精灵</h2><p>CSS 精灵(CSS sprite) 是一种可以实现快速悬停效果的技术，现在已经演变成了通过将装饰性的图片合并并下载，从而降低服务器负载的技术。CSS 精灵最基本的例子就是包含两种状态的图标，即一个挨着链接的正常显示版本，一个当链接被悬停时的”点亮”版本。</p>\n<h2 id=\"21-滑动门\"><a href=\"#21-滑动门\" class=\"headerlink\" title=\"21. 滑动门\"></a>21. 滑动门</h2><p>滑动门是一种可以使文本导航链接变成花哨的选项卡的技术。然而，通常的做法都只适用于效果而不试用于选项卡。</p>\n<h2 id=\"22-CSS-视差\"><a href=\"#22-CSS-视差\" class=\"headerlink\" title=\"22. CSS 视差\"></a>22. CSS 视差</h2><p>CSS 视差是一种很精巧的技术，它能让我们了解基于百分比的背景图像定位可以那么简单而直接地创造出意想不到的效果。首先，考虑一下百分比定位是怎么实现的。假设你把一个背景图像的位置设置为 50% 50%，那么它的中心将与背景区域的中心对齐。类似地，如果设置为 100% 100%，那么它的右下角就会和背景区域的右下角对齐。这就意味着背景图像位置的百分比值实际上被使用了两次。第一次用于找到背景区域中所定义的点，第二次用于找到图像本身中定义的点，然后再把这两个点对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(ice-1.png) -<span class=\"number\">75%</span> <span class=\"number\">0</span> repeat-x;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(ice-2.png) <span class=\"number\">75%</span> <span class=\"number\">0</span> repeat-x;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这样的设置，当浏览器窗口变宽时图片看起来就会使朝着远离窗口中心的方向移动的，这会产生类似”放大”的效果。而当窗口变窄时，图片会朝着窗口的中心移动，类似”缩小”的效果。</p>\n<h2 id=\"23-图像的框\"><a href=\"#23-图像的框\" class=\"headerlink\" title=\"23. 图像的框\"></a>23. 图像的框</h2><p>有些关于图像的东西，大多数人至今都没有意识到：它们与其他元素拥有相同的盒模型，这意味着你可以对图像元素应用诸如背景和内边距等样式。你可以为图像设置背景图像，做出一些有趣的组合效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_311.png\" alt=\"\" width=\"700\"></div>\n\n<p>内边距也可以很简单地应用在图像上。事实上，通过背景色、边框以及内边距的组合，可以使图像看上去具有深浅不一的双层边框。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_312.png\" alt=\"\" width=\"700\"></div>\n\n<p>再加上轮廓的话，你就会得到类似三层边框的效果了。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_313.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"24-受限的图像\"><a href=\"#24-受限的图像\" class=\"headerlink\" title=\"24. 受限的图像\"></a>24. 受限的图像</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span>&#123; <span class=\"attribute\">max-width</span>:<span class=\"number\">100%</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>这条简单的规则会保证图像不会比包含它们的元素更宽，不过在父元素比这些图像宽的情况下，它们会保持原始尺寸。你可以通过把图像在其父元素中居中来进行强化，像这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下图展示了将同一个图像放在 3 个不同宽度父元素中的例子，其中两个父元素比图像还窄，一个比图像宽(父元素的边缘已通过边框标出)。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_314.png\" alt=\"\" width=\"400\"></div>\n\n<p>这很明显会使你的图像任由浏览器的缩放操作摆布，因为它们会缩小图像。</p>\n<h2 id=\"25-表头、主体和脚注\"><a href=\"#25-表头、主体和脚注\" class=\"headerlink\" title=\"25. 表头、主体和脚注\"></a>25. 表头、主体和脚注</h2><p>HTML 为表格定义了 3 个元素用于对行进行分组，它们是 thead(表头)，tbody(表格主体) 和 tfoot(脚注)。毫不奇怪，这些元素分别代表了表格的表头，主体部分以及脚注部分。</p>\n<h2 id=\"26-行标题\"><a href=\"#26-行标题\" class=\"headerlink\" title=\"26. 行标题\"></a>26. 行标题</h2><p>有一个 HTML 属性在当初设计的时候就是用来让你指定一个 th 元素是列标题还是行标题的。表格主体中的每一行都以 th 元素开头，那些就是行标题。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"col\"</span>&gt;</span>Pageviews<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"col\"</span>&gt;</span>Visitors<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"row\"</span>&gt;</span>January 2010<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>1367234<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>326578<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"row\"</span>&gt;</span>February 2010<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>1491262<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>349091<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>为 th 元素恰当地添加已赋值的 scope(作用域)属性，相当于明确地告诉浏览器 th 元素与它周围单元格的关系。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_315.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"27-多背景\"><a href=\"#27-多背景\" class=\"headerlink\" title=\"27. 多背景\"></a>27. 多背景</h2><p>CSS3 中真正时髦的东西之一，就是它对于给定元素支持多个背景图像。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(bg01.png) top left no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg02.png) top right no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg03.png) bottom right no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg04.png) bottom left no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多背景的应用顺序是从“最高”到“最低”的，即以你观看页面的视角来看，是从最靠你的到离你最远的顺序应用。如果你把颜色放到第一个背景上，它就会位于其他背景的“上面”。这也意味着，如果你想让某种图案背景在所有背景的最后方，那么就需要把它放在最后一个并且确保把任何背景颜色的值也移到这个值中。</p>\n<h2 id=\"28-二维变换\"><a href=\"#28-二维变换\" class=\"headerlink\" title=\"28. 二维变换\"></a>28. 二维变换</h2><p>可以通过 <code>transform-origin</code> 改变旋转或缩放的原点</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform-origin</span>: <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transform-origin</span>: 75% 0;</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","slug":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","date":"2017-04-06T08:42:13.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_300.png","content":"<h2 id=\"1-Web-标准——结构、样式和行为的分离\"><a href=\"#1-Web-标准——结构、样式和行为的分离\" class=\"headerlink\" title=\"1. Web 标准——结构、样式和行为的分离\"></a>1. Web 标准——结构、样式和行为的分离</h2><p>Web 标准由一系列标准组合而成，其核心理念就是将网页的结构，样式和行为分离开来，所以它可以分为三大部分：结构标准，央视标准和行为标准。<br>结构标准包括 XML 标准，XHTML 标准，HTML 标准；<br>样式标准主要是指 CSS 标准；<br>行为标准主要包括 DOM 标准和 ECMAScript 标准。</p>\n<h2 id=\"2-打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\"><a href=\"#2-打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\" class=\"headerlink\" title=\"2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\"></a>2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序</h2><p>精简的代码可以让文件变小，有利于客户端快速下载；重用可以让代码更易于精简，同时有助于提升开发速度；有序可以让我们更清晰地组织代码，使代码易于维护，有效应对变化。</p>\n<h2 id=\"3-欲精一行，必先通十行\"><a href=\"#3-欲精一行，必先通十行\" class=\"headerlink\" title=\"3. 欲精一行，必先通十行\"></a>3. 欲精一行，必先通十行</h2><p>在前端开发领域，不通十行就无法精一行。专精很难，甚至不可能，一专多能才是现实的。在前端开发这个领域，一专多能更是非常必要的。</p>\n<h2 id=\"4-增加代码可读性——注释\"><a href=\"#4-增加代码可读性——注释\" class=\"headerlink\" title=\"4.增加代码可读性——注释\"></a>4.增加代码可读性——注释</h2><p>一个好的代码，注释要占 1/3 的篇幅</p>\n<h2 id=\"5-磨刀不误砍柴工——前期的构思很重要\"><a href=\"#5-磨刀不误砍柴工——前期的构思很重要\" class=\"headerlink\" title=\"5. 磨刀不误砍柴工——前期的构思很重要\"></a>5. 磨刀不误砍柴工——前期的构思很重要</h2><p>构思的内容主要包括规范的指定，公共组件的设计和复杂功能的技术方案等。一般来说，前期构思占整个项目 30% ~ 60% 的时间都算是正常的.</p>\n<h2 id=\"6-标签的语义\"><a href=\"#6-标签的语义\" class=\"headerlink\" title=\"6. 标签的语义\"></a>6. 标签的语义</h2><p>HTML 标签的设计都是有语义考虑的。下表是部分标签的全称和中文翻译：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_300.png\" alt=\"\" width=\"600\"></div><br><div align=\"center\"><img src=\"/images/hexo_post_301.png\" alt=\"\" width=\"600\"></div>\n\n<p>其中，<strong>div 和 span 其实是没有语义的</strong>，它们只是分别用作块级元素和行内元素的区域分隔符。事实上，CSS 布局只是 Web 标准的一部分。在 HTML，CSS，JavaScript 这三大元素中，HTML 才是最重要的，结构才是重点，样式是用来修饰结构的。正确的做法是，先确定 HTML，确定语义的标签，再来选用合适的 CSS。</p>\n<h2 id=\"7-如何确定你的标签是否语义良好\"><a href=\"#7-如何确定你的标签是否语义良好\" class=\"headerlink\" title=\"7. 如何确定你的标签是否语义良好\"></a>7. 如何确定你的标签是否语义良好</h2><p>判断网页标签语义是否良好的一个简单方法就是：<strong>去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性</strong>。除了去样式后的可读性外，值得重点提及的还有 h 标签。h 标签的含义是”标题”，搜索引擎对这个标签比较敏感，尤其是 h1 和 h2。一个语义良好的页面，h 标签应该是完整有序没有断层的。也就是说，<strong>要按照 h1，h2，h3，h4 这样依次排列下来，不要出现类似 h1，h2，h3，h4，漏掉 h2 的情况</strong>。</p>\n<h2 id=\"8-常见模块\"><a href=\"#8-常见模块\" class=\"headerlink\" title=\"8. 常见模块\"></a>8. 常见模块</h2><h3 id=\"标题和内容\"><a href=\"#标题和内容\" class=\"headerlink\" title=\"标题和内容\"></a>标题和内容</h3><p>当页面内标签无法满足设计需要时，才会适当添加 div 和 span 等无语义标签来辅助实现。</p>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>登录表单<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"name\"</span>&gt;</span>账号：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"pw\"</span>&gt;</span>密码：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pw\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"登录\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"subBtn\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>一般来说，表单域要用 fieldset 标签包起来，并用 legend 标签说明表单的用途。因为 fieldset 默认有边框，而 legend 也有默认的样式，为满足设计需要，我们可以将 fieldset 的 “border” 设为 “none”，把 legend 的 “display” 设为 “none”，以此来兼顾语义和设计两方面的要求。每个 input 标签对应的说明文本都需要 label1 标签，并且通过为 input 设置 id 属性，在 label 标签中设置 “for=someld” 来让说明文本和相应的 input 关联起来.</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>表格标题要用 caption，表头要用 thead 包围，主体部分用 tbody 包围，尾部要用 tfoot 包围，表头和一般单元格要区分开，表头用 th，一般单元格用 td。</p>\n<h2 id=\"9-语义化标签应注意的一些其他问题\"><a href=\"#9-语义化标签应注意的一些其他问题\" class=\"headerlink\" title=\"9. 语义化标签应注意的一些其他问题\"></a>9. 语义化标签应注意的一些其他问题</h2><p>为了保证网页去样式后的可读性，并且又符合 Web 标准，我们应注意以下几点：</p>\n<ul>\n<li>尽可能少的使用无语义标签 div 和 span；</li>\n<li>在语义不明显，既可以用 p 也可以用 div 的地方，尽量用 p，因为 p 默认情况下有上下间距，去样式后的可读性更好，对兼容特殊终端有利；</li>\n<li>不要使用纯样式标签，例如 b，font 和 u 等，改用 CSS 设置。语义上需要强调的文本可以包在 strong 或 em 标签里，strong 和 em 有”强调”的语意，其中 strong 的默认样式是加粗，而 em 的默认样式是斜体。</li>\n</ul>\n<h2 id=\"10-如何组织-CSS\"><a href=\"#10-如何组织-CSS\" class=\"headerlink\" title=\"10. 如何组织 CSS\"></a>10. 如何组织 CSS</h2><p>一种组织 CSS 的方法：<strong>base.css+common.css+page.css</strong>。将网站内的所有样式，按照职能分成三大类：base，common 和 page。</p>\n<h3 id=\"base-层\"><a href=\"#base-层\" class=\"headerlink\" title=\"base 层\"></a>base 层</h3><p>这一层位于三者的最底层，提供 CSS reset 功能和粒度最小的通用类——原子类。这一层会被所有页面引用，是页面样式所需依赖的最底层。这一层与具体 UI 无关，无论何种风格的设计都可以引用它，所以 base 层要力求精简和通用。base 层具有高度可移植性，不同设计风格的网站可以使用同一个 base 层. base 层相对稳定，基本上不需要维护。</p>\n<h3 id=\"common-层\"><a href=\"#common-层\" class=\"headerlink\" title=\"common 层\"></a>common 层</h3><p>这一层位于中间，提供组件级的 CSS 类。我们可以将页面内的元素拆分成一小块一小块功能和样式相对独立的小”模块”，这些”模块”有些是很少重复的，有些是会大量重复的，我们可以将大量重复的”模块”视为一个组件。我们从页面里尽可能多的将组件提取出来，放在 common 层里。common 层就相当于 MVC 模式中的 M(Model，模型)。为了保证重用性和灵活性，M 需要尽可能将内部实现封装，对可能会经常变化的部分提供灵活的接口。common 层是网站级的，不同的网站有不同的 common 层，同一个网站只有一个 common 层。在团队合作中，common 层最好由一个人负责，统一管理。</p>\n<h3 id=\"page-层\"><a href=\"#page-层\" class=\"headerlink\" title=\"page 层\"></a>page 层</h3><p>网站中高度重用的模块，我们把它们视为组件，放在 common 层；非高度重用的模块，可以把它们放在 page 层。page 层位于最高层，提供页面级的样式，对重用性没有要求。base 层基本上不需要维护，common 层修改的幅度不会很大，通常只由一个人负责维护，但到了 page 层，代码可能由多人开发，如何避免冲突是个需要注意的问题。通常我们通过命名规则来避免这种冲突。</p>\n<h2 id=\"11-推荐的-base-css\"><a href=\"#11-推荐的-base-css\" class=\"headerlink\" title=\"11. 推荐的 base.css\"></a>11. 推荐的 base.css</h2><p>通常情况下，为了让浮动元素的父容器能够根据浮动元素的高度而自适应高度，有三种做法：</p>\n<ul>\n<li>让父容器同时浮动起来，例如：<code>&lt;div class=&quot;fl&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>；</li>\n<li>让浮动元素后面紧跟一个用于清楚浮动的空标签，例如 <code>&lt;div&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;div class=&quot;cb&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>；</li>\n<li><strong>给父容器挂一个特殊 class，直接从父容器清除浮动元素的浮动，例如 <code>&lt;div class=&quot;clearfix&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></strong></li>\n</ul>\n<p><strong>第一种方法会让父容器也浮动起来，影响父元素后面的元素的布局，有副作用；第二种方法增加了一个空标签，破坏了语义化。第三种方法没有任何副作用，推荐使用。</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  <span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:inline-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-拆分模块\"><a href=\"#12-拆分模块\" class=\"headerlink\" title=\"12. 拆分模块\"></a>12. 拆分模块</h2><ul>\n<li>模块与模块之间尽量不要包含相同的部分，如果有相同部分，应将它们提取出来，拆分成一个独立的模块.</li>\n<li>模块应在保证数量尽可能少的原则下，做到尽可能简单，以提高重用性.</li>\n</ul>\n<p>##13. CSS 的命名</p>\n<p>推荐使用英语，不要使用汉语拼音。我们可以根据内容来选用合适的英文单词命名 CSS。比如头部用 head，底部用 foot，主体部分用 main，导航用 nav，菜单用 menu 等，page 层 css 命名不可过短，可以将开发人员名字缩写作为前缀，以免发生冲突。</p>\n<h2 id=\"14-挂多个-class-还是新建-class——多用组合，少用继承\"><a href=\"#14-挂多个-class-还是新建-class——多用组合，少用继承\" class=\"headerlink\" title=\"14. 挂多个 class 还是新建 class——多用组合，少用继承\"></a>14. 挂多个 class 还是新建 class——多用组合，少用继承</h2><p>在面向对象编程里，有个很重要的原则就是”多用组合，少用继承”. HTML 的 class 与程序中”类”有相同的”味道”，class 可以挂多个，从技术上支持了”组合”的用法。我们在使用 CSS 时，如果能灵活运用这点就可以大大减少类的数量，一方面减少了代码量，提高了可维护性，另一方面时类的职责更单一，弹性更强，增加了类的重用性，提高了开发效率。</p>\n<h2 id=\"15-组件的-margin\"><a href=\"#15-组件的-margin\" class=\"headerlink\" title=\"15 .组件的 margin\"></a>15 .组件的 margin</h2><p>如果对相邻的模块同时使用了 margin-top 和 margin-bottom，边距会重合带来不必要的麻烦，所以最好统一使用 margin-top 或者 margin-bottom，不要混合使用，从而降低出现问题的风险。<br>总结：如果不确定模块的上下 margin 特别稳定，最好不要将它写到模块的类里，而是使用类的祝贺，单独为上下 margin 挂用于边距的原子类(例如 mt10，mb20)。模块最好不要混用 margin-top 和 margin-bottom，统一使用 margin-top 或 margin-bottom。</p>\n<h2 id=\"16-低权重原则——避免滥用子选择器\"><a href=\"#16-低权重原则——避免滥用子选择器\" class=\"headerlink\" title=\"16. 低权重原则——避免滥用子选择器\"></a>16. 低权重原则——避免滥用子选择器</h2><p>除非确定 HTML 结构非常稳定，一定不会再修改了，否则尽量不要使用子选择器。为了保证样式容易被覆盖，提高可维护性，CSS 选择符需保证权重尽可能低。</p>\n<h2 id=\"17-CSS-sprit-技术\"><a href=\"#17-CSS-sprit-技术\" class=\"headerlink\" title=\"17. CSS sprit 技术\"></a>17. CSS sprit 技术</h2><p>CSS sprite 技术看似简单，其实不容易掌握，主要有如下原因:</p>\n<ul>\n<li>它能合并的只能是用于背景的图片，对于 <code>&lt;img src=&quot;&quot; /&gt;</code> 设置的图片，是不能合并到 CSS sprite 大图中的，如果合并这些图片会影响页面可读性。</li>\n<li>对于横向和纵向都平铺的图片，也不能使用 CSS sprite；如果是横向平铺的，只能将所有横向平铺的图合并成一张大图，只能竖直排列，不能水平排列；如果是纵向平铺的，我们只能将所有纵向平铺的图合并成一张大图，只能水平排列，不能竖直排列。</li>\n<li>图片如何排列能够尽量紧凑，同时保证不会影响扩展性。这点是 CSS sprite 技术最困难也是最具挑战性的地方。</li>\n</ul>\n<h2 id=\"18-CSS-hack\"><a href=\"#18-CSS-hack\" class=\"headerlink\" title=\"18. CSS hack\"></a>18. CSS hack</h2><h3 id=\"IE-条件注释法\"><a href=\"#IE-条件注释法\" class=\"headerlink\" title=\"IE 条件注释法\"></a>IE 条件注释法</h3><h4 id=\"只在IE下生效\"><a href=\"#只在IE下生效\" class=\"headerlink\" title=\"只在IE下生效\"></a>只在IE下生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE6-下生效\"><a href=\"#只在-IE6-下生效\" class=\"headerlink\" title=\"只在 IE6 下生效\"></a>只在 IE6 下生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE6-以上版本生效\"><a href=\"#只在-IE6-以上版本生效\" class=\"headerlink\" title=\"只在 IE6 以上版本生效\"></a>只在 IE6 以上版本生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if gt IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE7-上不生效\"><a href=\"#只在-IE7-上不生效\" class=\"headerlink\" title=\"只在 IE7 上不生效\"></a>只在 IE7 上不生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if ! IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注释和-style-标签\"><a href=\"#条件注释和-style-标签\" class=\"headerlink\" title=\"条件注释和 style 标签\"></a>条件注释和 style 标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;style type=\"text/CSS\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">.test&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注释和-script-标签\"><a href=\"#条件注释和-script-标签\" class=\"headerlink\" title=\"条件注释和 script 标签\"></a>条件注释和 script 标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;script type=\"text/JavaScript\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">alert(\"我是 IE 6\");</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"选择符前缀法\"><a href=\"#选择符前缀法\" class=\"headerlink\" title=\"选择符前缀法\"></a>选择符前缀法</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/CSS\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">80px</span>; &#125;               <span class=\"comment\">/* IE 6,IE 7,IE 8 */</span></span></span><br><span class=\"line\"><span class=\"css\">*<span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">60px</span>; &#125;         <span class=\"comment\">/* only for IE 6 */</span></span></span><br><span class=\"line\"><span class=\"css\">*+<span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">70px</span>; &#125;        <span class=\"comment\">/* only for IE 7 */</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>选择符前缀法相较于 IE 条件注释法来说，可维护性强了很多，但在向后兼容性上存在一点风险。另外，选择符前缀法不能用于内联样式上。</p>\n<h3 id=\"样式属性前缀法\"><a href=\"#样式属性前缀法\" class=\"headerlink\" title=\"样式属性前缀法\"></a>样式属性前缀法</h3><p>样式属性前缀法的原理是在样式的属性名前加前缀，这些前缀只在特定浏览器下才生效.例如 “_” 只在 IE6 下生效，”*” 在 IE6 和 IE7 下生效。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/CSS\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.test</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 80px;</span></span><br><span class=\"line\"><span class=\"undefined\">  *width: 70px;</span></span><br><span class=\"line\"><span class=\"undefined\">  _width: 60px;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"19-a-标签的四种状态\"><a href=\"#19-a-标签的四种状态\" class=\"headerlink\" title=\"19. a 标签的四种状态\"></a>19. a 标签的四种状态</h2><p>关于 a 标签的四种状态的排序问题，有个简单好记的原则，叫做 love hate 原则，即 l(link)ov(visited)e h(hover)a(active)te</p>\n<h2 id=\"20-hasLayout\"><a href=\"#20-hasLayout\" class=\"headerlink\" title=\"20. hasLayout\"></a>20. hasLayout</h2><p>hasLayout 是 IE 浏览器专有的一个属性，用于 CSS 的解析引擎。有时候在 IE 下一些复杂的 CSS 设置解析起来会出现 Bug，其原因可能与 hasLayout 没有被自动触发有关，我们通过一些技巧，手动触发 hasLayout 属性就可以解决Bug了。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_302.png\" alt=\"\" width=\"550\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_303.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"21-块级元素和行内元素的区别\"><a href=\"#21-块级元素和行内元素的区别\" class=\"headerlink\" title=\"21. 块级元素和行内元素的区别\"></a>21. 块级元素和行内元素的区别</h2><ul>\n<li>块级元素会独占一行，默认情况下，其宽度自动填满其父元素宽度，行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化；</li>\n<li>块级元素可以设置 width，height 属性。行内元素设置 width，height 属性无效。块级元素即使设置了宽度，仍然是独占一行的；</li>\n<li>块级元素可以设置 margin 和 padding 属性。行内元素的 margin 和 padding 属性很奇怪，水平方向的 padding 和 margin 都产生边距效果，但竖直方向的 padding，margin 却不会产生边距效果。</li>\n</ul>\n<h2 id=\"22-display-inline-block\"><a href=\"#22-display-inline-block\" class=\"headerlink\" title=\"22. display:inline-block\"></a>22. display:inline-block</h2><p>它是行内的块级元素，它拥有块级元素的特点，可以设置长宽，可以设置 margin 和 padding 值，但它却不是独占一行，它的宽度并不占满父元素，而是和行内元素一样，可以和其他行内元素排在同一行里.</p>\n<h2 id=\"23-relative，absolute-和-float\"><a href=\"#23-relative，absolute-和-float\" class=\"headerlink\" title=\"23. relative，absolute 和 float\"></a>23. relative，absolute 和 float</h2><p>设置 position: relative 或 position: absolute 都可以让元素激活 left，top，right，bottom 和 z-index 属性(默认情况下，这些属性未激活，设置了也无效) 设置 position:relative 或 position:absolute 会让元素”浮”起来，也就是 z-index 值大于 0，它会改变正常情况下的文档流。float 也能改变文档流，不同的是，float 属性不会让元素”上浮”到另一个 z-index 层，它仍然让元素在 z-index: 0 层排列。另外，不论之前什么类型的元素(display: none 除外)，只要设置了 position: absolute，float: left 或 float: right 中的任意一个，都会让元素以 display: inline-block 的方式显示，可以设置长宽，默认宽度并不占满父元素。就算我们显示地设置 display: inline 或者 display: block，也仍然无效。position: relative 不会隐式改变 display 的类型。</p>\n<h2 id=\"24-居中\"><a href=\"#24-居中\" class=\"headerlink\" title=\"24. 居中\"></a>24. 居中</h2><h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3><h4 id=\"文本，图片等行内元素的水平居中\"><a href=\"#文本，图片等行内元素的水平居中\" class=\"headerlink\" title=\"文本，图片等行内元素的水平居中\"></a>文本，图片等行内元素的水平居中</h4><p>父元素设置text-align:center</p>\n<h4 id=\"确定宽度的块级元素的水平居中\"><a href=\"#确定宽度的块级元素的水平居中\" class=\"headerlink\" title=\"确定宽度的块级元素的水平居中\"></a>确定宽度的块级元素的水平居中</h4><p>margin:0 auto</p>\n<h4 id=\"不确定宽度的块级元素的水平居中\"><a href=\"#不确定宽度的块级元素的水平居中\" class=\"headerlink\" title=\"不确定宽度的块级元素的水平居中\"></a>不确定宽度的块级元素的水平居中</h4><ul>\n<li>第一种方法：将 ul 包含在 table 标签内，对 table 设置 margin: 0 auto 就可以使 table 水平居中，间接地使 ul 实现了水平居中；</li>\n<li>第二种方法：改变块级元素的 display 为 inline 类型，然后使用 text-align: center 来实现居中；</li>\n<li>第三种方法：给父元素设置 float，然后父元素设置 position: relative 和 left: 50%，子元素设置 position: relative 和 left: -50% 来实现水平居中</li>\n</ul>\n<h3 id=\"竖直居中\"><a href=\"#竖直居中\" class=\"headerlink\" title=\"竖直居中\"></a>竖直居中</h3><h4 id=\"父元素高度不确定的文本，图片，块级元素的竖直居中\"><a href=\"#父元素高度不确定的文本，图片，块级元素的竖直居中\" class=\"headerlink\" title=\"父元素高度不确定的文本，图片，块级元素的竖直居中\"></a>父元素高度不确定的文本，图片，块级元素的竖直居中</h4><p>给父容器设置相同上下边距实现的</p>\n<h4 id=\"父元素高度确定的单行文本的竖直居中\"><a href=\"#父元素高度确定的单行文本的竖直居中\" class=\"headerlink\" title=\"父元素高度确定的单行文本的竖直居中\"></a>父元素高度确定的单行文本的竖直居中</h4><p>通过给父元素设置 line-height 来实现的，line-height 值和父元素的高度值相同。</p>\n<h4 id=\"父元素高度确定的多行文本，图片，块级元素的竖直居中\"><a href=\"#父元素高度确定的多行文本，图片，块级元素的竖直居中\" class=\"headerlink\" title=\"父元素高度确定的多行文本，图片，块级元素的竖直居中\"></a>父元素高度确定的多行文本，图片，块级元素的竖直居中</h4><p>块级元素的 display:table-cell，vertical-align:center。</p>\n<h2 id=\"25-使用匿名函数控制变量的作用域\"><a href=\"#25-使用匿名函数控制变量的作用域\" class=\"headerlink\" title=\"25. 使用匿名函数控制变量的作用域\"></a>25. 使用匿名函数控制变量的作用域</h2><p><code>(function(){ var a，c=&quot;abc&quot;; })();</code> 这种形式很巧妙，先定义一个匿名的 function，然后立即执行它.包在这个匿名 function 里的变量，作用域就不再是 window，而是局限在函数内部。用匿名函数将脚本包起来，可以有效控制全局变量，避免冲突隐患。让 JS 不产生冲突，需要避免全局变量的泛滥，合理使用命名空间以及为代码添加必要的注释。</p>\n<h2 id=\"26-window-onload-和-DOMReady\"><a href=\"#26-window-onload-和-DOMReady\" class=\"headerlink\" title=\"26. window.onload 和 DOMReady\"></a>26. window.onload 和 DOMReady</h2><p>window.onload 需要当页面完全加载完成时才会触发，包括图片，Flash 等富媒体，DOMReady 只判断页面内所有的 DOM 节点是否已经全部生成，至于节点的内容是否加载完成，它并不关心. DOMReady 比 window.onload 更适合用来调用初始化函数。值得注意的是，DOMReady 并不是原生 JavaScript 支持的事件，它不能像 window.load 那样直接调用，一般我们都是结合 JS 框架来使用它。</p>\n<h2 id=\"27-CSS-放在页头，JavaScript-放在页尾\"><a href=\"#27-CSS-放在页头，JavaScript-放在页尾\" class=\"headerlink\" title=\"27. CSS 放在页头，JavaScript 放在页尾\"></a>27. CSS 放在页头，JavaScript 放在页尾</h2><p>将 CSS 放在页头，在载入 HTML 元素之前，先载入它们的样式，这样可以避免 HTML 出现无样式状态；将 JavaScript 放在页尾，先将网页呈现给用户，再来加载页面内的脚本，避免 JavaScirpt 阻塞网页的呈现，减少页面空白的时间。</p>\n<h2 id=\"28-引入编译的概念——文件压缩\"><a href=\"#28-引入编译的概念——文件压缩\" class=\"headerlink\" title=\"28. 引入编译的概念——文件压缩\"></a>28. 引入编译的概念——文件压缩</h2><p>为了减小网页的大小，缩短网页的下载时间，在正式发布 JavaScript 之前，我们可以先对它进行一下压缩。JS 压缩通常的做法是去掉空格和换行，去掉注释，将复杂变量名替换成简单的变量名。</p>\n<h2 id=\"29-JavaScript-如何分层\"><a href=\"#29-JavaScript-如何分层\" class=\"headerlink\" title=\"29. JavaScript 如何分层\"></a>29. JavaScript 如何分层</h2><p>把 JavaScript 也分成三层，从下往上依次是 base 层，common 层和 page 层</p>\n<h3 id=\"base-层-1\"><a href=\"#base-层-1\" class=\"headerlink\" title=\"base 层\"></a>base 层</h3><p>有两个职责，职责一是封装不同浏览器下 JavaScript 的差异，提供统一的接口，我们可以依靠它来完成跨浏览器兼容的工作。职责二是扩展 JavaScript 语言底层提供的接口，让它提供更多更为易用的接口。</p>\n<h3 id=\"common-层-1\"><a href=\"#common-层-1\" class=\"headerlink\" title=\"common 层\"></a>common 层</h3><p>依赖于 base 层提供的接口。common 层提供可供复用的组件，它是典型的 mvc 模式中的 m，和页面内的具体功能没有直接关系。common 层的功能是给 page 层提供组件。</p>\n<h3 id=\"page-层-1\"><a href=\"#page-层-1\" class=\"headerlink\" title=\"page 层\"></a>page 层</h3><p>这一层和页面里的具体功能需求直接相关，是 mvc 模式中的 c。page 层的功能是完成页面内的功能需求。</p>\n<h2 id=\"30-JavaScript-中的参数\"><a href=\"#30-JavaScript-中的参数\" class=\"headerlink\" title=\"30. JavaScript 中的参数\"></a>30. JavaScript 中的参数</h2><p>如果一个函数内某个因素很不稳定，我们可以将它从函数内部分离出来，以参数的形式传入，从而将不稳定因素和函数解耦。在编程里有一个很出名的规则叫做 DRY——don’t repeat yourself，强调在程序中不要将相同的代码重复编写多次，更好的做法是只写一次，然后在多处引用。</p>\n<h2 id=\"31-JavaScript-与面向对象\"><a href=\"#31-JavaScript-与面向对象\" class=\"headerlink\" title=\"31. JavaScript 与面向对象\"></a>31. JavaScript 与面向对象</h2><p>JavaScript 很奇怪，它没有 Class 关键字，在 JavaScript 中是用函数来充当类的。函数在 JavaScript 中既可以当作普通函数使用，也可以当作类来使用，在充当类的时候，它本身又担负着构造函数的责任。函数作为普通函数使用时，通常直接使用 “()” 进行调用，而作为类使用时，通常使用 new 来实例化。通常情况下，作为函数时我们更倾向于用动词来命名，而作为类时用名词来命名。按照习惯，类名的首字母大写。JavaScript 是基于原型的语言，通过 new 实例化出来的对象，其属性和行为来自于两部分，一部分来自于构造函数，另一部分来自于原型。当我们声明一个类时，其实同时生成了一个对应的原型，例如我们定义 Animal 这个类时，会生成一个与 Animal 类对应的原型，通过 Animal.prototype 可以指向这个原型，原型可以通过 constructor 指向 Animal 类，更确切地说，是指向 Animal 类的构造函数。构造函数中定义的属性和行为的优先级比原型中定义的属性和行为优先级高，如果构造函数和原型定义了同名的属性和行为，构造函数中的属性和行为会覆盖原型中的同名的属性和行为。 this 关键字无论出现在构造函数中，还是出现在原型中，指向的都是实例对象，通过 this 关键字，可以让属性和方法在构造函数和原型间通信。正统的面向对象语言会提供 public，protect，private 等关键字来声明属性和行为的可访问性是公有还是私有。但 JavaScript 并不提供这些关键字，在 JavaScript 中公有还是私有是通过作用域实现的。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_304.png\" alt=\"\" width=\"550\"></div>\n\n<p>把行为写在原型里可以减少内存消耗，没有特殊原因，推荐尽量把行为写在原型里。写在原型中的行为一定是公有的，而且无法访问私有属性。</p>\n<h2 id=\"32-传值与传址\"><a href=\"#32-传值与传址\" class=\"headerlink\" title=\"32. 传值与传址\"></a>32. 传值与传址</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;             <span class=\"comment\">// 基本数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;              <span class=\"comment\">// 将变量 a 保存的值复制一份，传给变量 b，a 和 b 各保存一份数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = [<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>];       <span class=\"comment\">// 复杂数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = c;              <span class=\"comment\">// 将变量 c 指向的数据的内存地址传给变量d，c 和 b 指向同一份数据</span></span><br><span class=\"line\">b++;</span><br><span class=\"line\">d.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">alert(a);     <span class=\"comment\">// 10 </span></span><br><span class=\"line\">alert(b);     <span class=\"comment\">// 11        变量 b 保存的数据更改不会影响到变量 a</span></span><br><span class=\"line\">alert(c);     <span class=\"comment\">// 1，2，3，4 变量 c 和 d 指向同一份数据，数据更改会互相影响</span></span><br><span class=\"line\">alert(d);     <span class=\"comment\">// 1，2，3，4</span></span><br></pre></td></tr></table></figure>\n<p>在原生 JavaScript中，选择传值还是传址是根据数据类型自动判定的，但传址有时候会给我们带来意想不到的麻烦，所以我们需要对复杂类型数据的赋值进行控制，让复杂数据类型也可以进行传值。</p>\n<h2 id=\"33-UML-描述类\"><a href=\"#33-UML-描述类\" class=\"headerlink\" title=\"33. UML 描述类\"></a>33. UML 描述类</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">PhonebookManager</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">+getTel():string</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+addItem():void</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+removeItem():void</td>\n</tr>\n</tbody>\n</table>\n<p>一个方框代表一个类，将方框划分成上中下三栏，第一栏填入类名，第二栏填入类的属性，第三栏填入类的行为，其中公有属性和公有行为需要在属性和行为名前加上 “+” 号，而私有属性和私有行为需要在属性和行为名前加上 “-” 号。</p>\n<h2 id=\"34-prototype-和内置类\"><a href=\"#34-prototype-和内置类\" class=\"headerlink\" title=\"34. prototype 和内置类\"></a>34. prototype 和内置类</h2><div align=\"center\"><img src=\"/images/hexo_post_305.png\" alt=\"\" width=\"600\"></div>\n\n<p>只要是类就会有原型，不管它是自定义类还是 JavaScript 的内置类，我们可以通过修改内置类的原型，让 JavaScript 基本类型的对象获得一些有趣的功能。无论在类的构造函数中还是在原型中，this 都指向实例化的对象。内置类的方法可以重写，但属性却不能重写。在 JavaScript 中，包括内置类和自定义类，所有类的祖先类都是 Object，所以如果想对所有对象都扩展方法，可以通过修改 Object 类的原型实现。</p>\n<h2 id=\"35-修改内置类\"><a href=\"#35-修改内置类\" class=\"headerlink\" title=\"35. 修改内置类\"></a>35. 修改内置类</h2><p>使用自定义类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myArray</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getArray=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myArray.prototype=&#123;</span><br><span class=\"line\">  each:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fun</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o=<span class=\"keyword\">this</span>.getArray();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=-，n=o.length;i&lt;n;i++)&#123;</span><br><span class=\"line\">      fun(o\\[i\\]，i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"keyword\">new</span> nyArray(\\[<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>\\])，str=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">a.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v，k</span>)</span>&#123;</span><br><span class=\"line\">  str += k+<span class=\"string\">\":\"</span>+v+<span class=\"string\">\"\\\\n\"</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">alert(str);    <span class=\"comment\">// 0:1 1:2 2:3</span></span><br></pre></td></tr></table></figure>\n<p>代替直接修改内置类原型的做法，定义一个自定义类，将内置类的实例作为参数传给构造函数，在自定义类里定义扩展方法。这种做法的思路是将内置类再封装一层，以此保护内置类的原型不被污染。两种方法都各有优缺点，修改内置类的原型非常方便，缺点是可能会带来冲突隐患；自定义类可以保护原型不被修改，但它需要用 new 来实例化自定义类，相对麻烦一点。如果是小应用，不用过多考虑可维护性，推荐使用前者，如果是大中型应用，需要考虑可维护性，推荐使用后者。</p>\n<h2 id=\"36-自定义属性\"><a href=\"#36-自定义属性\" class=\"headerlink\" title=\"36. 自定义属性\"></a>36. 自定义属性</h2><p>对于常规属性，统一使用 node.XXX 的方式读取，对于自定义属性，统一使用 node.getAttribute(“XXX”) 读取。将复杂类型的数据转化成字符串，称为数据的序列化，其逆操作叫做数据的反序列化。字符串的反序列化是通过 eval 函数实现的。只要字符串长的像 JavaScript 支持的数据格式，就可以进行反序列化。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">\"a\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://www.adanghome.com\"</span> <span class=\"attr\">blogInfo</span>=<span class=\"string\">\"&#123;name:'阿当的博客'，</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">type:'前端开发'&#125;\"</span>&gt;</span>my blog<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/JavaScript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> node=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"a\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> info=node.getAttribute(<span class=\"string\">\"blogInfo\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  alert(<span class=\"keyword\">typeof</span> info);    <span class=\"comment\">//string</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.name);      <span class=\"comment\">//undefined</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.type);      <span class=\"comment\">//undefined</span></span></span><br><span class=\"line\"><span class=\"javascript\">  info=<span class=\"built_in\">eval</span>(<span class=\"string\">\"(\"</span> + info + <span class=\"string\">\")\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  alert(<span class=\"keyword\">typeof</span> info);    <span class=\"comment\">//object</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.name);      <span class=\"comment\">//阿当的博客</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.type);      <span class=\"comment\">//前端开发</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"37-代码可维护性\"><a href=\"#37-代码可维护性\" class=\"headerlink\" title=\"37. 代码可维护性\"></a>37. 代码可维护性</h2><p>好的可维护性可以从四个方面获得：</p>\n<ul>\n<li>代码的松耦合，高度模块化，将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从 HTML、CSS、JavaScript 三个层面考虑模块化。</li>\n<li>良好的注释。</li>\n<li>注意代码的弹性，在性能和弹性的选择上，一般情况下以弹性为优先考虑条件，在保证弹性的基础上，适当优化性能。</li>\n<li>严格按照规范编写代码。</li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（7）——JavaScript半知半解","slug":"读书笔记系列（7）——JavaScript半知半解","date":"2017-04-25T15:33:09.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（7）——JavaScript半知半解.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这本书是我无意中看到的一本电子版书籍，但是第一章就吸引到了我，然后就对作者展开了深入“挖掘”，通过作者的<a href=\"http://ghmagical.com/\" target=\"_blank\" rel=\"noopener\">个人博客</a>发现作者是一个很厉害的技术开发人员，不管是前端还是后台都有所涉猎，所以推荐大家去他的个人博客逛逛，同时推荐他的两本书籍：《JavaScript半知半解》和《Web实战》，一定会有所收获</p>\n<h2 id=\"1-完整的-JavaScript\"><a href=\"#1-完整的-JavaScript\" class=\"headerlink\" title=\"1. 完整的 JavaScript\"></a>1. 完整的 JavaScript</h2><p>完整的 JavaScript 实现由下列三个不同的部分组成：</p>\n<ul>\n<li>核心（<strong>ECMAScript</strong>）</li>\n<li>文档对象模型（<strong>DOM</strong>）</li>\n<li>浏览器对象模型（<strong>BOM</strong>）</li>\n</ul>\n<h2 id=\"2-lt-script-gt-元素\"><a href=\"#2-lt-script-gt-元素\" class=\"headerlink\" title=\"2. &lt;script&gt; 元素\"></a>2. <code>&lt;script&gt;</code> 元素</h2><p>向 HTML 页面中插入 JavaScript 的主要方法，就是使用 <code>&lt;script&gt;</code> 元素。<code>&lt;script&gt;</code> 中定义了下列 6 个属性：</p>\n<ul>\n<li><strong><code>async</code></strong>：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效</li>\n<li><strong><code>charset</code></strong>：可选，表示通过 src 属性指定的代码的字符集，比较少用。</li>\n<li><strong><code>defer</code></strong>：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li>\n<li><strong><code>language</code></strong>：已废弃</li>\n<li><strong><code>src</code></strong>：可选，表示包含要执行代码的外部文件</li>\n<li><strong><code>type</code></strong>：可选，表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。在 HTML5 中，默认是 text/javascript，所以不需要设置。</li>\n</ul>\n<h2 id=\"3-在使用-lt-script-gt-嵌入-JavaScript-代码时，切记不要在代码中的任何地方出现-lt-script-gt\"><a href=\"#3-在使用-lt-script-gt-嵌入-JavaScript-代码时，切记不要在代码中的任何地方出现-lt-script-gt\" class=\"headerlink\" title=\"3. 在使用 &lt;script&gt; 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 &lt;/script&gt;\"></a>3. 在使用 <code>&lt;script&gt;</code> 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 <code>&lt;/script&gt;</code></h2><p>执行下面的代码时，会产生一个错误：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  alert('</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-JavaScript-代码的执行顺序\"><a href=\"#4-JavaScript-代码的执行顺序\" class=\"headerlink\" title=\"4. JavaScript 代码的执行顺序\"></a>4. JavaScript 代码的执行顺序</h2><p>只要不存在 defer 和 async 属性，JavaScript 代码就会从上至下依次解析。带有 src 属性的 <code>&lt;script&gt;</code> 元素不应该在其 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签之间再包含额外的 JavaScript 代码，嵌入代码会被忽略。<strong>只要不存在 defer 和 async 属性，浏览器都会按照 <code>&lt;script&gt;</code> 出现的先后顺序对它们依次进行解析。</strong> 一般将全部 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中页面的内容后面。</p>\n<h2 id=\"5-延迟脚本\"><a href=\"#5-延迟脚本\" class=\"headerlink\" title=\"5. 延迟脚本\"></a>5. 延迟脚本</h2><p>当给 <code>&lt;script&gt;</code> 元素添加了 <code>defer</code> 属性时，src 指向的外部文件会立即下载，但包含的脚本会延迟到浏览器遇到 <code>&lt;/html&gt;</code> 标签（整个页面解析完毕）后再执行（按添加顺序执行），会先于 DOMContentLoaded 事件执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span>=<span class=\"string\">\"defer\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>会先执行 example.js，然后执行 example2.js。</p>\n<blockquote>\n<p>注意：defer 只适合外部脚本文件。</p>\n</blockquote>\n<h2 id=\"6-异步脚本\"><a href=\"#6-异步脚本\" class=\"headerlink\" title=\"6. 异步脚本\"></a>6. 异步脚本</h2><p><code>async</code> 与 <code>defer</code> 属性类似，都用于改变处理脚本的行为，适用于外部脚本文件，并告诉浏览器立即下载，但标记为 <code>async</code> 的脚本并不保证按照指定它们的先后顺序执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>两个执行顺序不定</strong>。指定 <code>async</code> 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p>\n<blockquote>\n<p>注意：异步脚本不要在加载期间修改 DOM。 <strong>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行</strong>。</p>\n</blockquote>\n<h2 id=\"7-元素\"><a href=\"#7-元素\" class=\"headerlink\" title=\"7. 元素\"></a>7. <noscript>元素</noscript></h2><p>当浏览器不支持 JavaScript 或被禁用时，显示里面的内容。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\"> 本页面需要浏览器支持（启用）JavaScript</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"8-关键字和保留字\"><a href=\"#8-关键字和保留字\" class=\"headerlink\" title=\"8. 关键字和保留字\"></a>8. 关键字和保留字</h2><p>ECMA-262 描述了一组具有特定用途的<strong>关键字</strong>，这些关键字可用于控制语句的开始或结束，或者用于执行特定操作等，不能用作标识符。</p>\n<blockquote>\n<p>break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try</p>\n</blockquote>\n<p>ECMA-262 还描述了一组不能用作标识符的<strong>保留字</strong>：</p>\n<blockquote>\n<p>abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public</p>\n</blockquote>\n<p>如果使用关键字作标识符，会导致 “Identifier Expected” 错误。 有些时候，我们不得不用到保留字货关键字的，比如 CSS 样式中的 float，这时就需要这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style.cssFloat</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-隐式全局变量\"><a href=\"#9-隐式全局变量\" class=\"headerlink\" title=\"9. 隐式全局变量\"></a>9. 隐式全局变量</h2><p>在下面的代码中，由于从右至左的操作符优先级，所以表达式 “b=0” 是先执行的，而此时b未经过声明，所以它会成为全局变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>\n<p>关于全局变量：</p>\n<ul>\n<li>使用 var 创建的全局变量不能删除。</li>\n<li>不是 var 创建的隐含全局变量可以使用 delete 删除（因为它并不是真正的变量，而是全局对象 window 的属性）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> b;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">//  0</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// ReferenceError: b is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-变量提升\"><a href=\"#10-变量提升\" class=\"headerlink\" title=\"10. 变量提升\"></a>10. 变量提升</h2><p><strong>变量提升</strong>是指所有变量的声明语句，都会被提升到代码的头部。 在函数内也一样，函数中的所有变量声明会在函数执行时被“提升”至函数体顶端：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>结果是不是有点出乎你的意料。其实 JavaScript 的执行环境分为<strong>声明阶段</strong>和<strong>执行阶段</strong>，因此对于上面的代码，JavaScript 会这样解释代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-typeof-操作符\"><a href=\"#11-typeof-操作符\" class=\"headerlink\" title=\"11. typeof 操作符\"></a>11. typeof 操作符</h2><p><strong><code>typeof</code></strong>操作符用来检测给定变量的数据类型，可能的返回值：</p>\n<ul>\n<li>“undefined” –&gt; 这个值未定义</li>\n<li>“boolean” –&gt; 这个值是布尔值</li>\n<li>“string” –&gt; 这个值是字符串</li>\n<li>“number” –&gt; 这个值是数值</li>\n<li>“object” –&gt; 这个值是对象或 <strong>null</strong></li>\n<li>“function” –&gt; 这个值是函数</li>\n</ul>\n<h2 id=\"12-undefined-和-null-类型\"><a href=\"#12-undefined-和-null-类型\" class=\"headerlink\" title=\"12. undefined 和 null 类型\"></a>12. undefined 和 null 类型</h2><p><code>Undefined</code> 类型只有一个值，即特殊的 <code>undefined</code>；<code>Null</code> 类型也是只有一个值的数据类型，这个特殊值就是 <code>null</code>；null 和 undefined 没有属性，甚至连 toString() 这种标准方法都没有；undefined 其实是派生自 null 值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"13-Boolean\"><a href=\"#13-Boolean\" class=\"headerlink\" title=\"13. Boolean()\"></a>13. Boolean()</h2><p>要将一个值转换为其对应的 Boolean 值，可以使用转型函数 Boolean()；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'tg'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Boolean</span>(name);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>可以对任何类型的值调用 Boolean 函数，而且总会返回一个 Boolean 值（true 或 false）<strong>转换规则</strong>：</p>\n<ul>\n<li>对于 true 或 false，返回原值（true 或 false）</li>\n<li>对于 String 类型的值，任何非空字符串返回 true，空字符串（””）返回 false</li>\n<li>对于 Number 类型的值，任何非零数字值（包括无穷大），返回 true；0 和 NaN 返回 false</li>\n<li>对于 Object 类型的值，任何对象返回 true，null 返回 false</li>\n<li>对于 Undefined 类型，undefined 返回 false（只有一个值）</li>\n</ul>\n<h2 id=\"14-浮点数值\"><a href=\"#14-浮点数值\" class=\"headerlink\" title=\"14. 浮点数值\"></a>14. 浮点数值</h2><p>保存浮点数值需要的内存空间是保存整数值的两倍。 默认情况下，ECMAScript 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示的数值。 浮点数的最高精度是 17 位小数（所以浮点数的比较比较麻烦）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> = <span class=\"number\">0.3000000000000004</span>; <span class=\"comment\">// 不是等于0.3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"15-数值范围\"><a href=\"#15-数值范围\" class=\"headerlink\" title=\"15. 数值范围\"></a>15. 数值范围</h2><p>ECMAScript 能够表示的最小数值保存在 <code>Number.MIN_VALUE</code>（最小值）中，这个值是 5e-324；能够表示的最大数值保存在 <code>Number.MAX_VALUE</code>（最大值）中，这个值是 1.7976931348623157e+308</p>\n<blockquote>\n<p>注意：Infinity 是不能参与计算的数值。用 <code>isFinite()</code> 来判断这个值是否无穷，该函数接受一个参数。如果参数位于最小与最大数值之间，返回 true。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isFinite</span>(<span class=\"number\">1</span>));  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isFinite</span>(<span class=\"literal\">Infinity</span>));  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"16-NaN\"><a href=\"#16-NaN\" class=\"headerlink\" title=\"16. NaN\"></a>16. NaN</h2><p>NaN（Not a Number）表示非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 注意点：</p>\n<ul>\n<li>任何涉及 NaN 的操作都会返回 NaN。</li>\n<li>NaN 与任何值都不相等，包括 NaN 本身。</li>\n<li>任何操作数与 NaN 比较，都会返回 false</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>);  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>我们可以用 <code>isNaN()</code> 函数来判断是否非数值，该函数接受一个参数，可以是任何类型。<code>isNaN()</code> 在接收到\b这个参数之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，比如：字符串 “10” 或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"number\">10</span>));  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"string\">'blue'</span>));  <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"17-Number\"><a href=\"#17-Number\" class=\"headerlink\" title=\"17. Number()\"></a>17. Number()</h2><p><strong>Number() 函数的转换规则</strong>：</p>\n<ul>\n<li>如果是 Boolean 值，true 和 false 将分别转换为 1 和 0</li>\n<li>如果是数字值，只是简单的传入和返回</li>\n<li>如果是 null 值，返回 0</li>\n<li>如果是 undefined，返回 NaN</li>\n<li>如果是字符串，遵循下列规则： （<ul>\n<li>如果是字符串中只包含数字（包括前面带正负号），则将其转换为十进制数值（前导的零会被忽略）</li>\n<li>如果字符串中包含有效的浮点格式，如 1.1，则将其转换为对应的浮点数值</li>\n<li>如果字符串中包含有效的十六进制，如 0xf，则将其转换为相同大小的十进制数值</li>\n<li>如果字符串是空的，返回0</li>\n<li>如果字符串中包含上述格式以外的字符，返回 NaN ）</li>\n</ul>\n</li>\n<li>如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回字符串值</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">'tg'</span>));   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">''</span>));   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">'0011'</span>));  <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"literal\">true</span>));   <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>一元加操作符的操作与 Number 函数规则相同</p>\n<h2 id=\"18-parseInt-和-parseFloat\"><a href=\"#18-parseInt-和-parseFloat\" class=\"headerlink\" title=\"18. parseInt() 和 parseFloat()\"></a>18. parseInt() 和 parseFloat()</h2><p><code>parseInt()</code> 会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回 NaN。如果第一个字符是数字字符，就会继续解析，直到解析完所有后续字符或者遇到了一个非数字字符。 <code>parseInt()</code> 也能识别八进制（在 ECMAScript 5 中无法识别，将开头的 0 当作 0）和十六进制，最后会转换成十进制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'123tg'</span>));  <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">''</span>));   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'070'</span>));  <span class=\"comment\">// 70</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'0xf'</span>));  <span class=\"comment\">//15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"number\">22.5</span>));  <span class=\"comment\">// 22</span></span><br></pre></td></tr></table></figure>\n<p>我们还可以为 <code>parseInt()</code> 提供第二个参数，指定需要转换的进制（刷算法题的时候经常用到）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'0xAF'</span>,<span class=\"number\">16</span>));  <span class=\"comment\">// 175</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'AF'</span>,<span class=\"number\">16</span>));  <span class=\"comment\">// 175</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'AF'</span>));  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'070'</span>,<span class=\"number\">8</span>));  <span class=\"comment\">// 56</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'70'</span>,<span class=\"number\">8</span>));  <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n<p><code>parseFloat()</code> 和 <code>parseInt()</code> 类似，也是从第一个字符（位置 0）开始解析每个字符，而且一直解析到字符串末尾，或者解析到遇到一个无效的浮点数字字符为止，换句话说，字符串中的第一个小数点是有效的，后面的小数点是无效的，它还会忽略前导的零，只会解析十进制值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'123tg'</span>));  <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'22.12.4'</span>));   <span class=\"comment\">// 22.12</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'070'</span>));  <span class=\"comment\">// 70</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'0xf'</span>));  <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"number\">22.5</span>));  <span class=\"comment\">// 22.5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"19-Object-类型\"><a href=\"#19-Object-类型\" class=\"headerlink\" title=\"19. Object 类型\"></a>19. Object 类型</h2><p>在 ECMAScript 中，<code>Object</code> 类型是所有对象的基础。<code>Object</code> 的每个实例都具有下列属性和方法：</p>\n<ul>\n<li><strong><code>Constructor</code></strong>：保存着用于创建当前对象的函数，比如上面的例子，构造函数就是 Object()</li>\n<li><strong><code>hasOwnProperty(propertyName)</code></strong>：用于检查给定的属性在当前对象实例中是否存在（而不是在实例的原型中），参数必须是字符串形式</li>\n<li><strong><code>isPrototypeOf(object)</code></strong>：用于检查传入的对象是否是另一个对象的原型</li>\n<li><strong><code>propertyIsEnumerable(propertyName)</code></strong>：用于检查给定的属性是否能够使用 for-in 语句来枚举，参数必须是字符串形式</li>\n<li><strong><code>toLocaleString()</code></strong>：返回对象的字符串表示，该字符串与执行环境的地区对应</li>\n<li><strong><code>toString()</code></strong>：返回对象的字符串表</li>\n<li><strong><code>valueOf()</code></strong>：返回对象的字符串、数值或布尔值表示，通常和 toString() 返回的值相同</li>\n</ul>\n<h2 id=\"20-递增和递减\"><a href=\"#20-递增和递减\" class=\"headerlink\" title=\"20. 递增和递减\"></a>20. 递增和递减</h2><p>递减和递增操作符会遵循下列规则：</p>\n<ul>\n<li>当操作数是一个包含有效数字字符的字符串，系统会将其转换为数字值，再执行递减或递增。</li>\n<li>当操作数是一个不包含有效数字字符的字符串，系统将变量的值设置为 NaN</li>\n<li>当操作数是布尔值，会将其转为数值（true 转为 1，false 转为 0）再操作。</li>\n<li>当操作数是浮点数值，直接执行递减或递增</li>\n<li>当操作数是对象，先调用对象的 valueOf() 方法取得一个可供操作的值，然后再遵循上面的三条规则。如果结果是 NaN，则在调用 toString() 方法后再遵循上面的规则转换。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'2'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  valueOf: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a++;  <span class=\"comment\">// 3</span></span><br><span class=\"line\">b++;  <span class=\"comment\">// NaN</span></span><br><span class=\"line\">c--;  <span class=\"comment\">// -1</span></span><br><span class=\"line\">d--;  <span class=\"comment\">// 0.10000000000000009 （浮点数操作结果，类似0.1+0.2 != 0.3）</span></span><br><span class=\"line\">o--;  <span class=\"number\">-2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"21-按位非（NOT）\"><a href=\"#21-按位非（NOT）\" class=\"headerlink\" title=\"21. 按位非（NOT）\"></a>21. 按位非（NOT）</h2><p>位运算符并不直接操作 64 位的值，而是先将 64 位的值转换为 32 位，然后执行操作，最后将结果转换回 64 位。按位非（否运算）就是<strong>一个数与自身的取反值相加，等于 -1</strong>。</p>\n<p>~3 + 3 = -1 =&gt; -1 - 3 = -4 == ~3</p>\n<h2 id=\"22-位运算符\"><a href=\"#22-位运算符\" class=\"headerlink\" title=\"22. 位运算符\"></a>22. 位运算符</h2><p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。</p>\n<p>##23. 逻辑与（&amp;&amp;）</p>\n<p>逻辑与（&amp;&amp;）有两个操作数，如果是布尔值，只有两个都是 true 时，才会返回 true，否则返回 false；逻辑与操作属于短路操作，也就是说如果第一个操作数能够决定结果（等于 false 时），就不会再对第二个操作数求值，如果不是布尔值，它遵循下面的规则：</p>\n<ul>\n<li>如果第一个操作数是对象，则返回第二个操作数</li>\n<li>如果第二个操作数是对象，则只有在第一个操作数的求值为 true 时才会返回第二个操作数</li>\n<li>如果有一个操作数是 null，则返回 null</li>\n<li>如果有一个操作数是 NaN，则返回 NaN</li>\n<li>如果有一个操作数是 undefined，则返回 undefined</li>\n</ul>\n<p>逻辑与操作符也就是先将第一个操作数转换为 Boolean 类型判断是 true 或 false，再根据结果决定是否执行第二个操作数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> &amp;&amp; <span class=\"string\">'tg'</span> ;  <span class=\"comment\">//  0</span></span><br><span class=\"line\">&#123;&#125; &amp;&amp; <span class=\"string\">'tg'</span>;  <span class=\"comment\">// \"tg\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"24-乘法运算符\"><a href=\"#24-乘法运算符\" class=\"headerlink\" title=\"24. 乘法运算符\"></a>24. 乘法运算符</h2><p>乘法运算符(<code>*</code>)，用于计算两个数值的乘积。 处理特殊值时，乘法运算符会遵循下列规则：</p>\n<ul>\n<li>如果操作数都是数值，但乘积超过了 ECMAScript 数值范围，则返回 Infinity 或 -Infinity</li>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果是 Infinity 乘以 0，结果是 NaN</li>\n<li>如果是 Infinity 与非 0 数值相乘，结果是 Infinity 或 -Infinity，取决于非0数值的符号</li>\n<li>如果是 Infinity 与 Infinity 相乘，结果是 Infinity</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> * <span class=\"literal\">NaN</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"literal\">Infinity</span> * <span class=\"number\">2</span>);  <span class=\"comment\">// Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> * <span class=\"number\">0</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> * <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"24-除法运算符\"><a href=\"#24-除法运算符\" class=\"headerlink\" title=\"24. 除法运算符\"></a>24. 除法运算符</h2><p>除法运算符（/），执行第二个操作数除第一个操作数计算。 处理特殊值，规则如下：</p>\n<ul>\n<li>如果操作数都是数值，但商超过了 ECMAScript 的表示范围，则返回 Infinity 或 -Infinity</li>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果是 Infinity 被 Infinity 除，结果是 NaN</li>\n<li>如果是零被零除，结果是 NaN</li>\n<li>如果是非零的有限数被零除，结果是 Infinity 或 -Infinity，取决于有符号的操作数</li>\n<li>如果是 Infinity 被任何非零数值除，结果是 Infinity 或 -Infinity</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> / <span class=\"number\">1</span>); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0</span> / <span class=\"number\">0</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> / <span class=\"number\">0</span>);  <span class=\"comment\">//  Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> / <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> / <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> / <span class=\"number\">2</span>);   <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"25-求模\"><a href=\"#25-求模\" class=\"headerlink\" title=\"25. 求模\"></a>25. 求模</h2><p>求模（余数）运算符（%） 处理特殊值，规则如下：</p>\n<ul>\n<li>如果被除数是无穷大值而除数是有限大的数值，结果是 NaN</li>\n<li>如果被除数是有限大的数值而除数是零，结果是 NaN</li>\n<li>如果是 Infinity 被 Infinity 除，结果是 NaN</li>\n<li>如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数</li>\n<li>如果被除数是零，结果是零</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">5</span> % <span class=\"number\">3</span>);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"26-减法\"><a href=\"#26-减法\" class=\"headerlink\" title=\"26. 减法\"></a>26. 减法</h2><p>减法运算符（-） 对于特殊值，减法操作会遵循下列规则：</p>\n<ul>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果 Infinity 减 Infinity，结果是 NaN</li>\n<li>如果是 -Infinity 减 -Infinity，结果是 NaN</li>\n<li>如果是 Infinity 减 -Infinity，结果是 Infinity</li>\n<li>如果是 -Infinity 减 Infinity，结果是 -Infinity</li>\n<li>如果是 +0 减 +0，结果是 +0</li>\n<li>如果是 -0 加 -0，结果是 +0</li>\n<li>如果是 +0 减 -0，结果是 -0</li>\n<li>如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 将其转换为数值，然后遵循上面的规则进行计算。</li>\n<li>如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值；如果该对象没有 valueOf() 方法，则调用其 toString() 方法将得到的字符串转换为数值，然后遵循上面的规则进行计算。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> - <span class=\"literal\">true</span>;  <span class=\"comment\">// 4 （true转换成1）</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"string\">'2'</span>    <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"literal\">null</span>;  <span class=\"comment\">// 5（null转换成0）</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"27-逗号运算符\"><a href=\"#27-逗号运算符\" class=\"headerlink\" title=\"27. 逗号运算符\"></a>27. 逗号运算符</h2><p>逗号运算符多用于声明多个变量。逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = (<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>);  <span class=\"comment\">// num的值为3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"28-标签语句\"><a href=\"#28-标签语句\" class=\"headerlink\" title=\"28. 标签语句\"></a>28. 标签语句</h2><p>语句是可以添加标签的，标签是由语句前的标识符和冒号组成：</p>\n<blockquote>\n<p><strong>label</strong> : statement</p>\n</blockquote>\n<p>label 语句定义的标签一般由 break 或 continue 语句引用。加标签的语句一般要与 for 等循环语句配合使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">tip : <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">  num += i;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);  <span class=\"comment\">//  轮流输出：0、1、2、3、4、5</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i ==<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span> tip;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num);  <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>当执行到 i = 5 时，会跳出循环，也就是 tip 对应的层，然后执行其下方的代码。</p>\n<h2 id=\"29-with-语句\"><a href=\"#29-with-语句\" class=\"headerlink\" title=\"29. with 语句\"></a>29. with 语句</h2><p><code>with</code> 语句用于临时扩展作用域链，也就是将代码的作用域设置到一个特定的对象中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span>(object)&#123;   </span><br><span class=\"line\">  statement  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将 object 添加到作用域链的头部，然后执行 statement，最后把作用域链恢复到原生状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'tg'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">24</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span>(o)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'name：'</span> + name);  <span class=\"comment\">// name：tg</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'age：'</span> + age);  <span class=\"comment\">// age：24</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>with 里面的 name 相当于 o.name。</p>\n<blockquote>\n<p>注意：在严格模式中是禁止使用 with 语句的，因为 with 语句性能非常差，不推荐使用。</p>\n</blockquote>\n<h2 id=\"30-debugger-语句\"><a href=\"#30-debugger-语句\" class=\"headerlink\" title=\"30. debugger 语句\"></a>30. debugger 语句</h2><p>debugger 语句用来产生一个断点（breakpoint），JavaScript 代码的执行会停止在断点的位置。一般用来调试代码。</p>\n<h2 id=\"31-对象\"><a href=\"#31-对象\" class=\"headerlink\" title=\"31. 对象\"></a>31. 对象</h2><p><strong>键名</strong>：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  <span class=\"string\">'1a'</span> : <span class=\"string\">'a'</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，如果键名 ‘1a’ 不用引号引起来，就会报错。注意：为了避免这种歧义，JavaScript 规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。</p>\n<h2 id=\"32-创建对象\"><a href=\"#32-创建对象\" class=\"headerlink\" title=\"32. 创建对象\"></a>32. 创建对象</h2><p>在 JavaScript 中，有三种方法创建对象</p>\n<ul>\n<li>对象直接量： var o={};</li>\n<li>关键字new： var o=new Object();</li>\n<li>Object.create() 函数： var o=Object.create(null)</li>\n</ul>\n<h3 id=\"提取方法\"><a href=\"#提取方法\" class=\"headerlink\" title=\"提取方法\"></a>提取方法</h3><p>如果对对象中的方法进行提取，则会失去与对象的连接。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.get());  <span class=\"comment\">//  \"a\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = obj.get;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func());  <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，object 对象中有一个方法 get()，用来获取 obj 对象中的 name，而当 get() 方法赋值给一个变量 func，再调用 func() 函数时，此时的 this 是指向 window 的，而非 obj 的。注意：如果在严格模式下，this 会是 undefined。</p>\n<h3 id=\"属性特性\"><a href=\"#属性特性\" class=\"headerlink\" title=\"属性特性\"></a>属性特性</h3><ul>\n<li>可写（writable attribute）：可设置该属性的值。</li>\n<li>可枚举（enumerable attribute）：可通过 for / in 循环返回该属性。</li>\n<li>可配置（configurable attribute）：可删除或修改属性。</li>\n</ul>\n<h3 id=\"查看所有属性\"><a href=\"#查看所有属性\" class=\"headerlink\" title=\"查看所有属性\"></a>查看所有属性</h3><p>查看一个对象本身的所有属性，可以使用 Object.keys 方法，返回一个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  age : <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(o)  <span class=\"comment\">// ['name','age']</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h3><p>delete 运算符可以删除对象的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.name  <span class=\"comment\">//true</span></span><br><span class=\"line\">o.name  <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：delete 运算符只能删除自有属性，不能删除继承属性。 删除一个不存在的属性，delete 不报错，而且返回 true。只有一种情况，delete 命令会返回 false，那就是该属性存在，且不得删除。</p>\n</blockquote>\n<h2 id=\"33-序列化对象\"><a href=\"#33-序列化对象\" class=\"headerlink\" title=\"33. 序列化对象\"></a>33. 序列化对象</h2><p>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 在 JavaScript 中，提供了内置函数 <strong>JSON.stringify()</strong> 和 <strong>JSON.parse()</strong> 用来序列化和还原 JavaScript 对象。NaN、Infinity 和 -Infinity 序列化的结果是 null</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  age : <span class=\"number\">12</span>,</span><br><span class=\"line\">  intro : \\[<span class=\"literal\">false</span>,<span class=\"literal\">null</span>,<span class=\"string\">''</span>\\]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s= <span class=\"built_in\">JSON</span>.stringify(o)  <span class=\"comment\">// s &#123;\"name\":\"a\",\"age\":12,\"intro\":[false,null,\"\"]&#125;</span></span><br><span class=\"line\">p=<span class=\"built_in\">JSON</span>.parse(s)  <span class=\"comment\">// p是o的深拷贝</span></span><br></pre></td></tr></table></figure>\n<p>注意：JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。</p>\n<h2 id=\"34-原型\"><a href=\"#34-原型\" class=\"headerlink\" title=\"34. 原型\"></a>34. 原型</h2><p>每一个 JavaScript 对象（null 除外）都和另一个对象相关联，也可以说，继承另一个对象。另一个对象就是我们熟知的“原型”（prototype），每一个对象都从原型继承属性。只有 null 除外，它没有自己的原型对象。所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。比如：通过 new Object() 创建的对象继承自 Object.prototype；通过 new Array() 创建的对象的原型就是 Array.prototype。没有原型的对象为数不多，Object.prototype 就是其中之一，它不继承任何属性。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。</p>\n<h2 id=\"35-空位\"><a href=\"#35-空位\" class=\"headerlink\" title=\"35. 空位\"></a>35. 空位</h2><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在<strong>空位</strong>（hole）。如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [,,];</span><br><span class=\"line\">arr.length  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"36-类数组对象\"><a href=\"#36-类数组对象\" class=\"headerlink\" title=\"36. 类数组对象\"></a>36. 类数组对象</h2><p>在 JavaScript 中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用 length 属性，但是它们并不是数组，无法使用一些数组的方法。<code>类数组对象</code>有一个特征，就是具有 length 属性。换句话说，只要有 length 属性，就可以认为这个对象类似于数组。但是，对象的 length 属性不是动态值，不会随着成员的变化而变化。典型的类似数组的对象是函数的 <strong>arguments 对象</strong>，以及<strong>大多数 DOM 元素集</strong>，还有<strong>字符串</strong>。</p>\n<h2 id=\"37-函数表达式\"><a href=\"#37-函数表达式\" class=\"headerlink\" title=\"37. 函数表达式\"></a>37. 函数表达式</h2><p>采用函数表达式声明函数时，function 命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"38-函数被提前\"><a href=\"#38-函数被提前\" class=\"headerlink\" title=\"38. 函数被提前\"></a>38. 函数被提前</h2><p>就像变量的“被提前”一样，函数声明语句也会“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。在函数提升中，函数体也会跟着提升（不像变量一样，只会提升变量声明），这也是我们可以引用后面声明的函数的原因。 此外，<strong>以表达式定义的函数并没有“被提前”，而是以变量的形式“被提前”</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f();  </span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>\n<p>变量其实是分为声明，赋值两部分的，上面的代码等同于下面的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f;</span><br><span class=\"line\">f();</span><br><span class=\"line\">f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"39-实参对象\"><a href=\"#39-实参对象\" class=\"headerlink\" title=\"39. 实参对象\"></a>39. 实参对象</h2><p><code>arguments</code> 类数组中每一个元素的值会与对应的命名参数的值保持同步，这种影响是单向的，也可以这样说，<strong>如果是修改 <code>arguments</code> 中的值，会影响到命名参数的值，但是修改命名参数的值，并不会改变 <code>arguments</code> 中对应的值</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);    <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] = <span class=\"literal\">null</span>;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);    <span class=\"comment\">// null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p><code>arguments</code> 并不是真正的数组，它只是类数组对象（有 length 属性且可使用索引来访问子项）。但我们可以借助 Array 类的原型对象的 slice 方法，将其转为真正的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 更简洁的写法</span></span><br><span class=\"line\">[].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"40-函数的属性、方法\"><a href=\"#40-函数的属性、方法\" class=\"headerlink\" title=\"40. 函数的属性、方法\"></a>40. 函数的属性、方法</h2><h3 id=\"name-属性\"><a href=\"#name-属性\" class=\"headerlink\" title=\"name 属性\"></a>name 属性</h3><p>name 属性返回紧跟在 function 关键字之后的那个函数名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">f.name   <span class=\"comment\">// f</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"length-属性\"><a href=\"#length-属性\" class=\"headerlink\" title=\"length 属性\"></a>length 属性</h3><p>函数的 length 属性是只读属性，代表函数形参的数量，也就是在函数定义时给出的形参个数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x,y</span>)</span>&#123;&#125;</span><br><span class=\"line\">f.length  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"41-立即调用的函数表达式（IIFE）\"><a href=\"#41-立即调用的函数表达式（IIFE）\" class=\"headerlink\" title=\"41. 立即调用的函数表达式（IIFE）\"></a>41. 立即调用的函数表达式（IIFE）</h2><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：</p>\n<ul>\n<li>一是不必为函数命名，避免了污染全局变量；</li>\n<li>二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li>\n</ul>\n<h2 id=\"42-Object-对象的静态方法\"><a href=\"#42-Object-对象的静态方法\" class=\"headerlink\" title=\"42. Object 对象的静态方法\"></a>42. Object 对象的静态方法</h2><p><code>Object.keys()</code> 方法和 <code>Object.getOwnPropertyNames()</code> 方法一般用来遍历对象的属性，它们的参数都是一个对象，返回一个数组，该数组的项都是对象自身的（不是继续原型的）的所有属性名。两者的区别在于， <code>Object.keys()</code> 只返回可枚举的属性，<code>Object.getOwnPropertyNames()</code> 方法还返回不可枚举的属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(arr));  <span class=\"comment\">// [\"0\", \"1\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(arr)); <span class=\"comment\">// [\"0\", \"1\", \"length\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"43-splice\"><a href=\"#43-splice\" class=\"headerlink\" title=\"43. splice()\"></a>43. splice()</h2><p><code>splice()</code> 用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素，该方法会改变原数组。第一个参数是删除的起始位置，如果是负数，就表示从倒数位置开始删除 第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如只是单纯地插入元素，splice 方法的第二个参数可以设为 0。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>));  <span class=\"comment\">// [\"b\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"c\", \"d\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'f'</span>));   <span class=\"comment\">// [\"b\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"f\", \"c\", \"d\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"string\">'h'</span>));  <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"h\", \"b\", \"c\", \"d\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"44-some-、every\"><a href=\"#44-some-、every\" class=\"headerlink\" title=\"44. some()、every()\"></a>44. some()、every()</h2><p><code>some()</code> 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是 true，则整个 some 方法的返回值就是 true，否则 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v == <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>every()</code> 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是 true，才返回 true，否则 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v == <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool);  <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bool2 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool2);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>some 和 every 方法还可以接受第二个参数，用来绑定函数中的 this 关键字。</p>\n<h2 id=\"45-基本包装类型\"><a href=\"#45-基本包装类型\" class=\"headerlink\" title=\"45. 基本包装类型\"></a>45. 基本包装类型</h2><p>ECMAScript 提供了三个基本包装类型：<code>Boolean</code>、<code>Number</code>、<code>String</code>。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能过调用一些方法来操作这些数据。执行步骤如下：</p>\n<ol>\n<li>创建那个类型的一个实例</li>\n<li>在实例上调用指定的方法</li>\n<li>销毁这个实例</li>\n</ol>\n<p>引用类型与基本包装类型的区别在于对象的生存期：使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁，这也是我们不能再运行时为基本类型值添加属性和方法的原因。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'tg'</span>;</span><br><span class=\"line\">s.age =<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.age);  <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码执行输出的是 undefined，这是音乐第二行创建的 String 对象在执行第三行代码时已经被销毁了，第三行又创建自己的 String 对象，而该对象没有 age 属性。</p>\n<h2 id=\"46-Boolean-类型\"><a href=\"#46-Boolean-类型\" class=\"headerlink\" title=\"46. Boolean 类型\"></a>46. Boolean 类型</h2><p>即使你使用 false 创建一个 Boolean 实例对象，当进行逻辑运算时，它会被转为 true，因为它是一个对象，而所有对象在逻辑运算中都会返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(bool)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"47-document-referrer\"><a href=\"#47-document-referrer\" class=\"headerlink\" title=\"47. document.referrer\"></a>47. document.referrer</h2><p>document.referrer 属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。 注：HTTPS 默认会关闭 referrer，需要通过 meta 来设置，设置方法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"referrer\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"always\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"48-数据集（dataset）属性\"><a href=\"#48-数据集（dataset）属性\" class=\"headerlink\" title=\"48. 数据集（dataset）属性\"></a>48. 数据集（dataset）属性</h2><p>在 HTML5 文档中，任意以 “data-” 为前缀的小写的属性名字都是合法的。 HTML5 还在 Element 对象上定义了 dataset 属性。该属性指代一个对象，它的各个属性对应于去掉前缀的 data-属性。因此 dataset.x 应该保存 data-x 属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test 属性就变成 dataset.jqueryTest 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"top\"</span> <span class=\"attr\">data-tip</span>=<span class=\"string\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'top'</span>);</span><br><span class=\"line\">t.dataset.tip  <span class=\"comment\">//title</span></span><br><span class=\"line\">t.dataset.tip = <span class=\"string\">'title2'</span></span><br></pre></td></tr></table></figure>\n<p>注意：dataset 属性是元素的 data-属性 的实时、双向接口。设置或删除 dataset 的一个属性就等同于设置或移除对应元素的 data-属性。</p>\n<h2 id=\"49-addEventListener\"><a href=\"#49-addEventListener\" class=\"headerlink\" title=\"49. addEventListener()\"></a>49. addEventListener()</h2><p>调用 addEventListener() 并不会影响 onclick 属性的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mybutton\"</span>&gt;</span>点击<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mybutton'</span>);</span><br><span class=\"line\">v.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;alert(<span class=\"string\">'1'</span>);&#125;</span><br><span class=\"line\">v.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'2'</span>);&#125;,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，单击按钮会产生两个 alert() 对话框。 能通过多次调用 addEventListener() 方法为同一个对象注册同一事件类型的多个处理程序函数。</p>\n<h2 id=\"50-调用顺序\"><a href=\"#50-调用顺序\" class=\"headerlink\" title=\"50. 调用顺序\"></a>50. 调用顺序</h2><p>文档元素或其他对象可以指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照下面的规则调用所有的事件处理程序：</p>\n<ul>\n<li>通过设置对象属性或 HTML 属性注册的处理程序一直优先调用。</li>\n<li>使用 addEventListener() 注册的处理程序按照它们的注册顺序调用。</li>\n<li>使用 attachEvent() 注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。</li>\n</ul>\n<h2 id=\"51-进度事件\"><a href=\"#51-进度事件\" class=\"headerlink\" title=\"51. 进度事件\"></a>51. 进度事件</h2><p>进度事件用来描述一个事件进展的过程。比如 XMLHttpRequest 对象发出的 HTTP 请求的过程，<code>&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;</code> 加载外部资源的过程。下载和上传都会发生进度事件。进度事件有以下几种：</p>\n<ul>\n<li>abort 事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。</li>\n<li>error 事件：由于错误导致资源无法加载时触发。</li>\n<li>load 事件：进度成功结束时触发。</li>\n<li>loadstart 事件：进度开始时触发。</li>\n<li>loaden d事件：进度停止时触发，发生顺序排在 error 事件 / abort 事件 / load 事件后面。</li>\n<li>progress 事件：当操作处于进度之中，由传输的数据块不断触发。</li>\n<li>timeout 事件：进度超过限时触发。</li>\n</ul>\n<h2 id=\"52-JSON-语法\"><a href=\"#52-JSON-语法\" class=\"headerlink\" title=\"52. JSON 语法\"></a>52. JSON 语法</h2><p>JSON 对值的类型和格式有严格的规定：</p>\n<ul>\n<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li>\n<li>简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和 null（不能使用 NaN, Infinity, -Infinity 和 undefined）。</li>\n<li>字符串必须使用双引号表示，不能使用单引号。</li>\n<li>对象的键名必须放在双引号里面。</li>\n<li>数组或对象最后一个成员的后面，不能加逗号。</li>\n</ul>\n<h2 id=\"53-上传文件\"><a href=\"#53-上传文件\" class=\"headerlink\" title=\"53. 上传文件\"></a>53. 上传文件</h2><p>如果要允许选择多个文件，可设置 file 控件的 multiple 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">multiple</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"54-同源策略\"><a href=\"#54-同源策略\" class=\"headerlink\" title=\"54. 同源策略\"></a>54. 同源策略</h2><p>同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 <code>&lt;iframe&gt;</code> 元素或打开其他浏览器窗口的时候，这一策略通常就会发挥作用。所谓“同源”指的是”三个相同“。</p>\n<ul>\n<li><strong>协议</strong>相同</li>\n<li><strong>域名</strong>相同</li>\n<li><strong>端口</strong>相同</li>\n</ul>\n<p>从不同 Web 服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用 http:协议 载入的文档和使用 https:协议 载入的文档具有不同的来源，即使它们来自同一个服务器。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<h2 id=\"55-获取表单元素\"><a href=\"#55-获取表单元素\" class=\"headerlink\" title=\"55. 获取表单元素\"></a>55. 获取表单元素</h2><p>获取表单元素一般有两种方式：</p>\n<ul>\n<li>通过 id 来获取，比如获取一个 id 名为 form1 的表单元素：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'form1'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 docuemnt.forms 获取 name 名为 form1 的表单元素：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.forms[<span class=\"string\">\"form1\"</span>]</span><br></pre></td></tr></table></figure>\n<p><code>document.forms</code> 可以获取到当前页面中所有的表单元素，我们又可以通过方括号表示法获取某个属性，传入数值索引或 <code>name</code> 值。</p>\n<h2 id=\"56-重置表单\"><a href=\"#56-重置表单\" class=\"headerlink\" title=\"56. 重置表单\"></a>56. 重置表单</h2><p>重置表单也有两种方式：</p>\n<h3 id=\"重置按钮\"><a href=\"#重置按钮\" class=\"headerlink\" title=\"重置按钮\"></a>重置按钮</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"reset\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"reset\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当点击重置按钮时，会触发 reset 事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form1.onreset = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过-reset-方法\"><a href=\"#通过-reset-方法\" class=\"headerlink\" title=\"通过 reset() 方法\"></a>通过 reset() 方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form1.reset();</span><br></pre></td></tr></table></figure>\n<p>与调用 submit() 不同，调用 reset() 方法时也会触发 reset 事件。</p>\n<h2 id=\"57-离线检测\"><a href=\"#57-离线检测\" class=\"headerlink\" title=\"57. 离线检测\"></a>57. 离线检测</h2><p>HTML5 定义了一个 <code>navigator.onLine</code> 属性，用来检测设备是在线还是离线，为 true 时表示设备能上网，否则表示设备离线。 检测代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.onLine)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正常工作</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设备已离线</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了 <code>navigator.onLine</code> 属性，HTML5 还为检测网络是否可用提供了两个事件：<code>online</code> 和 <code>offline</code>。</p>\n<ul>\n<li><code>online</code>：当网络从离线变为在线时触发</li>\n<li><code>offline</code>：当网络从在线变为离线时触发</li>\n</ul>\n<h2 id=\"58-应用缓存\"><a href=\"#58-应用缓存\" class=\"headerlink\" title=\"58. 应用缓存\"></a>58. 应用缓存</h2><p>HTML5 的应用缓存（application cache），简称：appcache，是专门为开发离线 Web 应用而设计的。 Appcache 就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。<code>manifest</code> 文件可分为三个部分：</p>\n<ul>\n<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>\n<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>\n<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"># 需要缓存的列表</span><br><span class=\"line\">test.css</span><br><span class=\"line\">test.jpg</span><br><span class=\"line\">test.js</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\"># 不需要缓存的</span><br><span class=\"line\">test2.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\"># 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件 *.html /offline.html</span><br><span class=\"line\">2.jpg/3.jpg</span><br></pre></td></tr></table></figure>\n<p>注意：manifest 文件的 <code>MIME</code> 类型必须是 “text/cache-manifest”。</p>\n<blockquote>\n<p>描述文件的扩展名以前推荐用 manifest，现在推荐用 appcache</p>\n</blockquote>\n<h2 id=\"59-localStorage-和-sessionStorage\"><a href=\"#59-localStorage-和-sessionStorage\" class=\"headerlink\" title=\"59. localStorage 和 sessionStorage\"></a>59. localStorage 和 sessionStorage</h2><p><code>localStorage</code> 和 <code>sessionStorage</code>这两个属性都代表同一个 Storage 对象（一个持久化关联数组，数组使用字符串来索引，存储的值都是字符串形式的）。</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>通过 <code>localStorage</code> 存储的数据是永久性的，除非Web应用刻意删除存储的数据或用户通过设置浏览器设置来删除，否则数据将一直保留在用户的电脑里，永不过期。<code>localStorage</code> 的作用域是限定在文档源（document origin）级别。 同源的文档间共享同样的 <code>localStorage</code> 数据。</p>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p><code>sessionStorage</code> 的作用域同样是限定在文档源中，不过它被限定在窗口中。也就是说，如果同源的文档在不同的浏览器标签页中，那它们互相之间拥有的是各自的 <code>sessionStorage</code> 数据，无法共享。</p>\n<p>注意：基于窗口作用域的 <code>sessionStorage</code> 指的窗口只是顶级窗口。如果一个浏览器标签页包含多个 <code>&lt;iframe&gt;</code> 元素，它们包含的文档是同源的，两者之间的 sessionStorage 是可共享的。</p>\n<h2 id=\"60-finally-子句\"><a href=\"#60-finally-子句\" class=\"headerlink\" title=\"60. finally 子句\"></a>60. finally 子句</h2><p>当使用 <code>finally</code> 子句时，其代码无论如何都会执行，也就是说，不管是正常执行还是出错了，<code>finally</code> 子句都会执行。甚至 <code>return</code> 语句，也不会阻止 <code>finally</code> 子句的执行。看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(error)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test()); </span><br><span class=\"line\"><span class=\"comment\">//结果</span></span><br><span class=\"line\">a</span><br><span class=\"line\">c</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>从运行结果，我们可以看到，<code>return</code> 语句并没有阻止 <code>finally</code> 子句的执行，而且是在 <code>finally</code> 子句执行后才会返回 <code>return</code> 语句的值。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（6）——大话数据结构","slug":"读书笔记系列（6）——大话数据结构","date":"2017-04-08T12:50:00.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（6）——大话数据结构.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_147.png","content":"<p>这本书我是在网上下载的电子版，所以可能会有一些错别字，但是无伤大雅；《大话数据结构》被誉为程序员面试必读书籍，我大概用了 3 天的时间详读了一遍，感觉作者的文笔很好，而且很擅长通过生活中的小故事总结相关知识和算法思路，对于计算机初级童鞋来说是一本很好的数据结构入门读物，而且作者对于代码的讲解很详尽，接近逐行解释了，和其他数据结构的书籍形成了鲜明的对比，总体评价五星吧；不过我是在刷完 Leetcode 的 easy 题才看的这本书，感觉先看这本书再刷题的话会好很多</p>\n<h2 id=\"一、数据结构与算法\"><a href=\"#一、数据结构与算法\" class=\"headerlink\" title=\"一、数据结构与算法\"></a>一、数据结构与算法</h2><h3 id=\"1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\"><a href=\"#1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\" class=\"headerlink\" title=\"1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\"></a>1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子</h3><h3 id=\"2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\"><a href=\"#2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\" class=\"headerlink\" title=\"2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\"></a>2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科</h3><h3 id=\"3、数据元素的存储结构形式有两种：顺序存储和链式存储\"><a href=\"#3、数据元素的存储结构形式有两种：顺序存储和链式存储\" class=\"headerlink\" title=\"3、数据元素的存储结构形式有两种：顺序存储和链式存储\"></a>3、数据元素的存储结构形式有两种：顺序存储和链式存储</h3><ul>\n<li>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（谁也别插谁的队）</li>\n<li>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的（需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置）</li>\n</ul>\n<h3 id=\"4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\"><a href=\"#4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\" class=\"headerlink\" title=\"4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\"></a>4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性</h3><h3 id=\"5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\"><a href=\"#5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\" class=\"headerlink\" title=\"5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\"></a>5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征</h3><h3 id=\"6、推导时间复杂度大-O-阶方法：\"><a href=\"#6、推导时间复杂度大-O-阶方法：\" class=\"headerlink\" title=\"6、推导时间复杂度大 O 阶方法：\"></a>6、推导时间复杂度大 O 阶方法：</h3><ol>\n<li>用常数 1 取代运行时间中的所有加法常数</li>\n<li>在修改后的运行次数函数中，只保留最高阶项</li>\n<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>\n</ol>\n<h3 id=\"7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\"><a href=\"#7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\" class=\"headerlink\" title=\"7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\"></a>7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</h3><h3 id=\"8、常见的时间复杂度所耗费的时间：\"><a href=\"#8、常见的时间复杂度所耗费的时间：\" class=\"headerlink\" title=\"8、常见的时间复杂度所耗费的时间：\"></a>8、常见的时间复杂度所耗费的时间：</h3><div align=\"center\"><img src=\"/images/hexo_post_147.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\"><a href=\"#9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\" class=\"headerlink\" title=\"9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\"></a>9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。</h3><p>在应用中，这是一种最重要的需求，通常，除非特别制定，我们提到的运行时间都是最坏情况的运行时间 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间</p>\n<h3 id=\"10、算法的空间复杂度\"><a href=\"#10、算法的空间复杂度\" class=\"headerlink\" title=\"10、算法的空间复杂度\"></a>10、算法的空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数</p>\n<h2 id=\"二、线性表\"><a href=\"#二、线性表\" class=\"headerlink\" title=\"二、线性表\"></a>二、线性表</h2><h3 id=\"1、描述顺序存储结构需要三个属性：\"><a href=\"#1、描述顺序存储结构需要三个属性：\" class=\"headerlink\" title=\"1、描述顺序存储结构需要三个属性：\"></a>1、描述顺序存储结构需要三个属性：</h3><ul>\n<li>存储空间的起始位置：数组 data，它的存储位置就是存储空间的存储位置</li>\n<li>线性表的最大存储容量：数组长度 MaxSize</li>\n<li>线性表的当前长度：length</li>\n</ul>\n<h3 id=\"2、插入算法的思路：\"><a href=\"#2、插入算法的思路：\" class=\"headerlink\" title=\"2、插入算法的思路：\"></a>2、插入算法的思路：</h3><ol>\n<li>如果插入位置不合理，抛出异常</li>\n<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li>\n<li>从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置</li>\n<li>将要插入元素填入位置 i 处</li>\n<li>表长加 1</li>\n</ol>\n<h3 id=\"3、删除算法的思路：\"><a href=\"#3、删除算法的思路：\" class=\"headerlink\" title=\"3、删除算法的思路：\"></a>3、删除算法的思路：</h3><ol>\n<li>如果删除位置不合理，抛出异常</li>\n<li>取出删除元素</li>\n<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置</li>\n<li>表长减 1</li>\n</ol>\n<h3 id=\"4、线性表的顺序存储结构的优缺点：\"><a href=\"#4、线性表的顺序存储结构的优缺点：\" class=\"headerlink\" title=\"4、线性表的顺序存储结构的优缺点：\"></a>4、线性表的顺序存储结构的优缺点：</h3><p><strong>优点：</strong></p>\n<ul>\n<li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li>\n<li>可以快速地存取表中任一位置的元素</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>插入和删除操作需要移动大量元素</li>\n<li>当线性表长度变化较大时，难以确定存储空间的容量</li>\n<li>造成存储空间的“碎片”</li>\n</ul>\n<h3 id=\"5、单链表\"><a href=\"#5、单链表\" class=\"headerlink\" title=\"5、单链表\"></a>5、单链表</h3><p>n 个结点（ai 的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起</p>\n<div align=\"center\"><img src=\"/images/hexo_post_148.png\" alt=\"\" width=\"400\"></div>\n\n<p>有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_149.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"6、头指针与头结点的异同\"><a href=\"#6、头指针与头结点的异同\" class=\"headerlink\" title=\"6、头指针与头结点的异同\"></a>6、头指针与头结点的异同</h3><h4 id=\"头指针\"><a href=\"#头指针\" class=\"headerlink\" title=\"头指针\"></a>头指针</h4><ul>\n<li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li>\n<li>头指针具有标识作用，所以常用头指针冠以链表的名字</li>\n<li>无论链表是否为空，头指针均不为空。头指针式链表的必要元素</li>\n</ul>\n<h4 id=\"头结点\"><a href=\"#头结点\" class=\"headerlink\" title=\"头结点\"></a>头结点</h4><ul>\n<li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</li>\n<li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li>\n<li>头结点不一定是链表必须要素</li>\n</ul>\n<h3 id=\"7、获取链表第-i-个数据的算法思路\"><a href=\"#7、获取链表第-i-个数据的算法思路\" class=\"headerlink\" title=\"7、获取链表第 i 个数据的算法思路\"></a>7、获取链表第 i 个数据的算法思路</h3><ol>\n<li>声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，返回结点 p 的数据</li>\n</ol>\n<h3 id=\"8、单链表第-i-个数据插入结点的算法思路\"><a href=\"#8、单链表第-i-个数据插入结点的算法思路\" class=\"headerlink\" title=\"8、单链表第 i 个数据插入结点的算法思路\"></a>8、单链表第 i 个数据插入结点的算法思路</h3><ol>\n<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，在系统中生成一个空结点 s</li>\n<li>将数据元素 e 赋值给 s -&gt; data</li>\n<li>单链表的插入标准语句 s-&gt;next=p-&gt;next;p-&gt;next=s</li>\n<li>返回成功</li>\n</ol>\n<h3 id=\"9、单链表第-i-个数据删除结点的算法思路\"><a href=\"#9、单链表第-i-个数据删除结点的算法思路\" class=\"headerlink\" title=\"9、单链表第 i 个数据删除结点的算法思路\"></a>9、单链表第 i 个数据删除结点的算法思路</h3><ol>\n<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，\b将欲删除的结点 p -&gt; next 赋值给 q</li>\n<li>单链表的删除标准语句 p-&gt;next=q-&gt;next</li>\n<li>将 q 结点中的数据赋值给 e，作为返回</li>\n<li>释放 q 结点</li>\n<li>返回成功</li>\n</ol>\n<h3 id=\"10、单链表整表创建的算法思路\"><a href=\"#10、单链表整表创建的算法思路\" class=\"headerlink\" title=\"10、单链表整表创建的算法思路\"></a>10、单链表整表创建的算法思路</h3><ol>\n<li>声明一结点 p 和计数器变量 i</li>\n<li>初始化一空链表 L</li>\n<li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表</li>\n<li>循环：</li>\n</ol>\n<ul>\n<li>生成一新结点赋值给 p</li>\n<li>随机生成一数字赋值给 p 的数据域 p-&gt;data</li>\n<li>将 p 插入到头结点与前一新节点之间</li>\n</ul>\n<h3 id=\"11、单链表的整表删除\"><a href=\"#11、单链表的整表删除\" class=\"headerlink\" title=\"11、单链表的整表删除\"></a>11、单链表的整表删除</h3><ol>\n<li>声明一结点 p 和 q</li>\n<li>将第一个结点赋值给 p</li>\n<li>循环：</li>\n</ol>\n<ul>\n<li>将下一结点赋值给 q</li>\n<li>释放 p</li>\n<li>将 q 赋值给 p</li>\n</ul>\n<h3 id=\"12、单链表结构和顺序存储结构做对比\"><a href=\"#12、单链表结构和顺序存储结构做对比\" class=\"headerlink\" title=\"12、单链表结构和顺序存储结构做对比\"></a>12、单链表结构和顺序存储结构做对比</h3><div align=\"center\"><img src=\"/images/hexo_post_150.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"13、所谓的成功男人就是-3-岁时不尿裤子，5-岁能自己吃饭……80-岁能自己吃饭，90-岁能不尿裤子\"><a href=\"#13、所谓的成功男人就是-3-岁时不尿裤子，5-岁能自己吃饭……80-岁能自己吃饭，90-岁能不尿裤子\" class=\"headerlink\" title=\"13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子\"></a>13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子</h3><h3 id=\"14、循环链表\"><a href=\"#14、循环链表\" class=\"headerlink\" title=\"14、循环链表\"></a>14、循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）:</p>\n<div align=\"center\"><img src=\"/images/hexo_post_151.png\" alt=\"\" width=\"500\"></div>\n\n<p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断 p-&gt;next 是否为空，现在则是 <strong>p-&gt;next 不等于头结点，则循环未结束</strong></p>\n<h3 id=\"15、合并两个循环链表\"><a href=\"#15、合并两个循环链表\" class=\"headerlink\" title=\"15、合并两个循环链表\"></a>15、合并两个循环链表</h3><div align=\"center\"><img src=\"/images/hexo_post_152.png\" alt=\"\" width=\"500\"></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p=rearA-&gt;next;                   /* 保存A表的头结点，即① */</span><br><span class=\"line\">rearA-&gt;next=rearB-&gt;next-&gt;next;   /* 将本是指向B表的第一个结点（不是头结点） */</span><br><span class=\"line\">                                 /* 赋值给rearA-&gt;next，即 ②*/</span><br><span class=\"line\">rearB-&gt;next=p;                   /* 将原A表的头结点赋值给rearB-&gt;next，即③ */</span><br><span class=\"line\">free(p);                         /* 释放p */</span><br></pre></td></tr></table></figure>\n<h3 id=\"16、双向链表\"><a href=\"#16、双向链表\" class=\"headerlink\" title=\"16、双向链表\"></a>16、双向链表</h3><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域</p>\n<h3 id=\"17、双向链表的插入\"><a href=\"#17、双向链表的插入\" class=\"headerlink\" title=\"17、双向链表的插入\"></a>17、双向链表的插入</h3><p>假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间需要下面几步：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_153.png\" alt=\"\" width=\"400\"></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-&gt;prior=p;           /* 把 p 赋值给 s 的前驱，如图中① */</span><br><span class=\"line\">s-&gt;next=p-&gt;next;      /* 把 p-&gt;next 赋值给 s 的后继，如图中② */</span><br><span class=\"line\">p-&gt;next-&gt;prior=s;     /* 把 s 赋值给 p-&gt;next 的前驱，如图中③ */</span><br><span class=\"line\">p-&gt;next=s;            /* 把 s 赋值给 p 的后继，如图中④ */</span><br></pre></td></tr></table></figure>\n<h3 id=\"18、线性表的总结\"><a href=\"#18、线性表的总结\" class=\"headerlink\" title=\"18、线性表的总结\"></a>18、线性表的总结</h3><div align=\"center\"><img src=\"/images/hexo_post_154.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"三、栈与队列\"><a href=\"#三、栈与队列\" class=\"headerlink\" title=\"三、栈与队列\"></a>三、栈与队列</h2><h3 id=\"1、栈的定义\"><a href=\"#1、栈的定义\" class=\"headerlink\" title=\"1、栈的定义\"></a>1、栈的定义</h3><p>栈（stack）是限定<strong>仅在表尾进行插入和删除操作</strong>的线性表，我们把允许插入和删除的一端称为<strong>栈顶</strong>（top），另一端称为<strong>栈底</strong>（bottom），不含任何数据元素的栈称为<strong>空栈</strong></p>\n<h3 id=\"2、当栈存在一个元素时，top-等于-0，因此通常把空栈的判定条件定位-top-等于-1（索引值从-0-开始）\"><a href=\"#2、当栈存在一个元素时，top-等于-0，因此通常把空栈的判定条件定位-top-等于-1（索引值从-0-开始）\" class=\"headerlink\" title=\"2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）\"></a>2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）</h3><h3 id=\"3、用一个数组来存储两个栈\"><a href=\"#3、用一个数组来存储两个栈\" class=\"headerlink\" title=\"3、用一个数组来存储两个栈\"></a>3、用一个数组来存储两个栈</h3><div align=\"center\"><img src=\"/images/hexo_post_155.png\" alt=\"\" width=\"700\"></div>\n\n<p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 n - 1 处。这样，如果两个栈增加元素，就是两端点向中间延伸</p>\n<p><strong>两个栈见面之时，也就是两个指针之间相差 1 时，即 top1 + 1 == top2为栈满</strong></p>\n<h3 id=\"4、递归定义\"><a href=\"#4、递归定义\" class=\"headerlink\" title=\"4、递归定义\"></a>4、递归定义</h3><p>一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数；每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>\n<h3 id=\"5、队列定义\"><a href=\"#5、队列定义\" class=\"headerlink\" title=\"5、队列定义\"></a>5、队列定义</h3><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表；允许插入的一端称为队尾，允许删除的一端称为队头</p>\n<h3 id=\"6、队列的链式存储结构\"><a href=\"#6、队列的链式存储结构\" class=\"headerlink\" title=\"6、队列的链式存储结构\"></a>6、队列的链式存储结构</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；队头指针指向链队列的头结点，而队尾指针指向终端结点：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_156.png\" alt=\"\" width=\"400\"></div>\n\n<p>空队列时，front 和 rear 都指向头结点</p>\n<h3 id=\"7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\"><a href=\"#7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\" class=\"headerlink\" title=\"7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\"></a>7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列</h3><h3 id=\"8、栈和队列的存储结构\"><a href=\"#8、栈和队列的存储结构\" class=\"headerlink\" title=\"8、栈和队列的存储结构\"></a>8、栈和队列的存储结构</h3><div align=\"center\"><img src=\"/images/hexo_post_295.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"9、关于栈和队列的人生感悟\"><a href=\"#9、关于栈和队列的人生感悟\" class=\"headerlink\" title=\"9、关于栈和队列的人生感悟\"></a>9、关于栈和队列的人生感悟</h3><p>人生，就像是一个很大的栈演变。出生时你赤条条地来到人世，慢慢地长大，渐渐地变老，最终还得赤条条地离开世间。<br>人生，又仿佛是一天一天小小的栈重现。童年父母每天抱你不断地进出家门，壮年你每天奔波于家与事业之间，老年你每天独自蹒跚于养老院的门里屋前。<br>人生，更需要有进栈出栈精神的体现。在哪里跌倒，就应该在哪里爬起来。无论陷入何等困境，只要抬头能仰望蓝天，就有希望，不断进取，你就可以让出头之日重现。困难不会永远存在，强者才能勇往直前。<br>人生，其实就是一个大大的队列演变。无知童年、快乐少年，稚傲青年，成熟中年，安逸晚年。<br>人生，又是一个又一个小小的队列重现。春夏秋冬轮回年年，早中晚夜循环天天。变化的是时间，不变的是你对未来执着的信念。<br>人生，更需要有队列精神的体现。南极到北极，不过是南纬90度到北纬90度的队列，如果你中途犹豫，临时转向，也许你就只能和企鹅相伴永远。可事实上，无论哪个方向，只要你坚持到底，你都可以到达终点。</p>\n<h2 id=\"四、串（字符串）\"><a href=\"#四、串（字符串）\" class=\"headerlink\" title=\"四、串（字符串）\"></a>四、串（字符串）</h2><h3 id=\"1、一首回文诗（李禺《两相思》）\"><a href=\"#1、一首回文诗（李禺《两相思》）\" class=\"headerlink\" title=\"1、一首回文诗（李禺《两相思》）\"></a>1、一首回文诗（李禺《两相思》）</h3><blockquote>\n<p>枯眼望遥山隔水，<br>往来曾见几心知？<br>壶空怕酌一杯酒，<br>笔下难成和韵诗。<br>途路阻人离别久，<br>讯音无雁寄回迟。<br>孤灯夜守长寥寂，<br>夫忆妻兮父忆儿。</p>\n</blockquote>\n<p>更多回文诗可以<a href=\"http://baike.baidu.com/link?url=VNTgFjBN0q2gekPkKqes9MWMtdOqf8_THZ-MuEh3vJTBKi88oJmvcrHNAkswt_oKY5pR58CL8C0CPKEHFfLFQpb6ZOQPU3W4G-P9z9gv6P2D4cO1CxwgyrBQNUg3fGfu\" target=\"_blank\" rel=\"noopener\">戳我一下</a></p>\n<h3 id=\"2、英语单词中的字符串\"><a href=\"#2、英语单词中的字符串\" class=\"headerlink\" title=\"2、英语单词中的字符串\"></a>2、英语单词中的字符串</h3><p>即使是 lover 也有个 over，即使是 friend 也有个 end，即使是 believe 也有个lie</p>\n<h3 id=\"3、关于字符串的一些概念\"><a href=\"#3、关于字符串的一些概念\" class=\"headerlink\" title=\"3、关于字符串的一些概念\"></a>3、关于字符串的一些概念</h3><p><strong>空格串</strong>：是只包含空格的串，空格串是有内容有长度的，而且可以不止一个空格<br>子串与主串：串中任意个数的连续字符组成的子序列称为该串的<strong>子串</strong>，相应地，包含子串的串称为<strong>主串</strong><br><strong>子串在主串中的位置</strong>：就是子串的第一个字符在主串中的序号</p>\n<h3 id=\"4、Unicode-和-ASCII-编码\"><a href=\"#4、Unicode-和-ASCII-编码\" class=\"headerlink\" title=\"4、Unicode 和 ASCII 编码\"></a>4、Unicode 和 ASCII 编码</h3><p>\b计算机中的常用字符是使用标准的 ASCII 编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展 ASCII 码由 8 位二进制数表示一个字符，总共可以表示 256 个字符；可是换做全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了 Unicode 编码，比较常用的是由 16 位的二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和 ASCII 码兼容，Unicode 的前 256 个字符与 ASCII 码完全相同</p>\n<h3 id=\"5、两个字符串的比较\"><a href=\"#5、两个字符串的比较\" class=\"headerlink\" title=\"5、两个字符串的比较\"></a>5、两个字符串的比较</h3><p>给定两个串：s=”a1a2……an”，t=”b1b2……bm”，当满足以下条件之一时，s &lt; t</p>\n<ul>\n<li>n &lt; m，且 ai=bi（i=1，2，……n），例如当 s=”hap”，t=”happy”，就有 s &lt; t。因为 t 比 s 多出了两个字母</li>\n<li>存在某个 k ≤ min(m,n)，使得 ai = bi（i=1，2，……，,k-1），ak &lt; bk，例如当 s=”happen”，t=”happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母（k 值），字母 e 的 ASCII 码是 101，而字母 y 的 ASCII 码是 121，显然 e &lt; y，所以 s &lt; t</li>\n</ul>\n<h2 id=\"五、树\"><a href=\"#五、树\" class=\"headerlink\" title=\"五、树\"></a>五、树</h2><h3 id=\"1、一些概念\"><a href=\"#1、一些概念\" class=\"headerlink\" title=\"1、一些概念\"></a>1、一些概念</h3><ul>\n<li>结点拥有的子树数称为结点的度（Degree）；</li>\n<li>度为 0 的结点称为叶节点（Leaf）或终端结点；</li>\n<li>度不为 0 的结点称为非终端结点或分支结点；</li>\n<li>除根结点之外，分支结点也成为内部结点树的度是树内各结点的度的最大值</li>\n<li>树中结点的最大层次称为树的深度（Depth）或高度</li>\n</ul>\n<h3 id=\"2、线性表与树的结构\"><a href=\"#2、线性表与树的结构\" class=\"headerlink\" title=\"2、线性表与树的结构\"></a>2、线性表与树的结构</h3><div align=\"center\"><img src=\"/images/hexo_post_158.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"3、双亲表示法\"><a href=\"#3、双亲表示法\" class=\"headerlink\" title=\"3、双亲表示法\"></a>3、双亲表示法</h3><p>以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置；由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_159.png\" alt=\"\" width=\"300\"></div>\n\n<p>这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，知道 parent 为 -1 时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，需要遍历整个结构。</p>\n<h3 id=\"4、多重链表表示法\"><a href=\"#4、多重链表表示法\" class=\"headerlink\" title=\"4、多重链表表示法\"></a>4、多重链表表示法</h3><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法；不过，树的每个结点的度，也就是孩子个数是不同的，所以可以设计两种方案来解决：</p>\n<h4 id=\"方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\"><a href=\"#方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\" class=\"headerlink\" title=\"方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\"></a>方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）</h4><div align=\"center\"><img src=\"/images/hexo_post_160.png\" alt=\"\" width=\"500\"></div>\n\n<p>其中 data 是数据域，child1 到 childd 是指针域，用来指向该结点的孩子结点，这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的</p>\n<h4 id=\"方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\"><a href=\"#方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\" class=\"headerlink\" title=\"方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\"></a>方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数</h4><div align=\"center\"><img src=\"/images/hexo_post_296.png\" alt=\"\" width=\"500\"></div>\n\n<p>这种方法提升了空间利用率，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗</p>\n<h3 id=\"5、孩子表示法\"><a href=\"#5、孩子表示法\" class=\"headerlink\" title=\"5、孩子表示法\"></a>5、孩子表示法</h3><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_162.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"6、双亲孩子表示法\"><a href=\"#6、双亲孩子表示法\" class=\"headerlink\" title=\"6、双亲孩子表示法\"></a>6、双亲孩子表示法</h3><div align=\"center\"><img src=\"/images/hexo_post_163.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"7、孩子兄弟表示法\"><a href=\"#7、孩子兄弟表示法\" class=\"headerlink\" title=\"7、孩子兄弟表示法\"></a>7、孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_164.png\" alt=\"\" width=\"300\"></div>\n\n<p>data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址，这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树</p>\n<h3 id=\"8、二叉树特点\"><a href=\"#8、二叉树特点\" class=\"headerlink\" title=\"8、二叉树特点\"></a>8、二叉树特点</h3><ul>\n<li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点（没有子树或者有一棵子树都是可以的）</li>\n<li>左子树和右子树是有顺序的，次序不能任意颠倒</li>\n<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</li>\n</ul>\n<h3 id=\"9、二叉树五种基本形态\"><a href=\"#9、二叉树五种基本形态\" class=\"headerlink\" title=\"9、二叉树五种基本形态\"></a>9、二叉树五种基本形态</h3><ol>\n<li>空二叉树</li>\n<li>只有一个根结点</li>\n<li>根结点只有左子树</li>\n<li>根结点只有右子树</li>\n<li>根结点既有左子树又有右子树</li>\n</ol>\n<h3 id=\"10、特殊二叉树\"><a href=\"#10、特殊二叉树\" class=\"headerlink\" title=\"10、特殊二叉树\"></a>10、特殊二叉树</h3><h4 id=\"斜树\"><a href=\"#斜树\" class=\"headerlink\" title=\"斜树\"></a>斜树</h4><p>所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树，这两者统称为斜树</p>\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</p>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_165.png\" alt=\"\" width=\"400\"></div>\n\n<p><strong>完全二叉树的特点：</strong></p>\n<ul>\n<li>叶子结点只能出现在最下两层</li>\n<li>最下层的叶子一定集中在左部连续位置</li>\n<li>倒数二层，若有叶子结点，一定都在右部连续位置</li>\n<li>如果结点度为 1，则该节点只有左孩子，即不存在只有右子树的情况</li>\n<li>同样结点数的二叉树，完全二叉树的深度最小</li>\n</ul>\n<h3 id=\"11、二叉树的性质\"><a href=\"#11、二叉树的性质\" class=\"headerlink\" title=\"11、二叉树的性质\"></a>11、二叉树的性质</h3><ol>\n<li>在二叉树的第 i 层上至多有 <strong>2i-1</strong> 个结点（i ≥ 1）</li>\n<li>深度为 k 的二叉树至多有 <strong>2k-1</strong> 个结点（k ≥ 1）</li>\n<li>对任何一棵二叉树 T，如果其终端结点数为 <strong>n0</strong>，度为 2 的节点数为 <strong>n2</strong>，则 <strong>n0 = n2 + 1</strong>（解释见下图）</li>\n<li>具有 n 个结点的完全二叉树的深度为 <strong>⌊log2n⌋ + 1</strong>（⌊x⌋ 表示不大于 x 的最大整数）</li>\n<li>如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log2n⌋+1）的结点按层序编号（从第 1 层到第 ⌊log2n⌋ + 1 层，每层从左到右），对任一结点 i（1≤i≤n）有：</li>\n</ol>\n<ul>\n<li>如果 i = 1，则结点i是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 ⌊i / 2⌋</li>\n<li>如果 2i &gt; n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左结点是结点 2i</li>\n<li>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_166.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"12、二叉链表\"><a href=\"#12、二叉链表\" class=\"headerlink\" title=\"12、二叉链表\"></a>12、二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_167.png\" alt=\"\" width=\"300\"></div>\n\n<p>其中 data 是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针</p>\n<h3 id=\"13、二叉树遍历方法\"><a href=\"#13、二叉树遍历方法\" class=\"headerlink\" title=\"13、二叉树遍历方法\"></a>13、二叉树遍历方法</h3><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树，遍历的顺序为：ABDGHCEIF</p>\n<div align=\"center\"><img src=\"/images/hexo_post_168.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树，遍历的顺序为：GDHBAEICF</p>\n<div align=\"center\"><img src=\"/images/hexo_post_169.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点，遍历的顺序为：GHDBIEFCA</p>\n<div align=\"center\"><img src=\"/images/hexo_post_170.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><p>若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序堆结点逐个访问，遍历的顺序为：ABCDEFGHI</p>\n<div align=\"center\"><img src=\"/images/hexo_post_171.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"14、两个二叉树遍历的性质\"><a href=\"#14、两个二叉树遍历的性质\" class=\"headerlink\" title=\"14、两个二叉树遍历的性质\"></a>14、两个二叉树遍历的性质</h3><ul>\n<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>\n<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>\n<li>但是已知前序和后序遍历，是不能确定一棵二叉树的</li>\n</ul>\n<h3 id=\"15、线索二叉树\"><a href=\"#15、线索二叉树\" class=\"headerlink\" title=\"15、线索二叉树\"></a>15、线索二叉树</h3><p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树</p>\n<div align=\"center\"><img src=\"/images/hexo_post_172.png\" alt=\"\" width=\"500\"></div>\n\n<p>通过上图（空心箭头实线为前驱，虚线黑箭头为后继），可以看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表；所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化；但是，我们并不知道某一结点的 lchild 是指向它的左孩子还是指向前驱，所以需要一个区分标致；因此，我们在每个结点再增设两个标志域 ltag 和 rtag，这两个 tag 只是存放 0 或 1 数字的布尔型变量，其占用的内存空间要小于像 lchild 和 rchild 的指针变量，结点结构如下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_173.png\" alt=\"\" width=\"400\"></div>\n\n<ul>\n<li>ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱</li>\n<li>rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_174.png\" alt=\"\" width=\"500\"></div>\n\n<p><strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong></p>\n<h3 id=\"16、树转换为二叉树\"><a href=\"#16、树转换为二叉树\" class=\"headerlink\" title=\"16、树转换为二叉树\"></a>16、树转换为二叉树</h3><ol>\n<li>加线，在所有兄弟结点之间加一条连线</li>\n<li>去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>\n<li>层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_175.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"17、森林转换为二叉树\"><a href=\"#17、森林转换为二叉树\" class=\"headerlink\" title=\"17、森林转换为二叉树\"></a>17、森林转换为二叉树</h3><ol>\n<li>把每个树转换为二叉树</li>\n<li>第一棵二叉树不动，从第二棵二叉树开始，以此把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来，当所有的二叉树连接起来后就得到了由森林转换来的二叉树</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_176.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"18、二叉树转换为树\"><a href=\"#18、二叉树转换为树\" class=\"headerlink\" title=\"18、二叉树转换为树\"></a>18、二叉树转换为树</h3><ol>\n<li>加线，若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接起来</li>\n<li>去线，删除原二叉树中所有结点与其右孩子结点的连线</li>\n<li>层次调整，使之结构层次分明</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_177.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"19、二叉树转换为森林\"><a href=\"#19、二叉树转换为森林\" class=\"headerlink\" title=\"19、二叉树转换为森林\"></a>19、二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树</p>\n<ol>\n<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树</li>\n<li>再将每棵分离后的二叉树转换为树即可</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_178.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"20、树的遍历\"><a href=\"#20、树的遍历\" class=\"headerlink\" title=\"20、树的遍历\"></a>20、树的遍历</h3><ol>\n<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树</li>\n<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li>\n</ol>\n<h3 id=\"21、森林的遍历\"><a href=\"#21、森林的遍历\" class=\"headerlink\" title=\"21、森林的遍历\"></a>21、森林的遍历</h3><ol>\n<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先跟遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林</li>\n<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林</li>\n</ol>\n<p><strong>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树中的中序遍历结果相同</strong></p>\n<h3 id=\"22、赫夫曼树算法描述\"><a href=\"#22、赫夫曼树算法描述\" class=\"headerlink\" title=\"22、赫夫曼树算法描述\"></a>22、赫夫曼树算法描述</h3><ol>\n<li>根据给定的n个权值 {w1，w2，···wn} 构成 n 棵二叉树的集合 F={T1，T2，···Tn}，其中每个二叉树 Ti 中只有一个带权为 wi 的根结点，其左右子树均为空。</li>\n<li>在 F 中选择两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。</li>\n<li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li>\n<li>重复 2 和 3，直到 F 只含一棵树为止。这棵树便是赫夫曼树。</li>\n</ol>\n<h3 id=\"23、赫夫曼编码\"><a href=\"#23、赫夫曼编码\" class=\"headerlink\" title=\"23、赫夫曼编码\"></a>23、赫夫曼编码</h3><p>一般地，设需要编码的字符集为 {d1，d2，···dn}，各个字符在电文中出现的次数或频率集合为 {w1，w2，···wn}，以 d1，d2，···dn 作为叶子结点，以 w1，w2，···wn 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码</p>\n<h2 id=\"六、图\"><a href=\"#六、图\" class=\"headerlink\" title=\"六、图\"></a>六、图</h2><h3 id=\"1、图的定义\"><a href=\"#1、图的定义\" class=\"headerlink\" title=\"1、图的定义\"></a>1、图的定义</h3><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合</p>\n<h3 id=\"2、关于图的一些定义\"><a href=\"#2、关于图的一些定义\" class=\"headerlink\" title=\"2、关于图的一些定义\"></a>2、关于图的一些定义</h3><ul>\n<li><strong>无向边</strong>：若顶点 vi 到 vj 之间的边没有方向，则称这条边为无向边（Edge），用无需偶对（vi，vj）来表示</li>\n<li><p><strong>有向边</strong>：若从顶点 vi 到 vj 的边有方向，则称这条边为有向边，也成为弧（Arc）<br><strong>无向边用小括号 “()” 表示，而有向边则是用尖括号 “&lt;&gt;” 表示</strong></p>\n</li>\n<li><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为<strong>简单图</strong></p>\n</li>\n<li>在无向图中，如果任意两个顶点之间都存在边，则称该图为<strong>无向完全图</strong></li>\n<li>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为<strong>有向完全图</strong></li>\n<li>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong></li>\n<li>这里稀疏和稠密是模糊的概念，是相对而言的 有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做<strong>权</strong>（Weight）</li>\n<li>带权的图通常称为<strong>网</strong>（Network）</li>\n<li>假设有两个图 G =（V，{E}）和G’ =（V’，{E’}），如果 V’ ⊆ V 且 E’ ⊆ E，则称 G’ 为 G 的<strong>子图</strong>（Subgraph）</li>\n<li>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。</li>\n<li>若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。</li>\n<li>图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量 无向图中连通且n个顶点n-1条边叫生成树。</li>\n<li>有向图中一顶点入度为0其余顶点入度为1的叫有向树。</li>\n<li>一个有向图由若干棵有向树构成生成森林</li>\n</ul>\n<blockquote>\n<p>由于定义实在太多，就不再叙述了，可以<a href=\"http://blog.csdn.net/luoweifu/article/details/9270439\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看关于图的其他定义</p>\n</blockquote>\n<h3 id=\"3、图的邻接矩阵\"><a href=\"#3、图的邻接矩阵\" class=\"headerlink\" title=\"3、图的邻接矩阵\"></a>3、图的邻接矩阵</h3><p>图的邻接矩阵（Adiacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息 n 个顶点和 e 条边的无向网图的创建，时间复杂度为 O（n+n2+e），其中对邻接矩阵的初始化需要耗费 O（n2）的时间</p>\n<h3 id=\"4、邻接表\"><a href=\"#4、邻接表\" class=\"headerlink\" title=\"4、邻接表\"></a>4、邻接表</h3><p>数组与链表相结合的存储方法称为邻接表 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息 图中每个顶点 vi 的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点 vi 的边表，有向图则称为顶点 vi 作为弧尾的出边表</p>\n<div align=\"center\"><img src=\"/images/hexo_post_179.png\" alt=\"\" width=\"600\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_180.png\" alt=\"\" width=\"600\"></div>\n\n<p>若是有向图，邻接表结构是类似的，但我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度，但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立<strong>一个有向图的逆邻接表，即对每个顶点 vi 都建立一个链接为 vi 为弧头的表</strong> 对于带权值的网图，可以在边表结点定义中再<strong>增加一个 weight 的数据域</strong>，存储权值信息即可</p>\n<h3 id=\"5、图的遍历\"><a href=\"#5、图的遍历\" class=\"headerlink\" title=\"5、图的遍历\"></a>5、图的遍历</h3><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）</p>\n<h3 id=\"6、深度优先遍历（DFS）\"><a href=\"#6、深度优先遍历（DFS）\" class=\"headerlink\" title=\"6、深度优先遍历（DFS）\"></a>6、深度优先遍历（DFS）</h3><p>从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止</p>\n<h3 id=\"7、广度优先遍历（BFS）\"><a href=\"#7、广度优先遍历（BFS）\" class=\"headerlink\" title=\"7、广度优先遍历（BFS）\"></a>7、广度优先遍历（BFS）</h3><p>如果说<strong>图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历</strong>了，如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_181.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"8、图的两种遍历方式的比较\"><a href=\"#8、图的两种遍历方式的比较\" class=\"headerlink\" title=\"8、图的两种遍历方式的比较\"></a>8、图的两种遍历方式的比较</h3><p>两者在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同，可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过，深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>\n<h3 id=\"9、最小生成树\"><a href=\"#9、最小生成树\" class=\"headerlink\" title=\"9、最小生成树\"></a>9、最小生成树</h3><p>我们把构造连通网的最小代价生成树称为<strong>最小生成树</strong>（Minimum Cost Spanning Tree）<br>找连通网的最小生成树，经典的有两种算法，<strong>普利姆算法</strong>和<strong>克鲁斯卡尔算法</strong></p>\n<h3 id=\"10、普利姆（Prim）算法\"><a href=\"#10、普利姆（Prim）算法\" class=\"headerlink\" title=\"10、普利姆（Prim）算法\"></a>10、普利姆（Prim）算法</h3><h4 id=\"算法思路：\"><a href=\"#算法思路：\" class=\"headerlink\" title=\"算法思路：\"></a>算法思路：</h4><p>以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</p>\n<h4 id=\"算法步骤：\"><a href=\"#算法步骤：\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><ol>\n<li>输入：一个加权连通图，其中顶点集合为 V，边集合为 E；</li>\n<li>初始化：Vnew = {x}，其中 x 为集合 V 中的任一节点（起始点），Enew = {}，为空；</li>\n<li>重复下列操作，直到 Vnew = V：</li>\n</ol>\n<ul>\n<li>在集合 E 中选取权值最小的边 <code>&lt;u, v&gt;</code>，其中 u 为集合 Vnew 中的元素，而 v 不在 <code>Vnew</code> 集合当中，并且 v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</li>\n<li>将 v 加入集合 Vnew 中，将 <code>&lt;u, v&gt;</code> 边加入集合 Enew 中；</li>\n</ul>\n<ol start=\"4\">\n<li>输出：使用集合 Vnew 和 Enew 来描述所得到的最小生成树。</li>\n</ol>\n<p>书中有非常详尽的解释，但是感觉解释的比较繁琐，建议去看一下<a href=\"http://baike.baidu.com/link?url=9SZQiA3Zm97fe1rIVtGuUCX0FszUTNnk2Qv5XwbPNZpFvjKgRfCL5PnqfPrEo2RdJQo1Asw2bdQx4RujLJL78X8AbfsvN6TUbVKl7w8a2CNQEADeXcqZydK4wrEmYFXybxEKUnpa83ksvSxsJS-zSbyMgjt-9r5Zx3aMquBsMJ26Qj_m2irhgVvsJsxw0QB8\" target=\"_blank\" rel=\"noopener\">百度百科</a>中的讲解</p>\n<h3 id=\"11、克鲁斯卡尔（Kruskal）算法\"><a href=\"#11、克鲁斯卡尔（Kruskal）算法\" class=\"headerlink\" title=\"11、克鲁斯卡尔（Kruskal）算法\"></a>11、克鲁斯卡尔（Kruskal）算法</h3><h4 id=\"算法思路：-1\"><a href=\"#算法思路：-1\" class=\"headerlink\" title=\"算法思路：\"></a>算法思路：</h4><p>因为权值是在边上，所以直接去找最小权值的边来构建生成树，只不过构建时要考虑是否会形成环路而已</p>\n<h4 id=\"算法步骤：-1\"><a href=\"#算法步骤：-1\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><p>先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。关于这个算法，百度百科上的讲解就不是很清楚了，如果感兴趣的话可以自行查阅其他资料</p>\n<h3 id=\"12、Prim-算法和-Kruskal-算法的对比\"><a href=\"#12、Prim-算法和-Kruskal-算法的对比\" class=\"headerlink\" title=\"12、Prim 算法和 Kruskal 算法的对比\"></a>12、Prim 算法和 Kruskal 算法的对比</h3><p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以堆于稀疏图有很大的优势；而普利姆算法对于稠密图，即边数非常多的情况会更好一些</p>\n<h3 id=\"13、最短路径\"><a href=\"#13、最短路径\" class=\"headerlink\" title=\"13、最短路径\"></a>13、最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点 主要有两种求最短路径的算法：迪杰斯特拉算法和</p>\n<h3 id=\"14、迪杰斯特拉（Dijkstra）算法\"><a href=\"#14、迪杰斯特拉（Dijkstra）算法\" class=\"headerlink\" title=\"14、迪杰斯特拉（Dijkstra）算法\"></a>14、迪杰斯特拉（Dijkstra）算法</h3><h4 id=\"算法步骤：-2\"><a href=\"#算法步骤：-2\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><p>G = {V,E}</p>\n<ol>\n<li>初始时令 S = {V0}, T = V - S = {其余顶点}，T 中顶点对应的距离值</li>\n</ol>\n<p>若存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 &lt;V0,Vi&gt; 弧上的权值</p>\n<p>若不存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 ∞</p>\n<ol start=\"2\">\n<li><p>从 T 中选取一个与 S 中顶点有关联边且权值最小的顶点 W，加入到 S 中</p>\n</li>\n<li><p>对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值</p>\n</li>\n</ol>\n<p>重复上述步骤 2、3，直到 S 中包含所有顶点，即 W = Vi 为止</p>\n<h3 id=\"15、弗洛伊德（Floyd）算法\"><a href=\"#15、弗洛伊德（Floyd）算法\" class=\"headerlink\" title=\"15、弗洛伊德（Floyd）算法\"></a>15、弗洛伊德（Floyd）算法</h3><h4 id=\"算法步骤：-3\"><a href=\"#算法步骤：-3\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><ol>\n<li><p>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</p>\n</li>\n<li><p>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</p>\n</li>\n</ol>\n<p>把图用邻接矩阵 G 表示出来，如果从 Vi 到 Vj 有路可达，则 G[i][j] = d，d 表示该路的长度；否则 G[i][j] = 无穷大。定义一个矩阵D用来记录所插入点的信息，D[i][j] 表示从 Vi 到 Vj 需要经过的点，初始化 D[i][j] = j。把各个顶点插入图中，比较插点后的距离与原来的距离，G[i][j] = min( G[i][j], G[i][k]+G[k][j])，如果 G[i][j] 的值变小，则 D[i][j] = k。在 G 中包含有两点之间最短道路的信息，而在 D 中则包含了最短通路径的信息。</p>\n<p>比如，要寻找从 V5 到 V1 的路径。根据 D，假如 D(5,1) = 3 则说明从 V5 到 V1 经过 V3，路径为 {V5,V3,V1}，如果 D(5,3)=3，说明 V5 与 V3 直接相连，如果 D(3,1) = 1，说明 V3 与 V1 直接相连。</p>\n<h3 id=\"16、拓扑排序\"><a href=\"#16、拓扑排序\" class=\"headerlink\" title=\"16、拓扑排序\"></a>16、拓扑排序</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 <strong>AOV 网</strong>（Activity On Vertex Network）<br><strong>拓扑序列</strong>：设 G = (V,E)是一个具有 n 个顶点的有向图，V 中的顶点序列 V1，V2，……，Vn，满足若从顶点 Vi 到 Vj 有一条路径，则在顶点序列中顶点 Vi 必在顶点 Vj 之前。则我们称这样的顶点序列为一个<strong>拓扑序列</strong><br><strong>拓扑排序</strong>：其实就是对一个有向图构造拓扑序列的过程；构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的 AOV 网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是 AOV 网。</p>\n<h3 id=\"17、拓扑排序算法\"><a href=\"#17、拓扑排序算法\" class=\"headerlink\" title=\"17、拓扑排序算法\"></a>17、拓扑排序算法</h3><p><strong>对 AOV 网进行拓扑排序的基本思路</strong>是：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止</p>\n<h3 id=\"18、关键路径\"><a href=\"#18、关键路径\" class=\"headerlink\" title=\"18、关键路径\"></a>18、关键路径</h3><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为 <strong>AOE 网</strong>（Activity On Edge Network）；我们把 AOE 网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点；正常情况下，AOE 网只有一个源点一个汇点，我们把路径上各个活动所持续的时间之和称为<strong>路径长度</strong>，从源点到汇点具有最大长度的路径叫<strong>关键路径</strong>，在关键路径上的活动叫<strong>关键活动</strong></p>\n<h3 id=\"19、关键路径算法\"><a href=\"#19、关键路径算法\" class=\"headerlink\" title=\"19、关键路径算法\"></a>19、关键路径算法</h3><p>原理：我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。为此，我们需要定义如下几个参数：</p>\n<ol>\n<li>事件的<strong>最早发生时间etv</strong>（earliest time of vertex）：即顶点 Vk 的最早发生时间</li>\n<li>事件的<strong>最晚发生时间ltv</strong>（latest time of vertex）：即顶点 Vk 的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期</li>\n<li>活动的<strong>最早开工时间ete</strong>（earliest time of edge）：即弧 ak 的最早发生时间</li>\n<li>活动的<strong>最晚开工时间lte</strong>（latest time of edge）：即弧 ak 的最晚发生时间，也就是不推迟工期的最晚开工时间</li>\n</ol>\n<p>我们是由 1 和 2 可以求得 3 和 4，然后再根据 ete[k] 是否与 lte[k] 相等来判断 ak 是否是关键活动</p>\n<h3 id=\"20、世界上最遥远的距离……\"><a href=\"#20、世界上最遥远的距离……\" class=\"headerlink\" title=\"20、世界上最遥远的距离……\"></a>20、世界上最遥远的距离……</h3><blockquote>\n<p>世界上最遥远的距离，不是从南极到北极，而是我在讲解算法为何如此精妙，你却能够安详在课堂上休息。<br>世界上最遥远的距离，不是珠峰与马里亚纳海沟的距离，而是我欲把古人的智慧全盘给你，你却不屑一顾毫不怜惜。<br>世界上最遥远的距离，不是牛 A 与牛 C 之间狭小空隙，而是你们当中，有人在通往牛逼的路上一路狂奔，而有人步入大学校园就学会放弃。</p>\n</blockquote>\n<h3 id=\"七、查找\"><a href=\"#七、查找\" class=\"headerlink\" title=\"七、查找\"></a>七、查找</h3><h4 id=\"1、查找概论\"><a href=\"#1、查找概论\" class=\"headerlink\" title=\"1、查找概论\"></a>1、查找概论</h4><ul>\n<li><strong>查找表</strong>（Search Table）是由同一类型的数据元素（或记录）构成的集合</li>\n<li><strong>关键字</strong>（Key）是数据元素中某个数据项的值，又称为<strong>键值</strong></li>\n<li>若此关键字可以唯一地标识一个记录，则称此关键字为<strong>主关键字</strong>（Primary Key）</li>\n<li>那些可以识别多个数据元素（或记录）的关键字，我们称为<strong>次关键字</strong>（Secondary Key）</li>\n<li><strong>查找</strong>（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值得数据元素（或记录）</li>\n</ul>\n<h4 id=\"2、查找表操作方式\"><a href=\"#2、查找表操作方式\" class=\"headerlink\" title=\"2、查找表操作方式\"></a>2、查找表操作方式</h4><p>分为两大种：静态查找表和动态查找表 <strong>静态查找表</strong>（Static Search Table）：只作查找操作的查找表。它的主要操作有：</p>\n<ul>\n<li>查询某个“特定的”数据元素是否在查找表中</li>\n<li>检索某个“特定的”数据元素和各种属性</li>\n</ul>\n<p><strong>动态查找表</strong>（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：</p>\n<ul>\n<li>查找时插入数据元素</li>\n<li>查找时删除数据元素</li>\n</ul>\n<h4 id=\"3、顺序查找\"><a href=\"#3、顺序查找\" class=\"headerlink\" title=\"3、顺序查找\"></a>3、顺序查找</h4><p>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是： 从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</p>\n<h3 id=\"4、二分查找\"><a href=\"#4、二分查找\" class=\"headerlink\" title=\"4、二分查找\"></a>4、二分查找</h3><p>折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是： 在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</p>\n<h4 id=\"5、插值查找\"><a href=\"#5、插值查找\" class=\"headerlink\" title=\"5、插值查找\"></a>5、插值查找</h4><p>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])，对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多</p>\n<h3 id=\"6、斐波那契查找算法\"><a href=\"#6、斐波那契查找算法\" class=\"headerlink\" title=\"6、斐波那契查找算法\"></a>6、斐波那契查找算法</h3><h4 id=\"算法核心：\"><a href=\"#算法核心：\" class=\"headerlink\" title=\"算法核心：\"></a>算法核心：</h4><ol>\n<li>当 key = a[mid] 时，查找就成功</li>\n<li>当 key &lt; a[mid] 时，新范围是第 low 个到第 mid - 1 个，此时范围个数为 F[k-1] - 1 个</li>\n<li>当 key &gt; a[mid] 时，新范围是第 m + 1 个到第 high 个，此时范围个数为 F[k-2] - 1 个</li>\n</ol>\n<h3 id=\"7、三种查找算法的比较\"><a href=\"#7、三种查找算法的比较\" class=\"headerlink\" title=\"7、三种查找算法的比较\"></a>7、三种查找算法的比较</h3><p>折半查找是进行加法与除法运算 (mid = (low + high) / 2)，插值查找进行复杂的四则运算(mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]))，而斐波那契查找只是最简单加减法运算(mid = low + F[k-1] - 1)，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率</p>\n<h3 id=\"8、线性索引\"><a href=\"#8、线性索引\" class=\"headerlink\" title=\"8、线性索引\"></a>8、线性索引</h3><p><strong>索引</strong>就是把一个关键字与它对应的记录相关联的过程 所谓<strong>线性索引</strong>就是将索引项集合组织为线性结构，也称为<strong>索引表</strong> 三种线性索引：稠密索引、分块索引和倒排索引</p>\n<h3 id=\"9、稠密索引\"><a href=\"#9、稠密索引\" class=\"headerlink\" title=\"9、稠密索引\"></a>9、稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</p>\n<div align=\"center\"><img src=\"/images/hexo_post_182.png\" alt=\"\" width=\"400\"></div>\n\n<p>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列 索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率</p>\n<h3 id=\"10、分块索引\"><a href=\"#10、分块索引\" class=\"headerlink\" title=\"10、分块索引\"></a>10、分块索引</h3><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p>\n<ul>\n<li><strong>块内无序</strong>：当然如果能够让块内有序对查找来说更理想</li>\n<li><strong>块间有序</strong>：只有块间有序，才有可能在查找时带来效率</li>\n</ul>\n<h4 id=\"分块索引的索引项结构分三个数据项：\"><a href=\"#分块索引的索引项结构分三个数据项：\" class=\"headerlink\" title=\"分块索引的索引项结构分三个数据项：\"></a>分块索引的索引项结构分三个数据项：</h4><ul>\n<li><strong>最大关键码</strong>，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>\n<li>存储了<strong>块中的记录个数</strong>，以便于循环时使用</li>\n<li>用于<strong>指向块首数据元素的指针</strong>，便于开始对这一块中记录进行遍历</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_183.png\" alt=\"\" width=\"400\"></div>\n\n<h4 id=\"分块索引表中查找的步骤：\"><a href=\"#分块索引表中查找的步骤：\" class=\"headerlink\" title=\"分块索引表中查找的步骤：\"></a>分块索引表中查找的步骤：</h4><ol>\n<li>在分块索引表中查找要查关键字所在的块，可以利用折半、插值等算法</li>\n<li>根据块首指针找到响应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找</li>\n</ol>\n<h3 id=\"11、倒排索引\"><a href=\"#11、倒排索引\" class=\"headerlink\" title=\"11、倒排索引\"></a>11、倒排索引</h3><p>记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index） 倒排索引的优点就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长</p>\n<h3 id=\"12、二叉排序树\"><a href=\"#12、二叉排序树\" class=\"headerlink\" title=\"12、二叉排序树\"></a>12、二叉排序树</h3><p>二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>\n<li>它的左、右子树也分别为二叉排序树</li>\n</ul>\n<p>如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。</p>\n<h3 id=\"13、平衡二叉树\"><a href=\"#13、平衡二叉树\" class=\"headerlink\" title=\"13、平衡二叉树\"></a>13、平衡二叉树</h3><p>平衡二叉树（Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于 1；我们将二叉树上结点的左子树深度减去右子树深度的值称为<strong>平衡因子</strong>BF（Balance Factor），那么平衡二叉树上所有结点的平衡因子只可能是 -1，0，1</p>\n<h3 id=\"14、最小不平衡子树\"><a href=\"#14、最小不平衡子树\" class=\"headerlink\" title=\"14、最小不平衡子树\"></a>14、最小不平衡子树</h3><p>距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，我们称为<strong>最小不平衡子树</strong></p>\n<div align=\"center\"><img src=\"/images/hexo_post_184.png\" alt=\"\" width=\"400\"></div>\n\n<p>如上图所示，当新插入结点 37 时，距离它最近的平衡因子绝对值超过 1 的结点是 58（即它的左子树高度 2 减去右子树高度 0），所以从 58 开始以下的子树为最小不平衡子树</p>\n<h3 id=\"15、平衡二叉树实现算法\"><a href=\"#15、平衡二叉树实现算法\" class=\"headerlink\" title=\"15、平衡二叉树实现算法\"></a>15、平衡二叉树实现算法</h3><h4 id=\"算法原理：\"><a href=\"#算法原理：\" class=\"headerlink\" title=\"算法原理：\"></a>算法原理：</h4><p>基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应地旋转，使之成为新的平衡子树</p>\n<h4 id=\"右旋操作：\"><a href=\"#右旋操作：\" class=\"headerlink\" title=\"右旋操作：\"></a>右旋操作：</h4><div align=\"center\"><img src=\"/images/hexo_post_185.png\" alt=\"\" width=\"500\"></div>\n\n<p>左旋和右旋代码是对称的</p>\n<h3 id=\"16、多路查找树\"><a href=\"#16、多路查找树\" class=\"headerlink\" title=\"16、多路查找树\"></a>16、多路查找树</h3><p>多路查找树（multi-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</p>\n<h3 id=\"17、2-3-树\"><a href=\"#17、2-3-树\" class=\"headerlink\" title=\"17、2-3 树\"></a>17、2-3 树</h3><p>2-3 树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）。</p>\n<ul>\n<li>一个 2 结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似</li>\n<li>一个 3 结点包含一小一大两个元素和三个孩子（或没有孩子），左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素</li>\n<li>2-3 树中所有的叶子都在同一层次上</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_186.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"18、2-3树的插入实现\"><a href=\"#18、2-3树的插入实现\" class=\"headerlink\" title=\"18、2-3树的插入实现\"></a>18、2-3树的插入实现</h3><p>可分为三种情况：</p>\n<ol>\n<li>对于空树，插入一个 2 结点即可，这很容易理解</li>\n<li>插入结点到一个 2 结点的叶子上。由于其本身就只有一个元素，所以只需要将其升级为 3 结点即可</li>\n<li>要往 3 结点中插入一个新元素。因为 3 结点本身已经是 2-3 树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</li>\n</ol>\n<h3 id=\"19、2-3-4树\"><a href=\"#19、2-3-4树\" class=\"headerlink\" title=\"19、2-3-4树\"></a>19、2-3-4树</h3><p>就是 2-3 树的概念扩展，包括了 4 结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个 4 结点要么没有孩子，要么具有 4 个孩子。如果某个 4 结点有孩子的话，从左到右按照由小到大的顺序排列</p>\n<h3 id=\"20、B树\"><a href=\"#20、B树\" class=\"headerlink\" title=\"20、B树\"></a>20、B树</h3><p>B树（B-tree）是一种平衡的多路查找树，2-3树和 2-3-4树都是 B树的特例。结点最大的孩子数目称为 <strong>B树的阶</strong>（order），因此，2-3树是 3 阶 B树，2-3-4树是 4 阶 B树</p>\n<h4 id=\"一个-m-阶的-B-树具有如下属性：\"><a href=\"#一个-m-阶的-B-树具有如下属性：\" class=\"headerlink\" title=\"一个 m 阶的 B 树具有如下属性：\"></a>一个 m 阶的 B 树具有如下属性：</h4><ul>\n<li>如果根结点不是叶节点，则其至少有两棵子树</li>\n<li>每一个非根的分支结点都有 k-1 个元素和k个孩子，其中 ⌈m/2⌉ ≤ k ≤ m。每一个叶子节点 n 都有 k - 1 个元素，其中 ⌈m/2⌉ ≤ k ≤m</li>\n<li>所有叶子结点都位于同一层次</li>\n<li>所有分支结点包含下列信息数据（n,A0,K1,A1,K2,A2,…,Kn,An），其中：Ki(i=1,2,…,n) 为关键字，且 Ki&lt;Ki+1(i=1,2,…,n-1)；Ai(i=0,2,…,n) 为指向子树根结点的指针，且指针 A(i-1) 所指子树中所有结点的关键字均小于 Ki(i=1,2,…,n),An 所指子树中所有结点的关键字均大于 Kn，n·(⌈m/2⌉-1≤n≤m-1) 为关键字的个数（或 n + 1 为子树的个数）</li>\n</ul>\n<h3 id=\"21、B-树\"><a href=\"#21、B-树\" class=\"headerlink\" title=\"21、B+树\"></a>21、B+树</h3><p>在 B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子节点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针</p>\n<div align=\"center\"><img src=\"/images/hexo_post_187.png\" alt=\"\" width=\"400\"></div>\n\n<p>一棵 m 阶的 B+树和 m 阶的 B树的差异在于：</p>\n<ul>\n<li>有 n 棵子树的结点中包含有 n 个关键字</li>\n<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</li>\n<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字</li>\n</ul>\n<p>如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是沿着指向下一叶子结点的指针就可遍历所有的关键字</p>\n<h3 id=\"22、散列表（哈希表）\"><a href=\"#22、散列表（哈希表）\" class=\"headerlink\" title=\"22、散列表（哈希表）\"></a>22、散列表（哈希表）</h3><p><strong>散列技术</strong>是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)，散列技术既是一种存储方法，也是一种查找方法<br>散列技术最适合的求解问题是查找与给定值相等的记录 f称为散列函数，又称为<strong>哈希（Hash）函数</strong><br>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为<strong>散列表或哈希表</strong>（Hash table）</p>\n<h4 id=\"散列过程有两步：\"><a href=\"#散列过程有两步：\" class=\"headerlink\" title=\"散列过程有两步：\"></a>散列过程有两步：</h4><ol>\n<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录</li>\n<li>当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录</li>\n</ol>\n<h3 id=\"23、散列函数构造方法\"><a href=\"#23、散列函数构造方法\" class=\"headerlink\" title=\"23、散列函数构造方法\"></a>23、散列函数构造方法</h3><h4 id=\"直接定址法\"><a href=\"#直接定址法\" class=\"headerlink\" title=\"直接定址法\"></a>直接定址法</h4><p>取关键字的某个线性函数值为散列地址</p>\n<h4 id=\"数字分析法\"><a href=\"#数字分析法\" class=\"headerlink\" title=\"数字分析法\"></a>数字分析法</h4><p>如果我们的关键字是位数较多的数字，可以对数字进行翻转、右环位移、左环位移、甚至前两数与后两数叠加等方法，合理地将关键字分配到散列表的各位置</p>\n<h4 id=\"平方取中法\"><a href=\"#平方取中法\" class=\"headerlink\" title=\"平方取中法\"></a>平方取中法</h4><p>假设关键字是 1234，那么它的平方就是 1522756，再抽取中间的 3 位就是 227，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况</p>\n<h4 id=\"折叠法\"><a href=\"#折叠法\" class=\"headerlink\" title=\"折叠法\"></a>折叠法</h4><p>将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况 比如我们的关键字是 9876543210，散列表表长为三位，我们将它分为四组，987|654|321|0，然后将它们叠加求和 987 + 654 + 321 + 0 = 1962，再求后 3 位得到散列地址为 962。</p>\n<h4 id=\"除留余数法\"><a href=\"#除留余数法\" class=\"headerlink\" title=\"除留余数法\"></a>除留余数法</h4><p>对关键字直接取模，也可在折叠、平方取中后再取模，对于散列表长为 m 的散列函数公式为：</p>\n<blockquote>\n<p>f(key)=key mod p(p≤m)</p>\n</blockquote>\n<p>根据前辈们的经验，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m）的最小质数或不包含小于 20 质因子的合数</p>\n<h4 id=\"随机数法\"><a href=\"#随机数法\" class=\"headerlink\" title=\"随机数法\"></a>随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址</p>\n<h3 id=\"24、采用不同的散列函数应该考虑的因素\"><a href=\"#24、采用不同的散列函数应该考虑的因素\" class=\"headerlink\" title=\"24、采用不同的散列函数应该考虑的因素\"></a>24、采用不同的散列函数应该考虑的因素</h3><ul>\n<li>计算散列地址所需的时间</li>\n<li>关键字的长度</li>\n<li>散列表的大小</li>\n<li>关键字的分布情况</li>\n<li>记录查找的频率</li>\n</ul>\n<h3 id=\"25、处理散列冲突的方法\"><a href=\"#25、处理散列冲突的方法\" class=\"headerlink\" title=\"25、处理散列冲突的方法\"></a>25、处理散列冲突的方法</h3><h4 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h4><p>一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入，公式是：</p>\n<blockquote>\n<p>fi(key)=（f(key)+di）MOD m(di=1,2,3,……,m-1)</p>\n</blockquote>\n<p>这种解决冲突的开放定址法称为<strong>线性探测法</strong><br>如果 di 改进为正负两类值，等于是可以双向寻找到可能的空位置，可以不让关键字都聚集在某一块区域。我们称这种方法为<strong>二次探测法</strong><br>如果 di 采用随机函数计算得到，我们称之为<strong>随机探测法</strong></p>\n<h4 id=\"再散列函数法\"><a href=\"#再散列函数法\" class=\"headerlink\" title=\"再散列函数法\"></a>再散列函数法</h4><p>我们事先准备多个散列函数，每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉</p>\n<h4 id=\"链地址法\"><a href=\"#链地址法\" class=\"headerlink\" title=\"链地址法\"></a>链地址法</h4><p>将所有关键字为同义词的记录存储在一个单链表红，我们称这种表尾同义词子表，在散列表中只存储所有同义词子表的头指针</p>\n<h4 id=\"公共溢出区法\"><a href=\"#公共溢出区法\" class=\"headerlink\" title=\"公共溢出区法\"></a>公共溢出区法</h4><p>凡是冲突的都将它们存储到溢出表中</p>\n<h2 id=\"八、排序\"><a href=\"#八、排序\" class=\"headerlink\" title=\"八、排序\"></a>八、排序</h2><p>关于排序，推荐我的另一篇文章：<a href=\"/20170318/js-implementation-of-ten-sorting-algorithms.html\">\b十大排序算法的Javascript实现</a>，这篇文章里有一些常见排序算法的实现步骤以及演示，是一个比较好的排序算法讲解</p>\n<h2 id=\"九、总结\"><a href=\"#九、总结\" class=\"headerlink\" title=\"九、总结\"></a>九、总结</h2><h3 id=\"1、数据结构和算法\"><a href=\"#1、数据结构和算法\" class=\"headerlink\" title=\"1、数据结构和算法\"></a>1、数据结构和算法</h3><p>数据结构和算法对于程序员的职业人生来说，那就是两个圆圈的交集部分，用心去掌握它，你的编程之路将会是坦途</p>\n<div align=\"center\"><img src=\"/images/hexo_post_188.png\" alt=\"\" width=\"350\"></div>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]},{"title":"读书笔记系列（9）——你不知道的JavaScript（上卷）","slug":"读书笔记系列（9）——你不知道的JavaScript（上卷）","date":"2017-10-10T11:42:12.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（9）——你不知道的JavaScript（上卷）.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这本书在 github 上很火，而中文译本迟迟没有发行，最近出了中卷，我很早之前就听说了该大作，然而一直没有时间拜读，现在实习告一段落了，终于可以静下心来品味经典了。</p>\n<h2 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h2><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p>\n<h3 id=\"分词-词法分析\"><a href=\"#分词-词法分析\" class=\"headerlink\" title=\"分词/词法分析\"></a>分词/词法分析</h3><p>将字符串分解成有意义的代码块，这些代码块被称为词法单元（token），例如：<code>var a = 2;</code>，会被分解为下面这些词法单元：var、a、=、2、；</p>\n<h3 id=\"解析-语法分析\"><a href=\"#解析-语法分析\" class=\"headerlink\" title=\"解析/语法分析\"></a>解析/语法分析</h3><p>将语法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，被称为“抽象语法树”（AST）。<code>var a = 2;</code> 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier (它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。</p>\n<h3 id=\"代码生成\"><a href=\"#代码生成\" class=\"headerlink\" title=\"代码生成\"></a>代码生成</h3><p>将 AST 转换为可执行代码。简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。 然而，比起那些编译过程只有三个步骤的语言的编译器，<strong>JavaScript 引擎要复杂得多</strong>。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。</p>\n<p>对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内。</p>\n<h3 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h3><p>首先介绍将要参与到对程序 <code>var a = 2;</code> 进行处理的过程中的演员们。</p>\n<h4 id=\"引擎\"><a href=\"#引擎\" class=\"headerlink\" title=\"引擎\"></a>引擎</h4><p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p>\n<h4 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h4><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>\n<h3 id=\"变量的赋值操作\"><a href=\"#变量的赋值操作\" class=\"headerlink\" title=\"变量的赋值操作\"></a>变量的赋值操作</h3><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。（我们在面试时会经常遇到变量为undefined的问题，其实就是这个道理）</p>\n<h4 id=\"编译器有话说\"><a href=\"#编译器有话说\" class=\"headerlink\" title=\"编译器有话说\"></a>编译器有话说</h4><p>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。</p>\n<p>讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</p>\n<h4 id=\"引擎和作用域的对话\"><a href=\"#引擎和作用域的对话\" class=\"headerlink\" title=\"引擎和作用域的对话\"></a>引擎和作用域的对话</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123; <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">2</span> );</span><br></pre></td></tr></table></figure>\n<p>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。</p>\n<blockquote>\n<p>引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?<br>作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎:哥们太够意思了!好吧，我来执行一下 foo。<br>引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?<br>作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。<br>引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。<br>引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?<br>作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。<br>引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。<br>引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。<br>作用域:放心吧，这个变量没有变动过，拿走，不谢。 引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。 ……</p>\n</blockquote>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 <code>var a = 2</code> 这样的声明会被分解成两个独立的步骤:</p>\n<ol>\n<li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>\n<li>接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li>\n</ol>\n<p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，但是如果对结果的操作是非法或不合理的，会抛出 TypeError 异常，或者直接抛出 ReferenceError 异常(严格模式下)。</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><h3 id=\"变量查找\"><a href=\"#变量查找\" class=\"headerlink\" title=\"变量查找\"></a>变量查找</h3><p>全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。 window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。</p>\n<p><strong>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</strong></p>\n<h3 id=\"欺骗词法\"><a href=\"#欺骗词法\" class=\"headerlink\" title=\"欺骗词法\"></a>欺骗词法</h3><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”(也可以说欺骗)词法作用域呢? JavaScript 中有两种机制来实现这个目的。</p>\n<ol>\n<li>eval</li>\n<li>with</li>\n</ol>\n<p>欺骗词法作用域会导致性能下降。</p>\n<h4 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h4><p>在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p>\n<p>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>; </span><br><span class=\"line\">    <span class=\"built_in\">eval</span>( str ); </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// ReferenceError: a is not defined </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">foo( <span class=\"string\">\"var a = 2\"</span> );</span><br></pre></td></tr></table></figure>\n<p>JavaScript 中还有其他一些功能效果和 <code>eval(..)</code> 很 相 似。setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们! new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。</p>\n<h4 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h4><p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。with 的副作用通过一个简单的例子就可以看到：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">2</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; </span><br><span class=\"line\">    b: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo( o1 );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( o1.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo( o2 );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( o2.a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2——不好，a 被泄漏到全局作用域上了!</span></span><br></pre></td></tr></table></figure>\n<p>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此<strong>这个对象的属性也会被处理为定义在这个作用域中的词法标识符</strong>。</p>\n<p>结合上面的例子，o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a=2 执行时，<strong>自动创建了一个全局变量</strong>(因为是非严格模式)。</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p>\n<h2 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h2><h3 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h3><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。</p>\n<h3 id=\"全局命名空间\"><a href=\"#全局命名空间\" class=\"headerlink\" title=\"全局命名空间\"></a>全局命名空间</h3><p>某些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyReallyCoolLibrary = &#123; </span><br><span class=\"line\">    awesome: <span class=\"string\">\"stuff\"</span>, </span><br><span class=\"line\">    doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    doAnotherThing: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"匿名和具名\"><a href=\"#匿名和具名\" class=\"headerlink\" title=\"匿名和具名\"></a>匿名和具名</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I waited 1 second!\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</p>\n<h3 id=\"然而，匿名函数也有几个缺点：\"><a href=\"#然而，匿名函数也有几个缺点：\" class=\"headerlink\" title=\"然而，匿名函数也有几个缺点：\"></a>然而，匿名函数也有几个缺点：</h3><ol>\n<li>匿名函数在栈追踪中不会显示出有意义的函数名，使得<strong>调试很困难</strong>。</li>\n<li>如果没有函数名，当函数需要引用自身时只能使用已经过期的<strong>arguments.callee</strong>引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li>\n<li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。<strong>一个描述性的名称可以让代码不言自明</strong>。</li>\n</ol>\n<p>综合考虑而言，始终给函数表达式命名是一个最佳实践（下面的例子叫做行内函数表达式）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeoutHandler</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// &lt;-- 快看，我有名字了! </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"I waited 1 second!\"</span> );</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<h3 id=\"立即执行函数表达式\"><a href=\"#立即执行函数表达式\" class=\"headerlink\" title=\"立即执行函数表达式\"></a>立即执行函数表达式</h3><p>立即执行函数表达式（IIFE）有两种形式：</p>\n<ol>\n<li>(function foo(){ .. })()</li>\n<li>(function foo(){ .. }())</li>\n</ol>\n<p>这两种形式在功能上是一致的，<strong>选择哪个全凭个人喜好</strong>。</p>\n<h3 id=\"IIFE的用途\"><a href=\"#IIFE的用途\" class=\"headerlink\" title=\"IIFE的用途\"></a>IIFE的用途</h3><h4 id=\"把它们当做函数调用并传递参数进去：\"><a href=\"#把它们当做函数调用并传递参数进去：\" class=\"headerlink\" title=\"把它们当做函数调用并传递参数进去：\"></a>把它们当做函数调用并传递参数进去：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)( <span class=\"built_in\">window</span> );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"解决-undefined-标识符的默认值被错误覆盖导致的异常-虽然不常见\"><a href=\"#解决-undefined-标识符的默认值被错误覆盖导致的异常-虽然不常见\" class=\"headerlink\" title=\"解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)\"></a>解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)</h4><p>将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 给其他代码挖了一个大坑!绝对不要这样做! </span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> undefined </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"string\">\"Undefined is safe here!\"</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\"><a href=\"#倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\" class=\"headerlink\" title=\"倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\"></a>倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>) </span>&#123; </span><br><span class=\"line\">    def( <span class=\"built_in\">window</span> );</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。</p>\n<h3 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h3><p>块作用域的例子：</p>\n<h4 id=\"with-1\"><a href=\"#with-1\" class=\"headerlink\" title=\"with\"></a>with</h4><p>with就是块作用域的一个例子（形式），用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效</p>\n<h4 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try/catch\"></a>try/catch</h4><p>try/catch 是 ES3 的规范，而很少有人注意到，<strong>catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效</strong></p>\n<blockquote>\n<p>尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境(除了老 版本的 IE 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。</p>\n</blockquote>\n<h4 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h4><p>ES6 引入的 let 关键字可以将变量绑定到所在的任意作用域中(通常是{ .. }内部)。换句话说，let 为其声明的变量隐式地了所在的块作用域。 但是，let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError! </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h4><p>ES6 还引入了 const，同样可以用来创建块作用域变量，但是其值是固定的</p>\n<h3 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h3><h4 id=\"先有鸡还是先有蛋\"><a href=\"#先有鸡还是先有蛋\" class=\"headerlink\" title=\"先有鸡还是先有蛋\"></a>先有鸡还是先有蛋</h4><p>首先，抛出两个例子，也是很经典的JS的“坑”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>关于这一奇怪现象，可以用一句话概括：<strong>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理</strong> 当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个——声明:var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。 换句话说，<strong>先有蛋（声明）后又鸡（赋值）</strong>；所以上面的两个例子会以如下形式进行处理： 例子一：（第一部分是编译，第二部分是执行）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">a = <span class=\"number\">2</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>例子二：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 不是 ReferenceError, 而是 TypeError!</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域(在这里是全局作用域)，因此foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式，那么就会赋值)。<strong>foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常</strong>。</p>\n<p>从上面的例子，我们还可以得出：<strong>函数声明会被提升，但是函数表达式不会被提升</strong></p>\n<h3 id=\"函数优先\"><a href=\"#函数优先\" class=\"headerlink\" title=\"函数优先\"></a>函数优先</h3><p>函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。考虑下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子会被引擎理解为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>从这两段代码我们可以得出两个结论：</p>\n<ol>\n<li>var foo 尽管出现在 function foo()…的声明之前，但它是重复的声明(因此<strong>被忽略</strong>了)，因为函数声明会被提升到普通变量之前。</li>\n<li>尽管重复的 var 声明会被忽略掉，但<strong>出现在后面的函数声明还是可以覆盖前面的</strong>。</li>\n</ol>\n<h2 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h2><h3 id=\"老生常谈，闭包是什么\"><a href=\"#老生常谈，闭包是什么\" class=\"headerlink\" title=\"老生常谈，闭包是什么\"></a>老生常谈，闭包是什么</h3><p>划重点：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 这一部分之前已经讲了很多次了，感觉这本书也没有很多新意，所以想了解闭包的童鞋可以参见我的另一篇文章：<a href=\"/20170405/closure-in-js.html\">前端面试系列（10）——JS中的闭包</a></p>\n<h3 id=\"不太显性的闭包\"><a href=\"#不太显性的闭包\" class=\"headerlink\" title=\"不太显性的闭包\"></a>不太显性的闭包</h3><p>其实，你已经写过的代码中一定到处都是闭包的身影。</p>\n<h4 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait(<span class=\"string\">\"Hello, closure!\"</span>);</span><br></pre></td></tr></table></figure>\n<p>将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域 的闭包，因此还保有对变量 message 的引用。wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，<strong>timer 函数依然保有 wait(..) 作用域的闭包</strong>。</p>\n<h4 id=\"jQuery-或其他-JS-框架\"><a href=\"#jQuery-或其他-JS-框架\" class=\"headerlink\" title=\"jQuery 或其他 JS 框架\"></a>jQuery 或其他 JS 框架</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setupBot</span>(<span class=\"params\">name, selector</span>) </span>&#123;</span><br><span class=\"line\">    $( selector ).click( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">activator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"string\">\"Activating: \"</span> + name ); </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setupBot( <span class=\"string\">\"Closure Bot 1\"</span>, <span class=\"string\">\"#bot_1\"</span> );</span><br><span class=\"line\">setupBot( <span class=\"string\">\"Closure Bot 2\"</span>, <span class=\"string\">\"#bot_2\"</span> );</span><br></pre></td></tr></table></figure>\n<p>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包!</p>\n<h4 id=\"IIFE\"><a href=\"#IIFE\" class=\"headerlink\" title=\"IIFE\"></a>IIFE</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么?因为函数(示例代码中的 IIFE)并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行(而外部作用域，也就是全局作用域也持有 a)。a 是通过普通的词法作用域查找而非闭包被发现的。 尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。</p>\n<h3 id=\"块作用域和闭包\"><a href=\"#块作用域和闭包\" class=\"headerlink\" title=\"块作用域和闭包\"></a>块作用域和闭包</h3><p>一道很经典的面试题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码在运行时会以每秒一次的频率输出五次 6，具体原因就不再赘述了。。而如果我们想让他连续输出1 2 3 4 5应该怎么办呢？有两种方法:</p>\n<h4 id=\"利用闭包\"><a href=\"#利用闭包\" class=\"headerlink\" title=\"利用闭包\"></a>利用闭包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">        &#125;, j*<span class=\"number\">1000</span> ); </span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"闭包-块作用域\"><a href=\"#闭包-块作用域\" class=\"headerlink\" title=\"闭包+块作用域\"></a>闭包+块作用域</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><h4 id=\"模块有两个主要特征：\"><a href=\"#模块有两个主要特征：\" class=\"headerlink\" title=\"模块有两个主要特征：\"></a>模块有两个主要特征：</h4><ol>\n<li>为创建内部作用域而调用了一个包装函数;</li>\n<li>包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>\n</ol>\n<p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览器或引擎有一个默认的“模块加载器”(可以被重载，但这远超出了我们的讨论范围)可以在导入模块时异步地加载模块文件。 模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。</p>\n<h4 id=\"动态作用域与词法作用域\"><a href=\"#动态作用域与词法作用域\" class=\"headerlink\" title=\"动态作用域与词法作用域\"></a>动态作用域与词法作用域</h4><p>下面一段代码很有意思：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2(不是3!)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    foo(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara=<span class=\"number\">2</span>;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>如果 JS 是动态作用域，上面将会输出 3，因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。 需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>\n<h2 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h2><h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>有两种常见的对于this的解释，但是它们都是错误的：</p>\n<h4 id=\"指向自身\"><a href=\"#指向自身\" class=\"headerlink\" title=\"指向自身\"></a>指向自身</h4><p>人们很容易把 this 理解成指向函数自身，然而如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符(变量)来引用它。 思考一下下面这两个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.count = <span class=\"number\">4</span>; <span class=\"comment\">// foo 指向它自身</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匿名(没有名字的)函数无法指向自身</span></span><br><span class=\"line\">&#125;,<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p>第一个函数被称为具名函数，在它内部可以使用 foo 来引用自身。 但是在第二个例子中，传入 setTimeout(..) 的回调函数没有名称标识符(这种函数被称为匿名函数)，因此无法从函数内部引用自身。</p>\n<h4 id=\"它的作用域\"><a href=\"#它的作用域\" class=\"headerlink\" title=\"它的作用域\"></a>它的作用域</h4><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。 <strong>每当你想要把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</strong></p>\n<h3 id=\"this到底是什么\"><a href=\"#this到底是什么\" class=\"headerlink\" title=\"this到底是什么\"></a>this到底是什么</h3><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</strong> 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>\n<h2 id=\"this全面解析\"><a href=\"#this全面解析\" class=\"headerlink\" title=\"this全面解析\"></a>this全面解析</h2><h3 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h3><p>在理解 this 的绑定过程之前，首先要理解调用位置：<strong>调用位置就是函数在代码中被调用的位置(而不是声明的位置)</strong>；然而做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。 下面通过一个例子来看看到底什么是调用栈和调用位置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是:baz</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置是全局作用域</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"baz\"</span> );</span><br><span class=\"line\">    bar(); <span class=\"comment\">// &lt;-- bar 的调用位置 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是 baz -&gt; bar</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置在 baz 中</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\">    foo(); <span class=\"comment\">// &lt;-- foo 的调用位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置在 bar 中</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">baz(); <span class=\"comment\">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p>\n<h4 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>this.a 被解析成了全局变量 a。为什么?因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此<strong>this会绑定到 undefined</strong> 这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是<strong>只有foo()运行在非strict mode下时，默认绑定才能绑定到全局对象；严格模式下与foo() 的调用位置无关：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>;</span><br><span class=\"line\">    foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>调用位置会使用 obj 上下文来引用函数</strong>，因此你可以说<strong>函数foo被调用时 obj 对象“拥有”或者“包含”它</strong>。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">42</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    obj2: obj2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj1.obj2.foo(); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h4><p>可以使用函数的 call(..) 和 apply(..) 方法。这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现在其他的参数上，但是现在我们不用考虑这些。 <strong>硬绑定</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.call( obj );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">setTimeout( bar, <span class=\"number\">100</span> ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 硬绑定的 bar 不可能再修改它的 this</span></span><br><span class=\"line\">bar.call( <span class=\"built_in\">window</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>无论我们如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype. bind，它的用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">3</span>);<span class=\"comment\">//23</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p>\n<h4 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h4><p>JS 中 new 的机制和面向类的语言完全不同：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>\n<ol>\n<li>创建(或者说构造)一个全新的对象。</li>\n<li>这个新对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>一个简单的例子来解释 new 绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar.a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。</strong></p>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><p>（原书中通过很多例子得到了上面四种绑定方式的优先级，这里就不再赘述了。。） 我们可以按照下面的顺序来进行判断：</p>\n<ol>\n<li>函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。 var bar = new foo()</li>\n<li>函数是否通过 call、apply(显式绑定)或者硬绑定调用?如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2)</li>\n<li>函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo()</li>\n<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo()</li>\n</ol>\n<p>然而，凡事总有例外。</p>\n<h4 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a>绑定例外</h4><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用的可能是默认绑定规则。</p>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara=<span class=\"number\">2</span>;</span><br><span class=\"line\">foo.call( <span class=\"literal\">null</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>一般，如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择。 然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。 划重点：<strong>Object.create(null)和{}很像，但是并不会创建Object.prototype 这个委托，所以它比 {}“更空”</strong></p>\n<h4 id=\"间接引用\"><a href=\"#间接引用\" class=\"headerlink\" title=\"间接引用\"></a>间接引用</h4><p>你有可能(有意或者无意地)创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。而间接引用最容易在赋值时发生：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>:<span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>:<span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此<strong>调用位置是 foo() 而不是 p.foo() 或者 o.foo()</strong>。根据我们之前说过的，这里会应用默认绑定。</p>\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><p>硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。 下面是一种被称为软绑定的方法，有时间的话可以研究一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Function</span>.prototype.softBind) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.softBind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 捕获所有 curried 参数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = \\[\\].slice.call( <span class=\"built_in\">arguments</span>, <span class=\"number\">1</span> );</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(</span><br><span class=\"line\">                (!<span class=\"keyword\">this</span> || <span class=\"keyword\">this</span> === (<span class=\"built_in\">window</span> || global)) ?</span><br><span class=\"line\">                    obj : <span class=\"keyword\">this</span></span><br><span class=\"line\">                curried.concat.apply( curried, <span class=\"built_in\">arguments</span> )</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = <span class=\"built_in\">Object</span>.create( fn.prototype );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this语法\"><a href=\"#this语法\" class=\"headerlink\" title=\"this语法\"></a>this语法</h3><p>ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定义的。<strong>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//this 继承自 foo()</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2, 不是3!</span></span><br></pre></td></tr></table></figure>\n<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不 行!)</p>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>对象可以通过两种形式定义:声明(文字)形式和构造形式。</p>\n<h4 id=\"文字形式（对象字面量）\"><a href=\"#文字形式（对象字面量）\" class=\"headerlink\" title=\"文字形式（对象字面量）\"></a>文字形式（对象字面量）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    key: value</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"构造形式\"><a href=\"#构造形式\" class=\"headerlink\" title=\"构造形式\"></a>构造形式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">myObj.key = value;</span><br></pre></td></tr></table></figure>\n<p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键值对，但是在构造形式中你必须逐个添加属性。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>在 JavaScrip t中一共有六种主要类型（语言类型）：</p>\n<ul>\n<li>string</li>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>object</li>\n</ul>\n<p>简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。 null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 “object”。实际上，<strong>null 本身是基本类型</strong>。</p>\n<blockquote>\n<p>原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。</p>\n</blockquote>\n<h3 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h3><p>JavaScript 中还有一些对象子类型，通常被称为内置对象。</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n</ul>\n<h3 id=\"自动转换\"><a href=\"#自动转换\" class=\"headerlink\" title=\"自动转换\"></a>自动转换</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strPrimitive = <span class=\"string\">\"I am a string\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( strPrimitive.length ); <span class=\"comment\">// 13</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( strPrimitive.charAt( <span class=\"number\">3</span> ) ); <span class=\"comment\">// \"m\"</span></span><br></pre></td></tr></table></figure>\n<p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为<strong>引擎自动把字面量转换成 String 对象</strong>，所以可以访问属性和方法。同样的事也会发生在数值字面量上 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式（只能通过 new Date() 创建一个 Date 对象）。</p>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"a\"</span>\\]; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>.a 语法通常被称为“<strong>属性访问</strong>”，[“a”] 语法通常被称为“<strong>键访问</strong>”。这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject\\[<span class=\"literal\">true</span>\\] = <span class=\"string\">\"foo\"</span>;</span><br><span class=\"line\">myObject\\[<span class=\"number\">3</span>\\] = <span class=\"string\">\"bar\"</span>;</span><br><span class=\"line\">myObject\\[myObject\\] = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"true\"</span>\\]; <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"3\"</span>\\]; <span class=\"comment\">// \"bar\"</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"\\[object Object\\]\"</span>\\]; <span class=\"comment\">// \"baz\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = \\[ <span class=\"string\">\"foo\"</span>, <span class=\"number\">42</span>, <span class=\"string\">\"bar\"</span> \\];</span><br><span class=\"line\">myArray.baz = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\">myArray.length; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myArray.baz; <span class=\"comment\">// \"baz\"</span></span><br></pre></td></tr></table></figure>\n<p>可以看到虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，<strong>数组的 length 值并未发生变化</strong>。但是，如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标(因此会修改数组的内容而不是添加一个属性)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = \\[ <span class=\"string\">\"foo\"</span>, <span class=\"number\">42</span>, <span class=\"string\">\"bar\"</span> \\];</span><br><span class=\"line\">myArray\\[<span class=\"string\">\"4\"</span>\\] = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\">myArray.length; <span class=\"comment\">// 5</span></span><br><span class=\"line\">myArray\\[<span class=\"number\">4</span>\\]; <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\">myArray\\[<span class=\"number\">3</span>\\]; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h3><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"a\"</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"number\">2</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h3><p>有时候你会希望属性或者对象是不可改变(无论有意还是无意)的，在 ES5 中可以通过很多种方法来实现：</p>\n<h4 id=\"对象常量\"><a href=\"#对象常量\" class=\"headerlink\" title=\"对象常量\"></a>对象常量</h4><p>结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性(不可修改、重定义或者删除):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"FAVORITE_NUMBER\"</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"number\">42</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"禁止扩展\"><a href=\"#禁止扩展\" class=\"headerlink\" title=\"禁止扩展\"></a>禁止扩展</h4><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions( myObject );</span><br><span class=\"line\">myObject.b = <span class=\"number\">3</span>;</span><br><span class=\"line\">myObject.b; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"密封\"><a href=\"#密封\" class=\"headerlink\" title=\"密封\"></a>密封</h4><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable: false。 所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。</p>\n<h4 id=\"冻结\"><a href=\"#冻结\" class=\"headerlink\" title=\"冻结\"></a>冻结</h4><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable: false，这样就无法修改它们的值。 <strong>这个方法是你可以应用在对象上的级别最高的不可变性</strong>，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。</p>\n<h4 id=\"数组上不要用for-in循环\"><a href=\"#数组上不要用for-in循环\" class=\"headerlink\" title=\"数组上不要用for..in循环\"></a>数组上不要用for..in循环</h4><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><h4 id=\"ES5中增加了一些数组的辅助迭代器：\"><a href=\"#ES5中增加了一些数组的辅助迭代器：\" class=\"headerlink\" title=\"ES5中增加了一些数组的辅助迭代器：\"></a>ES5中增加了一些数组的辅助迭代器：</h4><ol>\n<li>forEach(..)：遍历数组中的所有值并忽略回调函数的返回值</li>\n<li>every(..)：会一直运行直到回调函数返回 false</li>\n<li>some(..)：会一直运行直到回调函数返回 true</li>\n</ol>\n<h2 id=\"混合对象“类”\"><a href=\"#混合对象“类”\" class=\"headerlink\" title=\"混合对象“类”\"></a>混合对象“类”</h2><h3 id=\"类的机制\"><a href=\"#类的机制\" class=\"headerlink\" title=\"类的机制\"></a>类的机制</h3><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息(状态)。 类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。</p>\n<h4 id=\"JS中的类\"><a href=\"#JS中的类\" class=\"headerlink\" title=\"JS中的类\"></a>JS中的类</h4><p>在传统的面向类的语言中 super 有一个功能，就是<strong>从子类的构造函数中通过 super 可以直接调用父类的构造函数</strong>。通常来说这没什么问题，因为对于真正的类来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——<strong>实际上“类”是属于构造函数的</strong>(类似 Foo.prototype… 这样的类型引用)。由于<strong>JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中</strong>，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用</p>\n<blockquote>\n<p>注: 其实这一部分还蛮重要的，而原文也通过比较大量的篇幅对JS中的“类”进行了介绍，只不过我感觉没有什么与众不同之处就略过了，对这一部分还不太熟悉的童鞋可以自己研究一下。。</p>\n</blockquote>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"Prototype\"><a href=\"#Prototype\" class=\"headerlink\" title=\"[[Prototype]]\"></a>[[Prototype]]</h3><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。 而[[Prototype]]的作用是：对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个关联到 anotherObject 的对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到(并且是 enumerable)的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链(无论属性是否可枚举)</p>\n<h3 id=\"Object-prototype\"><a href=\"#Object-prototype\" class=\"headerlink\" title=\"Object.prototype\"></a>Object.prototype</h3><p><strong>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype</strong>。由于所有的“普通”(内置，不是特定主机的扩展)对象都“源于”(或者说把 [[Prototype]] 链的顶端设置为)这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。</p>\n<h3 id=\"属性屏蔽\"><a href=\"#属性屏蔽\" class=\"headerlink\" title=\"属性屏蔽\"></a>属性屏蔽</h3><p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为<strong>myObject.foo 总是会选择原型链中最底层的 foo 属性</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a++; <span class=\"comment\">// 隐式屏蔽!</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>尽管 myObject.a++ 看起来应该(通过委托)查找并增加 anotherObject.a 属性，但是别忘了<strong>++操作相当于myObject.a = myObject.a + 1</strong>。因此++操作首先会通过[[Prototype]]查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐!</p>\n<h3 id=\"“类”\"><a href=\"#“类”\" class=\"headerlink\" title=\"“类”\"></a>“类”</h3><h4 id=\"“类”函数\"><a href=\"#“类”函数\" class=\"headerlink\" title=\"“类”函数\"></a>“类”函数</h4><p>所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype; <span class=\"comment\">// &#123; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这个对象通常被称为 Foo 的原型，然而，如果是我的话就 会叫它“之前被称为 Foo 的原型的那个对象”。好吧我是开玩笑的，你觉得“<strong>被贴上‘Foo 点 prototype’标签的对象</strong>”这个名字怎么样？最直接的解释就是，这个对象是在调用new Foo()时创建的，最后会被(有点武断地)关联到这个“Foo 点 prototype”对象上。</p>\n<h4 id=\"继承与原型\"><a href=\"#继承与原型\" class=\"headerlink\" title=\"继承与原型\"></a>继承与原型</h4><p>继承意味着复制操作，JavaScript(默认)并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。委托(参见第 6 章)这个术语可以更加准确地描述 JavaScript 中对象的关联机制。</p>\n<h4 id=\"构造函数还是调用\"><a href=\"#构造函数还是调用\" class=\"headerlink\" title=\"构造函数还是调用\"></a>构造函数还是调用</h4><p>在JS中，<strong>new 会劫持所有普通函数并用构造对象的形式来调用它</strong>。换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是<strong>当且仅当使用 new 时，函数调用会变成“构造函数调用”</strong>。</p>\n<h4 id=\"constructor-并不表示被构造\"><a href=\"#constructor-并不表示被构造\" class=\"headerlink\" title=\"constructor 并不表示被构造\"></a>constructor 并不表示被构造</h4><p>function Foo() { /<em> .. </em>/ }<br>Foo.prototype = { /<em> .. </em>/ }; // 创建一个新原型对象<br>var a1 = new Foo();<br>a1.constructor === Foo; // false! a1.constructor === Object; // true!</p>\n<p>a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性(不过<strong>默认的 Foo.prototype 对象有这个属性</strong>!)，所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。 a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。</p>\n<h4 id=\"（原型）继承\"><a href=\"#（原型）继承\" class=\"headerlink\" title=\"（原型）继承\"></a>（原型）继承</h4><h3 id=\"Object-setPrototypeOf-…\"><a href=\"#Object-setPrototypeOf-…\" class=\"headerlink\" title=\"Object.setPrototypeOf(…)\"></a>Object.setPrototypeOf(…)</h3><p>ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6 之前需要抛弃默认的 Bar.prototype</span></span><br><span class=\"line\">Bar.ptototype = <span class=\"built_in\">Object</span>.create( Foo.prototype );</span><br><span class=\"line\"><span class=\"comment\">// ES6 开始可以直接修改现有的 Bar.prototype </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象关联\"><a href=\"#对象关联\" class=\"headerlink\" title=\"对象关联\"></a>对象关联</h3><p>[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。 这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p>\n<h2 id=\"行为委托\"><a href=\"#行为委托\" class=\"headerlink\" title=\"行为委托\"></a>行为委托</h2><p>委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Task = &#123;</span><br><span class=\"line\">    setID: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ID</span>) </span>&#123; <span class=\"keyword\">this</span>.id = ID; &#125;,</span><br><span class=\"line\">    outputID: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.id ); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 让XYZ委托Task</span></span><br><span class=\"line\">XYZ = <span class=\"built_in\">Object</span>.create( Task );</span><br><span class=\"line\"></span><br><span class=\"line\">XYZ.prepareTask = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ID,Label</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setID( ID );</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.label = Label;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">XYZ.outputTaskDetails = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.outputID();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.label );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ABC = Object.create( Task );</span></span><br><span class=\"line\"><span class=\"comment\">// ABC ... = ...</span></span><br></pre></td></tr></table></figure>\n<p>在上面这段代码中，Task 和 XYZ 并不是类（或者函数），它们是对象。<strong>XYZ 通过 Object. create(..) 创建，它的 [[Prototype]] 委托了 Task 对象</strong></p>\n<h3 id=\"互相委托（禁止）\"><a href=\"#互相委托（禁止）\" class=\"headerlink\" title=\"互相委托（禁止）\"></a>互相委托（禁止）</h3><p>你无法在两个或两个以上互相(双向)委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。如果你引用了一个两边都不存在的属性或者方法，那就会在 [[Prototype]] 链上产生一个<strong>无限递归的循环</strong>。 所以互相委托是被禁止的。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>JavaScript 规范并不会控制浏览器中开发者工具对于特定值或者结构的表示方式，所以浏览器和工具的解析结果并不一定相同。下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a1 = <span class=\"keyword\">new</span> Foo(); </span><br><span class=\"line\">a1; <span class=\"comment\">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>这段代码在chrome中会输出：Foo {}；而在Firefox中会得到Object {}</strong></p>\n<p>Chrome 实际上想说的是“<strong>{} 是一个空对象，由名为 Foo 的函数构造</strong>”。Firefox 想说的是“<strong>{} 是一个空对象，由 Object 构造</strong>”。之所以有这种细微的差别，是因为 <strong>Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性</strong>，但是其他浏览器并不会跟踪这些额外的信息。</p>\n<p>然而，这个行为被认定是 Chrome 的一个 bug，当你读到此书时，它可能已经被修复了。所以你看到的可能是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1; <span class=\"comment\">// Object &#123;&#125;。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h3><p>相比“类”的构造方式，<strong>对象关联可以更好地支持关注分离（separation of concerns）原则</strong>，创建和初始化并不需要合并为一个步骤。 对象关联除了能让代码看起来更简洁(并且更具扩展性)外还可以通过行为委托模式简化代码结构。</p>\n<h3 id=\"更好的语法\"><a href=\"#更好的语法\" class=\"headerlink\" title=\"更好的语法\"></a>更好的语法</h3><p>在 ES6 中，你可以使用对象的字面形式(这样就可以使用简洁方法定义)来改写之前繁琐的属性赋值语法(比如 AuthController 的定义)，然后用 Object.setPrototypeOf(..) 来修改它的 [[Prototype]]:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用更好的对象字面形式语法和简洁方法 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> AuthController = &#123;</span><br><span class=\"line\">    errors: \\[\\],</span><br><span class=\"line\">    checkAuth() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    server(url, data) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在把 AuthController 关联到 LoginController</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( AuthController, LoginController );</span><br></pre></td></tr></table></figure>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。</p>\n<p>在 js 中，instanceof 语法会产生语义困惑而且非常不直观。如果你想检查对象 a1 和某个对象的关系，那必须使用另一个引用该对象的函数才行——你不能直接判断两个对象是否关联。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* .. */</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* .. */</span> &#125;</span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create( Foo.prototype ); <span class=\"comment\">// 让Foo和Bar互相关联</span></span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype <span class=\"keyword\">instanceof</span> Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\">Bar <span class=\"keyword\">instanceof</span> Foo; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>然而，又回到上面的那个问题，<strong>如果通过对象关联的方式构造对象，内省的方法将更加简洁并且清晰</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Foo = &#123; <span class=\"comment\">/* .. */</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Bar = <span class=\"built_in\">Object</span>.create( Foo ); <span class=\"comment\">// 让Foo和Bar互相关联</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"built_in\">Object</span>.create( Bar ); <span class=\"comment\">// 让b1关联到Foo和Bar</span></span><br><span class=\"line\"></span><br><span class=\"line\">Foo.isPrototypeOf( Bar ); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf( Bar ) === Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Foo.isPrototypeOf( b1 ); <span class=\"comment\">// true </span></span><br><span class=\"line\">Bar.isPrototypeOf( b1 ); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf( b1 ) === Bar; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"ES6中的Class\"><a href=\"#ES6中的Class\" class=\"headerlink\" title=\"ES6中的Class\"></a>ES6中的Class</h3><p>除了语法更好看之外，ES6 还解决了什么问题？</p>\n<ol>\n<li>（基本上）不再引用杂乱的 .prototype 了；</li>\n<li>不再需要通过 Object.create(..) 来替换 .prototype 对象，也不需要设置 .__proto__ 或者 Object.setPrototypeOf(..)；</li>\n<li>可以通过 super(..) 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法；</li>\n<li>class 字面语法不能声明属性(只能声明方法)。看起来这是一种限制，但是它会排除掉许多不好的情况，可以帮助你避免犯错；</li>\n<li>可以通过 extends 很自然地扩展对象(子)类型，甚至是内置的对象(子)类型，比如 Array 或 RegExp。</li>\n</ol>\n<p>然而，class 语法并没有解决所有的问题，你可能会认为 ES6 的 class 语法是向 JavaScript 中引入了一种新的“类”机制，其实不是这样。class 基本上只是现有 [[Prototype]](委托!)机制的一种语法糖。 也就是说，class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你 (有意或无意)修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为<strong>它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托。</strong> 除此之外，class 还有以下问题：</p>\n<ol>\n<li><strong>class 语法无法定义类成员属性（只能定义方法）；</strong></li>\n<li>class 语法仍然面临<strong>意外屏蔽</strong>的问题；</li>\n<li>super 并不是动态绑定this的，它会在声明时“静态”绑定。（可以通过 toMethod(…) 手动修改 super 绑定）</li>\n</ol>\n<p>综上，class 最大的问题在于，像传统的类一样)它的语法有时会让你认为，定义了一个 class 后，它就变成了一个(未来会被实例化的)东西的静态定义。<strong>你会彻底忽略 C 是一个对象，是一个具体的可以直接交互的东西。</strong></p>\n<p>ES6 的 class 想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让 JavaScript 更加难以理解。</p>\n","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（8）——CSS Secrets","slug":"读书笔记系列（8）——CSS Secrets","date":"2017-07-06T10:21:45.000Z","updated":"2019-03-29T10:17:04.624Z","comments":true,"path":"api/articles/读书笔记系列（8）——CSS Secrets.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_248.png","content":"<p>这本书被誉为近十年来最出色的一本 CSS 相关书籍，作者是被誉为 “CSS一姐” 的 Lea Verou，是 W3C CSS 工作组特邀专家，而我看的是这本书的译本（翻译为 CSS 揭秘），作者叫张鹏，是百姓网的前端架构师；译者翻译的不错，同时还加入了自己的注解，如果对这本书有任何疑问，可以<a href=\"http://book.cssmagic.net\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看译者的注解。作者通过示例介绍了 CSS 的 47 个技巧，并将其归类至 7 大类中，由于这本书的绝大部分内容都是很值得学习的，所以关于这本书的读书笔记可能会比较长，强烈推荐你认真阅读一下这本书，是一本不可多得的 CSS 进阶教材。</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h3 id=\"currentColor\"><a href=\"#currentColor\" class=\"headerlink\" title=\"currentColor\"></a>currentColor</h3><p>这是一个特殊的颜色关键字，它是 CSS 中有史以来的第一个变量，举个例子，加入我们想让所有的水平分割线（所有 <code>&lt;hr&gt;</code> 元素）自动与文本的颜色一致，可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">hr</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: .<span class=\"number\">5em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: currentColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>currentColor 其实不仅仅可以用到 background 属性，还可以用在 border-color、outline-color、text-shadow 和 box-shadow 等等</p>\n<h3 id=\"避免不必要的媒体查询\"><a href=\"#避免不必要的媒体查询\" class=\"headerlink\" title=\"避免不必要的媒体查询\"></a>避免不必要的媒体查询</h3><ul>\n<li>使用百分比长度来取代固定长度，如果实在做不到这一点，也应该尝试使用与视口相关的单位（vw、vh、vmin  和vmax）</li>\n<li>当你需要在较大分辨率下得到固定宽度时，使用 max-width 而不是 width，因为它可以适应较小的分辨率，而无需使用媒体查询。</li>\n<li>不要忘记为替换元素(比如 img、object、video、iframe 等)设置一个 max-width，值为 100%。</li>\n<li>假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化，background-size: cover 这个属性都可以做到。但是，我们也要时刻牢记——带宽并不是无限的，因此在移动网页中通过 CSS 把一张大图缩小显示往往是不太明智的。</li>\n<li>当图片(或其他元素)以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局(即 Flexbox)或者 display: inline-block 加上常规的文本折行行为，都可以实现这一点。</li>\n<li>在使用多列文本时，指定 column-width(列宽)而不是指定 column-count(列数)，这样它就可以在较小的屏幕上自动显示为单列布局。</li>\n</ul>\n<h3 id=\"合理使用简写\"><a href=\"#合理使用简写\" class=\"headerlink\" title=\"合理使用简写\"></a>合理使用简写</h3><p>以下两行 CSS 代码并不是等价的：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">rebeccapurple</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-color</span>: <span class=\"selector-tag\">rebeccapurple</span>;</span><br></pre></td></tr></table></figure>\n<p>前者是简写，它可以确保你得到 rebeccapurple 纯色背景 但是如果你用的是展开式的单个属性（background-color），那这个元素的背景最终有可能会显示为一个粉色的渐变图案、一张猫的图片或其他任何东西，因为同时可能会有一条 background-image 声明在起作用。所以展开式属性并不会帮助你清空所有相关的其他属性，从而有可能会被其他属性所干扰。</p>\n<h3 id=\"预处理器不是完美无缺的\"><a href=\"#预处理器不是完美无缺的\" class=\"headerlink\" title=\"预处理器不是完美无缺的\"></a>预处理器不是完美无缺的</h3><ul>\n<li>CSS 的<strong>文件体积</strong>和<strong>复杂度</strong>可能会失控</li>\n<li><strong>调试难度</strong>会增加（但是 SourceMap 正是为了解决这个痛点而生的，它会告诉浏览器哪些编译生成的 CSS 代码对应哪些预处理器 CSS 代码，精确到行号）</li>\n<li>预处理器在开发过程中引入了一定程度的<strong>延时</strong></li>\n<li><strong>学习成本</strong>变高</li>\n<li>预处理器是由人类写出来的，就像所有由 人类写出来的大型程序一样，<strong>它们有它们自己的 bug</strong></li>\n</ul>\n<h3 id=\"预处理器中不可能做到的变量玩法\"><a href=\"#预处理器中不可能做到的变量玩法\" class=\"headerlink\" title=\"预处理器中不可能做到的变量玩法\"></a>预处理器中不可能做到的变量玩法</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> &#123; <span class=\"attribute\">--accent-color</span>: purple; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ol</span> &#123; <span class=\"attribute\">--accent-color</span>: rebeccapurple; &#125; </span><br><span class=\"line\"><span class=\"selector-tag\">li</span> &#123; <span class=\"attribute\">background</span>: <span class=\"built_in\">var</span>(--accent-color); &#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码的意图是：在有序列表中，列表项的背景色将是 rebeccapurple；但在无序列表中，列表项的背景色将是 purple</p>\n<h2 id=\"背景与边框\"><a href=\"#背景与边框\" class=\"headerlink\" title=\"背景与边框\"></a>背景与边框</h2><h3 id=\"半透明边框\"><a href=\"#半透明边框\" class=\"headerlink\" title=\"半透明边框\"></a>半透明边框</h3><p>假设我们想给一个容器设置一层白色背景和一道半透明白色边框，body 的背景会从它的半透明边框透上来。我们最开始的尝试可能是这样的:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border</span>: 10<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.5</span>); </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">white</span>;</span><br></pre></td></tr></table></figure>\n<p>但实际上，上面这段代码让 body 的背景从半透明白色边框处透了上来，这实际上得到的效果跟纯白实色的边框看起来完全一样。 所以我们可以通过 background-clip 属性来调整上述默认行为所带来的不便，这个属性的初始值是 border-box，意味着背景会被元素的 border box(边框的外沿框)裁切掉。如果不希望背景侵入边框所在的范围，我们要做的就是把它的值设为 padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border</span>: 10<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.5</span>); </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">white</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-clip</span>: <span class=\"selector-tag\">padding-box</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多重边框\"><a href=\"#多重边框\" class=\"headerlink\" title=\"多重边框\"></a>多重边框</h3><h4 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h4><p>box-shadow 还接受第四个参数（称作”扩张半径”），通过指定正值或负值，可以让投影面积加大或者减小。一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的“投影”其实就像一道实线边框。这并没有什么了不起的，因为你完全可以用 border 属性来生成完全一样的边框效果。不过 box-shadow 的好处在于，<strong>它支持逗号分隔语法，我们可以创建任意数量的投影</strong>，但是多重投影方案有一些注意事项： 投影不会影响布局，也不会受到 box-sizing 属性的影响。不过，你可以通过<strong>内边距或外边距</strong>(这取决于投影是内嵌和还是外扩的)来额外模拟出边框所需要占据的空间。 通过 box-shadow 创建出的假”边框’出现在元素的外圈，它们并不会响应鼠标事件，比如悬停或点击。可以通过给 box-shadow 加上 inset 关键字，来使投影绘制在元素的内圈，此时还需要额外的内边距来腾出足够的空隙</p>\n<h4 id=\"ouline\"><a href=\"#ouline\" class=\"headerlink\" title=\"ouline\"></a>ouline</h4><p>在某些情况下，你可能只需要两层边框，那就可以先设置一层常规边框，再加上 outline(描边)属性来产生外层的边框。这种方法的优点在于边框样式十分灵活（box-shadow 无法产生虚线边框），而且可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，但是同样有一些需要注意的地方：</p>\n<ul>\n<li>只适用于双层”边框”的场景，因为 outline 不接受逗号</li>\n<li>outline 产生的边框不一定会贴合 border-radius 产生的圆角</li>\n<li>对于 outline 的表现，各个浏览器可能会有所不同，最好在不同浏览器中完整地测试最终效果</li>\n</ul>\n<h3 id=\"灵活的背景定位\"><a href=\"#灵活的背景定位\" class=\"headerlink\" title=\"灵活的背景定位\"></a>灵活的背景定位</h3><h4 id=\"background-position\"><a href=\"#background-position\" class=\"headerlink\" title=\"background-position\"></a>background-position</h4><p>background-position 允许我们指定背景图片距离任意角的偏移量，只要我们在偏移量前面指定关键字：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">url</span>(<span class=\"selector-tag\">code-pirate</span><span class=\"selector-class\">.svg</span>) <span class=\"selector-tag\">no-repeat</span> <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: <span class=\"selector-tag\">right</span> 20<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">bottom</span> 10<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h4><p>背景图片的 background-position 属性是默认相对于 padding box 的左上角的，但是 background-origin 可以改变这种行为：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding</span>: 10<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">url</span>(\"<span class=\"selector-tag\">code-pirate</span><span class=\"selector-class\">.svg</span>\") <span class=\"selector-tag\">no-repeat</span> <span class=\"selector-id\">#58abottom</span> <span class=\"selector-tag\">right</span>; <span class=\"comment\">/* 或 100% 100% */</span> </span><br><span class=\"line\"><span class=\"selector-tag\">background-origin</span>: <span class=\"selector-tag\">content-box</span>;</span><br></pre></td></tr></table></figure>\n<p>此时，background-position 将以内容区的边缘作为基准，也就是此时图片距离边角的偏移量就跟内边距保持一致了</p>\n<h4 id=\"calc\"><a href=\"#calc\" class=\"headerlink\" title=\"calc\"></a>calc</h4><p>把背景图片定位到距离底边 10px 且距离右边 20px 的位置。如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个 100% - 20px 的水平偏移量，以及 100% - 10px 的垂直偏移量。calc() 函数可以完美地在 background-position 属性中使用：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">url</span>(\"<span class=\"selector-tag\">code-pirate</span><span class=\"selector-class\">.svg</span>\") <span class=\"selector-tag\">no-repeat</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>) <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 10<span class=\"selector-tag\">px</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"边框内圆角\"><a href=\"#边框内圆角\" class=\"headerlink\" title=\"边框内圆角\"></a>边框内圆角</h3><p>有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状，如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_248.png\" alt=\"\" width=\"400\"></div>\n\n<p>如果只需要达成简单地实色效果，我们可以只用一个元素：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">tan</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">border-radius</span>: <span class=\"selector-class\">.8em</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">padding</span>: 1<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 0 0 0 <span class=\"selector-class\">.6em</span> <span class=\"selector-id\">#655</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">outline</span>: <span class=\"selector-class\">.6em</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#655</span>;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码产生的视觉效果如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_249.png\" alt=\"\" width=\"\"></div>\n\n<p>我们受益于两个事实：<strong>描边并不会跟着元素的圆角走(因而显示出直角)，但 box-shadow 却是会的</strong>。因此，如果我们把这两者叠加到一起，box-shadow 会刚好填补描边和容器圆角之间的空隙，这两者的组合达成了我们想要的效果。</p>\n<h3 id=\"条纹背景\"><a href=\"#条纹背景\" class=\"headerlink\" title=\"条纹背景\"></a>条纹背景</h3><p>假如我们有一条基本的垂直现行渐变，颜色从 #fb3 过渡到 #58a：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 20%, <span class=\"selector-id\">#58a</span> 80%);</span><br></pre></td></tr></table></figure>\n<h4 id=\"水平条纹\"><a href=\"#水平条纹\" class=\"headerlink\" title=\"水平条纹\"></a>水平条纹</h4><p>现在容器顶部的 20% 区域被填充为 #fb3 实色，而底部 20% 区域被 填充为 #58a 实色。真正的渐变只出现在容器 60% 的高度区域。如果我们把两个色标重合在一起（改为 50% 和 50%）， 会发生什么?</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 50%, <span class=\"selector-id\">#58a</span> 50%);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_250.png\" alt=\"\" width=\"\"></div>\n\n<p>所以，本质上，我们通过垂直线性渐变创建了两条巨大的水平条纹 我们还可以通过 background-size 来调整其尺寸，然后由于背景在默认情况下是重复平铺的，整个容器其实已经被填满了水平条纹：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 50%, <span class=\"selector-id\">#58a</span> 50%); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_251.png\" alt=\"\" width=\"\"></div>\n\n<p>还有一条规范是：如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。这意味着，如果我们把第二个色标的位置值设置为 0，那它的位置就总是会被浏览器调整为前一个色标的位置值：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 30%, <span class=\"selector-id\">#58a</span> 0); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<p>如果要创建超过两种颜色的条纹，也是很容易的。举例来说，下面的代码可以生成三种颜色的水平条纹：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 33<span class=\"selector-class\">.3</span>%,<span class=\"selector-id\">#58a</span> 0, <span class=\"selector-id\">#58a</span> 66<span class=\"selector-class\">.6</span>%, <span class=\"selector-tag\">yellowgreen</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 45<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"垂直条纹\"><a href=\"#垂直条纹\" class=\"headerlink\" title=\"垂直条纹\"></a>垂直条纹</h4><p>我们只需要在开头加上一个额外的参数来指定渐变的方向（但是我们还需要把 background-size 的值颠倒一下）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">to</span> <span class=\"selector-tag\">right</span>, <span class=\"comment\">/* 或 90deg */</span> <span class=\"selector-id\">#fb3</span> 50%, <span class=\"selector-id\">#58a</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 30<span class=\"selector-tag\">px</span> 100%;</span><br></pre></td></tr></table></figure>\n<h4 id=\"斜向条纹\"><a href=\"#斜向条纹\" class=\"headerlink\" title=\"斜向条纹\"></a>斜向条纹</h4><p>我们需要用单个贴片包包含四条条纹，而不是两条，只有这样才可能做到无缝拼接：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_252.png\" alt=\"\" width=\"\"></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>,<span class=\"selector-id\">#fb3</span> 25%, <span class=\"selector-id\">#58a</span> 0, <span class=\"selector-id\">#58a</span> 50%,<span class=\"selector-id\">#fb3</span> 0, <span class=\"selector-id\">#fb3</span> 75%, <span class=\"selector-id\">#58a</span> 0); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 30<span class=\"selector-tag\">px</span> 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<p>但是，如果我们想得到条纹宽度为 15px 的背景，则需要借助<strong>勾股定理</strong>进行计算，具体原理就不在赘述，看上面图应该能看出来</p>\n<h4 id=\"更好的斜向条纹\"><a href=\"#更好的斜向条纹\" class=\"headerlink\" title=\"更好的斜向条纹\"></a>更好的斜向条纹</h4><p>一个鲜为人知的真相是 linear-gradient() 和 radial-gradient() 还各有一个循环式的加强版：repeating-linear-gradient() 和 repeating-radial-gradient()。 它们的工作方式跟前两者类似，只有一点不同：<strong>色标是无限循环重复的，直到填满整个背景</strong>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">repeating-linear-gradient</span>(60<span class=\"selector-tag\">deg</span>,<span class=\"selector-id\">#fb3</span>, <span class=\"selector-id\">#fb3</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0, <span class=\"selector-id\">#58a</span> 30<span class=\"selector-tag\">px</span>);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_253.png\" alt=\"\" width=\"\"></div>\n\n<p>在这个方法中，不论条纹的角度如何，我们在创建双色条纹时都需要用到四个色标</p>\n<h4 id=\"灵活的同色系条纹\"><a href=\"#灵活的同色系条纹\" class=\"headerlink\" title=\"灵活的同色系条纹\"></a>灵活的同色系条纹</h4><p>如果我们想要的条纹图案并不是由差异极大的几种颜色组成的，而是属于同一色系，只是在明度方面有轻微差异的话，我们可以<strong>把最深的颜色指定为背景色，同时把半透明白色的条纹叠加在背景色之上来得到浅色条纹</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span>: <span class=\"selector-tag\">repeating-linear-gradient</span>(30<span class=\"selector-tag\">deg</span>,</span><br><span class=\"line\">                    <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.1</span>),</span><br><span class=\"line\">                    <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.1</span>) 15<span class=\"selector-tag\">px</span>,</span><br><span class=\"line\">                    <span class=\"selector-tag\">transparent</span> 0, <span class=\"selector-tag\">transparent</span> 30<span class=\"selector-tag\">px</span>);</span><br></pre></td></tr></table></figure>\n<p>我们现在只需要修改一个地方就可以改变所有颜色了。我们还得到了一个额外的好处，对于那些不支持 CSS 渐变的浏览器来说，这里的背景色还起到了回退的作用</p>\n<h3 id=\"复杂的背景图案\"><a href=\"#复杂的背景图案\" class=\"headerlink\" title=\"复杂的背景图案\"></a>复杂的背景图案</h3><h4 id=\"网格\"><a href=\"#网格\" class=\"headerlink\" title=\"网格\"></a>网格</h4><p>做法：<strong>把水平和垂直的条纹叠加起来</strong>；在某些情况下，我们希望网格中每个格子的大小可以调整，而网格线条的粗细同时保持固定。此时可以使用长度而不是百分比作为色标。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span><span class=\"selector-pseudo\">:linear-gradient(white</span> 1<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0),<span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">white</span> 1<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 30<span class=\"selector-tag\">px</span> 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"波点\"><a href=\"#波点\" class=\"headerlink\" title=\"波点\"></a>波点</h4><p>径向渐变能够创建的最简单的图案是圆点的阵列；我们可以生成两层圆点阵列图案，并把它们的背景定位错开，这样就可以得到真正的波点图案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background: #655;</span><br><span class=\"line\">background-image: radial-gradient(tan 30%, transparent 0),radial-gradient(tan 30%, transparent 0); </span><br><span class=\"line\">background-size: 30px 30px;</span><br><span class=\"line\">background-position: 0 0, 15px 15px;</span><br></pre></td></tr></table></figure>\n<h4 id=\"棋盘\"><a href=\"#棋盘\" class=\"headerlink\" title=\"棋盘\"></a>棋盘</h4><p>棋盘图案是可以通过平铺生成的，平铺成这个图案的典型贴片包含两种不同颜色的方块，且相互间隔，这里的窍门在于用两个直角三角形来拼合出我们想要的方块</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#eee</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#bbb</span> 25%, <span class=\"selector-tag\">transparent</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 75%, <span class=\"selector-id\">#bbb</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#bbb</span> 25%, <span class=\"selector-tag\">transparent</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 75%, <span class=\"selector-id\">#bbb</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 0 0, 15<span class=\"selector-tag\">px</span> 15<span class=\"selector-tag\">px</span>,15<span class=\"selector-tag\">px</span> 15<span class=\"selector-tag\">px</span>, 30<span class=\"selector-tag\">px</span> 30<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 30<span class=\"selector-tag\">px</span> 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CSS3图案库\"><a href=\"#CSS3图案库\" class=\"headerlink\" title=\"CSS3图案库\"></a>CSS3图案库</h4><p><a href=\"http://lea.verou.me/css3patterns/\" target=\"_blank\" rel=\"noopener\">lea.verou.me/css3patterns</a>，展示了 CSS 渐变早在 2011 年就能够实现的效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_254.png\" alt=\"\" width=\"\"></div>\n\n<h4 id=\"SVG图案库\"><a href=\"#SVG图案库\" class=\"headerlink\" title=\"SVG图案库\"></a>SVG图案库</h4><p><a href=\"http://philbit.com/svgpatterns\" target=\"_blank\" rel=\"noopener\">philbit.com/svgpatterns</a>，这个网站是 CSS 图案库的 SVG 版实现</p>\n<h4 id=\"Bennett-Feely-的图案库\"><a href=\"#Bennett-Feely-的图案库\" class=\"headerlink\" title=\"Bennett Feely 的图案库\"></a>Bennett Feely 的图案库</h4><p><a href=\"http://bennettfeely.com/gradients\" target=\"_blank\" rel=\"noopener\">http://bennettfeely.com/gradients</a>，采用混合模式生成的 CSS 图案库</p>\n<h3 id=\"伪随机背景\"><a href=\"#伪随机背景\" class=\"headerlink\" title=\"伪随机背景\"></a>伪随机背景</h3><p>重现大自然的随机性是一个挑战，因为 CSS 本身没有提供任何随机功能。</p>\n<p>为了更真实地模拟条纹的随机性，我们接下来可能会想到，把这组条纹从一个平面拆散为多个图层:一种颜色作为底色，另三种颜色作为条纹，然后再让条纹以不同的间隔进行重复平铺：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">hsl</span>(20, 40%, 90%); </span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#fb3</span> 10<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#ab4</span> 20<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#655</span> 20<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 80<span class=\"selector-tag\">px</span> 100%, 60<span class=\"selector-tag\">px</span> 100%, 40<span class=\"selector-tag\">px</span> 100%;</span><br></pre></td></tr></table></figure>\n<p>但是我们很容易发现：<strong>各层背景图像以不同间距重复数次后再次统一对齐，而贴片的尺寸实际上就是所有 background-size 的最小公倍数</strong>，而 40、60 和 80 的最小公倍数正是 240。 所以为了模拟随机，我们需要把贴片的尺寸最大化：<strong>为了让最小公倍数最大化，这些数字最好是“相对质数”。</strong>这个技巧被 Alex Walker 定名为“蝉原则”，他最先提出了通过质数来 增加随机真实性的想法。请注意这个方法不仅适用于背景，还可以用于其他 涉及有规律重复的情况：</p>\n<ul>\n<li>在照片图库中，为每幅图片应用细微的伪随机旋转效果时，可以使 用多个 :nth-child(a) 选择符，且让 a 是质数。</li>\n<li>如果要生成一个动画，而且想让它看起来不是按照明显的规律在 循环时，我们可以应用多个时长为质数的动画。</li>\n</ul>\n<h3 id=\"连续的图像边框\"><a href=\"#连续的图像边框\" class=\"headerlink\" title=\"连续的图像边框\"></a>连续的图像边框</h3><p>有时我们想把一幅图案或图片应用为边框，而不是背景，达到下面的展示效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_255.png\" alt=\"\" width=\"\"></div>\n\n<p>此时 border-image 是不可能做到的，因为它无法随着元素宽高和边框厚度的变化而变化。所以我们的思路是<strong>在石雕背景图片之上，再叠加一层纯白的实色背景</strong>。为了让下层的图片背景透过边框区域显示出来，我们需要给两层背景指定不同的 background-clip 值。最后一个要点在于，我们只能在多重背景的最底层设置背景色，因此需要用一道从白色过渡到白色的 CSS 渐变来模拟出纯白实色背景的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding</span>: 1<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border</span>: 1<span class=\"selector-tag\">em</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">white</span>, <span class=\"selector-tag\">white</span>),<span class=\"selector-tag\">url</span>(<span class=\"selector-tag\">stone-art</span><span class=\"selector-class\">.jpg</span>); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: <span class=\"selector-tag\">cover</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-clip</span>: <span class=\"selector-tag\">padding-box</span>, <span class=\"selector-tag\">border-box</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-origin</span>: <span class=\"selector-tag\">border-box</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"老式信封样式的边框\"><a href=\"#老式信封样式的边框\" class=\"headerlink\" title=\"老式信封样式的边框\"></a><a href=\"http://play.csssecrets.io/vintage-envelope\" target=\"_blank\" rel=\"noopener\">老式信封样式的边框</a></h4><p>将上面的技巧用在渐变图案上：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding</span>: 1<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border</span>: 1<span class=\"selector-tag\">em</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">white</span>, <span class=\"selector-tag\">white</span>) <span class=\"selector-tag\">padding-box</span>,</span><br><span class=\"line\">            <span class=\"selector-tag\">repeating-linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>,</span><br><span class=\"line\">              <span class=\"selector-tag\">red</span> 0, <span class=\"selector-tag\">red</span> 12<span class=\"selector-class\">.5</span>%,</span><br><span class=\"line\">              <span class=\"selector-tag\">transparent</span> 0, <span class=\"selector-tag\">transparent</span> 25%,</span><br><span class=\"line\">              <span class=\"selector-id\">#58a</span> 0, <span class=\"selector-id\">#58a</span> 37<span class=\"selector-class\">.5</span>%,</span><br><span class=\"line\">              <span class=\"selector-tag\">transparent</span> 0, <span class=\"selector-tag\">transparent</span> 50%)</span><br><span class=\"line\">              0 / 5em 5em;</span><br></pre></td></tr></table></figure>\n<h4 id=\"蚂蚁行军边框\"><a href=\"#蚂蚁行军边框\" class=\"headerlink\" title=\"蚂蚁行军边框\"></a><a href=\"http://play.csssecrets.io/marching-ants\" target=\"_blank\" rel=\"noopener\">蚂蚁行军边框</a></h4><p>为了创建蚂蚁行军效果，我们将会用到“老式信封”技巧的一个变种。我们将把条纹转变为黑白两色，并把边框的宽度减少至 1px，然后再把 background-size 改为某个合适的值。最后，我们把 background-position 以动画的方式改变为 100%，就可以让它滚动起来了</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> ants &#123; <span class=\"selector-tag\">to</span> &#123; <span class=\"attribute\">background-position</span>: <span class=\"number\">100%</span> &#125; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.marching-ants</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent; <span class=\"attribute\">background</span>:</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(white, white) padding-box,</span><br><span class=\"line\">        <span class=\"built_in\">repeating-linear-gradient</span>(-45deg,</span><br><span class=\"line\">          black 0, black 25%, white 0, white 50%</span><br><span class=\"line\">        ) <span class=\"number\">0</span> / .<span class=\"number\">6em</span> .<span class=\"number\">6em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: ants <span class=\"number\">12s</span> linear infinite; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a><a href=\"http://play.csssecrets.io/footnote\" target=\"_blank\" rel=\"noopener\">脚注</a></h4><p>我们可以用 border-image 搭配渐变图案实现顶部边框被裁切的效果，就像一般的脚注那样，我们所需要的就是 border-image 属性再加上一条由渐变生成的垂直条纹，并把要裁切的长度在渐变中写好。边框线的粗细交给 border-width 来控制：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border-top</span>: <span class=\"selector-class\">.2em</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-image</span>: 100% 0 0 <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>,<span class=\"selector-tag\">currentColor</span> 4<span class=\"selector-tag\">em</span>,<span class=\"selector-tag\">transparent</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">padding-top</span>: 1<span class=\"selector-tag\">em</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"形状\"><a href=\"#形状\" class=\"headerlink\" title=\"形状\"></a>形状</h2><h3 id=\"自适应的椭圆\"><a href=\"#自适应的椭圆\" class=\"headerlink\" title=\"自适应的椭圆\"></a>自适应的椭圆</h3><p>我们想要达到这样效果：<strong>如果宽高相等，就显示为一个圆；如果宽高不等，就显示为一个椭圆</strong> border-radius 可以单独指定水平和垂直半径，用一个斜杠（/）分隔这两个值即可；同时，它不仅可以接受长度值，还可以接受百分比值，这个百分比值会基于元素的尺寸进行解析。这意味着相同的百分比可能会计算出不同的水平和垂直半径，因此可以这样实现自适应椭圆：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border-radius</span>: 50%;</span><br></pre></td></tr></table></figure>\n<h3 id=\"半椭圆\"><a href=\"#半椭圆\" class=\"headerlink\" title=\"半椭圆\"></a>半椭圆</h3><div align=\"center\"><img src=\"/images/hexo_post_256.png\" alt=\"\" width=\"\"></div>\n\n<p>我们可以为四个角提供完全不同的水平和垂直半径，这意味着当 border-radius 的值为 10px / 5px 20px 时，其效果相当于 10px 10px 10px 10px / 5px 20px 5px 20px；所以我们很容易写出半椭圆的 CSS 代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50% / 100% 100% 0 0;</span><br></pre></td></tr></table></figure>\n<p>举一反三，沿纵轴劈开的半椭圆：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 100% 0 0 100% / 50%;</span><br></pre></td></tr></table></figure>\n<p>四分之一椭圆（其中一个角的水平和垂直半径值都需要是 100%，而其他三个角都不能设为圆角）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border-radius</span>: 100% 0 0 0;</span><br></pre></td></tr></table></figure>\n<p>但是很遗憾，<strong>border-radius 是无法生成八分之一椭圆，三分之一椭圆的</strong>！</p>\n<h3 id=\"平行四边形\"><a href=\"#平行四边形\" class=\"headerlink\" title=\"平行四边形\"></a>平行四边形</h3><p>我们可以通过 skew() 的变形属性来对某个矩形进行斜向拉伸，但是这回导致它的内容也发生了斜向变形。所以我们的思路是<strong>把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.button</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    /\\* 其他的文字颜色、内边距等样式...... */</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-class\">.button</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>; <span class=\"comment\">/* 用伪元素来生成一个矩形 */</span> </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: -<span class=\"number\">1</span>; <span class=\"comment\">/* 防止伪元素的背景遮住内容 */</span></span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#58a</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(45deg); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个技巧<strong>适用于其他任何变形样式</strong>，当我们想<strong>变形一个元素而不想变形它的内容</strong>时就很有用：</p>\n<ul>\n<li>可以用<a href=\"http://nicolasgallagher.com/multiple-backgrounds-and-borders-with-css2/\" target=\"_blank\" rel=\"noopener\">在IE下实现多重背景</a></li>\n<li>实现“边框内圆角”效果</li>\n<li>可以用来为某一层“背景”<a href=\"http://nicolasgallagher.com/css-background-image-hacks\" target=\"_blank\" rel=\"noopener\">单独设置类似opacity这样的属性</a></li>\n<li>模拟多层边框</li>\n</ul>\n<h3 id=\"菱形图片\"><a href=\"#菱形图片\" class=\"headerlink\" title=\"菱形图片\"></a><a href=\"http://play.csssecrets.io/diamond-clip\" target=\"_blank\" rel=\"noopener\">菱形图片</a></h3><p>主要思路是使用 clip-path 属性，它最大的缺陷在于其浏览器支持程度还很有限。但是，它可以平稳退化（只是没有裁切效果而已），因此它至少有资格成为我们的备选方案 我们将会使用 polygon()（多边形）函数来指定一个菱形。实际上，它允许我们用一系列（以逗号分隔的）坐标点来指定任意的多边形。我们甚至可以使用百分比值，它们会解析为元素自身的尺寸：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">clip-path</span>: <span class=\"selector-tag\">polygon</span>(50% 0, 100% 50%, 50% 100%, 0 50%);</span><br></pre></td></tr></table></figure>\n<p>clip-path 所能创造的奇迹还不止于此。这个属性甚至可以参与动画，只要我们的动画是在同一种形状函数(比如这里是 polygon())之间进行的，而且点的数量是相同的。因此，如果我们希望图片在鼠标悬停时平滑地扩展为完整的面积，只需要这样做：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">clip-path</span>: <span class=\"built_in\">polygon</span>(50% 0, 100% 50%, 50% 100%, 0 50%);</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: <span class=\"number\">1s</span> clip-path;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">img</span><span class=\"selector-pseudo\">:hover</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">clip-path</span>: <span class=\"built_in\">polygon</span>(0 0, 100% 0, 100% 100%,0 100%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MDN 关于 clip-path 的文档：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path</a></p>\n<h3 id=\"切角效果\"><a href=\"#切角效果\" class=\"headerlink\" title=\"切角效果\"></a>切角效果</h3><p>把角切掉不仅是为了省钱，它还是一种非常流行的设计风格，不论是在印刷媒介还是在网页设计中都是如此。</p>\n<h4 id=\"用渐变实现\"><a href=\"#用渐变实现\" class=\"headerlink\" title=\"用渐变实现\"></a>用渐变实现</h4><p>假设我们只需要一个角被切掉，以右下角为例，可以充分利用渐变的一大特性：渐变可以接受一个角度（比如 45deg）作为方向，而且色标的位置信息也可以是绝对的长度值，不受容器尺寸的影响；综上，我们需要一个线性渐变，把一个透明色标放在切角处，然后在相同位置设置另一个色标，并且把它的颜色设置为我们想要的背景色：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0);</span><br></pre></td></tr></table></figure>\n<p><strong>左下角和右下角都有切角效果</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">                <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">            <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">                <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 50% 100%; </span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">no-repeat</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>四个角都有切角效果</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(135<span class=\"selector-tag\">deg</span>,  <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">        <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">left</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-135deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">        <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">        <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">        <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 50% 50%;</span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">no-repeat</span>;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码的可维护性并不理想，使用<strong>预处理器的 mixin</strong> 可以帮助我们减少代码的重复度</p>\n<h4 id=\"弧形切角\"><a href=\"#弧形切角\" class=\"headerlink\" title=\"弧形切角\"></a>弧形切角</h4><p>很多人也把这种效果成为“内凹圆角”，因为它看起来就像是圆角的反向版本。唯一的区别在于，我们会用<strong>径向渐变</strong>来替代上述线性渐变：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_257.png\" alt=\"\" width=\"400\"></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">circle</span> <span class=\"selector-tag\">at</span> <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">left</span>,</span><br><span class=\"line\">             <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0) <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">left</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">circle</span> <span class=\"selector-tag\">at</span> <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">             <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0) <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">circle</span> <span class=\"selector-tag\">at</span> <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">             <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0) <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">circle</span> <span class=\"selector-tag\">at</span> <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>,</span><br><span class=\"line\">             <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0) <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 50% 50%; </span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">no-repeat</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"clip-path-实现切角\"><a href=\"#clip-path-实现切角\" class=\"headerlink\" title=\"clip-path 实现切角\"></a>clip-path 实现切角</h4><p>裁切路径最神奇的地方在于我们<strong>可以同时使用百分比数值（它会以元素自身的宽高作为基数度进行换算）和绝对长度值</strong>，从而提供巨大的灵活性。举个例子，如果用裁切路径将一个元素切出 20px 大小的斜面切角，代码如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">clip-path</span>: <span class=\"selector-tag\">polygon</span>(</span><br><span class=\"line\">    20<span class=\"selector-tag\">px</span> 0, <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>) 0, 100% 20<span class=\"selector-tag\">px</span>,</span><br><span class=\"line\">    100% <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>), <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>) 100%,</span><br><span class=\"line\">    20<span class=\"selector-tag\">px</span> 100%, 0 <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>), 0 20<span class=\"selector-tag\">px</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>但是它有一个很明显的缺点，就是<strong>当内边距不够宽时，它会裁切掉文本</strong>，因为它只能对元素做统一的裁切，并不能区分元素的各个部分</p>\n<h3 id=\"梯形标签页\"><a href=\"#梯形标签页\" class=\"headerlink\" title=\"梯形标签页\"></a><a href=\"http://play.csssecrets.io/trapezoid-tabs\" target=\"_blank\" rel=\"noopener\">梯形标签页</a></h3><p>一直以来，梯形都是众所周知难以用 CSS 生成的形状，网页开发者如果没有用精心设计的背景图片来实现梯形，那多半就是在用伪元素的边框来模拟梯形两侧的斜边，而我们的思路是通过 3D 变形，将矩形进行3D旋转，就可以创建一个梯形。但由于旋转之后，元素的尺寸会变小，同时会稍微下移，所以我们需要让其在3D空间旋转时固定底边（transform-origin），同时通过 scale() 方法改变它的尺寸：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scaleY</span>(1<span class=\"selector-class\">.3</span>) <span class=\"selector-tag\">perspective</span>(<span class=\"selector-class\">.5em</span>) <span class=\"selector-tag\">rotateX</span>(5<span class=\"selector-tag\">deg</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">transform-origin</span>: <span class=\"selector-tag\">bottom</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_258.png\" alt=\"\" width=\"\"></div>\n\n<p>同时，我们只需要把 transform-origin 改成 bottom left 或 bottom right，就可以立即得到左侧倾斜或右侧倾斜的标签页</p>\n<h3 id=\"简单的饼图\"><a href=\"#简单的饼图\" class=\"headerlink\" title=\"简单的饼图\"></a>简单的饼图</h3><p>我们可以通过渐变来将一个圆形的左右两半设置为不同的颜色，然后通过伪元素的旋转不同角度来实现不同角度的简单饼图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_259.png\" alt=\"\" width=\"\"></div>\n\n<p>由于已经找到了实现任意比率的方法，我们甚至可以用 CSS 动画来实现一个饼图从 0 变化到 100% 的动画，从而得到一个<a href=\"http://play.csssecrets.io/pie-animated\" target=\"_blank\" rel=\"noopener\">炫酷的进度指示器</a>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> spin &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123; <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(.5turn); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> bg &#123;</span><br><span class=\"line\">    50% &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#655</span>; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.pie</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">0</span> <span class=\"number\">100%</span> <span class=\"number\">100%</span> <span class=\"number\">0</span> / <span class=\"number\">50%</span>; </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: inherit; </span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: spin <span class=\"number\">3s</span> linear infinite, bg <span class=\"number\">6s</span> step-end infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们需要一个静态的任意比率的饼图，可以利用<strong>负的动画延时</strong>来直接跳至动画中的任意时间 点，并且定格在那里。举例来说，如果动画持续时间定为 6s，我们只需要把 animation-delay 设置为 -1.2s，就能显示出 20% 的比率。最终的效果：<a href=\"http://play.csssecrets.io/pie-static\" target=\"_blank\" rel=\"noopener\">play.csssecrets.io/pie-static</a> 我们还可以通过 SVG 实现简单的饼图，与伪元素相比，SVG 的方案具有不少优点：</p>\n<ul>\n<li>增加第三种颜色非常容易</li>\n<li>不需要特别担心打印，因为 SVG 元素本身被视为页面内容</li>\n<li>可以用内联样式指定颜色这意味着我们可以通过脚本控制颜色</li>\n</ul>\n<p>SVG 方案实现的效果：<a href=\"http://play.csssecrets.io/pie-svg\" target=\"_blank\" rel=\"noopener\">play.csssecrets.io/pie-svg</a></p>\n<h2 id=\"视觉效果\"><a href=\"#视觉效果\" class=\"headerlink\" title=\"视觉效果\"></a>视觉效果</h2><h3 id=\"单侧投影\"><a href=\"#单侧投影\" class=\"headerlink\" title=\"单侧投影\"></a><a href=\"http://play.csssecrets.io/shadow-one-side\" target=\"_blank\" rel=\"noopener\">单侧投影</a></h3><p>解决方案来自 box-shadow 鲜为人知的第四个长度参数，称作扩张半径。这个参数会根据你指定的值去扩大或 (当指定负值时)缩小投影的尺寸。举例来说，一个 -5px 的扩张半径会把投影的宽度和高度各减少 10px(即每边各  5px)。如果给投影应用一个正的垂直偏移量，我们就会在元素的底部看到一道投影，而元素的另外三侧是没有投影的：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 0 5<span class=\"selector-tag\">px</span> 4<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-4px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"邻边投影\"><a href=\"#邻边投影\" class=\"headerlink\" title=\"邻边投影\"></a><a href=\"http://play.csssecrets.io/shadow-2-sides\" target=\"_blank\" rel=\"noopener\">邻边投影</a></h4><p>把一个 black、6px 的投影设置到右侧和底部可以这样做：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 3<span class=\"selector-tag\">px</span> 3<span class=\"selector-tag\">px</span> 6<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-3px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双侧投影\"><a href=\"#双侧投影\" class=\"headerlink\" title=\"双侧投影\"></a><a href=\"http://play.csssecrets.io/shadow-opposite-sides\" target=\"_blank\" rel=\"noopener\">双侧投影</a></h4><p>唯一的办法是用两块投影（每边各一块）来达到目的：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 5<span class=\"selector-tag\">px</span> 0 5<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-5px</span> <span class=\"selector-tag\">black</span>, </span><br><span class=\"line\">            <span class=\"selector-tag\">-5px</span> 0 5<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-5px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不规则投影\"><a href=\"#不规则投影\" class=\"headerlink\" title=\"不规则投影\"></a>不规则投影</h3><p>当我们想给一个矩形或其他能用 border-radius 生成的形状加投影时，box-shadow 的表现都堪称完美。但是，当元素添加了一些伪元素或半透明的装饰之后，它就有些力不从心了，因为 border-radius 会无耻地忽视透明部分：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_260.png\" alt=\"\" width=\"\"></div>\n\n<p>我们的解决方案是利用 filter 的新属性来指定滤镜效果，比如上面的投影效果可以这样来写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">drop-shadow</span>(2<span class=\"selector-tag\">px</span> 2<span class=\"selector-tag\">px</span> 10<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.5</span>));</span><br></pre></td></tr></table></figure>\n<p>实现效果：<a href=\"http://play.csssecrets.io/drop-shadow\" target=\"_blank\" rel=\"noopener\">play.csssecrets.io/drop-shadow</a></p>\n<h3 id=\"染色效果\"><a href=\"#染色效果\" class=\"headerlink\" title=\"染色效果\"></a>染色效果</h3><p>首先可以去<a href=\"https://2014.cssconf.com/\" target=\"_blank\" rel=\"noopener\">CSSConf 官网</a>欣赏一下讲师照片的染色效果，当鼠标悬停或获得焦点时，照片将显示为全彩的样式</p>\n<h4 id=\"基于滤镜的方案\"><a href=\"#基于滤镜的方案\" class=\"headerlink\" title=\"基于滤镜的方案\"></a><a href=\"http://play.csssecrets.io/color-tint-filter\" target=\"_blank\" rel=\"noopener\">基于滤镜的方案</a></h4><p>filter 属性提供了多种关于色调调整的方法，下面的代码可以实现染色效果的过渡动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">5s</span> filter;</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">sepia</span>(1) <span class=\"built_in\">saturate</span>(4) <span class=\"built_in\">hue-rotate</span>(295deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">img</span><span class=\"selector-pseudo\">:hover</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">img</span><span class=\"selector-pseudo\">:focus</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: none; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基于混合模式的方案\"><a href=\"#基于混合模式的方案\" class=\"headerlink\" title=\"基于混合模式的方案\"></a><a href=\"http://play.csssecrets.io/color-tint\" target=\"_blank\" rel=\"noopener\">基于混合模式的方案</a></h4><p>使用 background-blend-mode 属性可以让每层背景跟它的下层背景进行混合：</p>\n<p>HTML 代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tinted-image\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">style</span>=<span class=\"string\">\"background-image:url(tiger.jpg)\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>CSS 代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tinted-image</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">640px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">440px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover; </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">hsl</span>(335, 100%, 50%); </span><br><span class=\"line\">    <span class=\"attribute\">background-blend-mode</span>: luminosity; </span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">5s</span> background-color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tinted-image</span><span class=\"selector-pseudo\">:hover</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"毛玻璃效果\"><a href=\"#毛玻璃效果\" class=\"headerlink\" title=\"毛玻璃效果\"></a><a href=\"http://play.csssecrets.io/frosted-glass\" target=\"_blank\" rel=\"noopener\">毛玻璃效果</a></h3><p>我们想要达到下面这种效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_261.png\" alt=\"\" width=\"\"></div>\n\n<p>我们的实现方案是利用伪元素实现模糊背景，但由于模糊效果在接近边缘处会逐渐消退，所以我们需要让伪元素相对其宿主元素的尺寸再向外扩大至少模糊半径的距离，然后再对宿主元素应用 overflow:hidden 来将多余的模糊区域裁切掉，最终代码如下所示：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>, <span class=\"selector-tag\">main</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"tiger.jpg\"</span>) <span class=\"number\">0</span> / cover fixed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">hsla</span>(0,0%,100%,.3); </span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(20px);</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: -<span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"折角效果\"><a href=\"#折角效果\" class=\"headerlink\" title=\"折角效果\"></a>折角效果</h3><h4 id=\"45°折角的解决方案\"><a href=\"#45°折角的解决方案\" class=\"headerlink\" title=\"45°折角的解决方案\"></a><a href=\"http://play.csssecrets.io/folded-corner\" target=\"_blank\" rel=\"noopener\">45°折角的解决方案</a></h4><p>我们先根据“切角效果”一节中的渐变方案实现一个右上角的斜面切角，然后增加另一层渐变来生成一个三角形并将其定位在右上角，从而实现翻折效果，需要注意的是<strong>这个渐变的两个色标需要在正中央重合</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; <span class=\"comment\">/* 回退样式 */</span> </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">to</span> <span class=\"selector-tag\">left</span> <span class=\"selector-tag\">bottom</span>,</span><br><span class=\"line\">        <span class=\"selector-tag\">transparent</span> 50%, <span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.4</span>) 0)</span><br><span class=\"line\">        no-repeat 100% 0 / 2em 2em,</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-135deg</span>,</span><br><span class=\"line\">        <span class=\"selector-tag\">transparent</span> 1<span class=\"selector-class\">.5em</span>, <span class=\"selector-id\">#58a</span> 0);</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他角度的解决方案\"><a href=\"#其他角度的解决方案\" class=\"headerlink\" title=\"其他角度的解决方案\"></a><a href=\"http://play.csssecrets.io/folded-corner-realistic\" target=\"_blank\" rel=\"noopener\">其他角度的解决方案</a></h4><p>由于其他角度的切角需要旋转一定角度，所以我们需要借助伪元素来实现，同时还需要借助一些数学知识来计算角度和距离，具体实现过程比较复杂，大家可以看书中的解释或者直接看<a href=\"http://play.csssecrets.io/folded-corner-realistic\" target=\"_blank\" rel=\"noopener\">实现效果</a>，最终代码如下所示：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.note</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#58a</span>; <span class=\"comment\">/* 回退样式 */</span> </span><br><span class=\"line\"><span class=\"attribute\">background</span>:</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(-150deg,</span><br><span class=\"line\">            transparent 1.5em, #58a 0);</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: .<span class=\"number\">5em</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-class\">.note</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">linear-gradient</span>(to left bottom,</span><br><span class=\"line\">        transparent 50%, rgba(0,0,0,.2) <span class=\"number\">0</span>, <span class=\"built_in\">rgba</span>(0,0,0,.4))</span><br><span class=\"line\">        <span class=\"number\">100%</span> <span class=\"number\">0</span> no-repeat; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">1.73em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">3em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-1.3em) <span class=\"built_in\">rotate</span>(-30deg); </span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: bottom right; </span><br><span class=\"line\">    <span class=\"attribute\">border-bottom-left-radius</span>: inherit;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: -.<span class=\"number\">2em</span> .<span class=\"number\">2em</span> .<span class=\"number\">3em</span> -.<span class=\"number\">1em</span> <span class=\"built_in\">rgba</span>(0,0,0,.15);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字体排印\"><a href=\"#字体排印\" class=\"headerlink\" title=\"字体排印\"></a>字体排印</h2><h3 id=\"连字符断行\"><a href=\"#连字符断行\" class=\"headerlink\" title=\"连字符断行\"></a>连字符断行</h3><p>text-align:justify 可以实现两端对齐，但是对于英文字体来说，很容易出现“单词孤岛”现象，这样不仅看起来很糟糕，而且损伤了可读性。在打印媒介中，两端对齐总是和连字符断行相辅相成的，这样文本看起来就自然很多。 CSS 文本（第三版）引入了一个新的属性 hyphens：</p>\n<blockquote>\n<p>hyphens: none | manual | auto</p>\n</blockquote>\n<p>manual 是它的初始值，</p>\n<p>其行为正好对应了现有的工作方式：我们可以在任何时候手工插入软连字符，来实现断词折行的效果。很显然 hyphens: none; 会禁用这种行为；而最为神奇的是，只需这短短一行 CSS 就可以产生我们梦寐以求的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">hyphens</span>: <span class=\"selector-tag\">auto</span>;</span><br></pre></td></tr></table></figure>\n<p>为了确保它奏效，你需要在 HTML 标签的 lang 属性中指定合适的语言</p>\n<p>如果需要更细粒度地控制连字符的行为（比如在简短的引文中），你仍然可以通过一些软连字符（<code>&amp;shy;</code>）来辅助浏览器进行断词。这个 hyphens 属性会优先处理它们，然后再去计算其他可以断词的地方</p>\n<h3 id=\"插入换行\"><a href=\"#插入换行\" class=\"headerlink\" title=\"插入换行\"></a><a href=\"http://play.csssecrets.io/line-breaks\" target=\"_blank\" rel=\"noopener\">插入换行</a></h3><p>HTML代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dl</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>Name:<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>Lea Verou<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>Email:<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>lea@verou.me<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>Location:<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>Earth<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们想让 dt 和后面的 dd 在同一行，每个dt所在的内容都单独占一行。 有一个 Unicode 字符是专门代表换行符的:0x000A1。在 CSS 中， 这个字符可以写作 “\\000A”，或简化为 “\\A”。我们可以用它来作为 ::after 伪元素的内容，并将其添加到每个 <code>&lt;dd&gt;</code> 元素的尾部</p>\n<p>但是由于我们是在 HTML 代码中插入了换行符，所以这些换行符会和相邻的其他空白符进行合并，此时我们希望<strong>保留源代码中的这些空白符和换行，</strong>我们会用到 white-space:pre。然而如果你的结构代码在多个连续的 <code>&lt;dd&gt;</code> 之间包含了(未加注释的)空白符，那么逗号前面会有一个空格。有很多方法可以修复这个问题，但都不够完美。其中一种方法是利用<strong>负外边距</strong>。最终 CSS 代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dt</span>,<span class=\"selector-tag\">dd</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">dd</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">dd</span> + <span class=\"selector-tag\">dt</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">'\\\\A'</span>;</span><br><span class=\"line\">    <span class=\"attribute\">white-space</span>: pre; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">dd</span> + <span class=\"selector-tag\">dd</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">', '</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -.<span class=\"number\">25em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: normal; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文本行的斑马条纹\"><a href=\"#文本行的斑马条纹\" class=\"headerlink\" title=\"文本行的斑马条纹\"></a><a href=\"http://play.csssecrets.io/zebra-lines\" target=\"_blank\" rel=\"noopener\">文本行的斑马条纹</a></h3><p>我们可以通过 :nth-child() / :nth-of-type() 伪类来实现表格的“斑马条纹”：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">tr</span><span class=\"selector-pseudo\">:nth-child(even)</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(0,0,0,.2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，这种实现方式无法应用到文本行。我们可以<strong>在 CSS 中用渐变直接生成背景图像</strong>，而且可以用 em 单位来设定背景尺寸，这样背景就可以<strong>自动适应 font-size 的变化</strong>了。水平条纹背景的 background-size 需要设置为 line-height 的两倍，因为每个背景贴片需要覆盖两行代码。同时我们希望让背景自动跟着内边距的宽度走，所以就需要 background-origin 告诉浏览器在解析 background-position 时以 content box 的外沿作为基准：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding</span>: <span class=\"selector-class\">.5em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">line-height</span>: 1<span class=\"selector-class\">.5</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">beige</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: <span class=\"selector-tag\">auto</span> 3<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-origin</span>: <span class=\"selector-tag\">content-box</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.2</span>) 50%,</span><br><span class=\"line\">                                  <span class=\"selector-tag\">transparent</span> 0);</span><br></pre></td></tr></table></figure>\n<p>唯一可能破坏效果的情况可能就是在改变 line-height 时忘了相应地调整 background-size</p>\n<h3 id=\"调整tab的宽度\"><a href=\"#调整tab的宽度\" class=\"headerlink\" title=\"调整tab的宽度\"></a><a href=\"http://play.csssecrets.io/tab-size\" target=\"_blank\" rel=\"noopener\">调整tab的宽度</a></h3><p>我们通常使用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 元素来显示代码，但是<strong>浏览器会把 tab 的宽度显示为8个字符</strong>！ 而在 CSS 文本（第三版）中，一个新的 CSS 属性 tab-size 可以控制这个情况。这个属性接受一个数字(表示字符数)或者一个长度值(这个不那么实用)。我们通常希望把它设置为4(表示 4 个字符的宽度)或 2，后者是最近更为流行的缩进尺寸。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">pre</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">tab-size</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连字\"><a href=\"#连字\" class=\"headerlink\" title=\"连字\"></a><a href=\"http://play.csssecrets.io/ligatures\" target=\"_blank\" rel=\"noopener\">连字</a></h3><h4 id=\"什么是连字？（右侧为左侧连字写法）\"><a href=\"#什么是连字？（右侧为左侧连字写法）\" class=\"headerlink\" title=\"什么是连字？（右侧为左侧连字写法）\"></a>什么是连字？（右侧为左侧连字写法）</h4><p>i 的圆点往往会与 f 的升部发生冲突，导致两者都显示不清；为了缓解这个问题，字体设计师通常会在字体中包含一些额外的字形，称作连字。这些字形被设计为双字形或三字形的单一组合体，专门提供给排版软件使用，代为显示特定的字符组合：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_262.png\" alt=\"\" width=\"\"></div>\n\n<h4 id=\"支持连字解决方案\"><a href=\"#支持连字解决方案\" class=\"headerlink\" title=\"支持连字解决方案\"></a>支持连字解决方案</h4><p>在 CSS 字体（第三版）中，原有的 font- variant 被升级成了一个简写属性，由很多新的展开式属性组合而成。其中之一叫作 font-variant-ligatures，专门用来控制连字效果的开启和关闭。如果要启用所有可能的连字，需要同时指定这三个标识符:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">font-variant-ligatures</span>: <span class=\"selector-tag\">common-ligatures</span> </span><br><span class=\"line\">                        <span class=\"selector-tag\">discretionary-ligatures</span></span><br><span class=\"line\">                        <span class=\"selector-tag\">historical-ligatures</span>;</span><br></pre></td></tr></table></figure>\n<p>font-variant-ligatures 还接受 none 这个值，它会把所有的连字效果都关掉。千万不要使用 none，除非你绝对清楚自己是在做什么。如果要把 font-variant-ligatures 属性复位为初始值，应该使用 normal 而不是 none。</p>\n<h3 id=\"华丽的-amp-符号\"><a href=\"#华丽的-amp-符号\" class=\"headerlink\" title=\"华丽的 &amp; 符号\"></a><a href=\"http://play.csssecrets.io/ampersands\" target=\"_blank\" rel=\"noopener\">华丽的 &amp; 符号</a></h3><p>我们想要用另一种字体来单独美化某个特定字符（或是某个区间内的多个字符）： 首先，@font-face 规则中的 src 描述符是可以接受 local() 函数的，用于指定本地字体的名称：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">font-face</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: Ampersand;</span><br><span class=\"line\">    <span class=\"attribute\">src</span>: <span class=\"built_in\">local</span>(<span class=\"string\">'Baskerville'</span>),</span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'Goudy Old Style'</span>),</span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'Garamond'</span>),</span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'Palatino'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，整段文本会都被应用为我们指定的字体，所以需要一个描述符来声明我们想用这款字体来显示哪些字符，这个描述符叫做 unicode-range；它是基于 “Unicode 码位”的，所以需要知道你想指定的字符的十六进制码位，你可以在控制台打印下面JS代码获取：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"&amp;\"</span>.charCodeAt(<span class=\"number\">0</span>).toString(<span class=\"number\">16</span>); <span class=\"comment\">// 返回26</span></span><br></pre></td></tr></table></figure>\n<p>还需要在前面加上 U+ 作为前缀，所以最终声明方式为：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">unicode-range</span>: <span class=\"selector-tag\">U</span>+26;</span><br></pre></td></tr></table></figure>\n<p>如果你想指定一个字符区间，还是要加上 U+ 前缀，比如 U+400-4FF。实际上对于这个区间来说，你还可以使用通配符，以这样的方式来写：U+4??。同时指定多个字符或多个区间也是允许的，把它们用逗号隔开即可，比如 U+26, U+4??, U+2665-2670</p>\n<p>最后，为了指定某些字体的斜体版本，我们需要直接指定字体中我们想要的单个风格/字重所对应的 “PostScript 名称”：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">font-face</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: Ampersand;</span><br><span class=\"line\">    <span class=\"attribute\">src</span>: <span class=\"built_in\">local</span>(<span class=\"string\">'Baskerville-Italic'</span>),</span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'GoudyOldStyleT-Italic'</span>), </span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'Palatino-Italic'</span>), </span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'BookAntiqua-Italic'</span>);</span><br><span class=\"line\">    <span class=\"attribute\">unicode-range</span>: U+<span class=\"number\">26</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: Ampersand, Helvetica, sans-serif;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义下划线\"><a href=\"#自定义下划线\" class=\"headerlink\" title=\"自定义下划线\"></a>自定义下划线</h3><p>text-decoration:underline 实现的文本下划线不能够定制，同时<strong>在不同浏览器下的渲染效果大相径庭</strong>。所以为了得到更加定制化的下划线，我们可以通过 background-image 及其相关属性来实现（CSS 渐变）</p>\n<h4 id=\"实线下划线\"><a href=\"#实线下划线\" class=\"headerlink\" title=\"实线下划线\"></a>实线下划线</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">gray</span>, <span class=\"selector-tag\">gray</span>) <span class=\"selector-tag\">no-repeat</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 1<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 0 1<span class=\"selector-class\">.15em</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"防止下划线穿过文本的降部\"><a href=\"#防止下划线穿过文本的降部\" class=\"headerlink\" title=\"防止下划线穿过文本的降部\"></a>防止下划线穿过文本的降部</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">gray</span>, <span class=\"selector-tag\">gray</span>) <span class=\"selector-tag\">no-repeat</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 1<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 0 1<span class=\"selector-class\">.15em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: <span class=\"selector-class\">.05em</span> 0 <span class=\"selector-tag\">white</span>, <span class=\"selector-tag\">-</span><span class=\"selector-class\">.05em</span> 0 <span class=\"selector-tag\">white</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"虚线下划线\"><a href=\"#虚线下划线\" class=\"headerlink\" title=\"虚线下划线\"></a><a href=\"http://play.csssecrets.io/underlines\" target=\"_blank\" rel=\"noopener\">虚线下划线</a></h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">gray</span> 66%, <span class=\"selector-tag\">transparent</span> 0) <span class=\"selector-tag\">repeat-x</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: <span class=\"selector-class\">.2em</span> 2<span class=\"selector-tag\">px</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 0 1<span class=\"selector-tag\">em</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"波浪型的下划线（两层渐变）\"><a href=\"#波浪型的下划线（两层渐变）\" class=\"headerlink\" title=\"波浪型的下划线（两层渐变）\"></a><a href=\"http://play.csssecrets.io/wavy-underlines\" target=\"_blank\" rel=\"noopener\">波浪型的下划线（两层渐变）</a></h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>, <span class=\"selector-tag\">transparent</span> 40%, <span class=\"selector-tag\">red</span> 0, <span class=\"selector-tag\">red</span> 60%, <span class=\"selector-tag\">transparent</span> 0) 0 1<span class=\"selector-tag\">em</span>,</span><br><span class=\"line\">\t    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 40%, <span class=\"selector-tag\">red</span> 0, <span class=\"selector-tag\">red</span> 60%, <span class=\"selector-tag\">transparent</span> 0) <span class=\"selector-class\">.1em</span> 1<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">repeat-x</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: <span class=\"selector-class\">.2em</span> <span class=\"selector-class\">.1em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: <span class=\"selector-class\">.05em</span> 0 <span class=\"selector-tag\">white</span>, <span class=\"selector-tag\">-</span><span class=\"selector-class\">.05em</span> 0 <span class=\"selector-tag\">white</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"现实中的文字效果\"><a href=\"#现实中的文字效果\" class=\"headerlink\" title=\"现实中的文字效果\"></a>现实中的文字效果</h3><h4 id=\"凸版印刷效果\"><a href=\"#凸版印刷效果\" class=\"headerlink\" title=\"凸版印刷效果\"></a><a href=\"http://play.csssecrets.io/letterpress\" target=\"_blank\" rel=\"noopener\">凸版印刷效果</a></h4><p>我们通过 text-shadow 使人产生物体从平面上凸起的错觉 <strong>当我们在浅色背景上使用深色文字时，在底部加上浅色投影通常效果最佳</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">hsl</span>(210, 13%, 60%);</span><br><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">hsl</span>(210, 13%, 30%);</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 1<span class=\"selector-tag\">px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.8</span>);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_263.png\" alt=\"\" width=\"\"></div>\n\n<p><strong>当我们在深色背景上使用浅色文字时，在底部加上深色投影通常效果最佳</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">hsl</span>(210, 13%, 40%); </span><br><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">hsl</span>(210, 13%, 75%); </span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 <span class=\"selector-tag\">-1px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_264.png\" alt=\"\" width=\"\"></div>\n\n<h4 id=\"空心字效果\"><a href=\"#空心字效果\" class=\"headerlink\" title=\"空心字效果\"></a><a href=\"http://play.csssecrets.io/stroked-text\" target=\"_blank\" rel=\"noopener\">空心字效果</a></h4><p>我们一般使用多个 text-shadow 来模拟文字描边：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">deeppink</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">white</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 1<span class=\"selector-tag\">px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, <span class=\"selector-tag\">-1px</span> <span class=\"selector-tag\">-1px</span> <span class=\"selector-tag\">black</span>,</span><br><span class=\"line\">             1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-1px</span> <span class=\"selector-tag\">black</span>, <span class=\"selector-tag\">-1px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<p>但是，目前比较理想的方案是使用 SVG，HTML 代码可能是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"2em\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"1.2em\"</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#css\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span> <span class=\"attr\">id</span>=<span class=\"string\">\"css\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"1em\"</span>&gt;</span>CSS<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>CSS：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">500%</span>/<span class=\"number\">1</span> Rockwell, serif; </span><br><span class=\"line\">    <span class=\"attribute\">background</span>: deeppink;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> <span class=\"selector-tag\">text</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">fill</span>: currentColor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> <span class=\"selector-tag\">svg</span> &#123; <span class=\"attribute\">overflow</span>: visible &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> <span class=\"selector-tag\">use</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">stroke</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-width</span>: <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-linejoin</span>: round;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"文字外发光效果\"><a href=\"#文字外发光效果\" class=\"headerlink\" title=\"文字外发光效果\"></a><a href=\"http://play.csssecrets.io/glow\" target=\"_blank\" rel=\"noopener\">文字外发光效果</a></h4><p>文字外发光效果常用于凸显标题，或给链接添加鼠标悬停效果。它是最容易生成的文字美化效果之一。这种方法有一个最简单的版本:你只需要准备几层重叠的 text-shadow 即可，不需要考虑偏移量，颜色也只需跟文字保持一致：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#203</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-id\">#ffc</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 0 <span class=\"selector-class\">.1em</span>, 0 0 <span class=\"selector-class\">.3em</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">或者使用<span class=\"selector-tag\">CSS</span>滤镜：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#203</span>; </span><br><span class=\"line\">    <span class=\"attribute\">color</span>: white; </span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: <span class=\"number\">1s</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(.1em); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"文字凸起效果\"><a href=\"#文字凸起效果\" class=\"headerlink\" title=\"文字凸起效果\"></a><a href=\"http://play.csssecrets.io/extruded\" target=\"_blank\" rel=\"noopener\">文字凸起效果</a></h4><p>思路就是使用一长串累加的投影，不设模糊并以 1px 的跨度逐渐错开，使颜色逐渐变暗，然后在底部加一层强烈模糊的暗投影，从而模拟完整的立体效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background: #58a;</span><br><span class=\"line\">color: white;</span><br><span class=\"line\">text-shadow: 0 1px hsl(0,0%,85%),</span><br><span class=\"line\">             0 2px hsl(0,0%,80%), </span><br><span class=\"line\">             0 3px hsl(0,0%,75%), </span><br><span class=\"line\">             0 4px hsl(0,0%,70%), </span><br><span class=\"line\">             0 5px hsl(0,0%,65%), </span><br><span class=\"line\">             0 5px 10px black;</span><br></pre></td></tr></table></figure>\n<h4 id=\"模拟复古标志牌：\"><a href=\"#模拟复古标志牌：\" class=\"headerlink\" title=\"模拟复古标志牌：\"></a>模拟复古标志牌：</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">white</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">hsl</span>(0,50%,45%);</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 1<span class=\"selector-tag\">px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, 2<span class=\"selector-tag\">px</span> 2<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>,</span><br><span class=\"line\">             3<span class=\"selector-tag\">px</span> 3<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, 4<span class=\"selector-tag\">px</span> 4<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>,</span><br><span class=\"line\">             5<span class=\"selector-tag\">px</span> 5<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, 6<span class=\"selector-tag\">px</span> 6<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>,</span><br><span class=\"line\">             7<span class=\"selector-tag\">px</span> 7<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, 8<span class=\"selector-tag\">px</span> 8<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_265.png\" alt=\"\" width=\"\"></div>\n\n<h3 id=\"环形文字\"><a href=\"#环形文字\" class=\"headerlink\" title=\"环形文字\"></a><a href=\"http://play.csssecrets.io/circular-text\" target=\"_blank\" rel=\"noopener\">环形文字</a></h3><p>目前我们没有很好的纯 CSS 方案实现环形问题，只能借助内联 SVG 来实现这种效果；</p>\n<p>在 SVG 中，让文本按照路径排列的基本方法就是用一个 <code>&lt;textPath&gt;</code> 元素来包裹住这段文本，再把它们装进一个 <code>&lt;text&gt;</code> 元素中。这个 <code>&lt;textPath&gt;</code> 元素还需要在它的 ID 属性中引用一个 <code>&lt;path&gt;</code> 元素，然后就可以用这个 <code>&lt;path&gt;</code> 元素来定义我们想要的路径</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"circular\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">viewBox</span>=<span class=\"string\">\"0 0 100 100\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 0,50 a 50,50 0 1,1 0,1 z\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"circle\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这个效果的实现比较复杂，所以直接点击上面标题链接查看吧。。</p>\n<h2 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h2><h3 id=\"选用合适的鼠标光标\"><a href=\"#选用合适的鼠标光标\" class=\"headerlink\" title=\"选用合适的鼠标光标\"></a>选用合适的鼠标光标</h3><p>在<a href=\"http://w3.org/TR/css3-ui/#cursor\" target=\"_blank\" rel=\"noopener\">CSS 基本UI 特性（第三版）</a>中，我们获得了一大批新的内建光标：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_266.png\" alt=\"\" width=\"\"></div>\n\n<h3 id=\"扩大可点击区域\"><a href=\"#扩大可点击区域\" class=\"headerlink\" title=\"扩大可点击区域\"></a><a href=\"http://play.csssecrets.io/hit-area\" target=\"_blank\" rel=\"noopener\">扩大可点击区域</a></h3><p><a href=\"http://simonwallner.at/ext/fitts/\" target=\"_blank\" rel=\"noopener\">Fitts法则</a>：人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数；所以将可点击区域（热区）向外扩张往往可以带来可用性的提升，我们还需要了解：<strong>伪元素同样可以代表其宿主元素来响应鼠标交互</strong></p>\n<p>所以，我们可以在按钮的上层覆盖一层透明的伪元素，并让伪元素在四个方向上都比宿主元素大出 10px：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">button</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    /\\* \\[其余样式\\] */ </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: -<span class=\"number\">10px</span>; <span class=\"attribute\">right</span>: -<span class=\"number\">10px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: -<span class=\"number\">10px</span>; <span class=\"attribute\">left</span>: -<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个基于伪元素的解决方案极为灵活，我们基本上可以把热区设置为任何想要的尺寸、位置或形状，甚至可以脱离元素原有的位置!</p>\n<h3 id=\"自定义复选框\"><a href=\"#自定义复选框\" class=\"headerlink\" title=\"自定义复选框\"></a>自定义复选框</h3><p>知识点：伪类选择符 :checked 和属性选择符 [checked] 之间的区别是<strong>后者是不会根据用户的交互行为进行更新的，因为用户的交互并不会影响到 HTML 标签上的属性</strong>。 下面是作者实现的效果：</p>\n<ul>\n<li><a href=\"http://play.csssecrets.io/checkboxes\" target=\"_blank\" rel=\"noopener\">自定义复选框</a></li>\n<li><a href=\"http://play.csssecrets.io/toggle-buttons\" target=\"_blank\" rel=\"noopener\">开关式按钮</a></li>\n</ul>\n<h3 id=\"通过阴影来弱化背景\"><a href=\"#通过阴影来弱化背景\" class=\"headerlink\" title=\"通过阴影来弱化背景\"></a>通过阴影来弱化背景</h3><p>很多时候，我们需要通过一层半透明的遮罩层来把后面的一切整体调暗，以便凸显某个特定的 UI 元素，引导用户关注</p>\n<h4 id=\"伪元素方案\"><a href=\"#伪元素方案\" class=\"headerlink\" title=\"伪元素方案\"></a>伪元素方案</h4><p>我们可以通过伪元素来添加：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.dimmed</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed; </span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(0,0,0,.8);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>伪元素方案的缺点：<strong>伪元素无法绑定独立的JavaScript事件处理函数；</strong>同时 ::before 伪元素有可能已经被占用；还需要一点 JavaScript 来给 <code>&lt;body&gt;</code> 添加 dimmed 这个类</p>\n<h4 id=\"box-shadow方案\"><a href=\"#box-shadow方案\" class=\"headerlink\" title=\"box-shadow方案\"></a><a href=\"http://play.csssecrets.io/dimming-box-shadow\" target=\"_blank\" rel=\"noopener\">box-shadow方案</a></h4><p>box-shadow 的扩张参数可以把元素的投影向各个方向延伸放大。具体做法就是生成一个巨大的投影，不偏移也不模糊，简单而拙劣地模拟出遮罩层的效果:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 0 0 0 50<span class=\"selector-tag\">vmax</span> <span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.8</span>);</span><br></pre></td></tr></table></figure>\n<p>但是它也存在两个非常严重的问题：当我们滚动页面时，遮罩层的边缘就露出来了；<strong>它只能在视觉上起到引导注意力的作用，却无法阻止鼠标交互</strong></p>\n<h4 id=\"backdrop-方案\"><a href=\"#backdrop-方案\" class=\"headerlink\" title=\"backdrop 方案\"></a><a href=\"http://play.csssecrets.io/native-modal\" target=\"_blank\" rel=\"noopener\">backdrop 方案</a></h4><p>\b如果你想引导用户关注元素就是一个模态的 <code>&lt;dialog&gt;</code> 元素，那么根据浏览器的默认样式，它会自带一个遮罩层。借助 ::backdrop 伪元素，这个原生的遮罩层也是可以设置样式的，比如可以把它变得更暗一些：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dialog</span><span class=\"selector-pseudo\">::backdrop</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(0, 0, 0, .8);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>唯一需要注意的地方在于，<strong>浏览器对它的支持还极为有限</strong></p>\n<h2 id=\"通过模糊来弱化背景\"><a href=\"#通过模糊来弱化背景\" class=\"headerlink\" title=\"通过模糊来弱化背景\"></a><a href=\"http://play.csssecrets.io/deemphasizing-blur\" target=\"_blank\" rel=\"noopener\">通过模糊来弱化背景</a></h2><p>我们需要一个额外的 HTML 元素来实现这个效果：需要把页面上除了关键元素之外的一切都包裹起来，这样就可以只对这个容器元素进行模糊处理了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\">    O HAI, I'm a dialog. Click on me to dismiss.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> 其他对话框都写在这里 <span class=\"attr\">--</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>接下来，每当弹出一个对话框，都需要给 <code>&lt;main&gt;</code> 元素增加一个类，以便对它应用模糊滤镜：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span><span class=\"selector-class\">.de-emphasized</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(5px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动提示\"><a href=\"#滚动提示\" class=\"headerlink\" title=\"滚动提示\"></a><a href=\"http://play.csssecrets.io/scrolling-hints\" target=\"_blank\" rel=\"noopener\">滚动提示</a></h3><p>我们需要实现的效果类似 Google Reader 中的一种用户体验模式：当侧边栏的容器还有更多内容时，一层淡淡的阴影会出现在容器的顶部和 / 或底部，用来提示侧边栏需要滚动才能看到完整的内容</p>\n<div align=\"center\"><img src=\"/images/hexo_post_267.png\" alt=\"\" width=\"\"></div>\n\n<p>我们可以用纯 CSS 实现这种效果，利用的就是 background-attachment 属性的一个关键字：local，但是<strong>我们需要两层背景</strong>：一层用来生成那条阴影，另一层基本上就是一个用来遮挡阴影的白色矩形，其作用类似于遮罩层。生成阴影的那层背景将具有默认的 background-attachment 值(scroll)，因为我们希望它总是保持在原位。我们把遮罩背景的 background-attachment 属性设置为 local，这样它就会在我们滚动到最顶部时盖住阴影，在向下滚动时跟着滚动，从而露出阴影。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">white</span> 30%, <span class=\"selector-tag\">transparent</span>), </span><br><span class=\"line\">            <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">at</span> 50% 0, <span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.2</span>),<span class=\"selector-tag\">transparent</span> 70%); </span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">no-repeat</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 50<span class=\"selector-tag\">px</span>, 100% 15<span class=\"selector-tag\">px</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-attachment</span>: <span class=\"selector-tag\">local</span>, <span class=\"selector-tag\">scroll</span>;</span><br></pre></td></tr></table></figure>\n<p>但是为了完整地实现这个效果，我们<strong>还需要再用两层渐变来实现底部的阴影和它配套的遮罩</strong>，具体实现可以点击上面的链接查看</p>\n<h3 id=\"交互式的图片对比控件\"><a href=\"#交互式的图片对比控件\" class=\"headerlink\" title=\"交互式的图片对比控件\"></a>交互式的图片对比控件</h3><p>有时，我们需要展示两张图片的外观差异，通常是“之前和之后”形式的对比</p>\n<h4 id=\"CSS-resize方案\"><a href=\"#CSS-resize方案\" class=\"headerlink\" title=\"CSS resize方案\"></a><a href=\"http://play.csssecrets.io/image-slider\" target=\"_blank\" rel=\"noopener\">CSS resize方案</a></h4><p>resize 属性可以让某个元素的大小变得可调整，我们的第一个念头可能是列出两个 <code>&lt;img&gt;</code> 元素。但是，直接对一个 <code>&lt;img&gt;</code> 元素应用 resize 看起来会很怪异，因为直接调整图片大小会导致其变形失真。如果用一个 <code>&lt;div&gt;</code> 作为它的容器，再对这个容器应用 resize 属性，那就合理多了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"image-slider\"</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"adamcatlace-before.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Before\"</span> /&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"adamcatlace-after.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"After\"</span> /&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>resize 起作用的前提条件是它的 overflow 属性不是 visible；</strong>同时我们可以通过伪元素改变调节手柄的样式；最后，我们可以对这两张图片应用 user-select: none，这样即使用户在没有点中调节手柄的情况下拖动鼠标，也不会误选图片：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.image-slider</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.image-slider</span> &gt; <span class=\"selector-tag\">div</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">resize</span>: horizontal; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.image-slider</span> &gt; <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">12px</span>; <span class=\"attribute\">height</span>: <span class=\"number\">12px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">linear-gradient</span>(-45deg, white 50%, transparent 0); </span><br><span class=\"line\">    <span class=\"attribute\">background-clip</span>: content-box;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: ew-resize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.image-slider</span> <span class=\"selector-tag\">img</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">user-select</span>: none; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"范围输入控件方案\"><a href=\"#范围输入控件方案\" class=\"headerlink\" title=\"范围输入控件方案\"></a>范围输入控件方案</h4><p>上面的 CSS resize 方案有一些不足之处：</p>\n<ul>\n<li>对键盘来说不可访问</li>\n<li>调整上层图片的唯一方法就是拖动</li>\n<li>用户只能在右下角进行调整大小的操作</li>\n</ul>\n<p>我们可以将原生的滑块控件（HTML 范围输入控件）覆盖在图片上，用它来控制上层图片的伸缩，这样就可以解决上述三个问题，同时为了让范围输入控件在视觉上与整个控件更加统一，可以用混合模式和滤镜来实现，最终实现效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_268.png\" alt=\"\" width=\"\"></div>\n\n<h2 id=\"结构与布局\"><a href=\"#结构与布局\" class=\"headerlink\" title=\"结构与布局\"></a>结构与布局</h2><h3 id=\"自适应内部元素\"><a href=\"#自适应内部元素\" class=\"headerlink\" title=\"自适应内部元素\"></a><a href=\"http://play.csssecrets.io/intrinsic-sizing\" target=\"_blank\" rel=\"noopener\">自适应内部元素</a></h3><p>众所周知，如果不给元素指定一个具体的 height，它就会自动适应其内容的高度。假如我们希望 width 也具有类似的行为，该怎么做呢?</p>\n<p>CSS 内部与外部尺寸模型（第三版）为 width 和 height 属性定义了一些新的关键字，其中最有用的应该就是 min-content 了。这个关键字将解析为这个容器内部最大的不可断行元素的宽度(即最宽的单词、图片或具有固定宽度的盒元素)。这正是我们梦寐以求的！为了给那些旧版浏览器提供一个平稳的回退样式，我们需要在使用这个技巧的同时，提供一个固定的 max-width 值：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">figure</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: <span class=\"number\">300px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: min-content; </span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">figure</span> &gt; <span class=\"selector-tag\">img</span> &#123; <span class=\"attribute\">max-width</span>: inherit; &#125;</span><br></pre></td></tr></table></figure>\n<p>关于 width 和 height 的新关键字，还有 max-content，它的行为类似于我们在前面看到的 display: inline-block；而 fit-content 的行为与浮动元素是相同的(和 min-content 的效果通常一致，但也有例外)。</p>\n<h3 id=\"精确控制表格列宽\"><a href=\"#精确控制表格列宽\" class=\"headerlink\" title=\"精确控制表格列宽\"></a><a href=\"http://play.csssecrets.io/table-column-widths\" target=\"_blank\" rel=\"noopener\">精确控制表格列宽</a></h3><p>对于不固定的内容来说，表格的布局是很难预测的，这是因为<strong>列宽根据其内容进行调整</strong>，即使我们显式地指定了 width。解决方案来自于 CSS 2.1 中一个鲜为人知的属性，叫做 table-layout，它的默认值是 auto，其行为模式被称作自动表格布局算法，也就是我们最为熟悉的表格布局行为。不过，它还接受另外一个值 <strong>fixed</strong>，这个值的行为要明显可控一些，使用也很简单：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">table</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">table-layout</span>: fixed; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"根据兄弟元素的数量来设置样式\"><a href=\"#根据兄弟元素的数量来设置样式\" class=\"headerlink\" title=\"根据兄弟元素的数量来设置样式\"></a><a href=\"http://play.csssecrets.io/styling-sibling-count\" target=\"_blank\" rel=\"noopener\">根据兄弟元素的数量来设置样式</a></h3><p>在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。</p>\n<p>对于只有一个列表项的特殊场景来说，解决方案显然就是 :only-child：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:only-child</span> &#123;</span><br><span class=\"line\">    /\\* 只有一个列表项时的样式 */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，:only-child 等效于 :first-child:last-child，道理就是：如果第一项也是最后一项，那它就是唯一的那一项；而 :first-child:nth-last-child(4) 会匹配到一个正好有四个列表项的列表中的第一个列表项，所以下面的选择符就相当于<strong>在这个列表正好包含四个列表项时，命中它的每一项</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(4)</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(4)</span> ~ <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    /\\* 当列表正好包含四项时，命中所有列表项 */ </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用选择符的表达式，我们可以<strong>在列表项的总数是4或更多时选中所有列表项</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(n+4)</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(n+4)</span> ~ <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    /\\* 当列表至少包含四项时，命中所有列表项 */ </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理，-n+b 这种形式的表达式可以选中开头的 b 个元素。因此，我们可以<strong>在列表项的总数是 4 个或更少时选中所有列表项</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(-n+4)</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(-n+4)</span> ~ <span class=\"selector-tag\">li</span> &#123; </span><br><span class=\"line\">    /\\* 当列表最多包含四项时，命中所有列表项 */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，我们还可以把这两种技巧组合起来使用，不过代码也会变得更加复杂。假设我们希望<strong>在列表包含 2 ~ 6 个列表项时命中所有的列表项</strong>，可以这样写:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(n+2)</span><span class=\"selector-pseudo\">:nth-last-child(-n+6)</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(n+2)</span><span class=\"selector-pseudo\">:nth-last-child(-n+6)</span> ~ <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    /\\* 当列表包含2~6项时，命中所有列表项 */ </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"满幅的背景，定宽的内容\"><a href=\"#满幅的背景，定宽的内容\" class=\"headerlink\" title=\"满幅的背景，定宽的内容\"></a><a href=\"http://play.csssecrets.io/fluid-fixed\" target=\"_blank\" rel=\"noopener\">满幅的背景，定宽的内容</a></h3><p>背景宽度满幅，内容宽度固定的设计手法在网页的页脚中经常看到：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_269.png\" alt=\"\" width=\"\"></div>\n\n<p>绝大多数的网页设计师/工程师都是用两层元素来实现的，那么能不能用一层元素实现呢？其实我们可以用 calc() 来实现内容的居中：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: <span class=\"number\">900px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">1em</span>;  <span class=\"comment\">/* 回退样式 */</span></span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span> <span class=\"built_in\">calc</span>(50% - 450px); </span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h3><blockquote>\n<p>44 年前我们就把人类送上月球了，但现在我们仍然无法在 CSS 中实现垂直居中 —— James Anderson</p>\n</blockquote>\n<h4 id=\"几种十分流行的技巧：\"><a href=\"#几种十分流行的技巧：\" class=\"headerlink\" title=\"几种十分流行的技巧：\"></a>几种十分流行的技巧：</h4><ul>\n<li>表格布局法</li>\n<li>行内块法</li>\n</ul>\n<p>Chris Coyier 写的<a href=\"http://css-tricks.com/centering-in-the-unknown\" target=\"_blank\" rel=\"noopener\">“不为人知的居中方法”</a>详细讲述了这两种技巧</p>\n<h4 id=\"基于绝对定位的解决方案\"><a href=\"#基于绝对定位的解决方案\" class=\"headerlink\" title=\"基于绝对定位的解决方案\"></a><a href=\"http://play.csssecrets.io/vertical-centering-abs\" target=\"_blank\" rel=\"noopener\">基于绝对定位的解决方案</a></h4><p>早期的垂直居中方法，它要求元素具有固定的宽度和高度：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">3em</span>; <span class=\"comment\">/* 6/2 = 3 */</span> </span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">9em</span>; <span class=\"comment\">/* 18/2 = 9 */</span> </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">18em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CSS 领域有一个很常见的现象，真正的解决方案往往来自于我们最意想不到的地方。当我们在 translate() 变形函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的，所以就解除了对固定尺寸的依赖：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-50%, -50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个方法有一些需要注意的地方：</p>\n<ul>\n<li>有时不能选用绝对定位</li>\n<li>如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视口裁切掉</li>\n<li>在某些浏览器中，这个方法可能会导致元素的显示有一些模糊</li>\n</ul>\n<h4 id=\"基于视口单位的解决方案\"><a href=\"#基于视口单位的解决方案\" class=\"headerlink\" title=\"基于视口单位的解决方案\"></a><a href=\"http://play.csssecrets.io/vertical-centering-vh\" target=\"_blank\" rel=\"noopener\">基于视口单位的解决方案</a></h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">18em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span> <span class=\"number\">1.5em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">50vh</span> auto <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基于-Flexbox-的解决方案\"><a href=\"#基于-Flexbox-的解决方案\" class=\"headerlink\" title=\"基于 Flexbox 的解决方案\"></a><a href=\"http://play.csssecrets.io/vertical-centering\" target=\"_blank\" rel=\"noopener\">基于 Flexbox 的解决方案</a></h4><p>这是毋庸置疑的最佳解决方案：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们使用 Flexbox 时，margin:auto 不仅在水平方向上将元素居中，垂直方向上也是如此</p>\n<h3 id=\"紧贴底部的页脚\"><a href=\"#紧贴底部的页脚\" class=\"headerlink\" title=\"紧贴底部的页脚\"></a>紧贴底部的页脚</h3><p>这是一个相当常见的问题：我们希望内容很长时，页脚在内容的尾部；而如果内容很短，页脚会在视口的底部。</p>\n<h4 id=\"一些解决方案（仍然有局限之处）：\"><a href=\"#一些解决方案（仍然有局限之处）：\" class=\"headerlink\" title=\"一些解决方案（仍然有局限之处）：\"></a>一些解决方案（仍然有局限之处）：</h4><ul>\n<li><a href=\"https://css-tricks.com/snippets/css/sticky-footer/\" target=\"_blank\" rel=\"noopener\">https://css-tricks.com/snippets/css/sticky-footer/</a></li>\n<li><a href=\"https://pixelsvsbytes.com/2011/09/sticky-css-footers-the-flexible-way/\" target=\"_blank\" rel=\"noopener\">https://pixelsvsbytes.com/2011/09/sticky-css-footers-the-flexible-way/</a></li>\n</ul>\n<h4 id=\"固定高度的解决方案\"><a href=\"#固定高度的解决方案\" class=\"headerlink\" title=\"固定高度的解决方案\"></a><a href=\"http://play.csssecrets.io/sticky-footer-fixed\" target=\"_blank\" rel=\"noopener\">固定高度的解决方案</a></h4><p>我们可以通过计算给内容指定最小高度，然后就可以将页脚“固定”到底部：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"built_in\">calc</span>(100vh - 7em); <span class=\"comment\">/* 7em为页脚高度 */</span> </span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Flexbox-的解决方案\"><a href=\"#Flexbox-的解决方案\" class=\"headerlink\" title=\"Flexbox 的解决方案\"></a><a href=\"http://play.csssecrets.io/sticky-footer\" target=\"_blank\" rel=\"noopener\">Flexbox 的解决方案</a></h4><p>我们需要对 <code>&lt;body&gt;</code> 元素设置 display:flex，然后将其 min-height 属性指定为 100vh，这样它就至少会占据整个视口的高度；此时我们所期望的是，页头和页脚的高度由其内部元素来决定，而内容区块的高度应该可以自动伸展并占满所有的可用空间。我们只要给 <code>&lt;main&gt;</code> 这个容器的 flex 属性指定一个大于 0 的值(比如 1 即可)，就可以实现这个效果了:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-flow</span>: column;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">100vh</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123; <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"过渡与动画\"><a href=\"#过渡与动画\" class=\"headerlink\" title=\"过渡与动画\"></a>过渡与动画</h2><h3 id=\"缓动效果\"><a href=\"#缓动效果\" class=\"headerlink\" title=\"缓动效果\"></a>缓动效果</h3><p>在现实世界中，物体从 A 点到 B 点的移动往往不是完全匀速的</p>\n<h4 id=\"弹跳动画\"><a href=\"#弹跳动画\" class=\"headerlink\" title=\"弹跳动画\"></a><a href=\"http://play.csssecrets.io/bounce\" target=\"_blank\" rel=\"noopener\">弹跳动画</a></h4><p>CSS 提供了一个 cubic-bezier() 函数，允许我们指定自定义的调速函数，借助该函数，我们可以近乎完美的实现回弹动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> bounce &#123; </span><br><span class=\"line\">    60%, 80%, <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(400px);</span><br><span class=\"line\">        <span class=\"attribute\">animation-timing-function</span>: ease; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    70% &#123; <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(300px); &#125;</span><br><span class=\"line\">    90% &#123; <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(360px); &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.ball</span> &#123;</span><br><span class=\"line\">    /\\* 外观样式 */</span><br><span class=\"line\">    <span class=\"selector-tag\">animation</span>: <span class=\"selector-tag\">bounce</span> 3<span class=\"selector-tag\">s</span> <span class=\"selector-tag\">cubic-bezier</span>(<span class=\"selector-class\">.1</span>,<span class=\"selector-class\">.25</span>,1,<span class=\"selector-class\">.25</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"弹性过渡\"><a href=\"#弹性过渡\" class=\"headerlink\" title=\"弹性过渡\"></a><a href=\"http://play.csssecrets.io/elastic\" target=\"_blank\" rel=\"noopener\">弹性过渡</a></h4><p>同样是 cubic-bezier() 函数的使用：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:focus)</span> + <span class=\"selector-class\">.callout</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0); </span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">25s</span> transform;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.callout</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: <span class=\"number\">1.4em</span> -.<span class=\"number\">4em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">5s</span> <span class=\"built_in\">cubic-bezier</span>(.25,.1,.3,1.5) transform;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"逐帧动画\"><a href=\"#逐帧动画\" class=\"headerlink\" title=\"逐帧动画\"></a><a href=\"http://play.csssecrets.io/frame-by-frame\" target=\"_blank\" rel=\"noopener\">逐帧动画</a></h4><p>在很多时候，我们需要一个很难（或不可能）只通过某些 CSS 属性的过渡来实现的动画。但由于 GIF 不具备透明的特性，所以下面的加载提示只能用CSS动画实现：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_270.png\" alt=\"\" width=\"\"></div>\n\n<p>而如何实现这种逐帧动画效果呢？秘诀就是 steps() 这个调速函数，steps() 函数会使整个动画在帧与帧之间硬切，所以只需把动画的代码修改为下面的形式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">animation</span>: <span class=\"selector-tag\">loader</span> 1<span class=\"selector-tag\">s</span> <span class=\"selector-tag\">infinite</span> <span class=\"selector-tag\">steps</span>(8);</span><br></pre></td></tr></table></figure>\n<h3 id=\"闪烁效果\"><a href=\"#闪烁效果\" class=\"headerlink\" title=\"闪烁效果\"></a><a href=\"http://play.csssecrets.io/blink\" target=\"_blank\" rel=\"noopener\">闪烁效果</a></h3><p>这里涉及到的知识点是 animation-direction 中的 alternate 属性，它的作用是反转第偶数个循环周期（包括调整函数）：</p>\n<blockquote>\n<p>animation-direction: normal | alternate | reverse | alternate-reverse</p>\n</blockquote>\n<div align=\"center\"><img src=\"/images/hexo_post_271.png\" alt=\"\" width=\"\"></div>\n\n<h3 id=\"打字动画\"><a href=\"#打字动画\" class=\"headerlink\" title=\"打字动画\"></a><a href=\"http://play.csssecrets.io/typing\" target=\"_blank\" rel=\"noopener\">打字动画</a></h3><p>CSS 值与单位规范引入了一个新单位，表示“0”字形的宽度，叫做 ch ；在等宽字体中，“0” 字形的宽度和其他所有字形的宽度是一样的，所以如果我们用 ch 单位来表达一段文本的宽度，那取值实际上就是字符的数量；最后，我们可以借助上面的闪烁动画的原理来实现文字后面闪烁的光标</p>\n<h3 id=\"状态平滑的动画\"><a href=\"#状态平滑的动画\" class=\"headerlink\" title=\"状态平滑的动画\"></a><a href=\"http://play.csssecrets.io/state-animations\" target=\"_blank\" rel=\"noopener\">状态平滑的动画</a></h3><p>我们需要根据用户的交互行为来暂停动画和继续之前的动画状态，从而避免生硬的跳回现象，而 animation-play-state 正是为这种暂停动画的需求专门设计的：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> panoramic &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123; <span class=\"attribute\">background-position</span>: <span class=\"number\">100%</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.panoramic</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>; <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"img/naxos-greece.jpg\"</span>); </span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: auto <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: panoramic <span class=\"number\">10s</span> linear infinite alternate; </span><br><span class=\"line\">    <span class=\"attribute\">animation-play-state</span>: paused;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.panoramic</span><span class=\"selector-pseudo\">:hover</span>, <span class=\"selector-class\">.panoramic</span><span class=\"selector-pseudo\">:focus</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">animation-play-state</span>: running;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"沿环形路径平移的动画\"><a href=\"#沿环形路径平移的动画\" class=\"headerlink\" title=\"沿环形路径平移的动画\"></a>沿环形路径平移的动画</h3><p>我们需要让一个元素沿着环形路径动起来，同时元素中的内容（图片、文字）不能发生旋转</p>\n<h4 id=\"需要两个元素的解决方案\"><a href=\"#需要两个元素的解决方案\" class=\"headerlink\" title=\"需要两个元素的解决方案\"></a><a href=\"http://play.csssecrets.io/circular-2elements\" target=\"_blank\" rel=\"noopener\">需要两个元素的解决方案</a></h4><p>我们让元素旋转，同时让其中的内容以相反的方向进行自转，从而可以抵消元素旋转的影响，由此可见，我们可以用 animation-direction 来实现这样的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> spin &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123; <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(1turn); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.avatar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: spin <span class=\"number\">3s</span> infinite linear; </span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: <span class=\"number\">50%</span> <span class=\"number\">150px</span>; <span class=\"comment\">/* 150px = 路径的半径 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.avatar</span> &gt; <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: inherit; </span><br><span class=\"line\">    <span class=\"attribute\">animation-direction</span>: reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"单个元素的解决方案\"><a href=\"#单个元素的解决方案\" class=\"headerlink\" title=\"单个元素的解决方案\"></a><a href=\"http://play.csssecrets.io/circular\" target=\"_blank\" rel=\"noopener\">单个元素的解决方案</a></h4><blockquote>\n<p>“transform-origin 只是一个语法糖而已。实际上你总是可以用 translate() 来代替它。” ——Aryeh Gregor</p>\n</blockquote>\n","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]}]}