{"name":"git","postlist":[{"title":"Git commit 中的Change-Id是什么","slug":"Git commit 中的Change-Id是什么","date":"2017-08-20T12:38:52.000Z","updated":"2019-02-04T13:27:44.349Z","comments":true,"path":"api/articles/Git commit 中的Change-Id是什么.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_91.png","content":"<p>之前在创业公司实习的时候代码管理很不规范，技术部负责人把每个人的 ssh key 添加到公司 github 中之后就可以执行 git 相关操作了，根本没有权限的概念；后来进入公司之后，才知道还有 Gerrit 这种东西，而第一次 push 代码的时候就遇到了 <code>ERROR: missing Change-Id in commit message</code> 的错误，后来才得知是因为没有 Change-Id 的缘故，下面就介绍一下 Change-Id 是什么东东：</p>\n<h2 id=\"什么是-Change-Id\"><a href=\"#什么是-Change-Id\" class=\"headerlink\" title=\"什么是 Change-Id\"></a>什么是 Change-Id</h2><p>Change-Id 其实就是一段形如 <code>I7cbfa01f5136b8815e5e2c6dc5dcda28ce49d13a</code> 的字符串，它的作用是：</p>\n<blockquote>\n<p>保证已经提交审核的修订通过审核入库后，被别的分支 cherry-pick 后再推送至服务器时不会产生新的重复的评审任务。</p>\n</blockquote>\n<p>Gerrit 设计了一套方法，即要求每个提交包含唯一的 Change-Id，这个 Change-Id 因为出现在日志中，当执行 cherry-pick 时也会保持，Gerrit 一旦发现新的提交包含了已经处理过的 Change-Id，就不再为该修订创建新的评审任务和 task-id，而直接将提交入库。<br>总之，Change-Id 就是 Gerrit 为了确保 cherry-pick 已提交审核的分支时不会在产生新的提交记录。</p>\n<h2 id=\"解决-ERROR：missing-Change-Id-in-commit-message\"><a href=\"#解决-ERROR：missing-Change-Id-in-commit-message\" class=\"headerlink\" title=\"解决 ERROR：missing Change-Id in commit message\"></a>解决 <code>ERROR：missing Change-Id in commit message</code></h2><p>在一开始我们提到过，在执行 <code>git push origin Head:refs/for/xxxx</code> 时有时会报出上面标题这样的错误，也就是在 commit Message 仅仅包含如 <code>feature：xxxx</code> 等 title 这样的信息而缺少 Change-Id。那么怎样解决呢？</p>\n<h3 id=\"临时解决\"><a href=\"#临时解决\" class=\"headerlink\" title=\"临时解决\"></a>临时解决</h3><p>git commit 有一个神奇的参数，叫做 <code>--amend</code>，如果我们遇到了上面的错误，可以执行下面的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n<p>然后我们可以看到最近一次 commit 的相关信息，在 title 下面空出一行（注意，一定要空出一行，否则 git 会把其作为 title 的一部分处理）后，将 <code>Change-Id: XXXX</code> 复制到 Message 中。然后就可以 push 了。你可能会问了，我哪知道 Change-Id 是什么呢？可以先查看一下之前的 commit 信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<p>然后你可能会看到这样一条信息：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_91.png\" alt=\"\" width=\"400\"></div>\n\n<p>现在你懂了吧，其实可以看到之前人提交 commit 信息的 Change-Id，我们只需要复制一下（注意 <code>Change-Id:</code> 后面有个空格）然后改一下其中某个字母就可以了（因为 Change-Id 不允许重复，如果重复了，可以再改一个字母，一般只需要改一个字母就可以了），这时我们就有了一个人工生成的 <code>Change-Id</code> 了。 注意，这种办法只是一种临时解决方案，下次如果你再想 commit 就需要再复制一个 Change-Id，然后 –amend 修改 commit 信息，是不是感觉每次这样修改很麻烦？没事，我们有一个永久解决方案：</p>\n<h3 id=\"自动生成-Change-Id\"><a href=\"#自动生成-Change-Id\" class=\"headerlink\" title=\"自动生成 Change-Id\"></a>自动生成 Change-Id</h3><p>其实我们可以利用 commit-msg 这个 hook 文件自动生成 Change-Id，具体做法如下：</p>\n<ul>\n<li>将文章下面的 commit-msg hook 脚本复制到 git 项目中 .git/hooks 下，并命名为 commit-msg（一般情况下 .git/hooks 下会包含一个叫 commit-msg.sample 的文件，可以把它删除）</li>\n<li>添加完之后，执行</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u+x .git/hooks/commit-msg</span><br></pre></td></tr></table></figure>\n<p>激活 hook，以后提交的时候就会自动携带 Change-Id 了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\">\\<span class=\"comment\"># From Gerrit Code Review 2.6</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># Part of Gerrit Code Review (http://code.google.com/p/gerrit/)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># Copyright (C) 2009 The Android Open Source Project</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># Licensed under the Apache License, Version 2.0 (the \"License\");</span></span><br><span class=\"line\">\\<span class=\"comment\"># you may not use this file except in compliance with the License.</span></span><br><span class=\"line\">\\<span class=\"comment\"># You may obtain a copy of the License at</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class=\"line\">\\<span class=\"comment\"># distributed under the License is distributed on an \"AS IS\" BASIS,</span></span><br><span class=\"line\">\\<span class=\"comment\"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class=\"line\">\\<span class=\"comment\"># See the License for the specific language governing permissions and</span></span><br><span class=\"line\">\\<span class=\"comment\"># limitations under the License.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unset</span> GREP_OPTIONS</span><br><span class=\"line\"></span><br><span class=\"line\">CHANGE\\_ID\\_AFTER=<span class=\"string\">\"Bug|Issue\"</span></span><br><span class=\"line\">MSG=<span class=\"string\">\"<span class=\"variable\">$1</span>\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">\\<span class=\"comment\"># Check for, and add if missing, a unique Change-Id</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">add_ChangeId</span></span>() &#123;</span><br><span class=\"line\">clean_message=`sed -e <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">/^diff --git a\\\\/.*/&#123;</span></span><br><span class=\"line\"><span class=\"string\">s///</span></span><br><span class=\"line\"><span class=\"string\">q</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">/^Signed-off-by:/d</span></span><br><span class=\"line\"><span class=\"string\">/^#/d</span></span><br><span class=\"line\"><span class=\"string\">'</span> <span class=\"string\">\"<span class=\"variable\">$MSG</span>\"</span> | git stripspace`</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> -z <span class=\"string\">\"<span class=\"variable\">$clean_message</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">return</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\\<span class=\"comment\"># Does Change-Id: already exist? if so, exit (no change).</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> grep -i <span class=\"string\">'^Change-Id:'</span> <span class=\"string\">\"<span class=\"variable\">$MSG</span>\"</span> &gt;/dev/null</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">return</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">id=`\\_gen\\_ChangeId`</span><br><span class=\"line\">T=<span class=\"string\">\"<span class=\"variable\">$MSG</span>.tmp.$$\"</span></span><br><span class=\"line\">AWK=awk</span><br><span class=\"line\"><span class=\"keyword\">if</span> \\[ -x /usr/xpg4/bin/awk \\]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\\<span class=\"comment\"># Solaris AWK is just too broken</span></span><br><span class=\"line\">AWK=/usr/xpg4/bin/awk</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\\<span class=\"comment\"># How this works:</span></span><br><span class=\"line\">\\<span class=\"comment\"># - parse the commit message as (textLine+ blankLine*)*</span></span><br><span class=\"line\">\\<span class=\"comment\"># - assume textLine+ to be a footer until proven otherwise</span></span><br><span class=\"line\">\\<span class=\"comment\"># - exception: the first block is not footer (as it is the title)</span></span><br><span class=\"line\">\\<span class=\"comment\"># - read textLine+ into a variable</span></span><br><span class=\"line\">\\<span class=\"comment\"># - then count blankLines</span></span><br><span class=\"line\">\\<span class=\"comment\"># - once the next textLine appears, print textLine+ blankLine* as these</span></span><br><span class=\"line\">\\<span class=\"comment\"># aren't footer</span></span><br><span class=\"line\">\\<span class=\"comment\"># - in END, the last textLine+ block is available for footer parsing</span></span><br><span class=\"line\"><span class=\"variable\">$AWK</span> <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">BEGIN &#123;</span></span><br><span class=\"line\"><span class=\"string\">\\# while we start with the assumption that textLine+</span></span><br><span class=\"line\"><span class=\"string\">\\# is a footer, the first block is not.</span></span><br><span class=\"line\"><span class=\"string\">isFooter = 0</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 0</span></span><br><span class=\"line\"><span class=\"string\">blankLines = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Skip lines starting with \"#\" without any spaces before it.</span></span><br><span class=\"line\"><span class=\"string\">/^#/ &#123; next &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Skip the line starting with the diff command and everything after it,</span></span><br><span class=\"line\"><span class=\"string\">\\# up to the end of the file, assuming it is only patch data.</span></span><br><span class=\"line\"><span class=\"string\">\\# If more than one line before the diff was empty, strip all but one.</span></span><br><span class=\"line\"><span class=\"string\">/^diff --git a/ &#123;</span></span><br><span class=\"line\"><span class=\"string\">blankLines = 0</span></span><br><span class=\"line\"><span class=\"string\">while (getline) &#123; &#125;</span></span><br><span class=\"line\"><span class=\"string\">next</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Count blank lines outside footer comments</span></span><br><span class=\"line\"><span class=\"string\">/^$/ &amp;&amp; (footerComment == 0) &#123;</span></span><br><span class=\"line\"><span class=\"string\">blankLines++</span></span><br><span class=\"line\"><span class=\"string\">next</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Catch footer comment</span></span><br><span class=\"line\"><span class=\"string\">/^\\\\\\[\\[a-zA-Z0-9-\\]+:/ &amp;&amp; (isFooter == 1) &#123;</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 1</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/\\]$/ &amp;&amp; (footerComment == 1) &#123;</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 2</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# We have a non-blank line after blank lines. Handle this.</span></span><br><span class=\"line\"><span class=\"string\">(blankLines &gt; 0) &#123;</span></span><br><span class=\"line\"><span class=\"string\">print lines</span></span><br><span class=\"line\"><span class=\"string\">for (i = 0; i &lt; blankLines; i++) &#123;</span></span><br><span class=\"line\"><span class=\"string\">print \"\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">lines = \"\"</span></span><br><span class=\"line\"><span class=\"string\">blankLines = 0</span></span><br><span class=\"line\"><span class=\"string\">isFooter = 1</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Detect that the current block is not the footer</span></span><br><span class=\"line\"><span class=\"string\">(footerComment == 0) &amp;&amp; (!/^\\\\\\[?\\[a-zA-Z0-9-\\]+:/ || /^\\[a-zA-Z0-9-\\]+:\\\\/\\\\//) &#123;</span></span><br><span class=\"line\"><span class=\"string\">isFooter = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">\\# We need this information about the current last comment line</span></span><br><span class=\"line\"><span class=\"string\">if (footerComment == 2) &#123;</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">if (lines != \"\") &#123;</span></span><br><span class=\"line\"><span class=\"string\">lines = lines \"\\\\n\";</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">lines = lines $0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Footer handling:</span></span><br><span class=\"line\"><span class=\"string\">\\# If the last block is considered a footer, splice in the Change-Id at the</span></span><br><span class=\"line\"><span class=\"string\">\\# right place.</span></span><br><span class=\"line\"><span class=\"string\">\\# Look for the right place to inject Change-Id by considering</span></span><br><span class=\"line\"><span class=\"string\">\\# CHANGE\\_ID\\_AFTER. Keys listed in it (case insensitive) come first,</span></span><br><span class=\"line\"><span class=\"string\">\\# then Change-Id, then everything else (eg. Signed-off-by:).</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\">\\# Otherwise just print the last block, a new line and the Change-Id as a</span></span><br><span class=\"line\"><span class=\"string\">\\# block of its own.</span></span><br><span class=\"line\"><span class=\"string\">END &#123;</span></span><br><span class=\"line\"><span class=\"string\">unprinted = 1</span></span><br><span class=\"line\"><span class=\"string\">if (isFooter == 0) &#123;</span></span><br><span class=\"line\"><span class=\"string\">print lines \"\\\\n\"</span></span><br><span class=\"line\"><span class=\"string\">lines = \"\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">changeIdAfter = \"^(\" tolower(\"'</span><span class=\"string\">\"<span class=\"variable\">$CHANGE</span>\\_ID\\_AFTER\"</span><span class=\"string\">'\") \"):\"</span></span><br><span class=\"line\"><span class=\"string\">numlines = split(lines, footer, \"\\\\n\")</span></span><br><span class=\"line\"><span class=\"string\">for (line = 1; line &lt;= numlines; line++) &#123;</span></span><br><span class=\"line\"><span class=\"string\">if (unprinted &amp;&amp; match(tolower(footer\\[line\\]), changeIdAfter) != 1) &#123;</span></span><br><span class=\"line\"><span class=\"string\">unprinted = 0</span></span><br><span class=\"line\"><span class=\"string\">print \"Change-Id: I'</span><span class=\"string\">\"<span class=\"variable\">$id</span>\"</span><span class=\"string\">'\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">print footer\\[line\\]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">if (unprinted) &#123;</span></span><br><span class=\"line\"><span class=\"string\">print \"Change-Id: I'</span><span class=\"string\">\"<span class=\"variable\">$id</span>\"</span><span class=\"string\">'\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span> <span class=\"string\">\"<span class=\"variable\">$MSG</span>\"</span> &gt; <span class=\"string\">\"<span class=\"variable\">$T</span>\"</span> &amp;&amp; mv <span class=\"string\">\"<span class=\"variable\">$T</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$MSG</span>\"</span> || rm -f <span class=\"string\">\"<span class=\"variable\">$T</span>\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\\_gen\\<span class=\"function\"><span class=\"title\">_ChangeIdInput</span></span>() &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"tree \\`git write-tree\\`\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> parent=\\`git rev-parse <span class=\"string\">\"HEAD^0\"</span> 2&gt;/dev/null\\`</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"parent <span class=\"variable\">$parent</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"author \\`git var GIT\\_AUTHOR\\_IDENT\\`\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"committer \\`git var GIT\\_COMMITTER\\_IDENT\\`\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">'%s'</span> <span class=\"string\">\"<span class=\"variable\">$clean_message</span>\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\\_gen\\<span class=\"function\"><span class=\"title\">_ChangeId</span></span>() &#123;</span><br><span class=\"line\">\\_gen\\_ChangeIdInput |</span><br><span class=\"line\">git <span class=\"built_in\">hash</span>-object -t commit --stdin</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add_ChangeId</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[{"name":"git","path":"api/tags/git.json"},{"name":"change-id","path":"api/tags/change-id.json"}]},{"title":"Git工作区、暂存区和历史记录区","slug":"Git工作区、暂存区和历史记录区","date":"2017-06-28T12:13:42.000Z","updated":"2019-02-04T13:27:44.349Z","comments":true,"path":"api/articles/Git工作区、暂存区和历史记录区.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_5.jpg","content":"<h2 id=\"三个区域\"><a href=\"#三个区域\" class=\"headerlink\" title=\"三个区域\"></a>三个区域</h2><p>可以将 git 简单的分为三个区域：</p>\n<ul>\n<li>工作区（working directory）</li>\n<li>暂存区（stage index）</li>\n<li>历史记录区（history）</li>\n</ul>\n<p>如图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_5.jpg\" alt=\"\" width=\"500\"></div>\n\n<h2 id=\"简单解释\"><a href=\"#简单解释\" class=\"headerlink\" title=\"简单解释\"></a>简单解释</h2><p><strong>工作区</strong>：就是我们能看到的区域，也是我们经常修改代码的目录<br><strong>暂存区</strong>：文件在本地修改之后，需要提交到暂存区之后才能提交到版本库，作为过渡层；可以避免误操作和保护工作区和版本库<br><strong>历史记录区</strong>：可以理解为版本库，我们从暂存区提交之后的记录会保存在这里</p>\n<h2 id=\"详细解释\"><a href=\"#详细解释\" class=\"headerlink\" title=\"详细解释\"></a>详细解释</h2><p>当我们执行 <code>git add files</code> 时，我们把当前工作目录中的文件放入了暂存区域，这其实做了两件事：</p>\n<ol>\n<li>将本地文件的时间戳、长度，当前文档对象的id等信息保存到一个树形目录中去（index，即平时说的暂存区）</li>\n<li>将本地文件的内容做快照并保存到 Git 的对象库。</li>\n</ol>\n<p>所以，暂存区实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等），文件的内容并不存储其中，而是保存在 Git 对象库（.git/objects）中，文件索引建立了文件和对象库中对象实体之间的对应。如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_6.png\" alt=\"\" width=\"600\"></div>\n\n<p>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个“游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下</p>\n<h2 id=\"三个区域与-git-命令\"><a href=\"#三个区域与-git-命令\" class=\"headerlink\" title=\"三个区域与 git 命令\"></a>三个区域与 git 命令</h2><h3 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h3><p>当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中</p>\n<h3 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h3><p>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p>\n<h3 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h3><p>当执行 “git status” 命令扫描工作区改动的时候，先依据 .git/index 文件中记录的（工作区跟踪文件的）时间戳、长度等信息判断工作区文件是否改变。如果工作区的文件时间戳改变，说明文件的内容<strong>可能</strong>被改变了，需要打开文件，读取文件内容，和更改前的原始文件相比较（本地文件和与之对应的 object 库中的文件的内容进行对比），判断文件内容是否被更改。如果文件内容没有改变，则将该文件新的时间戳记录到 .git/index 文件中。因为判断文件是否更改，使用时间戳、文件长度等信息进行比较要比通过文件内容比较要快的多，所以 Git 这样的实现方式可以让工作区状态扫描更快速的执行，这也是 Git 高效的因素之一。</p>\n<h3 id=\"git-diff-files\"><a href=\"#git-diff-files\" class=\"headerlink\" title=\"git diff files\"></a>git diff files</h3><p>git diff files 用来进行具体文件的变动对比，通常用来进行工作区与暂存区之间的对比，实质上是用 git objects 库中的快照与工作区文件的内容的对比。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://josh-persistence.iteye.com/blog/2215214\" target=\"_blank\" rel=\"noopener\">详解Git工作区、暂存区、历史记录区以及git reset、git revert、git checkout等撤销命令的区别</a></li>\n</ul>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[{"name":"git","path":"api/tags/git.json"}]},{"title":"Git撤销操作","slug":"Git撤销操作","date":"2017-06-29T02:46:13.000Z","updated":"2019-02-04T13:27:44.349Z","comments":true,"path":"api/articles/Git撤销操作.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>Git中提供了几个相关的撤销操作的命令，如 clean、checkout、reset和revert；在看这篇文章之前，我希望你能够浏览一下我的另一篇文章：<a href=\"/20170628/workspace-temporary-zone-and-history-zone-in-git.html\">Git工作区、暂存区和历史记录区</a>，看完之后理解这篇文章会更简单一些</p>\n<h2 id=\"git-clean\"><a href=\"#git-clean\" class=\"headerlink\" title=\"git clean\"></a>git clean</h2><p>git clean 命令用来从你的工作目录中删除所有没有 tracked 过的文件</p>\n<h3 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean -n</span><br></pre></td></tr></table></figure>\n<p>是一次 clean 的演习， 告诉你哪些文件会被删除。 记住他不会真正的删除文件， 只是一个提醒。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean -f</span><br></pre></td></tr></table></figure>\n<p>删除当前目录下所有没有 track 过的文件。 他不会删除 .gitignore 文件里面指定的文件夹和文件， 不管这些文件有没有被 track 过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean -f &lt;path&gt;</span><br></pre></td></tr></table></figure>\n<p>删除指定路径下的没有被 track 过的文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean -df</span><br></pre></td></tr></table></figure>\n<p>删除当前目录下没有被 track 过的文件和文件夹。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean -xf</span><br></pre></td></tr></table></figure>\n<p>删除当前目录下所有没有 track 过的文件。 不管他是否是 .gitignore 文件里面指定的文件夹和文件。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"假如你要删除所有工作目录下面的修改，包括新添加的文件：\"><a href=\"#假如你要删除所有工作目录下面的修改，包括新添加的文件：\" class=\"headerlink\" title=\"假如你要删除所有工作目录下面的修改，包括新添加的文件：\"></a>假如你要删除所有工作目录下面的修改，包括新添加的文件：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard</span><br><span class=\"line\">git clean -df</span><br></pre></td></tr></table></figure>\n<p>运行后，工作目录和缓存区回到最近一次 commit 时候一摸一样的状态， git status 会告诉你这是一个干净的工作目录，又是一个新的开始了。</p>\n<h2 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h2><p>git checkout 命令用来丢弃本地修改</p>\n<h3 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- files</span><br></pre></td></tr></table></figure>\n<p>把文件从暂存区域复制到工作目录，用来丢弃本地修改</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n<p>会用暂存区全部的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD .</span><br></pre></td></tr></table></figure>\n<p>会用 HEAD 指向的 master 分支中的全部文件替换暂存区以及工作区中的文件。<strong>这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动</strong></p>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>有时候我们的工作区会增加一些不想要的文件（多数为隐藏文件），比如 .idea/、.DS_Store 文件，此时我们不想将这些无关紧要的文件添加到暂存区，所以就像将它们从工作区丢弃，此时就可以利用下面的命令将该文件夹丢弃：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout .idea/</span><br></pre></td></tr></table></figure>\n<p>当然，这种总是会自动生成的文件最好写到 .gitignore 里，否则每次都要 checkout 会很烦的</p>\n<h2 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h2><p>git reset 命令撤销对于暂存区 / 历史记录区的修改，也就是撤销你本地的 add，commit 操作</p>\n<h3 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset</span><br></pre></td></tr></table></figure>\n<p>撤销所有暂存区域文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset -- files</span><br></pre></td></tr></table></figure>\n<p>用来撤销最后一次的 git add files（因为每 git add file 一次，暂存区的文件都会被更改一次）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --mixed &lt;commit id&gt;</span><br></pre></td></tr></table></figure>\n<p>会保留源码，只是将 git commit 和 index 信息回退到了某个版本。（相当于撤销了 add 和 commit 操作，提交的修改都回到了工作区）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --soft &lt;commit id&gt;</span><br></pre></td></tr></table></figure>\n<p>保留源码，只回退 commit 信息到某个版本，不涉及index的回退，如果还需要提交，直接commit即可。（也就是只撤销了commit，并没有撤销add）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard &lt;commit id&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>源码也会回退到某个版本</strong>，commit 和 index 都回回退到某个版本。(注意，这种方式是改变本地代码仓库源码)，当然有人在 push 代码以后，也可以使用 <code>reset --hard &lt;commit id&gt;</code> 回退本地的代码到某个版本之前，但是这样会有一个问题，你线上的代码没有变，线上 commit，index 都没有变，当你把本地代码修改完提交的时候你会发现全是冲突。。（此时就需要用到下面要介绍的 git revert 了）</p>\n<h3 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"当我们在使用-pull-的时候，可能会出现冲突，就需要-merge，而在冲突状态下，需要解决冲突的文件会从-index-暂存区打回到工作区，如果我们想放弃-index-和工作区的改动，就可以执行下面这条命令：\"><a href=\"#当我们在使用-pull-的时候，可能会出现冲突，就需要-merge，而在冲突状态下，需要解决冲突的文件会从-index-暂存区打回到工作区，如果我们想放弃-index-和工作区的改动，就可以执行下面这条命令：\" class=\"headerlink\" title=\"当我们在使用 pull 的时候，可能会出现冲突，就需要 merge，而在冲突状态下，需要解决冲突的文件会从 index 暂存区打回到工作区，如果我们想放弃 index 和工作区的改动，就可以执行下面这条命令：\"></a>当我们在使用 pull 的时候，可能会出现冲突，就需要 merge，而在冲突状态下，需要解决冲突的文件会从 index 暂存区打回到工作区，如果我们想放弃 index 和工作区的改动，就可以执行下面这条命令：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD</span><br></pre></td></tr></table></figure>\n<p>上面这条命令用来撤销还没 commit 的 merge，就放弃了 index 暂存区和工作区的改动</p>\n<h4 id=\"当我们在本地进行了-add-和-commit-操作之后，发现本地的修改都是错误的，想要回到前一版本，就可以执行下面这条命令：\"><a href=\"#当我们在本地进行了-add-和-commit-操作之后，发现本地的修改都是错误的，想要回到前一版本，就可以执行下面这条命令：\" class=\"headerlink\" title=\"当我们在本地进行了 add 和 commit 操作之后，发现本地的修改都是错误的，想要回到前一版本，就可以执行下面这条命令：\"></a>当我们在本地进行了 add 和 commit 操作之后，发现本地的修改都是错误的，想要回到前一版本，就可以执行下面这条命令：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n<p>上面这条命令用来撤销已经 commit 的内容（等价于 <code>git reset --hard HEAD~1</code>）。原理就是放弃工作区和 index 的改动，同时 HEAD 指针指向前一个 commit 对象</p>\n<h4 id=\"如果我们已经用-add-命令将某个文件加入暂存区了，此时想撤销对这个文件的-add-操作，就可以用下面的命令：\"><a href=\"#如果我们已经用-add-命令将某个文件加入暂存区了，此时想撤销对这个文件的-add-操作，就可以用下面的命令：\" class=\"headerlink\" title=\"如果我们已经用 add 命令将某个文件加入暂存区了，此时想撤销对这个文件的 add 操作，就可以用下面的命令：\"></a>如果我们已经用 add 命令将某个文件加入暂存区了，此时想撤销对这个文件的 add 操作，就可以用下面的命令：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>\n<p>上面这条命令用来撤销对单个文件的 git add，执行之后该文件会从暂存区回到工作区中</p>\n<h2 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git revert\"></a>git revert</h2><p>git revert 用于反转提交，执行 revert 命令时要求工作树必须是干净的。git revert 用一个新提交来消除一个历史提交所做的任何修改。</p>\n<p>###参数说明</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert &lt;commit id&gt;</span><br></pre></td></tr></table></figure>\n<p>revert 使用，需要先找到你想回滚版本唯一的 commit 标识代码，可以用 <code>git log</code> 进行查看，commit id 是一串 40 位的字符串，通常用前几位即可（6 位就差不多保证唯一了）；执行完之后，revert 的那一次 commit 被撤销，原理是 git revert 用一次逆向的 commit “中和”之前的提交，所以此时 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容；这样在日后合并老的 branch 时，导致这部分改变不会再次出现，就不会出现类似 git reset 带来的冲突问题</p>\n<h3 id=\"应用场景-3\"><a href=\"#应用场景-3\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"对于已经把代码-push-到线上仓库，但是此时发现-push-的代码有问题，你想回退本地代码的同时也回退线上代码，回滚到某个指定的版本，使得线上和线下代码保持一致：\"><a href=\"#对于已经把代码-push-到线上仓库，但是此时发现-push-的代码有问题，你想回退本地代码的同时也回退线上代码，回滚到某个指定的版本，使得线上和线下代码保持一致：\" class=\"headerlink\" title=\"对于已经把代码 push 到线上仓库，但是此时发现 push 的代码有问题，你想回退本地代码的同时也回退线上代码，回滚到某个指定的版本，使得线上和线下代码保持一致：\"></a>对于已经把代码 push 到线上仓库，但是此时发现 push 的代码有问题，你想回退本地代码的同时也回退线上代码，回滚到某个指定的版本，使得线上和线下代码保持一致：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert &lt;commit id&gt;</span><br></pre></td></tr></table></figure>\n<p>执行完此命令之后，再执行 git push 就可以将线上代码回滚到某个指定版本，同时不会像 git reset 一样可能会导致一大堆冲突</p>\n<h2 id=\"git-的其它删除命令\"><a href=\"#git-的其它删除命令\" class=\"headerlink\" title=\"git 的其它删除命令\"></a>git 的其它删除命令</h2><p>这些命令类似于 Linux 的命令，是一种物理层面的删除，也会经常遇到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached readme.txt</span><br></pre></td></tr></table></figure>\n<p>只从缓存区中删除readme.txt，保留物理文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm readme.txt</span><br></pre></td></tr></table></figure>\n<p>不但从缓存区中删除，同时删除物理文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git mv a.txt b.txt</span><br></pre></td></tr></table></figure>\n<p>把a.txt改名为b.txt</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/pingfan1990/p/5454757.html\" target=\"_blank\" rel=\"noopener\">git clean(转载)</a></li>\n<li><a href=\"http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html\" target=\"_blank\" rel=\"noopener\">git reset revert 回退回滚取消提交返回上一版本</a></li>\n<li><a href=\"http://josh-persistence.iteye.com/blog/2215214\" target=\"_blank\" rel=\"noopener\">详解Git工作区、暂存区、历史记录区以及git reset、git revert、git checkout等撤销命令的区别</a></li>\n</ul>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[{"name":"git","path":"api/tags/git.json"}]},{"title":"Git配置别名","slug":"Git配置别名","date":"2017-06-28T03:04:28.000Z","updated":"2019-02-04T13:27:44.349Z","comments":true,"path":"api/articles/Git配置别名.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_102.png","content":"<p>git 提供了各种各样的操作方法，但是我们常常会陷入“敲 git 命令敲的手疼”的困境，此时为 git 配置别名就显得尤为重要了，尤其是当我们的项目有各种各样的分支（master、dev、test…）时，经常需要 merge、rebase、add、commit，如果能用一两个字母代替这些命令的话，我相信会减轻很多打字的负担。</p>\n<h2 id=\"方法一：临时修改\"><a href=\"#方法一：临时修改\" class=\"headerlink\" title=\"方法一：临时修改\"></a>方法一：临时修改</h2><p>我们只需要敲一行命令，告诉 git，以后 st 就表示 status：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.st status</span><br></pre></td></tr></table></figure>\n<p>–global 参数是全局参数，也就是这一行命令在这台电脑的所有 git 仓库下都有用；当然，如果你想只在当前项目中使用简写命令，可以在项目的目录下使用 git config 命令而不带 –global 选项，这样会在你当前项目目录下的 .git/config 文件增加一节 [user] 内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[user]</span><br><span class=\"line\">    name = Merrier</span><br><span class=\"line\">    eamil = 953075999@qq.com</span><br></pre></td></tr></table></figure>\n<p>只改了 status 不过瘾？没关系，我们还有别的命令可以简写，很多人用 co 表示 checkout，ci 表示 commit，br 表示 branch（每个人都有自己的简写习惯，不过最好和别人相同，否则别人在你的电脑上提交代码的话可能会有不必要的麻烦）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.co checkout</span><br><span class=\"line\">git config --global alias.ci commit</span><br><span class=\"line\">git config --global alias.br branch</span><br></pre></td></tr></table></figure>\n<p>当然，除了上面这些简单的命令之外，我们还可以为一些复杂的命令设置别名，比如配置一个 git last，让其显示最后一次提交信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.last <span class=\"string\">'log -1'</span></span><br></pre></td></tr></table></figure>\n<p>这样，我们用 git last 就能显示最近一次的提交：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git last</span><br><span class=\"line\">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class=\"line\">Merge: bd6ae48 291bea8</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法二：修改-gitconfig\"><a href=\"#方法二：修改-gitconfig\" class=\"headerlink\" title=\"方法二：修改 .gitconfig\"></a>方法二：修改 .gitconfig</h2><p>如果我们拿到的是一台新电脑，像上面那样一行一行敲设置简写的命令的话会将一件本来让自己方便的事变得很麻烦，所以有没有一次性设置全部简写命令的方法呢？当然是有的了（要不然我这个方法二从何而来），就是修改 .gitconfig 文件，其实我们上面那些命令就是在一次次的修改 .gitconfig 文件；.gitconfig 文件在哪呢？理论上就在你的主目录下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_102.png\" alt=\"\" width=\"400\"></div>\n\n<p>从上图可以看到，可以通过 cat ~/.gitconfig 查看自己电脑的 .gitconfig 文件内容，而由于我已经设置了 git 别名，所以该文件中会有 [alias] 内容，那么你就可以通过在这个文件中添加类似的内容来配置你自己的别名了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">alias</span>]</span><br><span class=\"line\">    co = checkout</span><br><span class=\"line\">    ci = commit</span><br><span class=\"line\">    st = status</span><br><span class=\"line\">    pl = pull</span><br><span class=\"line\">    ps = push</span><br><span class=\"line\">    dt = difftool</span><br><span class=\"line\">    l = <span class=\"built_in\">log</span> --<span class=\"built_in\">stat</span></span><br><span class=\"line\">    cp = cherry-pick</span><br><span class=\"line\">    ca = commit -a</span><br><span class=\"line\">    b = branch</span><br></pre></td></tr></table></figure>\n<p>和方法一一样，如果你只想要在某些项目中使用简写，可以进入项目的目录，然后编辑 .git/config 文件，加入上面的内容就可以了</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[{"name":"git","path":"api/tags/git.json"}]},{"title":"一篇绝对能看懂的Git入门教程","slug":"一篇绝对能看懂的Git入门教程","date":"2017-04-17T13:35:16.000Z","updated":"2019-02-04T13:27:44.353Z","comments":true,"path":"api/articles/一篇绝对能看懂的Git入门教程.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_237.png","content":"<p>不管你是从事什么方面的程序猿，只要你属于这个神秘组织，就必须要对 SVN 或 Git 这种版本控制系统有所了解；和大部分人一样，当初项目负责人告诉我需要学 Git 的时候，只说了这样一句话：“网上很多教程，自己看着学吧”，当然，这句话直到今天我也无力反驳，因为对于一个新鲜的程序猿来说，只需要懂一些 Git 的基本指令就可以了，一些高端指令可能永远都用不到，所以，我就查阅了一些 Git 的教程和手册，整理出这篇对于新手很友好的 Git 入门教程</p>\n<h2 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h2><p>很多 Git 教程都把这一部分的讲解放到很靠后的位置，所以我当初学习的时候并没有把这一部分放在心上；但是现在我觉得，这一部分才是最需要明白的，因为这一部分是非常“真实”的，对于一个之前从来没接触过命令行或一直在 windows 上打游戏、看直播的程序猿来说，这一部分也是最容易理解的</p>\n<p><strong>工作区</strong>：通俗易懂的来说就是你电脑里面的能看到的目录，比如 learngit 的目录。<br><strong>版本库</strong>：工作区有一个隐藏的目录 .git，这是 Git 的版本库。版本库中存了很多东西，其中最重要的就是stage(index)的 <strong>暂存区</strong>。 下面这张图非常清晰的表明了这三者的关系，我就不多说了：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_237.png\" alt=\"\" width=\"400\"></div>\n\n<p><strong>请牢牢记住这三\b个概念，因为下面会经常用到</strong></p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><h3 id=\"生成-ssh\"><a href=\"#生成-ssh\" class=\"headerlink\" title=\"生成 ssh\"></a>生成 ssh</h3><p>通过下面的指令可以生成 id_rsa 和 id_rsa.pub 两个文件，不同操作系统这两个文件所在位置不同，id_rsa.pub 里面的所有内容就是你的公钥，直接复制到 GitHub 的 Add SSH key 页面就可以愉快的进行玩耍了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t ras -C <span class=\"string\">\"email@xxx\"</span></span><br></pre></td></tr></table></figure>\n<p>ssh 是一种协议，而 Git 目前支持<a href=\"http://www.cnblogs.com/lzxianren/p/git2.html\" target=\"_blank\" rel=\"noopener\">4种协议</a>——ssh协议，http/s协议，git 协议，本地协议，ssh 协议配置简单，权限管理也比较全面，更重要的是无需密码和 linux 内置（git 是 linus 写的软件，linus 是 linux的作者，所以你懂得），至于 ssh 究竟怎么做的就不在本文介绍了，可以去阮一峰的博客中查找相关资料</p>\n<h3 id=\"设置用户名\"><a href=\"#设置用户名\" class=\"headerlink\" title=\"设置用户名\"></a>设置用户名</h3><p>和现实世界类似，你想和别人进行数据通信，首先得让别人知道你是谁，你的联系方式吧，而和现实世界不同的是，这里的联系方式只能填写邮箱，填写微信或者 QQ 号是木有用的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">\"cc\"</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"cc@xx\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化当前目录的项目\"><a href=\"#初始化当前目录的项目\" class=\"headerlink\" title=\"初始化当前目录的项目\"></a>初始化当前目录的项目</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p>还记得上面我们提到的三个概念吗，这里的初始化就是为了在本地目录中添加本地版本库，然后才可以后续的 git 操作。比如初始化之前你的目录是这样的（当前目录为空是因为我是在一个空文件夹的基础上进行初始化的，而实际情况是这里面会有你的项目文件）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_189.png\" alt=\"\" width=\"700\"></div>\n\n<p>而执行初始化操作之后：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_190.png\" alt=\"\" width=\"700\"></div>\n\n<p>从上图可以看到，当前目录中多了 .git 文件夹，这个文件夹就是你的本地的版本库了，里面存储着很多东西，其中包括暂存区；通过短短的一行命令，初始化操作就已经完成了，同时 Git 也为我们创建了第一个分支 master，和一个指向 master 的指针 HEAD，接下来就是一些常用的命令</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><h3 id=\"查看工作区状态\"><a href=\"#查看工作区状态\" class=\"headerlink\" title=\"查看工作区状态\"></a>查看工作区状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<p>这是一条需要经常使用的命令，因为有时候工作区的改变可能会是“隐性”的，比如你的编辑器自己添加的文件或者其他类型的隐藏文件，而经常查看状态也是检验某些 git 命令是否执行的方法。通过执行这一命令，我们在终端中可能会看到：</p>\n<div align=\"center\"><img src=\"/images/QQ20170417-153116@2x.png\" alt=\"\" width=\"700\"></div>\n\n<p>从终端的第四行我们可以看到，当我们查看状态时，Git 告诉我们当前分支为 master；第八行的意思是我们没有什么可以 commit 的，说明我们在当前目录下并没有进行修改，所以我们需要进行修改之后再进行后续操作：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_192.png\" alt=\"\" width=\"700\"></div>\n\n<p>从上图我们可以看到，我在当前目录中新添加了一个文件 octocat.txt，然后我们再通过 <code>git status</code> 查看一下当前工作区的状态：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_193.png\" alt=\"\" width=\"700\"></div>\n\n<p>这次好像和上次不一样了，Git 告诉我们有一个文件 untracked files 叫做 octocat.txt，同时还提醒你通过 <code>git add &lt;file&gt;...</code> 进行提交，那这里就稍微提一下 git status 时可能看到的当前工作区的文件的状态</p>\n<ul>\n<li>staged：已经添加到暂存区，等待提交的文件</li>\n<li>unstaged：已经发生了改变，但是还没有提交</li>\n<li>untracked：Git 都不知道还有这个文件，所以说明这是一个新添加的文件（就像上面的 octocat.txt）</li>\n<li>deleted：已经从本地删除的文件</li>\n</ul>\n<h3 id=\"提交工作区修改到暂存区\"><a href=\"#提交工作区修改到暂存区\" class=\"headerlink\" title=\"提交工作区修改到暂存区\"></a>提交工作区修改到暂存区</h3><ul>\n<li>git add .  // 将工作区所有修改添加到暂存区</li>\n<li>git add filename // 将指定文件添加到暂存区</li>\n</ul>\n<p>还是一开始我们提到的那三个概念，我们在本地进行了修改（新建、修改、删除），但是此时还只是我们自己知道发生了哪些改变，Git 根本都不知道（本地的 Git 都不知道，更别提远程），所以需要进行提交；那么你可能有疑问了，为什么提交到暂存区？直接提交给远程不就完了吗？这里就是 Git 设计的巧妙之处，通过暂存区可以防止你的错误提交（事实证明，这一点很重要）。经过 git add 后，我们再通过 git status 查看一下状态：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_194.png\" alt=\"\" width=\"700\"></div>\n\n<p>Git 告诉我们它看到了一个新的文件 octocat.txt，并且 to be committed，那么你可能会问了，假如我当前的目录里有好多文件都需要 add 怎么办，难道一次次执行命令吗？当然不需要，从上面的代码块中可以看到，我们可以通过 <code>git add .</code> 提交所有修改，但是<strong>不推荐这种操作</strong>，因为有可能会将一些不想提交的隐藏文件也提交到暂存区了；假如我们当前目录下有很多 .txt 文件等待提交：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_195.png\" alt=\"\" width=\"700\"></div>\n\n<p>我们可以使用 “*.txt” 匹配到所有的 txt 文件，然后就可以将它们全部提交了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add <span class=\"string\">'*.txt'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"将暂存区修改添加到本地仓库\"><a href=\"#将暂存区修改添加到本地仓库\" class=\"headerlink\" title=\"将暂存区修改添加到本地仓库\"></a>将暂存区修改添加到本地仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">'备注信息'</span></span><br></pre></td></tr></table></figure>\n<p>经过多次的 git add，此时的暂存区有好多本地的修改，通过上面的 commit 可以将所有的暂存区的修改添加到本地仓库，所以你可以简单理解为：需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>\n<h3 id=\"push-到远程\"><a href=\"#push-到远程\" class=\"headerlink\" title=\"push 到远程\"></a>push 到远程</h3><p>经过上面的一顿折腾，仍然只有本地的 “Git” 知道了我们都做了些什么，如果想让远程仓库也知道，我们需要先和远程仓库建立联系：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/try-git/try_git.git</span><br></pre></td></tr></table></figure>\n<p>在这里遇到一个问题：每次 push 都要输入用户名和密码，原因是我们是通过 https 方式进行 push，解决方法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin      // 移除</span><br><span class=\"line\">git remote add origin git@github.com:try-git/test.git       // 添加</span><br></pre></td></tr></table></figure>\n<p>此后就不用再输入用户名和密码了，同时我们和远程建立联系以后就不用再 git remote add 了，这就好比你去别人家串门，第一次可能需要你需要查一下地图，第二次的话就直接去找他就行了。接下来就是 push 到远程了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>第一次 push 是需要加 -u 参数的，这个参数是告诉远程我是谁（<a href=\"https://www.zhihu.com/question/20019419\" target=\"_blank\" rel=\"noopener\">git push的-u参数具体含义</a>），还是刚才串门的例子，第一次去别人家串门肯定需要表明身份的，第二次就不再需要了，因为已经知道你是谁了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h3 id=\"从远程-pull\"><a href=\"#从远程-pull\" class=\"headerlink\" title=\"从远程 pull\"></a>从远程 pull</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<p>如果别人提交了他们的修改到远程仓库，我们需要从远程 pull 修改到我们的本地，从而保证大家的进度保持同步，比如别人提交了一个 yellow_octocat.txt 文件到远程，我们 git pull 之后：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_197.png\" alt=\"\" width=\"700\"></div>\n\n<p>Git 告诉我们，你 pull 成功了，新增加了一个文件叫做 yellow_octocat.txt，此时我们的当前目录就多了一个 yellow_octocat.txt（.git 也就是本地版本库也知道了这个文件）</p>\n<div align=\"center\"><img src=\"/images/hexo_post_198.png\" alt=\"\" width=\"700\"></div>\n\n<h3 id=\"查看修改的内容\"><a href=\"#查看修改的内容\" class=\"headerlink\" title=\"查看修改的内容\"></a>查看修改的内容</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n<p>有可能别人和我对同一文件进行了修改，所以在 pull 之后需要查看一下都发生了哪些修改:</p>\n<div align=\"center\"><img src=\"/images/hexo_post_199.png\" alt=\"\" width=\"700\"></div>\n\n<p>其实，git diff 的用法不仅只有这一种，还可以查看暂存区的修改都有哪些：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --staged</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h3><h4 id=\"丢弃工作区的修改\"><a href=\"#丢弃工作区的修改\" class=\"headerlink\" title=\"丢弃工作区的修改\"></a>丢弃工作区的修改</h4><p>假如我们对之前的一个文件 readme.txt 进行了修改，但是现在我发现对这个文件进行的修改都是错的（经常会发生），此时我不想要我对这个文件的修改了，就可以执行下面的命令，然后 readme.txt 就可以回退到我修改之前的样子</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout readme.txt</span><br></pre></td></tr></table></figure>\n<h4 id=\"丢弃暂存区的修改\"><a href=\"#丢弃暂存区的修改\" class=\"headerlink\" title=\"丢弃暂存区的修改\"></a>丢弃暂存区的修改</h4><p>和刚才不一样的是，我已经将我的修改提交到暂存区了（也就是说已经执行了 git add readme.txt 命令），此时我想把这个文件的修改从暂存区放回到工作区，就需要执行下面的命令，然后此时的暂存区就不再有 readme.txt 的修改，就像没 git add 过</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支相关\"><a href=\"#分支相关\" class=\"headerlink\" title=\"分支相关\"></a>分支相关</h2><p>除了 Git，其他版本控制系统如 SVN 中也有分支管理，但是 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。但是截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即<code>master</code> 分支。<code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<strong><code>HEAD</code> 指向的就是当前分支</strong>。每次提交，<code>master</code> 分支都会向前移动一步，这样，随着你不断提交，<code>master</code> 分支的线也越来越长。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_1.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch clean_up</span><br></pre></td></tr></table></figure>\n<p>此时我们在本地创建了一个分支叫做 clean_up，对于 Git 来说，相当于新建了一个指针叫 clean_up，指向和 master 相同的提交，但是此时的 HEAD 仍然指向 master，因为此时我们只是新建了一个分支，并没有切换到 clean_up 分支</p>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout clean_up</span><br></pre></td></tr></table></figure>\n<p>我们新创建了 clean_up 分支后，可以通过上面的命令将本地的分支切换到 clean_up，此时的 HEAD 就会指向 clean_up</p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p>为了后面的分支命令展示，我们通过下面的命令将 .txt 文件（注意此时所在的分支仍然是 clean_up）删除</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm <span class=\"string\">'*.txt'</span></span><br></pre></td></tr></table></figure>\n<p>然后，我们将删除这些文件的修改进行提交（add + commit），此时本地的 clean_up 分支就没有这些 .txt 文件了：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_200.png\" alt=\"\" width=\"700\"></div>\n\n<p>此时我们再切换到 master 分支（git checkout master）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_201.png\" alt=\"\" width=\"700\"></div>\n\n<p>通过上面两张图片，我们可以清晰的看到分支的作用，其实相当于两个平行世界（branch），而你所扮演的就是上帝的角色，想让哪个世界继续进行，就 checkout 哪个分支就可以了。此时如果我们想让\b clean_up 分支上做出的改变合并到 master 分支该怎么办呢？</p>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge clean_up</span><br></pre></td></tr></table></figure>\n<p>上面这段命令执行的前提是你当前的分支是 master，而通过 git merge 某分支可以将某分支的改变合并到当前分支：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_202.png\" alt=\"\" width=\"700\"></div>\n\n<p>我们通过上面的结果可以看到此时的 master 分支已经没有了 .txt 文件</p>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d clean_up</span><br></pre></td></tr></table></figure>\n<p>既然我们已经把 clean_up 分支的改变合并到了 master 分支，所以此时我们就不再需要 clean_up 分支了，通过上面的命令可以将该分支删除</p>\n<h2 id=\"版本相关\"><a href=\"#版本相关\" class=\"headerlink\" title=\"版本相关\"></a>版本相关</h2><p>较为复杂的分支命令的介绍就告一段落了，下面介绍一下和版本相关的一些常用命令</p>\n<h3 id=\"查看提交的历史记录\"><a href=\"#查看提交的历史记录\" class=\"headerlink\" title=\"查看提交的历史记录\"></a>查看提交的历史记录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<p>我们可以通过 git log 查看提交的历史记录（每一次 commit 都是一次记录）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_196.png\" alt=\"\" width=\"700\"></div>\n\n<p>从上面的图片可以看到，我们有两次 commit 记录，他们的 id 是很长的黄色字符串，这个 id 和每次提交是一一对应的，同时也对应着相应的版本，而除了 commit id，我们还可以看到提交的作者、日期以及备注信息（这里就体现出了备注信息是多么的重要）</p>\n<h3 id=\"回退版本\"><a href=\"#回退版本\" class=\"headerlink\" title=\"回退版本\"></a>回退版本</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n<p>通过上面的命令，我们可以回退到上个版本，<code>HEAD</code> 为当前版本，<code>HEAD^</code> 为上一个版本，<code>HEAD^^</code> 为上上个版本，如果有 100 个版本 <code>HEAD~100</code>。当然，我们也可以通过上面提到的 commit id 来回到过去的某个版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard commit_id</span><br></pre></td></tr></table></figure>\n<p>是不是更感觉自己像是一个上帝了，在 Git 中，你可以随意控制平行世界的发展，需要做的只是输出一行命令而已</p>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><p>上面就是一些我们最常用的 Git 命令，但是 Git 的强大之处远不止这些，下面就简单介绍几种我们可能会用到的命令：</p>\n<h3 id=\"建立本地分支与远程分支的追踪关系\"><a href=\"#建立本地分支与远程分支的追踪关系\" class=\"headerlink\" title=\"建立本地分支与远程分支的追踪关系\"></a>建立本地分支与远程分支的追踪关系</h3><p>当在本地新建分支的时候，可能远程并没有这个分支，所以你需要建立追踪关系，这样你 push 的时候才不会 push 到别的分支上去</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --<span class=\"built_in\">set</span>-upstream-to=&lt;remote&gt;/branchName  // 建立本地分支与远程分支的追踪关系</span><br><span class=\"line\">git branch --track branchName [remote branch]   // 新建一个分支，并与远程建立追踪关系</span><br></pre></td></tr></table></figure>\n<h3 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h3><p>这是 Git 的又一神奇命令，它可以让你将任何一次 commit 的修改合并到当前分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick commitId  // 将与 commitId 对应的提交合进当前分支</span><br></pre></td></tr></table></figure>\n<h3 id=\"bug-分支\"><a href=\"#bug-分支\" class=\"headerlink\" title=\"bug 分支\"></a>bug 分支</h3><p>当我们修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除分支；但是如果我们的手头工作没有完成呢，就需要暂时放弃当前没有提交的修改，然后去修复bug，修复完之后再回来恢复原样继续做刚才的工作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash     // 暂时放弃未提交的修改</span><br><span class=\"line\">git stash pop    // 恢复</span><br></pre></td></tr></table></figure>\n<h2 id=\"实践步骤\"><a href=\"#实践步骤\" class=\"headerlink\" title=\"实践步骤\"></a>实践步骤</h2><table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>git操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>克隆代码</td>\n<td>git clone远端代码</td>\n</tr>\n<tr>\n<td>创建分支</td>\n<td>git checkout -b branch_name</td>\n</tr>\n<tr>\n<td>在分支中开发</td>\n<td>无</td>\n</tr>\n<tr>\n<td>review代码</td>\n<td>无</td>\n</tr>\n<tr>\n<td>第一轮测试</td>\n<td>无</td>\n</tr>\n<tr>\n<td>添加代码至分支</td>\n<td>git add somefile</td>\n</tr>\n<tr>\n<td>提交代码至分支</td>\n<td>“git commit -m “”本次提交注释”””</td>\n</tr>\n<tr>\n<td>切换至主分支</td>\n<td>git checkout master</td>\n</tr>\n<tr>\n<td>获取远端最新代码</td>\n<td>git pull origin master</td>\n</tr>\n<tr>\n<td>合并分支至master分支</td>\n<td>git merge branch_name</td>\n</tr>\n<tr>\n<td>解决合并时产生的冲突</td>\n<td></td>\n</tr>\n<tr>\n<td>第二轮测试</td>\n<td>无</td>\n</tr>\n<tr>\n<td>获取远端最新代码</td>\n<td>git pull origin master</td>\n</tr>\n<tr>\n<td>推送至master分支</td>\n<td>git push origin master</td>\n</tr>\n<tr>\n<td>若无问题，删除本地分支</td>\n<td>git branch -d branch_name</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">图解Git</a></li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">廖雪峰-Git教程</a></li>\n<li><a href=\"https://try.github.io/levels/1/challenges/1\" target=\"_blank\" rel=\"noopener\">在线练习git命令</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2\" target=\"_blank\" rel=\"noopener\">Pro Git</a></li>\n<li><a href=\"http://www.jianshu.com/p/50892fac6cbc\" target=\"_blank\" rel=\"noopener\">实用Git Workflow</a></li>\n<li><a href=\"http://gitbook.liuhui998.com/index.html\" target=\"_blank\" rel=\"noopener\">Git Community Book 中文版</a></li>\n</ul>\n<h2 id=\"另外一些关于-Git-Github-入门的文章\"><a href=\"#另外一些关于-Git-Github-入门的文章\" class=\"headerlink\" title=\"另外一些关于 Git / Github 入门的文章\"></a>另外一些关于 Git / Github 入门的文章</h2><ul>\n<li><a href=\"http://blog.jobbole.com/111187/\" target=\"_blank\" rel=\"noopener\">大白话解释 Git 和 GitHub</a></li>\n<li><a href=\"http://rogerdudler.github.io/git-guide/\" target=\"_blank\" rel=\"noopener\">git - the simple guide</a></li>\n<li><a href=\"https://www.pluralsight.com/blog/software-development/github-tutorial\" target=\"_blank\" rel=\"noopener\">GitHub: the beginner’s guide</a></li>\n</ul>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[{"name":"git","path":"api/tags/git.json"},{"name":"教程","path":"api/tags/教程.json"}]}]}