{"total":114,"pageSize":10,"pageCount":12,"data":[{"title":"那些惊艳的移动端H5案例","slug":"那些惊艳的移动端H5案例","date":"2018-02-11T08:25:53.000Z","updated":"2019-01-29T09:23:55.540Z","comments":true,"path":"api/articles/那些惊艳的移动端H5案例.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_235.jpeg","content":"<p>不管是公司用于宣传还是对某个产品进行营销，移动端 H5 的应用范围越来越广，其取得的效果也有目共睹，而这篇文章就带大家领略一下那些十分惊艳的移动端H5案例，希望大家抱着猎奇的心态观看，毕竟可远观而不可亵玩呐-。-（以下活动有可能是限时的，所以当你再次访问时有可能已经关站了，排名不分先后）</p>\n<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2><h3 id=\"adidas-胜势全开\"><a href=\"#adidas-胜势全开\" class=\"headerlink\" title=\"adidas-胜势全开\"></a><a href=\"http://show.im20.com.cn/bbcny/\" target=\"_blank\" rel=\"noopener\">adidas-胜势全开</a></h3><p>\badidas 为自己的新战靴做的宣传，不过看开头动画的时候有点吓到我了- -，这为了宣传新鞋也真是下了一番功夫啊。。</p>\n<h3 id=\"凡科720°全景×活动促销\"><a href=\"#凡科720°全景×活动促销\" class=\"headerlink\" title=\"凡科720°全景×活动促销\"></a><a href=\"https://s.wcd.im/v/2uZ71/\" target=\"_blank\" rel=\"noopener\">凡科720°全景×活动促销</a></h3><p>凡科互动是凡科旗下的一个子品牌，主要做的就是这种活动促销 H5，其中大多数为游戏的形式，而这个 720° 全景营销案例很经典，之前我也曾经尝试过实现一个类似的，结果可想而知。。因为 720° 需要用到一些数学知识，同时为了让其滑动的更顺滑，引入了很多插件，所以是一个比较难实现的案例。</p>\n<h3 id=\"Merrier和王者荣耀的故事\"><a href=\"#Merrier和王者荣耀的故事\" class=\"headerlink\" title=\"Merrier和王者荣耀的故事\"></a><a href=\"https://game.weixin.qq.com/cgi-bin/act?noticeid=90113615&amp;actid=7519&amp;k=m4GgtZfFORJ_wyqLywTnnw&amp;q=0&amp;jsapi_ticket=1&amp;openid=owanlsmlZT4pSDOwMrD8P9ObuEEU&amp;partition=4052#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Merrier和王者荣耀的故事</a></h3><p>不知道你们能不能打开这个链接，应该是只能在微信中打开的- -，这是王者荣耀在两周年的时候出的一个总结性质的 H5，色彩搭配很舒服，同时各种数据的统计证明这个文案是用了很大心思的。</p>\n<h3 id=\"有志者，吃就橙\"><a href=\"#有志者，吃就橙\" class=\"headerlink\" title=\"有志者，吃就橙\"></a><a href=\"http://h5.flyfinger.com/2017/dlanping/foodleS/index.html\" target=\"_blank\" rel=\"noopener\">有志者，吃就橙</a></h3><p>大众点评和摩拜单车联合搞的一次“炫光吃货车”活动，虽然其实就是一个不能暂停也没有很人性化的静音按钮的视频，但是不得不说，文案还是有一丢丢创意的，而且配音也很有意思。。</p>\n<h3 id=\"车轮招聘节\"><a href=\"#车轮招聘节\" class=\"headerlink\" title=\"车轮招聘节\"></a><a href=\"http://h5.eclicks.cn/2016/hr/index.html\" target=\"_blank\" rel=\"noopener\">车轮招聘节</a></h3><p><a href=\"http://eclicks.cn/\" target=\"_blank\" rel=\"noopener\">车轮——让有车生活更美好</a>制作的招聘宣传 H5，虽然动画比较简单，而且元素也比较单一，但是整体效果还是不错的，而且有一个很牛逼的微信分享标题：《我们在召唤你，艾泽拉斯最强的勇士们！》</p>\n<h3 id=\"开打法魔用能只章文篇这\"><a href=\"#开打法魔用能只章文篇这\" class=\"headerlink\" title=\"开打法魔用能只章文篇这\"></a><a href=\"http://news.163.com/special/fdh5_harrypotter20_18/\" target=\"_blank\" rel=\"noopener\">开打法魔用能只章文篇这</a></h3><p>（这个标题用了我 30 秒的时间）不得不承认这是我见过的最炫酷的 H5 宣传案例了，当那熟悉的旋律响起，我们仿佛就置身于霍格沃茨魔法学院，通过一些手势产生互动，最后还能学到魔法，不得不说真的很赞，不过缺点就是：这个是宣传什么的来着？</p>\n<h3 id=\"艾泽拉斯全景之旅\"><a href=\"#艾泽拉斯全景之旅\" class=\"headerlink\" title=\"艾泽拉斯全景之旅\"></a><a href=\"http://zhouxin.legendh5.com/h5/537c983e-b0a6-8a91-435b-abb04ad6c704.html\" target=\"_blank\" rel=\"noopener\">艾泽拉斯全景之旅</a></h3><p>80 年代的魔兽世界，大灾变之前的艾泽拉斯，wower 老玩家的回忆。不知不觉，魔兽世界已经陪伴我们超过十年了，虽然我自己玩魔兽的时间很短很短，不过对魔兽世界的文化本身还是比较感兴趣的，而这个 720° 全景可以说做的很用心，也很真实，同时还能够看到一些玩家在暴风城等地方留下的感慨，岁月流转，曾经一起下副本的朋友们你们过得还好吗？</p>\n<h3 id=\"朕收到一条来自你妈的微信\"><a href=\"#朕收到一条来自你妈的微信\" class=\"headerlink\" title=\"朕收到一条来自你妈的微信\"></a><a href=\"http://9be705463ff7.vt.iamh5.cn/v3/idea/7gEJ3FF5\" target=\"_blank\" rel=\"noopener\">朕收到一条来自你妈的微信</a></h3><p>这个标题着实吓到我了，不过点开才发现，这和我妈有什么关系？！其实就是故宫食品的宣传 H5，在这里赞一下文案设计，风趣而不失稳重（看饿了）：</p>\n<blockquote>\n<p>圣旨到<br>奉天承运，皇帝诏曰<br>朕最近心情不佳<br>打农药微信总弹窗<br>段位一直掉掉掉掉<br>烦死朕了<br>朕实在控记不住记几啊<br>点开一看<br>朕收到了你妈的微信<br>让你中秋回家吃月饼 SO<br>朕就给你批个长假<br>回家过节<br>反正带不回对象<br>那就带朕的心意<br>哈哈哈哈，没想到吧<br>朕给自家御膳房走波广告<br>（…各种弹幕）<br>朕的御厨，平时很闲<br>除了月饼，还做了一堆<br>（…各种吃的）<br>现在有些妖艳的月饼<br>咬一口防腐半年<br>一定是哪个刁民<br>想谋害朕<br>好继承朕的江山<br>稳住我们能赢！<br>朕的御膳房，刀枪不入，百毒不侵<br>国味汝肴典藏月饼<br>这就是朕的心意<br>故  宫  的  月  饼<br>眼花了吧 哈哈哈哈哈<br>朕就是这样迷人的汉子<br>（好不要脸）</p>\n</blockquote>\n<h3 id=\"领英丨名企梦工厂-今日头条\"><a href=\"#领英丨名企梦工厂-今日头条\" class=\"headerlink\" title=\"领英丨名企梦工厂-今日头条\"></a><a href=\"https://h5.veervr.tv/player/?vid=%E9%A2%86%E8%8B%B1%E4%B8%A8%E5%90%8D%E4%BC%81%E6%A2%A6%E5%B7%A5%E5%8E%82-%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-66114\" target=\"_blank\" rel=\"noopener\">领英丨名企梦工厂-今日头条</a></h3><p>领英在校招季携手 18 家顶级名企，用 VR 全景带你全方位无死角地触碰心仪公司，可以说结合 VR 进行企业的介绍效果很赞，再加上旁白的介绍更加饱满充实，不过就是流量消耗巨大。。如果对 VR 感兴趣的话，欢迎去 <a href=\"https://veervr.tv/\" target=\"_blank\" rel=\"noopener\">VeeR-全球VR内容分享社区</a>观看更多 VR 视频（首先，你得有一副好的 VR 眼镜）</p>\n<h3 id=\"2017两会\"><a href=\"#2017两会\" class=\"headerlink\" title=\"2017两会\"></a><a href=\"http://www.html5case.com.cn/case/people-cn/likeqiang-timeline/index2.html\" target=\"_blank\" rel=\"noopener\">2017两会</a></h3><p>人民日报在两会期间做的微信宣传 H5，很有创意，借用微信群聊和朋友圈的方式对国家取得的成果进行了展示，同时进行了一些宣传和号召。</p>\n<h3 id=\"王思聪邀请你加入群聊\"><a href=\"#王思聪邀请你加入群聊\" class=\"headerlink\" title=\"王思聪邀请你加入群聊\"></a><a href=\"http://static.udache.com/gulfstream/webapp/modules/tmall2didi/index.html\" target=\"_blank\" rel=\"noopener\">王思聪邀请你加入群聊</a></h3><p>现在的标题党越来越多了。。其实和上面那个两会的 H5 类似，只不过粗糙一些，而且内容也比较少，就是滴滴的一个活动的宣传，很明显的不太用心啊。</p>\n<h3 id=\"河北衡水中学720°全景图\"><a href=\"#河北衡水中学720°全景图\" class=\"headerlink\" title=\"河北衡水中学720°全景图\"></a><a href=\"http://720yun.com/t/7b9z011r08z?code=03101967458b0569d107870c89280a4H\" target=\"_blank\" rel=\"noopener\">河北衡水中学720°全景图</a></h3><p>衡中虽然占地面积比较小，但是每年产出的清北人数可以说在全国都是名列前茅的，而这个 720° 全景图相比之前魔兽和凡科的就差太多了，好希望有人能做一个比较细致的 720° 全景图啊- -</p>\n<h3 id=\"比尔盖茨邀请你加入群聊\"><a href=\"#比尔盖茨邀请你加入群聊\" class=\"headerlink\" title=\"比尔盖茨邀请你加入群聊\"></a><a href=\"http://m.creatby.com/v2/manage/book/rkcmfz/?weixin_auth_key=20180215100913870054844\" target=\"_blank\" rel=\"noopener\">比尔盖茨邀请你加入群聊</a></h3><p>需要在微信中打开，和上面的“王思聪邀请你加入群聊”类似，都是模仿微信进行宣传，同时加入了一些用户互动，最后重定向到了公众号中的一篇文章，其实这种形式是一种很好的宣传，值得借鉴</p>\n<h3 id=\"以你之名，守护汉字\"><a href=\"#以你之名，守护汉字\" class=\"headerlink\" title=\"以你之名，守护汉字\"></a><a href=\"http://shared.youdao.com/market/xmdh/163.html?d=1518660346820\" target=\"_blank\" rel=\"noopener\">以你之名，守护汉字</a></h3><p>网易有道做的“守护汉字”主题活动，根据你的姓名为你分配一个需要守护的古汉字，让我不禁想起了《国家宝藏》，不过不得不说，动画特效和 BGM 都很赞，在“提笔忘字”的今天，守护汉字显得尤为重要</p>\n<h3 id=\"快看！李彦宏父女跑进你的手机啦！\"><a href=\"#快看！李彦宏父女跑进你的手机啦！\" class=\"headerlink\" title=\"快看！李彦宏父女跑进你的手机啦！\"></a><a href=\"https://eopa.baidu.com/page/RV-gFZw4Ct7\" target=\"_blank\" rel=\"noopener\">快看！李彦宏父女跑进你的手机啦！</a></h3><p>虽然只是一个视频，技术上难度很低，不过这个视频做的很赞，百度通过这种形式宣传自己的“手机百度”，虽然对百度并无好感，不过如此用心的视频还是要赞一个</p>\n<h3 id=\"2017，谁是头条？\"><a href=\"#2017，谁是头条？\" class=\"headerlink\" title=\"2017，谁是头条？\"></a><a href=\"http://p.static.jimingkeji.com.cn/infini-first171208/index.html\" target=\"_blank\" rel=\"noopener\">2017，谁是头条？</a></h3><p>头条对于 2017 年度新闻的总结，水墨画与太极的结合很是中国风，文案处处体现着“中国功夫”的元素。</p>\n<h3 id=\"唐朝名媛高阶生活指南\"><a href=\"#唐朝名媛高阶生活指南\" class=\"headerlink\" title=\"唐朝名媛高阶生活指南\"></a><a href=\"http://wx.amo9.com/h5/2018/nov/cmcc10086/8/index.html?proj=cmcc10086&amp;\" target=\"_blank\" rel=\"noopener\">唐朝名媛高阶生活指南</a></h3><p>你不看到末尾不会想到，这是中国移动的广告。。。</p>\n<h3 id=\"二零一七年娱乐圈画传\"><a href=\"#二零一七年娱乐圈画传\" class=\"headerlink\" title=\"二零一七年娱乐圈画传\"></a><a href=\"http://ent.163.com/special/entphotos2017/?spssid=5892622e2f96d034a7931d06dd4b4dd0&amp;spsw=12&amp;spss=other&amp;from=groupmessage&amp;isappinstalled=0\" target=\"_blank\" rel=\"noopener\">二零一七年娱乐圈画传</a></h3><p>去年的一个网易娱乐年度新闻盘点的 H5 页面非常的新颖，采用画中画的形式依次串联十多个手绘娱乐图片，加上洗脑的“好运来”音乐，让人有很大的分享的欲望。这里有一篇解密的文章：<a href=\"https://juejin.im/post/5bfbcb1e5188252e8966a298\" target=\"_blank\" rel=\"noopener\">《Canvas 实现画中画动画效果–网易娱乐年度盘点H5动画解密》</a></p>\n<h3 id=\"娱乐圈画传2018：江湖多离别-十年如一梦\"><a href=\"#娱乐圈画传2018：江湖多离别-十年如一梦\" class=\"headerlink\" title=\"娱乐圈画传2018：江湖多离别 十年如一梦\"></a><a href=\"http://h5.data.163.com/163/html/ent/entpainting2018/index.html?spssid=5892622e2f96d034a7931d06dd4b4dd0&amp;spsw=3&amp;spss=native\" target=\"_blank\" rel=\"noopener\">娱乐圈画传2018：江湖多离别 十年如一梦</a></h3><p>从 2008 到 2018，时间是世事更迭最好的导演。网易娱乐将娱乐圈画传做成了一个 IP，希望一直做下去吧。</p>\n<h3 id=\"她挣扎48小时后死去，无人知晓\"><a href=\"#她挣扎48小时后死去，无人知晓\" class=\"headerlink\" title=\"她挣扎48小时后死去，无人知晓\"></a><a href=\"https://c.m.163.com/nc/qa/activity/dada_protection/index.html?spssid=5892622e2f96d034a7931d06dd4b4dd0&amp;spsw=1&amp;spss=163\" target=\"_blank\" rel=\"noopener\">她挣扎48小时后死去，无人知晓</a></h3><p>副标题：《你也是这个故事的主角》，首先不要被这个标题所吓到，其实这是网易出品的一个号召大家关注环境保护的一个 H5，不得不说，网易在这个方面做的真的很出色。</p>\n<h3 id=\"制造【我】的草莓音乐节\"><a href=\"#制造【我】的草莓音乐节\" class=\"headerlink\" title=\"制造【我】的草莓音乐节\"></a><a href=\"http://wap.zhengzai.tv/pages/strawberry2018/index.html\" target=\"_blank\" rel=\"noopener\">制造【我】的草莓音乐节</a></h3><p>可以在线生成草莓音乐节主题海报，你可以定制自己的外形，并添加一些简单的文案。</p>\n<h3 id=\"重回1978，带你潇洒走一回！\"><a href=\"#重回1978，带你潇洒走一回！\" class=\"headerlink\" title=\"重回1978，带你潇洒走一回！\"></a><a href=\"http://omgmkt.qq.com/tencent_news/201811/reform/40year.8b3ec.html\" target=\"_blank\" rel=\"noopener\">重回1978，带你潇洒走一回！</a></h3><p>腾讯新闻出品的，结合重力感应带你回顾改革开放四十年来我们的变化，筒子楼、迪斯科、马里奥，这些具有十分明显的时代痕迹的符号代表了那一辈人的童年，就像标题一样，带你潇洒走一回！</p>\n<h3 id=\"当TiMi一声响起的时候\"><a href=\"#当TiMi一声响起的时候\" class=\"headerlink\" title=\"当TiMi一声响起的时候\"></a><a href=\"https://timi.qq.com/act/a20181212timi/index.html\" target=\"_blank\" rel=\"noopener\">当TiMi一声响起的时候</a></h3><p>天美工作室出品，这是属于我们十年的回忆，不止是王者荣耀</p>\n<h3 id=\"我在幸福长街40号等你\"><a href=\"#我在幸福长街40号等你\" class=\"headerlink\" title=\"我在幸福长街40号等你\"></a><a href=\"https://c.h5in.net/people/\" target=\"_blank\" rel=\"noopener\">我在幸福长街40号等你</a></h3><p>人民日报携手快手出品，这是一张“长动图”，见证了 1979-2019 这 40 年的沧桑巨变。</p>\n<h3 id=\"带你全方位欣赏美丽的重庆邮电大学\"><a href=\"#带你全方位欣赏美丽的重庆邮电大学\" class=\"headerlink\" title=\"带你全方位欣赏美丽的重庆邮电大学\"></a><a href=\"https://720yun.com/t/70c26xsgq1f\" target=\"_blank\" rel=\"noopener\">带你全方位欣赏美丽的重庆邮电大学</a></h3><p>重邮全景</p>\n<h2 id=\"一些专门做H5媒体内容的平台：\"><a href=\"#一些专门做H5媒体内容的平台：\" class=\"headerlink\" title=\"一些专门做H5媒体内容的平台：\"></a>一些专门做H5媒体内容的平台：</h2><h3 id=\"木疙瘩\"><a href=\"#木疙瘩\" class=\"headerlink\" title=\"木疙瘩\"></a><a href=\"http://www.mugeda.com\" target=\"_blank\" rel=\"noopener\">木疙瘩</a></h3><p>H5 交互融媒体内容制作与管理平台。首先吐槽一下这个名字，可能是因为只买到了这个稍微能凑出汉字的域名吧，毕竟现在的域名是真贵啊- -，其特色有：</p>\n<ul>\n<li>免费无广告</li>\n<li>零代码交互</li>\n<li>自动适配屏幕</li>\n<li>可导出源文件</li>\n</ul>\n<p>然而，人民日报的一篇题为《燃爆！人民日报首部闪卡H5动画“史上最牛团队这样创业！”》的 H5 文案却被删除了：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_235.jpeg\" width=\"300\" alt=\"\"></div>\n\n<h3 id=\"凡科互动\"><a href=\"#凡科互动\" class=\"headerlink\" title=\"凡科互动\"></a><a href=\"http://hd.faisco.com/\" target=\"_blank\" rel=\"noopener\">凡科互动</a></h3><p>H5 游戏营销领导者。H5游戏因为其跨平台、传播快等特性，近年来受到了广泛关注，而凡科互动就是专注于 H5 游戏的一个平台，我自己也试玩了一下它的几款游戏，包括大转盘、摇一摇、砸金蛋等等，画面音效都很不错，不过应该不是免费的，所以还是要预估一下成本和收益再做决定吧。</p>\n<h3 id=\"720yun\"><a href=\"#720yun\" class=\"headerlink\" title=\"720yun\"></a><a href=\"http://720yun.com/\" target=\"_blank\" rel=\"noopener\">720yun</a></h3><p>从名字可以看出，这是一家做 720 度全景和 VR 视频的平台，首先这个网站的风格我很喜欢，非常紧致有力，不过名气不是很大，也不知道效果如何和收费情况。</p>\n<h3 id=\"MAKA\"><a href=\"#MAKA\" class=\"headerlink\" title=\"MAKA\"></a><a href=\"http://maka.im/\" target=\"_blank\" rel=\"noopener\">MAKA</a></h3><blockquote>\n<p>MAKA 是一款简单、强大的 H5 数字化营销创作工具 其在线编辑器可帮助企业创作出专业级 H5 酷炫动态效果</p>\n</blockquote>\n<p>这是其官网的介绍，MAKA 在业界算是很有名气的了，经常会看到一些企业用 MAKA 做 H5 宣传，所以其本身的效果是已经经过广泛验证的了，最关键的是免费制作（当然，有一些也需要收费），如果有感兴趣的童鞋可以下载一下 MAKA 的 APP 尝试一下，操作简单但是功能强大。</p>\n<h3 id=\"易企秀\"><a href=\"#易企秀\" class=\"headerlink\" title=\"易企秀\"></a><a href=\"http://www.eqxiu.com/\" target=\"_blank\" rel=\"noopener\">易企秀</a></h3><blockquote>\n<p>企业移动营销综合服务平台 极简制作流程 奢华呈现形式 精准投放保证传播效果 数据随时跟踪反馈 从营销到再营销 从传播到二次传播 易企秀提供一键解决方案</p>\n</blockquote>\n<p>易企秀和 MAKA 类似，也是我最开始接触到的 H5 营销平台，虽然其介绍感觉比 MAKA 要强大许多，不过从我自身的体验来讲，易企秀比较适合中小型企业以及那些不太追求外表，同时在线时间比较短的营销活动，比如年会邀请函、新品介绍等等。总之吧，和 MAKA 相比各有千秋。</p>\n<h2 id=\"它山之石\"><a href=\"#它山之石\" class=\"headerlink\" title=\"它山之石\"></a>它山之石</h2><p>还有一些志同道合的童鞋也对与H5的玩法案例进行了总结：</p>\n<h3 id=\"H5玩法知多少\"><a href=\"#H5玩法知多少\" class=\"headerlink\" title=\"H5玩法知多少\"></a><a href=\"https://www.jianshu.com/p/34987148c9d9\" target=\"_blank\" rel=\"noopener\">H5玩法知多少</a></h3><p>来自简书，作者不仅介绍了许许多多经典的 H5 案例，作者还将 H5 玩法归纳为<strong>基于传感器、基于触摸屏操作、基于画面呈现、基于内容</strong>这四类，内容很充实。</p>\n","raw":null,"categories":[{"name":"mobile","path":"api/categories/mobile.json"}],"tags":[{"name":"移动端","path":"api/tags/移动端.json"}]},{"title":"再见，2017","slug":"再见，2017","date":"2017-12-31T15:15:52.000Z","updated":"2019-01-29T09:23:55.536Z","comments":true,"path":"api/articles/再见，2017.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_236.jpeg","content":"<p>今天是2017年12月31号，也就是2017年的最后一天，一般有个人博客的人都会搞个总结神马的，那我也不能落后啊？！</p>\n<h2 id=\"2017\"><a href=\"#2017\" class=\"headerlink\" title=\"2017\"></a>2017</h2><p>2017 对于我来说，可以说是非常重要的一年，在这一年中我经历了很多，也度过了很多个难忘的夜晚，废话少说：</p>\n<h3 id=\"人\"><a href=\"#人\" class=\"headerlink\" title=\"人\"></a>人</h3><p>首先，2017 年最重要的当然是<strong>找到了第一份工作</strong>，在字节跳动遇到了很多有趣的同事，其实现在想想，我的秋招就这样以一场面试开始，以同样一场面试结束了。。 在这里不得不讲一下<strong>字节跳动</strong>的种种，这里的人都很 nice，上级并没有官架子，同事们也很有趣，当然这里的饭菜在互联网界也是非常出名的，每一餐都是 50+ 的水准，不得不说，一个好食堂真的能提高生产力~除此之外，每天中午吃完饭之后还能休息 1-2 个小时，这对于我这种不睡午觉一天就没精神的简直是超级福利。。说了这么多，如果有想来字节跳动工作的童鞋，欢迎联系我~ 2017 年对于所有的90后来说也是独特的一年，因为过了今天就意味着<strong>所有的90后都已满18岁</strong>，不再是当初那个叛逆的年纪了，所以在最近也看到了各种秀 18 岁的朋友圈，时光催人老，不服不行：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_236.jpeg\" width=\"400\" alt=\"\"></div>\n\n<p>这张照片是当初在衡中远足时拍的，应该在 2009 年，当时差不多 17 岁。<br>2017 年还是一个<strong>主播行业大热</strong>的年份，不得不说，我是看着冯提莫、二珂、大表姐、大奶强等主播逐渐成长起来的，可以说直播不仅让我吃外卖的时候不感觉无聊，同时让我学到了很多姿势，成为了我日常生活中不可缺少的一部分。</p>\n<h3 id=\"事\"><a href=\"#事\" class=\"headerlink\" title=\"事\"></a>事</h3><p>首先，这一年我的个人博客终于上线了。在经过一系列的折腾和 YueBug 的热情帮助下，<strong>Merrier说</strong>在今年 4 月份的时候上线了，虽然我的水平有限，不能像其他前端大牛一样对各种新鲜技术进行讲解，或对一些框架的源码进行解读，但是我始终相信，基础知识才是最重要的，所以如果你也入了前端的坑，那么 Merrier说 一定能让你学到一些东西~ 2017 年不得不提一下<strong>共享单车</strong>这个行业，从最初的 ofo，到后来的各种单车，再到现在的 ofo 和摩拜平分天下的形势，可以说我们都成为了共享单车行业的见证人，同时也让我们看到了为什么<strong>创业需谨慎</strong>，提到共享单车，就联想到了我至今还没有追回的 99 大洋押金：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_234.jpeg\" width=\"300\" alt=\"\"></div>\n\n<p>当然，如果让我在 ofo 和摩拜中选一个，我站摩拜（新摩拜简直好骑到爆）！ 不知道什么时候，本命年的梗深受人心，不过对于我来说，2017 年可以说是收获的一年，不仅在前端方面找到了自己喜爱的学习方式，同时在工作上也有了自己满意的结果，当然希望看到这里的有缘人不管 2017 年过得如何，在 2018 年都能如自己所愿。</p>\n<h2 id=\"2018\"><a href=\"#2018\" class=\"headerlink\" title=\"2018\"></a>2018</h2><p>展望一下2018的话，希望能够：</p>\n<ul>\n<li>在工作上取得突破，不管是前端技术还是为人处事都能再进一步</li>\n<li>说了好几年的健身应该能付诸行动了吧？</li>\n<li>多看几部纪录片</li>\n<li>把漫威DC的电影都看一遍</li>\n<li>Leetcode 再刷 200 道题</li>\n<li>Merrier说 能够再多一些干货文章</li>\n<li>完成一个 chrome 插件</li>\n<li>向 npm 库提交一个自己做的插件</li>\n<li>小程序可以玩一玩</li>\n<li>一直想做的图片上传和展示网站能落地</li>\n<li><strong>顺利毕业！</strong></li>\n<li><strong>摇到号！</strong></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>你以为完了？并没有！以一张网图作为结束吧：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_233.jpeg\" width=\"300\" alt=\"\"></div>\n\n<p>愿你走出半生，归来仍是少年。</p>\n","raw":null,"categories":[{"name":"talk","path":"api/categories/talk.json"}],"tags":[{"name":"life","path":"api/tags/life.json"},{"name":"总结","path":"api/tags/总结.json"}]},{"title":"Blue老师ES6视频笔记","slug":"Blue老师ES6视频笔记","date":"2017-12-12T14:10:42.000Z","updated":"2019-01-29T09:23:55.528Z","comments":true,"path":"api/articles/Blue老师ES6视频笔记.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>请容许我吐槽一下，我发现中国很多前端的大神的英文真的差啊。。</p>\n<h2 id=\"ES6-兼容性\"><a href=\"#ES6-兼容性\" class=\"headerlink\" title=\"ES6 兼容性\"></a>ES6 兼容性</h2><p>可以在线查看兼容性：</p>\n<ul>\n<li>ES5：<a href=\"https://kangax.github.io/compat-table/es5/\" target=\"_blank\" rel=\"noopener\">kangax.github.io/compat-table/es5/</a></li>\n<li>ES6：<a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"noopener\">kangax.github.io/compat-table/es6/</a></li>\n</ul>\n<h3 id=\"在线编译\"><a href=\"#在线编译\" class=\"headerlink\" title=\"在线编译\"></a>在线编译</h3><p><strong>babel === browser.js</strong>，只不过叫法不同 可以通过如下方式实现在线编译 ES6，只不过会多出额外的编译时间，用户体验稍差：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"browser.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/babel\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> a = <span class=\"number\">12</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> b = <span class=\"number\">5</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    alert(a+b);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"ES5-中-var-的缺点：\"><a href=\"#ES5-中-var-的缺点：\" class=\"headerlink\" title=\"ES5 中 var 的缺点：\"></a>ES5 中 var 的缺点：</h3><ul>\n<li>可以重复声明</li>\n<li>无法限制修改，即没有常量的概念</li>\n<li>没有块级作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert a; <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"块级作用域有什么用？\"><a href=\"#块级作用域有什么用？\" class=\"headerlink\" title=\"块级作用域有什么用？\"></a>块级作用域有什么用？</h3><p>可以限定变量在块中起作用，而不像ES5一样在函数块中起作用，最常见的是 for 循环中的索引值</p>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ol>\n<li>如果只有一个参数，()可以省略</li>\n<li>如果只有一个 return，{}可以省略</li>\n</ol>\n<h2 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h2><p>ES6新增：</p>\n<h3 id=\"参数扩展（…args必须为最后一个形参）\"><a href=\"#参数扩展（…args必须为最后一个形参）\" class=\"headerlink\" title=\"参数扩展（…args必须为最后一个形参）\"></a>参数扩展（…args必须为最后一个形参）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b, ...args</span>)</span>&#123;</span><br><span class=\"line\">  alert(a);</span><br><span class=\"line\">  alert(b);</span><br><span class=\"line\">  alert(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">show(<span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"展开一个数组\"><a href=\"#展开一个数组\" class=\"headerlink\" title=\"展开一个数组\"></a>展开一个数组</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\];</span><br><span class=\"line\">\\[...arr\\] = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\];</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b=<span class=\"number\">5</span>, c=<span class=\"number\">12</span></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b, c\\] = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[&#123;a, b&#125;, \\[n1, n2, n3\\], num, str\\] = \\[&#123;<span class=\"attr\">a</span>: <span class=\"number\">12</span>, <span class=\"attr\">b</span>: <span class=\"number\">5</span>&#125;, \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>\\], <span class=\"number\">8</span>, <span class=\"string\">'cxzcv'</span>\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, n1, n2, n3, num, str);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b\\] = &#123;<span class=\"attr\">a</span>: <span class=\"number\">12</span>, <span class=\"attr\">b</span>: <span class=\"number\">45</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// undefined is not a function, 前提1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125; = &#123;<span class=\"number\">12</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// unexpected token, 前提2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b\\];</span><br><span class=\"line\">\\[a, b\\] = \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>\\]; <span class=\"comment\">// XXXX error, 前提3</span></span><br></pre></td></tr></table></figure>\n<p>前提：</p>\n<ol>\n<li>左右两边解构必须一样</li>\n<li>右边必须是个东西</li>\n<li>声明和赋值不能分开（必须在一句话中完成）</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>新增四个方法：</p>\n<ul>\n<li>map：映射</li>\n<li>reduce：汇总</li>\n<li>filter：过滤器</li>\n<li>forEach：循环（迭代）</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result); <span class=\"comment\">// 24, 10, 16</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><p>经常用来算总数、平均数等指标</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">69</span>, <span class=\"number\">180</span>, <span class=\"number\">8763</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tmp, item, index</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp + item;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result);</span><br></pre></td></tr></table></figure>\n<p>求平均数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">69</span>, <span class=\"number\">180</span>, <span class=\"number\">8763</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\">(<span class=\"params\">tmp, item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index != arr.length - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp+item;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (tmp+item)/arr.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result);</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>filter 中 return true 就留下来，return false 就不保留</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>类似于传统的 for 循环，参数为 item, index</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>新增：</p>\n<ol>\n<li>多了两个新方法，startsWith，endsWith</li>\n<li>字符串模板</li>\n</ol>\n<h3 id=\"字符串模板\"><a href=\"#字符串模板\" class=\"headerlink\" title=\"字符串模板\"></a>字符串模板</h3><p>普通字符串无法折行，字符串模板可以折行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = \\<span class=\"string\">`a<span class=\"subst\">$&#123;a&#125;</span>bc\\`;</span></span><br><span class=\"line\"><span class=\"string\">alert(str); // a12bc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p>ES5 中的面向对象：类和构造函数不分，混为一谈；ES6 中的面向对象：</p>\n<ol>\n<li>class 关键字，构造器和类分开了</li>\n<li>class 里面直接加方法</li>\n<li>extends-继承</li>\n</ol>\n<h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2><p>json 的标准写法：</p>\n<ol>\n<li>只能用双引号</li>\n<li>所有的名字（key）都必须用引号包起来</li>\n</ol>\n<p>在 ES 中，当名字和值相同时，可以只写其中一个；方法可以省掉: function</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>异步会让代码更复杂，而同步的代码简单，而 Promise 用同步的方式来书写异步代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">  $.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'arr.txt'</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    success(arr)&#123;</span><br><span class=\"line\">      resolve(arr);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error(err)&#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'成功'</span>)&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'失败'</span>)&#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise.all([promise1, promise2, …]) =&gt; 都 resolve 的时候才算成功，只要有一个 reject 就算失败<br>Promise.\brace([promise1, promise2, …]) =&gt; 只要有一个 resolve 的时候就算成功，全部 reject 才算失败 在高版本 jQuery 中，$.ajax 的返回值就是一个 Promise 对象</p>\n<h2 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h2><p>和普通函数相比，中间能暂停，需要和 yield 配合使用 generator 并不会直接执行，而是会创建一个 generator 对象，其中该对象的 next 方法用于继续执行，碰到 yield 就会停</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  alert(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = show();</span><br><span class=\"line\">genObj.next(); <span class=\"comment\">// a</span></span><br><span class=\"line\">genObj.next(); <span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><p>yield 既可以传参，又可以返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">show</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">`<span class=\"subst\">$&#123;num1&#125;</span>, <span class=\"subst\">$&#123;num2&#125;</span>`</span>);</span><br><span class=\"line\">  alert(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  alert(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  alert(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = show(<span class=\"number\">99</span>, <span class=\"number\">88</span>);</span><br><span class=\"line\">gen.next(<span class=\"number\">12</span>); <span class=\"comment\">// 第一个next没法给yield传参</span></span><br><span class=\"line\">gen.next(<span class=\"number\">5</span>); <span class=\"comment\">// 会传给上面的yield，所以a=5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-的局限性\"><a href=\"#Promise-的局限性\" class=\"headerlink\" title=\"Promise 的局限性\"></a>Promise 的局限性</h3><p>其实 generator 之所以出现也是因为纯 Promise 也有其自身的缺陷，并不能完全避免“回调陷阱”，而网上对于 Promise 的局限性解释很多，建议大家直接去看相关博客就可以了，而在我理解就是<strong>Promise 在解决数据依赖问题时避免不了“回调陷阱”</strong>，比如我需要根据数据 A 去请求数据 B，然后再根据数据 B 请求数据 C，然后再……，如果你自己用 Promis e实现一下的话就会发现这时候它的局限性所在；这也再一次证明了那句话：<strong>懒惰是最大生产力</strong></p>\n<h2 id=\"ES7-预览\"><a href=\"#ES7-预览\" class=\"headerlink\" title=\"ES7 预览\"></a>ES7 预览</h2><p>ES6 还没掌握，ES7 都定稿了。。ES8 都有草案了。。，不过现在浏览器对 ES7 的支持很惨</p>\n<ul>\n<li>数组 includes -&gt; 检查数组是否包含某元素</li>\n<li>数组 keys/values/entries -&gt; 一般配合 for…of 使用，for…of 即对 value 的循环，entries 是对键值对的循环</li>\n<li>求幂新操作符 -&gt; 3**8 === Math.pow(3, 8)</li>\n<li>字符串的 padStart/padEnd 方法 -&gt; 补充空格或其他字符串</li>\n<li>增加了函数容忍度 function show(a, b, c, ) -&gt; 不报错</li>\n<li>async 和 await，这基本上是 ES7 最好用的。。用于替代 generator 和 yield</li>\n<li>……</li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"ES6","path":"api/tags/ES6.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"Hybrid设计与浅析","slug":"Hybrid设计与浅析","date":"2017-12-01T14:19:00.000Z","updated":"2019-01-29T09:23:55.528Z","comments":true,"path":"api/articles/Hybrid设计与浅析.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_288.png","content":"<p>慕课网视频——<a href=\"https://www.imooc.com/learn/850\" target=\"_blank\" rel=\"noopener\">Hybrid设计</a>的学习笔记，同时加入了一些自己的理解，希望通过本篇文章能够让你理解什么是 Hybrid，以及 Hybrid 有什么特点，同时还会简单介绍一下 Hybrid 开发时的注意事项。</p>\n<h2 id=\"什么是-Hybrid\"><a href=\"#什么是-Hybrid\" class=\"headerlink\" title=\"什么是 Hybrid\"></a>什么是 Hybrid</h2><p>Hybrid 和普通前端代码没差别，只不过宿主不一样，Hybrid 就是在 app 中运行的前端代码。</p>\n<h2 id=\"业内的-Hybrid-App\"><a href=\"#业内的-Hybrid-App\" class=\"headerlink\" title=\"业内的 Hybrid App\"></a>业内的 Hybrid App</h2><ul>\n<li>携程</li>\n<li>百度糯米</li>\n<li>京东</li>\n<li>天猫</li>\n<li>微信</li>\n<li>QQ</li>\n<li>手机百度</li>\n<li>支付宝</li>\n</ul>\n<h3 id=\"一般地，APP-开发方式有以下几种方式：\"><a href=\"#一般地，APP-开发方式有以下几种方式：\" class=\"headerlink\" title=\"一般地，APP 开发方式有以下几种方式：\"></a>一般地，APP 开发方式有以下几种方式：</h3><ol>\n<li>Web App（浏览器网页）</li>\n<li>Native App（原生app）</li>\n<li>Hybrid App（ H5 混合app）</li>\n<li>超级Hybrid（React Native、Weex）</li>\n<li>微信/支付宝小程序（或内嵌页面）</li>\n</ol>\n<h2 id=\"Hybrid-相比-Native-和纯-Html5-的优缺点\"><a href=\"#Hybrid-相比-Native-和纯-Html5-的优缺点\" class=\"headerlink\" title=\"Hybrid 相比 Native 和纯 Html5 的优缺点\"></a>Hybrid 相比 Native 和纯 Html5 的优缺点</h2><div align=\"center\"><img src=\"/images/hexo_post_288.png\" alt=\"\"></div>\n\n<h2 id=\"Native-与-H5-的职责\"><a href=\"#Native-与-H5-的职责\" class=\"headerlink\" title=\"Native 与 H5 的职责\"></a>Native 与 H5 的职责</h2><ul>\n<li>H5 做业务</li>\n<li>Native 提供基础能力</li>\n<li>Native 做好必须 Native 做的业务</li>\n</ul>\n<h2 id=\"H5-与-Native-通信\"><a href=\"#H5-与-Native-通信\" class=\"headerlink\" title=\"H5 与 Native 通信\"></a>H5 与 Native 通信</h2><h3 id=\"JavascriptCore\"><a href=\"#JavascriptCore\" class=\"headerlink\" title=\"JavascriptCore\"></a>JavascriptCore</h3><p>和 JS Bridge 类似</p>\n<div align=\"center\"><img src=\"/images/hexo_post_104.png\" alt=\"\"></div>\n\n<h2 id=\"通过-URL-Schema-通信\"><a href=\"#通过-URL-Schema-通信\" class=\"headerlink\" title=\"通过 URL Schema 通信\"></a>通过 URL Schema 通信</h2><h3 id=\"App-主动与-H5-通信\"><a href=\"#App-主动与-H5-通信\" class=\"headerlink\" title=\"App 主动与 H5 通信\"></a>App 主动与 H5 通信</h3><div align=\"center\"><img src=\"/images/hexo_post_88.png\" alt=\"\"></div>\n\n<p>将一组 API 绑定在 webview 的 window 对象上，App 通过 iOS/Android 原生方法调用 window 对象中的 js 方法</p>\n<h3 id=\"H5-主动与-App-通信\"><a href=\"#H5-主动与-App-通信\" class=\"headerlink\" title=\"H5 主动与 App 通信\"></a>H5 主动与 App 通信</h3><div align=\"center\"><img src=\"/images/hexo_post_105.png\" alt=\"\"></div>\n\n<p>App 实现对 WebView URL 的观察者模式，H5 通过改变 URL 的哈希值，App 会通过解析哈希值的变化执行对应的操作</p>\n","raw":null,"categories":[{"name":"慕课网","path":"api/categories/慕课网.json"}],"tags":[{"name":"Hybrid","path":"api/tags/Hybrid.json"},{"name":"慕课网","path":"api/tags/慕课网.json"}]},{"title":"浅谈搜索引擎（SEO）","slug":"浅谈搜索引擎（SEO）","date":"2017-11-30T14:47:40.000Z","updated":"2019-01-29T09:23:55.540Z","comments":true,"path":"api/articles/浅谈搜索引擎（SEO）.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这是一篇视频笔记，最近看了幕课网上的视频——<a href=\"https://www.imooc.com/learn/855\" target=\"_blank\" rel=\"noopener\">浅谈搜索引擎_SEO</a>，同时结合了之前有位公司的同事分享的关于 SEO 的一些内容，可以说是基本上包含了 SEO 的全部内容了~</p>\n<h2 id=\"SEO-与-SEM-的区别\"><a href=\"#SEO-与-SEM-的区别\" class=\"headerlink\" title=\"SEO 与 SEM 的区别\"></a>SEO 与 SEM 的区别</h2><p>SEO：Search Engine Optimization，搜索引擎优化，SEM：Search Engine Marketing，搜索引擎营销，因为价钱越高排名越靠前，所以也可以称为搜索引擎竞价</p>\n<ul>\n<li>SEO 免费，SEM 付费</li>\n<li>SEM 短，效益快、SEO 长期投入，增长慢</li>\n<li>新广告法颁布之后 SEM 广告位减少、竞争压力大</li>\n</ul>\n<h2 id=\"IP、PV、UV\"><a href=\"#IP、PV、UV\" class=\"headerlink\" title=\"IP、PV、UV\"></a>IP、PV、UV</h2><ul>\n<li><strong>IP</strong>：独立IP访问的用户</li>\n<li><strong>PV</strong>：页面浏览量或点击量</li>\n<li><strong>UV</strong>：独立访客数</li>\n</ul>\n<p>搜索引擎占有率工具：statcounter</p>\n<h2 id=\"SEO-的三个大方向\"><a href=\"#SEO-的三个大方向\" class=\"headerlink\" title=\"SEO 的三个大方向\"></a>SEO 的三个大方向</h2><ol>\n<li>优化网站的内容</li>\n<li>提升用户体验，吸引更多流量</li>\n<li>优化网站结构，帮助搜索引擎抓取</li>\n</ol>\n<p>虽然搜索引擎的算法，网站的技术不断更新，但是 SEO 的三个大的方向从未变过</p>\n<h2 id=\"SEO-优化最重要的三要素\"><a href=\"#SEO-优化最重要的三要素\" class=\"headerlink\" title=\"SEO 优化最重要的三要素\"></a>SEO 优化最重要的三要素</h2><ul>\n<li>标题（title，一般格式为内容-关键词-品牌词）</li>\n<li>关键词（keywords，一般不超过 100 个字符）</li>\n<li>描述（description，50-170 个字）</li>\n</ul>\n<p><code>title</code>:一般会作为搜索结果的标题中，<code>description</code>:可能会被引用为搜索结果，也可能不会，<code>keyowrds</code>:由于很多网站无法准确提取关键词，一些网站恶意堆砌关键词，关键词的重要性已经在降低。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><h3 id=\"内链\"><a href=\"#内链\" class=\"headerlink\" title=\"内链\"></a>内链</h3><ul>\n<li>提升网站内部页面抓取率</li>\n<li>优化本站、提高流量</li>\n</ul>\n<p>经典的内链网站为百度百科</p>\n<h3 id=\"外链\"><a href=\"#外链\" class=\"headerlink\" title=\"外链\"></a>外链</h3><p>外链是指网站与网站之间的链接向导，外链是提升权重的方式，互联网是链接与链接实现的一条网络，灌水式外链会让人头疼</p>\n<h2 id=\"友情链接交换注意事项\"><a href=\"#友情链接交换注意事项\" class=\"headerlink\" title=\"友情链接交换注意事项\"></a>友情链接交换注意事项</h2><p>和内容相近的网站交换 链接交换形式多样</p>\n<ul>\n<li>单向链接：别人指向我或者我指向别人，而对方不指过来</li>\n<li>双向链接：网站与网站之间互相交换链接</li>\n</ul>\n<h2 id=\"SEO建议\"><a href=\"#SEO建议\" class=\"headerlink\" title=\"SEO建议\"></a>SEO建议</h2><ul>\n<li>经常更新</li>\n<li>质量</li>\n<li>原创</li>\n<li>关键词密度（2%~8%）</li>\n<li>图文并茂</li>\n</ul>\n<h2 id=\"和SEO相关的HTML标签\"><a href=\"#和SEO相关的HTML标签\" class=\"headerlink\" title=\"和SEO相关的HTML标签\"></a>和SEO相关的HTML标签</h2><h3 id=\"a-标签中的-nofollow\"><a href=\"#a-标签中的-nofollow\" class=\"headerlink\" title=\"a 标签中的 nofollow\"></a>a 标签中的 nofollow</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"nofollow\"</span>&gt;</span>链接<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>作用：使链接指向的页面不影响本页权重，但不能保证搜索引擎不抓取，使用时机：</p>\n<ul>\n<li>搜索引擎不需要抓取的页面，如登录、注册、付费等；</li>\n<li>对页面没有正向权重的页面，如了解更多；</li>\n<li>页面中的重复链接。</li>\n</ul>\n<h3 id=\"meta-中-robots-设置\"><a href=\"#meta-中-robots-设置\" class=\"headerlink\" title=\"meta 中 robots 设置\"></a>meta 中 robots 设置</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"robots\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"index,follow\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>noindex：不要索引此页面</li>\n<li>nofollow：不要关注此页面的链接</li>\n<li>noatchive：不要保存网页快照</li>\n<li>nosnippet：不要此页面的描述</li>\n</ul>\n<p>目前不是所有的搜索引擎都支持 robots，即使支持，也不是所有的字段都会遵守。</p>\n<h2 id=\"避免过度-SEO\"><a href=\"#避免过度-SEO\" class=\"headerlink\" title=\"避免过度 SEO\"></a>避免过度 SEO</h2><h3 id=\"不要尝试欺骗搜索引擎\"><a href=\"#不要尝试欺骗搜索引擎\" class=\"headerlink\" title=\"不要尝试欺骗搜索引擎\"></a>不要尝试欺骗搜索引擎</h3><ul>\n<li>采用图片遮盖、透明度等方式隐藏文字</li>\n<li>关键词、标题、描述和内容不符</li>\n</ul>\n<h3 id=\"避免抄袭\"><a href=\"#避免抄袭\" class=\"headerlink\" title=\"避免抄袭\"></a>避免抄袭</h3><ul>\n<li>避免机器采集</li>\n<li>有技巧的借鉴</li>\n</ul>\n<h3 id=\"购买外链，恶意交换友情链接\"><a href=\"#购买外链，恶意交换友情链接\" class=\"headerlink\" title=\"购买外链，恶意交换友情链接\"></a>购买外链，恶意交换友情链接</h3><ul>\n<li>保证适量的外链和友情链接</li>\n<li>不购买被百度惩罚了的网站的外链</li>\n</ul>\n<h3 id=\"移动端强引导下载\"><a href=\"#移动端强引导下载\" class=\"headerlink\" title=\"移动端强引导下载\"></a>移动端强引导下载</h3><p><code>冰心算法</code>是专门用来打击移动端的强引导下载。不下载 app 就无法阅读网页全部内容被百度认为是最严重影响用户体验的行为</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>《SEO实战密码》——堪称 SEO 必读书籍</li>\n<li>seoWhy——关于 seo 的一个论坛</li>\n<li>cnzz、百度统计、谷歌统计——流量统计网站</li>\n</ul>\n<p>本博客用的就是 cnzz，因为流量比较小，所以看不出来和百度统计、谷歌统计比有哪些好处，而且这三家统计网站好像统计的标准都不相同，所以最好的方案就是放三套统计代码。。</p>\n","raw":null,"categories":[{"name":"慕课网","path":"api/categories/慕课网.json"}],"tags":[{"name":"慕课网","path":"api/tags/慕课网.json"},{"name":"SEO","path":"api/tags/SEO.json"}]},{"title":"是时候为网易云音乐的评论打call了","slug":"是时候为网易云音乐的评论打call了","date":"2017-11-07T08:37:46.000Z","updated":"2019-01-29T09:23:55.536Z","comments":true,"path":"api/articles/是时候为网易云音乐的评论打call了.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_232.jpeg","content":"<p>如果你问我，用的最频繁的软件是什么？我的回答不会是微信 or QQ ，而是<strong>网易云音乐</strong>！是的，虽然从研究生开始才入了网易云音乐的坑，但是入了坑才发现之前的音乐播放器都是什么鬼东西啊我的天！而更吸引我的是网易云音乐的评论，一个纯粹的音乐软件竟然把评论系统做的如此有声有色实属不易；所以，是时候为网易云音乐的评论打 call 了！</p>\n<h2 id=\"一生所爱（卢冠廷版）\"><a href=\"#一生所爱（卢冠廷版）\" class=\"headerlink\" title=\"一生所爱（卢冠廷版）\"></a>一生所爱（卢冠廷版）</h2><p>第一首给我最爱的《一生所爱》，最爱的电影《大话西游》和最喜欢的导演星爷</p>\n<ul>\n<li>不戴金箍，如何救你；戴了金箍，如何爱你。</li>\n<li>白晶晶爱的是孙悟空，爱白晶晶的是至尊宝，紫霞爱的是至尊宝，爱紫霞的是孙悟空，你以为是同一个人，其实已经相隔 500 年。</li>\n<li>95 版此恨绵绵无绝期，15版曾经沧海难为水，时移、事易，不同心境而已。无悔，都是自己的回忆。有回忆，还是好的。有怨，还是未能免俗。世俗了，我能理解，不接受。</li>\n<li>《大话西游》的结尾有句话，“你看那个人，好奇怪哟，象一条狗”。像条狗的人，是放弃了人间的男女情欢，无欲无念兢兢业业走在西天取经路上的至尊宝。他如你我这般，收起了脾气火气不再任性淘气，只顾奔波职场。人生百年，谁不曾大闹天宫，谁不曾头上紧箍，谁不曾爱上层楼，谁不曾孤单上路。</li>\n</ul>\n<h2 id=\"一生所爱（莫文蔚版）\"><a href=\"#一生所爱（莫文蔚版）\" class=\"headerlink\" title=\"一生所爱（莫文蔚版）\"></a>一生所爱（莫文蔚版）</h2><p>莫文蔚在天籁之战第八期上的翻唱版本，就像评论说的“兜兜转转，最终没有得到孙悟空的白晶晶又唱起了一生所爱，我想没有人会比她更适合翻唱这首歌了。”</p>\n<ul>\n<li>想要救紫霞就必须打败牛魔王，想要打败牛魔王就必须要变成孙悟空，想要变成孙悟空就必须忘掉七情六欲从此不能再有半点沾染。人生就是这样：想自由地和心爱之人在一起必须要事业有成，想要事业有成就必须要抛弃天真戴上面具，当你变得有能力给心爱之人一切时，却发现找不回最初的自己亦失去了爱的能力。</li>\n<li>白晶晶和紫霞都找到了如意郎君，只有至尊宝沉迷在“大话西游”的世界出不来。</li>\n<li>“昨晚你念晶晶的名字98次，哦，晶晶是我的娘子，还有个叫紫霞的你念了784次，啊，这紫霞一定欠你很多钱。”之前以为这句台词只是为了搞笑</li>\n<li>知乎上有个提问：为何我年龄越大，看周星驰的电影就越心酸？点赞数最高的答案结尾写道：究其原因，我们都变成了我们当初讨厌的模样。</li>\n<li>“从此相逢，便是路人”——一致《一生所爱》</li>\n<li>孟婆汤是否分六口，一口出世甜、二口叛逆辣、三口珍惜酸、四口情责苦、五口身心麻，最后一口却为白水，淡了口中味，忘了前尘事，泯了爱恩仇，舒了川字眉</li>\n<li>每个男人都想当至尊宝有梦想的日子，简单快乐，却不得不戴上紧箍咒，变成齐天大圣，但你会失去很多，生活就是紧箍咒，社会就是牛魔王，父母就是唐僧，紫霞就是梦想，可是你却活的像条狗</li>\n</ul>\n<h2 id=\"I-Wanna-Fuck-You\"><a href=\"#I-Wanna-Fuck-You\" class=\"headerlink\" title=\"I Wanna Fuck You\"></a>I Wanna Fuck You</h2><p>额。。我英语不好。。</p>\n<ul>\n<li>想草就直说，别披着爱情的虚伪</li>\n<li>看到歌名我沉默了，我想了很久，还是同意了，来吧，阿肯，如果你不介意我是个男的话</li>\n<li>有时候你想约个炮，却不小心谈了场恋爱；有时候你想好好谈个恋爱，却发现只是约了个炮。世界那么大，床却那么小，床上的两个人曾经那么好，却不能一起携手到老。我喜欢牵了手就能成婚的故事，却活在了一个上了床也没有结果的时代。</li>\n</ul>\n<h2 id=\"隔烟水（Cover-晃儿）\"><a href=\"#隔烟水（Cover-晃儿）\" class=\"headerlink\" title=\"隔烟水（Cover 晃儿）\"></a>隔烟水（Cover 晃儿）</h2><p>歌手：暖阳/特曼，之前一直看不起古风类的歌曲，后来发现有些古风歌曲不管是词还是曲都还是蛮不错的。。</p>\n<ul>\n<li>爹爹给我的基因也就只有美貌了</li>\n<li>我只剩一百块了 我还是愿意花三十块钱打个车去找你 六十块钱买两张电影票再花八块钱给你买两杯奶茶 剩下两块钱自己坐公交车到银行 提三百万明天我们一起花</li>\n<li>总有一天，你会碰到这样一个女孩，她温柔体贴，漂亮大方，不嫌你穷，不嫌你丑，不要你的钱，也不要你的车，也不要你。</li>\n</ul>\n<h2 id=\"Strength-Of-A-Thousand-Men\"><a href=\"#Strength-Of-A-Thousand-Men\" class=\"headerlink\" title=\"Strength Of A Thousand Men\"></a>Strength Of A Thousand Men</h2><p>自从听了几首纯音乐之后，日推就再也没有词了。。</p>\n<ul>\n<li>尼玛 送快递 听这些音乐 感觉自己在护送核弹</li>\n<li>别让 isis 看到这个歌单。。。</li>\n<li>我要把中国的雾霾全吸干净 不要拦着我</li>\n<li>借我三千虎骑，复我浩荡中华！ 饮马恒河畔，剑指天山西； 碎叶城揽月，库叶岛赏雪； 黑海之滨垂钓，贝加尔湖张弓； 中南半岛访古，东京废墟遥祭华夏列祖。 汉旗指处，望尘逃遁——敢犯中华天威者、虽远必诛;</li>\n<li>爸妈，对不起，原谅我的不辞而别。我只是在床上听了这首音乐，感觉地球有灾难了，我必须站出来了！</li>\n<li>扶朕起来！朕还能再刷几十道高数！！</li>\n</ul>\n<h2 id=\"步戏\"><a href=\"#步戏\" class=\"headerlink\" title=\"步戏\"></a>步戏</h2><p>歌手：五音Jw</p>\n<ul>\n<li>我此生遇到过三个戏子，第一个哥哥演绎的程蝶衣，一生戏痴，第二个二月红，以情入戏，第三个解语花，红妆倾城，从此入了戏，世间有朵解语花，凭谁解花语 这三个中有两个在三叔笔下 他们都有血有肉 对于我来说已经不只是一个书中的角色那么简单了 我本是听书人 奈何入戏太深——典狱司</li>\n<li>讲真的，哪一天这歌很火了，他们就开始疯狂的刷评论，而我们这些老一辈的评论就有很重要的历史意义了，是我们帮他们打下江山，那时候我们早开始新的旅程了，而他们还刚开始。不知过了多久，他们便会发现，哪里都有我们的足迹</li>\n<li>这么多年，他硬是将这身粉色穿出了杀气。</li>\n<li>当这个歌没火的时候评论多半在说第几第几 坐等火 不火没道理之类的 火了之后人们才开始说歌词和故事 而没有故事的万年单身狗只能凭借一腔喜欢刷评论 简单而执着</li>\n<li>瞎子无眼，却道破天机。 哑巴无言，却生死不弃。 戏子无情，却缘定倾心。 天真无邪，却阴谋算尽。</li>\n<li>一身是血的他笑着嘲笑吴邪太天真，告诉他倒斗界里有规矩，不管同伴是谁都要先保自己，却忘了是谁一身伤仍披着沉重的盔甲，忍受着头发钻进伤口的痛苦，一步一步把吴邪带出山洞；忘了是谁还未了解计划的全部，就为了吴邪铤而走险，与强大的对手搏斗。他叫解雨臣，有着世界上最冰冷的温柔。</li>\n</ul>\n<h2 id=\"九九八十一-piano-ver\"><a href=\"#九九八十一-piano-ver\" class=\"headerlink\" title=\"九九八十一 piano ver.\"></a>九九八十一 piano ver.</h2><p>评论的各位大佬真的是 666</p>\n<ul>\n<li>“何谓孤寂？”“清风、艳日，无笑意。”“可否具体？”“左拥、右抱，无情欲。”“可否再具体？”“不得你。”</li>\n<li>“何谓思服？”“巧笑、含睇、山阿盼。”“可否具体？”“琴瑟、钟鼓、寤寐求。”“可否再具体？”“不见你。”</li>\n<li>“何谓无医？” “灵丹、妙药、救不急。”“可否具体”“华佗、仲景、摇头不语。”“可否再具体？”“思你成疾”</li>\n<li>“何谓绝色？”“长空，落日，江山雪。”“可否具体？”“青冥，残霞，天水一线。”“可否再具体？”“不如你”</li>\n<li>“何谓颓靡？” “功名、利禄、皆无趣。”“可否具体”“山珍、糟粕、食之如一。”“可否再具体？”“让我忘了你”</li>\n<li>“何谓遗世？”“流放，独立，无踪迹。”“可否具体？”“无情，冷梦，旧不记。”“可否再具体？”“他已弃。”</li>\n<li>“何谓怠惰?”“无痛，无痒，心惆怅”“可否具体”“淡欲，浅望，双眼迷离”“可否再具体”“心在轮回道”</li>\n<li>“何谓痴情？”“相思泪、千杯酒，是否再遇。”“可否具体？”“足荆棘、手玫瑰，只博一笑。”“可否再具体？”“爱上你。”</li>\n<li>“何为漂泊？”“飞蓬，飘萍，无根底。”“可否具体？”“只鹤，孤雁，寒塘独下迟。”“可否再具体？”“南游，东出，客愁，旅思，离乡千万里。”“可否更具体？”“春行，秋度，杳杳无归期。”“仍是不解。”“浪迹云游，何处寻你。”</li>\n<li>“何谓分裂？”“喜孤、厌闹、渴关注。”“可否具体？”“古风、电音、蒸汽波。”“可否再具体？”“欲卸网易却不舍。”</li>\n</ul>\n<h2 id=\"天空之城\"><a href=\"#天空之城\" class=\"headerlink\" title=\"天空之城\"></a>天空之城</h2><p>歌手：李志，其实蒋敦豪版本也不错。。</p>\n<ul>\n<li>有次校园广播，一哥们说点一首天空之城送给他的港岛妹妹，于是响起了经典的久石让</li>\n<li>这个高冷的人，关闭了微博评论，舞台上他很少话就一直唱啊唱，一曲又一曲，曲曲都肆意。起初不以为意，听久了才发现他是一个经得起单曲循环的歌者。</li>\n<li>从今天起朝九晚五，早起早睡，作息规律，有法定休假，有保险，福利，有体面的工作，有规划有书有音乐，终于成为了普通人，和这座城市的所有人一样，不再奢望仗剑走天涯不再以梦为马，终于可以坦然的承认所有的不羁都将成为过去，都将随着公交车周而复始的轮回被淹没，一切，为了更好的生活。</li>\n<li>人平均活到六十八岁，一共24820天，19万个小时，3500万分钟，差不多21亿秒左右，这10秒，你在读这段话，这十秒，你只属于我，我爱你陌生人</li>\n<li>爱民谣的人是孤独的…05年许巍，06年朴树，07年李健，08年李志，09年绕十三，10年宋冬野，11年贰佰，12年左小祖咒，13年赵雷，14年王喂马，15年周云鹏……身边朋友都说我听的歌变态…是吗？也许这就是用心听歌与用耳听歌的区别吧…</li>\n<li>梵高的爱人是一个妓女 他把所有的钱都用在画画和妓女身上 有一天妓女说想要梵高的耳朵 于是梵高真的把耳朵割下来 有了著名的梵高的自画像 但是当梵高把耳朵给了妓女的时候妓女吓的落荒而逃了 你看 为什么我把你想要的给了你 你还是走了</li>\n</ul>\n<h2 id=\"如果我爱你\"><a href=\"#如果我爱你\" class=\"headerlink\" title=\"如果我爱你\"></a>如果我爱你</h2><p>歌手：周冬雨/张一山，电视剧《春风十里，不如你》片头曲；“春风十里，不如你”，很喜欢这句话。</p>\n<ul>\n<li>公交车上来两个初中生，他们聊天声音很轻，之间的距离也保持在刚好不会碰到彼此。男孩一直害羞低着头不看旁边的女生，女孩一直笑笑的听男生说话，他们一直偷偷瞟着对方。我突然心里柔软得想要笑着落泪，那样青涩又美好的时光，就像小时候偷喝了蜜糖，踩在云端，甜在心里，却再也回不来。✔很棒</li>\n<li>如果我们不能结婚，你来当伴郎吧，因为我们也算是同走红地毯。后来我又想，如果我们不能结婚，你来砸我场、抢我走吧，我一定脱下高跟鞋，跟你私奔到天涯。后来仔细想想，算了，如果我们不能结婚，你别来了，我怕你什么都不做、却举杯祝我幸福。</li>\n<li>“我喜欢你”四个字，在我肠子里饶了几个弯儿，在我胸口跌倒好几回，爬到我的喉咙里又开始胆怯，滑到我的嘴边又改头换面，最后乔装打扮成“你好吗”又或者是“你在干嘛”</li>\n</ul>\n<h2 id=\"逝年\"><a href=\"#逝年\" class=\"headerlink\" title=\"逝年\"></a>逝年</h2><p>歌手：夏小虎，“时间似流水，催促我们长大，年轻的心有了白发，当初的人呐，你们如今在哪”</p>\n<ul>\n<li>当所有人喜欢《董小姐》的时候，你听董小姐，当所以人热捧《南山南》的时候，你循环南山南，我说这些美丽你遇见的太晚了，你说我不懂流行，我笑你不懂民谣。仅此而已。</li>\n<li>我有故事，你有酒嘛</li>\n</ul>\n<h2 id=\"逆流时光\"><a href=\"#逆流时光\" class=\"headerlink\" title=\"逆流时光\"></a>逆流时光</h2><p>歌手：安图声乐队，第一次听这首歌的时候感觉没什么，第二次感觉还可以，就这样听了将近一百次。。</p>\n<ul>\n<li>后来听说你混的风声水起 可我还是喜欢那个与世无争的你</li>\n<li>如果我18岁， 我会喜欢这首歌。 好吧，其实我28岁也喜欢， 但是，我已经38岁了。 那又怎样，我48岁依旧爱这首歌。</li>\n<li>一般般吧，我也就单曲循环了2个小时就换歌了。</li>\n<li>愿你有高跟鞋也有跑鞋，喝茶也喝酒。愿你有勇敢的朋友，有牛逼的对手。愿你对过往的一切情深意重，但从不回头。愿你特别美丽，特别平静，特别凶狠，也特别温柔。</li>\n</ul>\n<h2 id=\"慢慢捱\"><a href=\"#慢慢捱\" class=\"headerlink\" title=\"慢慢捱\"></a>慢慢捱</h2><p>歌手：土不叔叔乐队/李柏凝，曲很简单，词也很简单，但是放在一起就不简单了</p>\n<ul>\n<li>带着当初跟朋友借的200块买了一张火车票孤身一人出门闯荡，当时立志士不成名誓不还，闯过北京，去过上海，到过深圳，从当初的200块到30万，再到200万，500万，800万，再到现在的1300万，我没有任何炫富的意思，我只是想告诉大家，手机像素越高拍的照片越清晰。</li>\n<li>网易诗人多如狗，可惜都没女朋友</li>\n<li>生来平庸，茅屋未破衣暖饭饱。打量比较，陷于名利未圆其梦。前方泥沼，后有余埃。微笑苦笑，未知几年几日，死于荒谬。</li>\n</ul>\n<h2 id=\"一个歌手的情书\"><a href=\"#一个歌手的情书\" class=\"headerlink\" title=\"一个歌手的情书\"></a>一个歌手的情书</h2><p>歌手：周三/蔡健雅，从《红色高跟鞋》认识蔡健雅，然后就反复地听她的歌了</p>\n<ul>\n<li>你不是赵雷的南方姑娘，不是马頔的傲寒，不是宋冬野的董小姐，不是李志的港岛妹妹，不是海龟的玛卡瑞纳，不是王威的她，不是贰佰的玫瑰，不是尧十三的北方女王，不是许巍的故乡，不是低苦艾的小花花，不是陈粒的祝星。不是周三情书里的那个心上人。你只是风尘中我恋恋不舍的姑娘。</li>\n<li>她说民谣太穷了，一听就是一根烟，一听就是一瓶酒。而我只有一根烟了，还要撑一夜，只剩一点爱了，还要过一生。</li>\n</ul>\n<h2 id=\"别有天\"><a href=\"#别有天\" class=\"headerlink\" title=\"别有天\"></a>别有天</h2><p>歌手：排骨教主，平常听古风类歌曲的话比较喜欢听排骨教主的，嗓音很特别</p>\n<ul>\n<li>你说，十里桃花，两人一马； 后来，谢了繁华，生死无话。 你说，修起篱笆，闲话桑麻； 后来，岁至月腊，空负韶华。 你说，对坐饮茶，共看晚霞； 后来，惨淡月牙，心思暗哑。 你说，不恋戎马，归田卸甲； 后来，倾覆天下，一夜白发。</li>\n<li>自古红尘多少人只欲寻仙问道超然去，却不知，总有仙人偶然窥见了人间华灯初上的光景，便甘愿从此坠入红尘中寻世间烟火、听市井俚歌，只为遇到一个萍水相逢的你。一场绮梦天涯，此生无悔。</li>\n<li>采桑子 欧阳修 画船载酒西湖好， 急管繁弦， 玉盏催传， 稳泛平波任醉眠。 行云却在行舟下， 空水澄鲜， 俯仰留连， 疑是湖中别有天。</li>\n</ul>\n<h2 id=\"你，好不好？\"><a href=\"#你，好不好？\" class=\"headerlink\" title=\"你，好不好？\"></a>你，好不好？</h2><p>歌手：周兴哲，电视剧《遗憾拼图》片尾图，相信很多人听到这首歌都会有很多感受</p>\n<ul>\n<li>有些异性不能拿来做恋人，却也舍不得给别人。</li>\n<li>想让你吃醋，又怕你祝我幸福。</li>\n<li>我戒烟了，没玩游戏了，每天不断的充实自己，我真的过的很好，你来看下我好不好</li>\n<li>牙疼 你的喜糖就不吃了 不胜酒力 你的喜酒就不喝了 健忘 特别健忘 你叫什么就不记了 ​​</li>\n<li>朋友之间，千万别谈爱情，要么一生，要么陌生。</li>\n</ul>\n<h2 id=\"ブルーバード\"><a href=\"#ブルーバード\" class=\"headerlink\" title=\"ブルーバード\"></a>ブルーバード</h2><p>每当听到这首歌的时候就想起了火影，就像某条评论“虽然不会日语，但这首歌我差不多可以唱完。”</p>\n<ul>\n<li>看火影那么多年，才知道。晓组织的十叛忍：佩恩，迪达拉，小南，鼬，绝，带土，鬼鲛，角都，飞段，蝎。代表了人类的十个梦想：和平，艺术，友情，亲情，统治，爱情，力量，金钱，宗教，童年。</li>\n<li>此生无悔入火影，来世愿生木叶村</li>\n<li>电影院里一个小孩问妈妈：“怎么这么多大人？大人也爱看动漫么？” 妈妈说“是看动漫的小孩都长大了”</li>\n<li>看了那么多年火影，才知道木叶三忍，自来也，纲手，大蛇丸分别代表黄，赌，毒。</li>\n<li>每次听到这歌，心中的火之意志在熊熊燃烧，尼玛我们村长太腐败了，劳资要推翻他，建立和平の村。</li>\n<li>整个火影故事里，有人相信血统，有人相信精神，有人相信身体，有人相信眼睛，有人相信先天传承，有人相信后天努力。只有大蛇丸，他相信科学。</li>\n</ul>\n<h2 id=\"生きていたんだよな\"><a href=\"#生きていたんだよな\" class=\"headerlink\" title=\"生きていたんだよな\"></a>生きていたんだよな</h2><p>歌名翻译成中文的意思是：她曾活过啊</p>\n<ul>\n<li>这是一首歌颂死亡的歌，无论一个人选择如何结束自己的生命，都不是未经历过死亡的我们可以靠着想象来自以为是地理解并指手画脚的，因为无论如何，她曾经活过啊。</li>\n<li>不知道是否安慰你，但是我突然想起我的语文老师对我开导的一句话“人生就像心电图，一帆风顺，就死了。”我仍然记得那时她说这句话时眼里闪烁的泪，以及她声音的颤，最忘不了的是她紧紧握住的，我的手。</li>\n<li>“有一天我忽然意识到：我自己是我一生中最后一个死去的人。”</li>\n<li>初一冬天得了抑郁， 割腕以后痛的心慌， 打了出租去医院， 捧着手狂哭， 司机后座被我弄的全都是血， 到了医院还带我去处理， 生意都不要了， 带着我去吃了一顿饭， 他一边哭一边说： “十来岁的小姑娘， 人生路还长， 千万别冲动， 千万别学我女儿。”</li>\n<li>齐奥朗认为自杀的念头是自然的、健康的，对存在的强烈渴望才是一种严重的缺陷。他甚至将自杀视为能保证人活下去的唯一想法，因为“自杀让我明白，我可以在我愿意的时候离开这个世界，这令生命变得可以承受，而不是毁掉它。”</li>\n<li>喜欢iPad你就去买，喜欢莱卡你就去赚，想喝港式奶茶你就过口岸，想当team leader你就努力学习然后努力去工作，想去威尼斯你就攒钱去，想爱谁你就去爱，想追谁你就去追，想到了就去做，拼命努力，拼命享受，忍着守着惦记着，青春就过去了，何必用40岁的心态过20岁的年华。</li>\n<li>小时候家里养过一只猫和一只狗 狗总是被猫欺负 不是狗憨厚 而是斗不过猫 比如猫藏在鞋盒偷袭狗 狗只能绕着鞋盒转圈 后来狗去世了 猫没看见它去世的样子 只是没见狗回来 半年过去了 有天我故意在门口喊了声狗的名字 猫从屋里飞奔到门口左右张望</li>\n<li>很多自杀的人最后一刻都是后悔的，证据是，90%跳楼而死的人，都伤在手部，肘部或者腿骨，因为在最后一刻他们采取了撑地的姿势，他们想活下去。有个朋友说，像香港女星陈宝莲就是这样的。但也有10%的例外，他们最后的姿势是仰躺，比如张国荣</li>\n</ul>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>很荣幸你能看到最后（或者你直接就翻到最后了。。），现在网易云音乐对于我而言已经不再是一款单纯的音乐软件了，而是一种信仰！所以，我的网易云音乐账户叫 <code>wangcongbug</code>，欢迎大家关注我~（我收藏了很多好听到爆的歌曲，希望你也能喜欢~）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_232.jpeg\" alt=\"\" width=\"300\"></div>\n\n<p>歌单里又有很多歌变灰了，在版权面前，情怀仿佛变得不堪一击，但是，我不会选择离开，你会吗？</p>\n","raw":null,"categories":[{"name":"summary","path":"api/categories/summary.json"}],"tags":[{"name":"life","path":"api/tags/life.json"},{"name":"网易云音乐","path":"api/tags/网易云音乐.json"}]},{"title":"机器学习概念入门","slug":"机器学习概念入门","date":"2017-11-02T14:23:08.000Z","updated":"2019-01-29T09:23:55.536Z","comments":true,"path":"api/articles/机器学习概念入门.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_287.png","content":"<p>最近在做毕设，需要用到一些机器学习的内容（不要问我为什么，做前端根本没办法毕业！），这篇文章是我看 bilibili 上<a href=\"https://www.bilibili.com/video/av12556478/\" target=\"_blank\" rel=\"noopener\">莫烦系列教程-Tensorflow教程</a>时候做的笔记，都是一些机器学习入门概念，如果你和我一样都是入门选手，我相信这些概念能够帮助到你~</p>\n<h2 id=\"什么是机器学习\"><a href=\"#什么是机器学习\" class=\"headerlink\" title=\"什么是机器学习\"></a>什么是机器学习</h2><p>机器学习是一帮计算机科学家想让计算机像人一样思考，所研发出来的计算机理论</p>\n<h2 id=\"机器学习分类\"><a href=\"#机器学习分类\" class=\"headerlink\" title=\"机器学习分类\"></a>机器学习分类</h2><h3 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h3><p>有数据和标签</p>\n<h3 id=\"非监督学习\"><a href=\"#非监督学习\" class=\"headerlink\" title=\"非监督学习\"></a>非监督学习</h3><p>只有数据，没有标签</p>\n<h3 id=\"半监督学习\"><a href=\"#半监督学习\" class=\"headerlink\" title=\"半监督学习\"></a>半监督学习</h3><p>结合了监督学习和非监督学习</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>从经验中总结提升</p>\n<h3 id=\"遗传算法\"><a href=\"#遗传算法\" class=\"headerlink\" title=\"遗传算法\"></a>遗传算法</h3><p>和强化学习类似，有着适者生存，不适者淘汰准则</p>\n<h2 id=\"什么是神经网络\"><a href=\"#什么是神经网络\" class=\"headerlink\" title=\"什么是神经网络\"></a>什么是神经网络</h2><p>神经网络是一种数学模型，是存在于计算机的神经系统，由大量的神经元相连接并进行计算，在外界信息的基础上，改变内部的结构，常用来对输入和输出间复杂的关系进行建模。</p>\n<p>神经网络由大量的节点和之间的联系构成，负责传递信息和加工信息，神经元也可以通过训练而被强化。</p>\n<h2 id=\"怎么检验神经网络\"><a href=\"#怎么检验神经网络\" class=\"headerlink\" title=\"怎么检验神经网络\"></a>怎么检验神经网络</h2><p>为了检验、评价神经网络，并努力改善这些问题，我们常会把收集到的数据分为<strong>训练数据</strong>和<strong>测试数据</strong>，一般用于训练的数据可以是全部数据的百分之 70，剩下的百分之 30 可以用来测试学习结果。接着，对于神经网络的评价，基本上基于这百分之 30 的测试结果。</p>\n<ul>\n<li>评价机器学习可以从误差这个值开始，随着训练时间的变长，优秀的神经网络能够预测到更精准的答案，预测的误差也会越小；</li>\n<li>除了误差曲线，我们也可以看它的精确度曲线，最好的精度是趋向于百分之百的精度；</li>\n<li>对于回归问题，我们可以采用 R2 score 作为评分标准；</li>\n<li>还有 F1 score 用来测量不均衡数据的精度。</li>\n</ul>\n<h2 id=\"什么叫过拟合\"><a href=\"#什么叫过拟合\" class=\"headerlink\" title=\"什么叫过拟合\"></a>什么叫过拟合</h2><p>如下图，训练时的误差比测试误差小，神经网络虽然学习到了知识，但是对于训练数据太过依赖，所以测试数据产生的误差会产生波谷，后面会变大。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_287.png\" alt=\"\" width=\"400\"></div>\n\n<p>在机器学习中，解决过拟合的方法也有很多，比如 <strong>L1，L2正规化</strong>和 <strong>Dropout方法</strong></p>\n<h2 id=\"什么是交叉验证\"><a href=\"#什么是交叉验证\" class=\"headerlink\" title=\"什么是交叉验证\"></a>什么是交叉验证</h2><p>交叉验证不仅可以用于神经网络的调参，还可以用于其他机器学习方法的调参，同样是选择你想观看的误差值或者精确度，不过横坐标不再是学习时间，而是你要测试的某一参数，比如说神经网络的层数。。</p>\n<h2 id=\"为什么要特征标准化\"><a href=\"#为什么要特征标准化\" class=\"headerlink\" title=\"为什么要特征标准化\"></a>为什么要特征标准化</h2><p>我们在机器学习训练之前, 先对数据预先处理一下, 取值跨度大的特征数据, 我们浓缩一下, 跨度小的括展一下, 使得他们的跨度尽量统一，这样可以<strong>提升学习效率</strong> 通常用于 特征标准化的途径有两种, 一种叫做 min max normalization, 他会将所有特征数据按比例缩放到 0-1 的这个取值区间. 有时也可以是 -1 到 1 的区间. 还有一种叫做 standard deviation normalization, 他会将所有特征数据缩放成平均值为 0, 方差为 1. 使用这些标准化手段. 我们不仅可以快速推进机器学习的学习速度, 还可以<strong>避免机器学习学得特扭曲</strong>.</p>\n<h2 id=\"区分好用的特征\"><a href=\"#区分好用的特征\" class=\"headerlink\" title=\"区分好用的特征\"></a>区分好用的特征</h2><p>在选择特征的时候,我们得要时刻回想起这三点.：</p>\n<ol>\n<li>避免无意义的信息</li>\n<li>避免重复性的信息</li>\n<li>避免复杂的信息</li>\n</ol>\n<p>这就是我们这次机器学习简介中所聊到的如何区分好用的特征</p>\n<h2 id=\"为什么需要激励函数\"><a href=\"#为什么需要激励函数\" class=\"headerlink\" title=\"为什么需要激励函数\"></a>为什么需要激励函数</h2><p>因为现实中的问题往往不是线性的，所以需要一个激励函数<strong>来扭曲原来的线性结果</strong> 你甚至可以创造自己的激励函数来处理自己的问题, 不过要确保的是这些激励函数必须是可以微分的, 因为在 backpropagation 误差反向传递的时候, 只有这些可微分的激励函数才能把误差传递回去. 在少量层结构中, 我们可以尝试很多种不同的激励函数. 在卷积神经网络 Convolutional neural networks 的卷积层中, 推荐的激励函数是 relu. 在循环神经网络中 recurrent neural networks, 推荐的是 tanh 或者是 relu</p>\n<h2 id=\"如何加速神经网络训练\"><a href=\"#如何加速神经网络训练\" class=\"headerlink\" title=\"如何加速神经网络训练\"></a>如何加速神经网络训练</h2><p>越复杂的神经网络，越多的数据，我们需要在训练神经网络的过程上花费的时间也就越多；原因很简单，就是因为计算量太大了。可是往往有时候为了解决复杂的问题, 复杂的结构和大数据又是不能避免的, 所以我们需要寻找一些方法, 让神经网络聪明起来, 快起来. 包括以下几种模式:</p>\n<ul>\n<li>Stochastic Gradient Descent (SGD)</li>\n<li>Momentum</li>\n<li>AdaGrad</li>\n<li>RMSProp</li>\n<li>Adam</li>\n</ul>\n<p>关于这几种方法的具体原理，可以<a href=\"https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-06-speed-up-learning/\" target=\"_blank\" rel=\"noopener\">点击这里</a>观看莫烦的讲解</p>\n<h2 id=\"如何处理不均衡数据\"><a href=\"#如何处理不均衡数据\" class=\"headerlink\" title=\"如何处理不均衡数据\"></a>如何处理不均衡数据</h2><p>不均衡的数据预测起来很简单. 永远都猜多的那一方面准没错. 没错, 机器也懂这个小伎俩. 所以机器学到最后, 学乖了, 每次都预测多数派. 解决的方法有几种, 我们来谈谈.</p>\n<h3 id=\"方法一：想办法获取更多数据\"><a href=\"#方法一：想办法获取更多数据\" class=\"headerlink\" title=\"方法一：想办法获取更多数据\"></a>方法一：想办法获取更多数据</h3><h3 id=\"方法二：更换评判方式\"><a href=\"#方法二：更换评判方式\" class=\"headerlink\" title=\"方法二：更换评判方式\"></a>方法二：更换评判方式</h3><p>通常, 我们会用到准确率 accuracy, 或者误差 cost 来判断机器学习的成果. 可是这些评判方法在不均衡数据面前, 高的准确率和低的误差变得没那么重要. 所以我们得换一种方式评判. 通过 confusion matrix 来计算 precision 和 recall, 然后通过 precision 和 recall 再计算f1 score.这种方式能成功地区分不均衡数据, 给出更好的评判分数.</p>\n<h3 id=\"方法三：重组数据\"><a href=\"#方法三：重组数据\" class=\"headerlink\" title=\"方法三：重组数据\"></a>方法三：重组数据</h3><p>这是最简单粗暴的方法之一，重新组合不均衡数据，使之均衡。有两种方式：</p>\n<ol>\n<li>复制或者合成少数部分的样本, 使之和多数部分差不多数量</li>\n<li>砍掉一些多数部分, 使两者数量差不多</li>\n</ol>\n<h3 id=\"方法四：使用其他机器学习方法\"><a href=\"#方法四：使用其他机器学习方法\" class=\"headerlink\" title=\"方法四：使用其他机器学习方法\"></a>方法四：使用其他机器学习方法</h3><p>如果使用的机器学习方法像神经网络等, 在面对不均衡数据时, 通常是束手无策. 不过有些机器学习方法, 像决策树, decision trees 就不会受到不均很数据的影响.</p>\n<h3 id=\"方法五：修改算法\"><a href=\"#方法五：修改算法\" class=\"headerlink\" title=\"方法五：修改算法\"></a>方法五：修改算法</h3><p>最后一种方法是让自己变得有创造力, 尝试修改算法. 如果你用的是 Sigmoid 的激励函数, activation function, 他会有一个<strong>预测门槛</strong>, 一般如果输出结果落在门槛的这一段,预测结果为梨, 如果落在这一段, 预测结果为苹果, 不过因为现在的梨是多数派, 我们得<strong>调整一下门槛的位置，</strong>使得门槛偏向苹果这边, 只有很自信的时候, 模型才会预测这是苹果. 让机器学习,学习到更好的效果.</p>\n<h2 id=\"什么是批标准化\"><a href=\"#什么是批标准化\" class=\"headerlink\" title=\"什么是批标准化\"></a>什么是批标准化</h2><p>和普通的数据标准化类似, 是将分散的数据统一的一种做法, 也是优化神经网络的一种方法. Batch normalization 的 batch 是批数据, <strong>把数据分成小批小批进行 stochastic gradient descent. 而且在每批数据进行前向传递 forward propagation 的时候, 对每一层都进行 normalization 的处理</strong> Batch normalization 也可以被看做一个层面. 在一层层的添加神经网络的时候, 我们先有数据 X, 再添加全连接层, 全连接层的计算结果会经过 激励函数 成为下一层的输入, 接着重复之前的操作. Batch Normalization (BN) 就被添加在每一个全连接和激励函数之间。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/e112012a4b2d\" target=\"_blank\" rel=\"noopener\">一文学会用 Tensorflow 搭建神经网络</a></li>\n</ul>\n","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"机器学习","path":"api/tags/机器学习.json"}]},{"title":"我为什么要写个人博客","slug":"我为什么要写个人博客","date":"2017-10-17T07:51:33.000Z","updated":"2019-01-29T09:23:55.536Z","comments":true,"path":"api/articles/我为什么要写个人博客.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>之前看到了一篇文章：<a href=\"http://www.cnblogs.com/zery/p/3343893.html\" target=\"_blank\" rel=\"noopener\">做为技术人员为什么要写博客</a>，作者写的很真诚，也说出了很多技术人员的心声，然后，我后来又看到了一篇文章：<a href=\"http://blog.jobbole.com/18251/\" target=\"_blank\" rel=\"noopener\">为什么有些技术人员不写博客？</a>，这篇文章篇幅较短，虽然看题目好像是一篇介绍“不写博客”的，但是看完之后才发现，其实作者还是推荐大家写博客。。作为众多拥有个人博客的技术人员之一，我也斗胆谈一下我为什么要写个人博客？</p>\n<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>其实我从小学开始就喜欢收藏和总结，记得小学的时候流行那种或圆形或方形的卡片，我就收藏了很多；然后初中之后就收藏烟盒（这个习惯到目前还有）；后来到大学之后，和计算机打交道比较多，就将一些好用的软件和工具记录下来；研究生期间开始做前端，看到写的好的技术类文章就保存到有道云笔记里，虽然有些可能一直放在里面后来再也没看过。。 所以，其实总结和个人习惯是密切关联的，这也是我写博客的初衷。</p>\n<h2 id=\"导火线\"><a href=\"#导火线\" class=\"headerlink\" title=\"导火线\"></a>导火线</h2><p>虽然写博客的想法很早之前就有，但是就像上面那两篇文章里说的，那时候觉得自己水平有限，就算写出来恐怕也是哗众取宠，无人问津罢了，同时也不知道是去某个平台写还是自己搭建一个网站，这件事情就暂时搁置了；后来到研二的时候，需要找实习了，而前端知识繁杂，找实习之前脑子里还一头雾水，就打算趁着这个机会把当初那个小愿望实现了吧。。 淫僧就是如此的奇妙，找实习就成为了我写博客的导火线。</p>\n<h2 id=\"wordpress？\"><a href=\"#wordpress？\" class=\"headerlink\" title=\"wordpress？\"></a>wordpress？</h2><p>其实，目前有很多现成的博客平台，我在写博客之前也了解了一些，而最终没有选择大平台的原因是：</p>\n<ul>\n<li><strong>被动</strong>：虽然有很多博客平台，但是也有一些平台都已经死气沉沉半死不活了，所以不能确保现在你选择的某个平台能否一直活下去，如果突然某一天，你选择的某个平台停止维护了而又没办法导出数据的话，那简直就是“叫天天不应，叫地地不灵”了</li>\n<li><strong>不安全</strong>：虽然我们现在已经身处一个“没有隐私”的世界，但是这种意识还是要有的，而如果选择平台的话，你发的文章都会存储在别人的数据库中，同时你的一些行为也会被记录下来，不得不说，这确实是不安全的</li>\n<li><strong>缺乏灵活性</strong>：其实我是喜欢定制化的东西的，而平台的话会受到许许多多的制约，比如你想添加某个插件或者改变网站的背景颜色，估计是做不到的</li>\n</ul>\n<p>所以基于以上原因，我最终选择自己搭建博客，而选择 wordpress 的原因很简单，毕竟 wordpress 在业界已经拥有统治地位了，值得信赖。</p>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h2><p>前面可能对你的作用不是很大，那么下面我就说一下在个人博客这件事情上我的建议，如果能够对你所有帮助是再好不过的了：</p>\n<ol>\n<li><strong>通过平台搭建或者个人搭建各有利弊，一定要考虑清楚</strong>；上面我已经介绍了平台搭建的弊端，而个人搭建的话相对来说会更麻烦，需要你对服务器、域名等知识也有所了解，会有一定的学习成本，同时日常的维护也会比现成平台繁琐</li>\n<li><strong>写博客贵在坚持</strong>；如果你写过技术类博客的话，你肯定会有所感触：写一篇文章往往需要几个小时甚至几天的时间，你需要阅读大量相关资料，同时还有可能需要写domo、敲代码，这无疑会占用你大量的业余时间，在写博客之前要有心理准备</li>\n<li><strong>心态放平稳</strong>；对于每一个博客作者而言，如果自己写的东西受到更多人关注那肯定是一件好事，而其实大部分人写的文章是很少有人看到的，这种现象的造成会有很多原因，有个人的原因（文章质量、SEO等），也有外界的原因（墙、技术迭代很快）；但是“事在人为”，一定要放平心态，即使现在访问量/阅读量很少，相信坚持下去你肯定会收货很多读者</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>说了这么多，总结成一句话就是： <strong>有些事情你现在不去做，可能以后都不会有机会了！</strong></p>\n","raw":null,"categories":[{"name":"talk","path":"api/categories/talk.json"}],"tags":[{"name":"life","path":"api/tags/life.json"}]},{"title":"杂谈系列","slug":"杂谈系列","date":"2017-10-17T06:02:51.000Z","updated":"2019-01-29T09:23:55.536Z","comments":true,"path":"api/articles/杂谈系列.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这个系列的文章大多数都是我的所想所感，大部分和技术关联不大，或感概或吐槽或叙述，反正就是想到什么就会写点什么，毕竟博客的意义就在于此嘛。。当然，因为平时喜欢看一些东西，发现了一些不错的文章/视频，参见<a href=\"/20170807/good-article-recommendation.html\">他山之石，可以攻玉，好文章推荐</a>和<a href=\"/20171007/recommend-some-videos.html\">推荐一些视频</a>。以下文章按照发布时间倒叙排列：</p>\n<ul>\n<li><a href=\"/20190101/goodbye-2018.html\">再见，2018</a></li>\n<li><a href=\"/20180922/cat-strategy.html\">铲屎官，这里有一份属于你的空投</a></li>\n<li><a href=\"/20171231/goodbye-2017.html\">再见，2017</a></li>\n<li><a href=\"/20171017/why-i-write-blog.html\">我为什么要写个人博客</a></li>\n<li><a href=\"/20170906/beautiful-poetry.html\">不想当诗人的程序员不是好工程师</a></li>\n<li><a href=\"/20170820/it-nouns.html\">身在IT界，不能不知道这些名词</a></li>\n<li><a href=\"/20170801/there-is-always-a-sentence.html\">总有那么一句话……</a></li>\n<li><a href=\"/20170403/to-just-touched-the-front-end.html\">写给刚接触前端的你</a></li>\n</ul>\n","raw":null,"categories":[{"name":"series","path":"api/categories/series.json"}],"tags":[{"name":"life","path":"api/tags/life.json"}]},{"title":"读书笔记系列（9）——你不知道的JavaScript（上卷）","slug":"读书笔记系列（9）——你不知道的JavaScript（上卷）","date":"2017-10-10T11:42:12.000Z","updated":"2019-01-29T09:23:55.540Z","comments":true,"path":"api/articles/读书笔记系列（9）——你不知道的JavaScript（上卷）.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这本书在 github 上很火，而中文译本迟迟没有发行，最近出了中卷，我很早之前就听说了该大作，然而一直没有时间拜读，现在实习告一段落了，终于可以静下心来品味经典了。</p>\n<h2 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h2><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p>\n<h3 id=\"分词-词法分析\"><a href=\"#分词-词法分析\" class=\"headerlink\" title=\"分词/词法分析\"></a>分词/词法分析</h3><p>将字符串分解成有意义的代码块，这些代码块被称为词法单元（token），例如：<code>var a = 2;</code>，会被分解为下面这些词法单元：var、a、=、2、；</p>\n<h3 id=\"解析-语法分析\"><a href=\"#解析-语法分析\" class=\"headerlink\" title=\"解析/语法分析\"></a>解析/语法分析</h3><p>将语法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，被称为“抽象语法树”（AST）。<code>var a = 2;</code> 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier (它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。</p>\n<h3 id=\"代码生成\"><a href=\"#代码生成\" class=\"headerlink\" title=\"代码生成\"></a>代码生成</h3><p>将 AST 转换为可执行代码。简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。 然而，比起那些编译过程只有三个步骤的语言的编译器，<strong>JavaScript 引擎要复杂得多</strong>。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。</p>\n<p>对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内。</p>\n<h3 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h3><p>首先介绍将要参与到对程序 <code>var a = 2;</code> 进行处理的过程中的演员们。</p>\n<h4 id=\"引擎\"><a href=\"#引擎\" class=\"headerlink\" title=\"引擎\"></a>引擎</h4><p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p>\n<h4 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h4><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>\n<h3 id=\"变量的赋值操作\"><a href=\"#变量的赋值操作\" class=\"headerlink\" title=\"变量的赋值操作\"></a>变量的赋值操作</h3><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。（我们在面试时会经常遇到变量为undefined的问题，其实就是这个道理）</p>\n<h4 id=\"编译器有话说\"><a href=\"#编译器有话说\" class=\"headerlink\" title=\"编译器有话说\"></a>编译器有话说</h4><p>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。</p>\n<p>讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</p>\n<h4 id=\"引擎和作用域的对话\"><a href=\"#引擎和作用域的对话\" class=\"headerlink\" title=\"引擎和作用域的对话\"></a>引擎和作用域的对话</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123; <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">2</span> );</span><br></pre></td></tr></table></figure>\n<p>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。</p>\n<blockquote>\n<p>引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?<br>作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎:哥们太够意思了!好吧，我来执行一下 foo。<br>引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?<br>作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。<br>引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。<br>引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?<br>作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。<br>引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。<br>引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。<br>作用域:放心吧，这个变量没有变动过，拿走，不谢。 引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。 ……</p>\n</blockquote>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 <code>var a = 2</code> 这样的声明会被分解成两个独立的步骤:</p>\n<ol>\n<li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>\n<li>接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li>\n</ol>\n<p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，但是如果对结果的操作是非法或不合理的，会抛出 TypeError 异常，或者直接抛出 ReferenceError 异常(严格模式下)。</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><h3 id=\"变量查找\"><a href=\"#变量查找\" class=\"headerlink\" title=\"变量查找\"></a>变量查找</h3><p>全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。 window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。</p>\n<p><strong>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</strong></p>\n<h3 id=\"欺骗词法\"><a href=\"#欺骗词法\" class=\"headerlink\" title=\"欺骗词法\"></a>欺骗词法</h3><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”(也可以说欺骗)词法作用域呢? JavaScript 中有两种机制来实现这个目的。</p>\n<ol>\n<li>eval</li>\n<li>with</li>\n</ol>\n<p>欺骗词法作用域会导致性能下降。</p>\n<h4 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h4><p>在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p>\n<p>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>; </span><br><span class=\"line\">    <span class=\"built_in\">eval</span>( str ); </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// ReferenceError: a is not defined </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">foo( <span class=\"string\">\"var a = 2\"</span> );</span><br></pre></td></tr></table></figure>\n<p>JavaScript 中还有其他一些功能效果和 <code>eval(..)</code> 很 相 似。setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们! new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。</p>\n<h4 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h4><p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。with 的副作用通过一个简单的例子就可以看到：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">2</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; </span><br><span class=\"line\">    b: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo( o1 );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( o1.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo( o2 );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( o2.a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2——不好，a 被泄漏到全局作用域上了!</span></span><br></pre></td></tr></table></figure>\n<p>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此<strong>这个对象的属性也会被处理为定义在这个作用域中的词法标识符</strong>。</p>\n<p>结合上面的例子，o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a=2 执行时，<strong>自动创建了一个全局变量</strong>(因为是非严格模式)。</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p>\n<h2 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h2><h3 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h3><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。</p>\n<h3 id=\"全局命名空间\"><a href=\"#全局命名空间\" class=\"headerlink\" title=\"全局命名空间\"></a>全局命名空间</h3><p>某些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyReallyCoolLibrary = &#123; </span><br><span class=\"line\">    awesome: <span class=\"string\">\"stuff\"</span>, </span><br><span class=\"line\">    doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    doAnotherThing: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"匿名和具名\"><a href=\"#匿名和具名\" class=\"headerlink\" title=\"匿名和具名\"></a>匿名和具名</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I waited 1 second!\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</p>\n<h3 id=\"然而，匿名函数也有几个缺点：\"><a href=\"#然而，匿名函数也有几个缺点：\" class=\"headerlink\" title=\"然而，匿名函数也有几个缺点：\"></a>然而，匿名函数也有几个缺点：</h3><ol>\n<li>匿名函数在栈追踪中不会显示出有意义的函数名，使得<strong>调试很困难</strong>。</li>\n<li>如果没有函数名，当函数需要引用自身时只能使用已经过期的<strong>arguments.callee</strong>引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li>\n<li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。<strong>一个描述性的名称可以让代码不言自明</strong>。</li>\n</ol>\n<p>综合考虑而言，始终给函数表达式命名是一个最佳实践（下面的例子叫做行内函数表达式）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeoutHandler</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// &lt;-- 快看，我有名字了! </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"I waited 1 second!\"</span> );</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<h3 id=\"立即执行函数表达式\"><a href=\"#立即执行函数表达式\" class=\"headerlink\" title=\"立即执行函数表达式\"></a>立即执行函数表达式</h3><p>立即执行函数表达式（IIFE）有两种形式：</p>\n<ol>\n<li>(function foo(){ .. })()</li>\n<li>(function foo(){ .. }())</li>\n</ol>\n<p>这两种形式在功能上是一致的，<strong>选择哪个全凭个人喜好</strong>。</p>\n<h3 id=\"IIFE的用途\"><a href=\"#IIFE的用途\" class=\"headerlink\" title=\"IIFE的用途\"></a>IIFE的用途</h3><h4 id=\"把它们当做函数调用并传递参数进去：\"><a href=\"#把它们当做函数调用并传递参数进去：\" class=\"headerlink\" title=\"把它们当做函数调用并传递参数进去：\"></a>把它们当做函数调用并传递参数进去：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)( <span class=\"built_in\">window</span> );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"解决-undefined-标识符的默认值被错误覆盖导致的异常-虽然不常见\"><a href=\"#解决-undefined-标识符的默认值被错误覆盖导致的异常-虽然不常见\" class=\"headerlink\" title=\"解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)\"></a>解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)</h4><p>将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 给其他代码挖了一个大坑!绝对不要这样做! </span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> undefined </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"string\">\"Undefined is safe here!\"</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\"><a href=\"#倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\" class=\"headerlink\" title=\"倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\"></a>倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>) </span>&#123; </span><br><span class=\"line\">    def( <span class=\"built_in\">window</span> );</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。</p>\n<h3 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h3><p>块作用域的例子：</p>\n<h4 id=\"with-1\"><a href=\"#with-1\" class=\"headerlink\" title=\"with\"></a>with</h4><p>with就是块作用域的一个例子（形式），用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效</p>\n<h4 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try/catch\"></a>try/catch</h4><p>try/catch 是 ES3 的规范，而很少有人注意到，<strong>catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效</strong></p>\n<blockquote>\n<p>尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境(除了老 版本的 IE 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。</p>\n</blockquote>\n<h4 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h4><p>ES6 引入的 let 关键字可以将变量绑定到所在的任意作用域中(通常是{ .. }内部)。换句话说，let 为其声明的变量隐式地了所在的块作用域。 但是，let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError! </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h4><p>ES6 还引入了 const，同样可以用来创建块作用域变量，但是其值是固定的</p>\n<h3 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h3><h4 id=\"先有鸡还是先有蛋\"><a href=\"#先有鸡还是先有蛋\" class=\"headerlink\" title=\"先有鸡还是先有蛋\"></a>先有鸡还是先有蛋</h4><p>首先，抛出两个例子，也是很经典的JS的“坑”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>关于这一奇怪现象，可以用一句话概括：<strong>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理</strong> 当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个——声明:var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。 换句话说，<strong>先有蛋（声明）后又鸡（赋值）</strong>；所以上面的两个例子会以如下形式进行处理： 例子一：（第一部分是编译，第二部分是执行）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">a = <span class=\"number\">2</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>例子二：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 不是 ReferenceError, 而是 TypeError!</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域(在这里是全局作用域)，因此foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式，那么就会赋值)。<strong>foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常</strong>。</p>\n<p>从上面的例子，我们还可以得出：<strong>函数声明会被提升，但是函数表达式不会被提升</strong></p>\n<h3 id=\"函数优先\"><a href=\"#函数优先\" class=\"headerlink\" title=\"函数优先\"></a>函数优先</h3><p>函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。考虑下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子会被引擎理解为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>从这两段代码我们可以得出两个结论：</p>\n<ol>\n<li>var foo 尽管出现在 function foo()…的声明之前，但它是重复的声明(因此<strong>被忽略</strong>了)，因为函数声明会被提升到普通变量之前。</li>\n<li>尽管重复的 var 声明会被忽略掉，但<strong>出现在后面的函数声明还是可以覆盖前面的</strong>。</li>\n</ol>\n<h2 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h2><h3 id=\"老生常谈，闭包是什么\"><a href=\"#老生常谈，闭包是什么\" class=\"headerlink\" title=\"老生常谈，闭包是什么\"></a>老生常谈，闭包是什么</h3><p>划重点：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 这一部分之前已经讲了很多次了，感觉这本书也没有很多新意，所以想了解闭包的童鞋可以参见我的另一篇文章：<a href=\"/20170405/closure-in-js.html\">前端面试系列（10）——JS中的闭包</a></p>\n<h3 id=\"不太显性的闭包\"><a href=\"#不太显性的闭包\" class=\"headerlink\" title=\"不太显性的闭包\"></a>不太显性的闭包</h3><p>其实，你已经写过的代码中一定到处都是闭包的身影。</p>\n<h4 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait(<span class=\"string\">\"Hello, closure!\"</span>);</span><br></pre></td></tr></table></figure>\n<p>将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域 的闭包，因此还保有对变量 message 的引用。wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，<strong>timer 函数依然保有 wait(..) 作用域的闭包</strong>。</p>\n<h4 id=\"jQuery-或其他-JS-框架\"><a href=\"#jQuery-或其他-JS-框架\" class=\"headerlink\" title=\"jQuery 或其他 JS 框架\"></a>jQuery 或其他 JS 框架</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setupBot</span>(<span class=\"params\">name, selector</span>) </span>&#123;</span><br><span class=\"line\">    $( selector ).click( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">activator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"string\">\"Activating: \"</span> + name ); </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setupBot( <span class=\"string\">\"Closure Bot 1\"</span>, <span class=\"string\">\"#bot_1\"</span> );</span><br><span class=\"line\">setupBot( <span class=\"string\">\"Closure Bot 2\"</span>, <span class=\"string\">\"#bot_2\"</span> );</span><br></pre></td></tr></table></figure>\n<p>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包!</p>\n<h4 id=\"IIFE\"><a href=\"#IIFE\" class=\"headerlink\" title=\"IIFE\"></a>IIFE</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么?因为函数(示例代码中的 IIFE)并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行(而外部作用域，也就是全局作用域也持有 a)。a 是通过普通的词法作用域查找而非闭包被发现的。 尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。</p>\n<h3 id=\"块作用域和闭包\"><a href=\"#块作用域和闭包\" class=\"headerlink\" title=\"块作用域和闭包\"></a>块作用域和闭包</h3><p>一道很经典的面试题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码在运行时会以每秒一次的频率输出五次 6，具体原因就不再赘述了。。而如果我们想让他连续输出1 2 3 4 5应该怎么办呢？有两种方法:</p>\n<h4 id=\"利用闭包\"><a href=\"#利用闭包\" class=\"headerlink\" title=\"利用闭包\"></a>利用闭包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">        &#125;, j*<span class=\"number\">1000</span> ); </span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"闭包-块作用域\"><a href=\"#闭包-块作用域\" class=\"headerlink\" title=\"闭包+块作用域\"></a>闭包+块作用域</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><h4 id=\"模块有两个主要特征：\"><a href=\"#模块有两个主要特征：\" class=\"headerlink\" title=\"模块有两个主要特征：\"></a>模块有两个主要特征：</h4><ol>\n<li>为创建内部作用域而调用了一个包装函数;</li>\n<li>包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>\n</ol>\n<p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览器或引擎有一个默认的“模块加载器”(可以被重载，但这远超出了我们的讨论范围)可以在导入模块时异步地加载模块文件。 模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。</p>\n<h4 id=\"动态作用域与词法作用域\"><a href=\"#动态作用域与词法作用域\" class=\"headerlink\" title=\"动态作用域与词法作用域\"></a>动态作用域与词法作用域</h4><p>下面一段代码很有意思：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2(不是3!)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    foo(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara=<span class=\"number\">2</span>;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>如果 JS 是动态作用域，上面将会输出 3，因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。 需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>\n<h2 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h2><h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>有两种常见的对于this的解释，但是它们都是错误的：</p>\n<h4 id=\"指向自身\"><a href=\"#指向自身\" class=\"headerlink\" title=\"指向自身\"></a>指向自身</h4><p>人们很容易把 this 理解成指向函数自身，然而如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符(变量)来引用它。 思考一下下面这两个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.count = <span class=\"number\">4</span>; <span class=\"comment\">// foo 指向它自身</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匿名(没有名字的)函数无法指向自身</span></span><br><span class=\"line\">&#125;,<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p>第一个函数被称为具名函数，在它内部可以使用 foo 来引用自身。 但是在第二个例子中，传入 setTimeout(..) 的回调函数没有名称标识符(这种函数被称为匿名函数)，因此无法从函数内部引用自身。</p>\n<h4 id=\"它的作用域\"><a href=\"#它的作用域\" class=\"headerlink\" title=\"它的作用域\"></a>它的作用域</h4><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。 <strong>每当你想要把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</strong></p>\n<h3 id=\"this到底是什么\"><a href=\"#this到底是什么\" class=\"headerlink\" title=\"this到底是什么\"></a>this到底是什么</h3><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</strong> 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>\n<h2 id=\"this全面解析\"><a href=\"#this全面解析\" class=\"headerlink\" title=\"this全面解析\"></a>this全面解析</h2><h3 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h3><p>在理解 this 的绑定过程之前，首先要理解调用位置：<strong>调用位置就是函数在代码中被调用的位置(而不是声明的位置)</strong>；然而做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。 下面通过一个例子来看看到底什么是调用栈和调用位置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是:baz</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置是全局作用域</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"baz\"</span> );</span><br><span class=\"line\">    bar(); <span class=\"comment\">// &lt;-- bar 的调用位置 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是 baz -&gt; bar</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置在 baz 中</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\">    foo(); <span class=\"comment\">// &lt;-- foo 的调用位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置在 bar 中</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">baz(); <span class=\"comment\">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p>\n<h4 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>this.a 被解析成了全局变量 a。为什么?因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此<strong>this会绑定到 undefined</strong> 这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是<strong>只有foo()运行在非strict mode下时，默认绑定才能绑定到全局对象；严格模式下与foo() 的调用位置无关：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>;</span><br><span class=\"line\">    foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>调用位置会使用 obj 上下文来引用函数</strong>，因此你可以说<strong>函数foo被调用时 obj 对象“拥有”或者“包含”它</strong>。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">42</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    obj2: obj2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj1.obj2.foo(); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h4><p>可以使用函数的 call(..) 和 apply(..) 方法。这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现在其他的参数上，但是现在我们不用考虑这些。 <strong>硬绑定</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.call( obj );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">setTimeout( bar, <span class=\"number\">100</span> ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 硬绑定的 bar 不可能再修改它的 this</span></span><br><span class=\"line\">bar.call( <span class=\"built_in\">window</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>无论我们如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype. bind，它的用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">3</span>);<span class=\"comment\">//23</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p>\n<h4 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h4><p>JS 中 new 的机制和面向类的语言完全不同：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>\n<ol>\n<li>创建(或者说构造)一个全新的对象。</li>\n<li>这个新对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>一个简单的例子来解释 new 绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar.a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。</strong></p>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><p>（原书中通过很多例子得到了上面四种绑定方式的优先级，这里就不再赘述了。。） 我们可以按照下面的顺序来进行判断：</p>\n<ol>\n<li>函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。 var bar = new foo()</li>\n<li>函数是否通过 call、apply(显式绑定)或者硬绑定调用?如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2)</li>\n<li>函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo()</li>\n<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo()</li>\n</ol>\n<p>然而，凡事总有例外。</p>\n<h4 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a>绑定例外</h4><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用的可能是默认绑定规则。</p>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara=<span class=\"number\">2</span>;</span><br><span class=\"line\">foo.call( <span class=\"literal\">null</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>一般，如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择。 然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。 划重点：<strong>Object.create(null)和{}很像，但是并不会创建Object.prototype 这个委托，所以它比 {}“更空”</strong></p>\n<h4 id=\"间接引用\"><a href=\"#间接引用\" class=\"headerlink\" title=\"间接引用\"></a>间接引用</h4><p>你有可能(有意或者无意地)创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。而间接引用最容易在赋值时发生：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>:<span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>:<span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此<strong>调用位置是 foo() 而不是 p.foo() 或者 o.foo()</strong>。根据我们之前说过的，这里会应用默认绑定。</p>\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><p>硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。 下面是一种被称为软绑定的方法，有时间的话可以研究一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Function</span>.prototype.softBind) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.softBind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 捕获所有 curried 参数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = \\[\\].slice.call( <span class=\"built_in\">arguments</span>, <span class=\"number\">1</span> );</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(</span><br><span class=\"line\">                (!<span class=\"keyword\">this</span> || <span class=\"keyword\">this</span> === (<span class=\"built_in\">window</span> || global)) ?</span><br><span class=\"line\">                    obj : <span class=\"keyword\">this</span></span><br><span class=\"line\">                curried.concat.apply( curried, <span class=\"built_in\">arguments</span> )</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = <span class=\"built_in\">Object</span>.create( fn.prototype );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this语法\"><a href=\"#this语法\" class=\"headerlink\" title=\"this语法\"></a>this语法</h3><p>ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定义的。<strong>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//this 继承自 foo()</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2, 不是3!</span></span><br></pre></td></tr></table></figure>\n<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不 行!)</p>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>对象可以通过两种形式定义:声明(文字)形式和构造形式。</p>\n<h4 id=\"文字形式（对象字面量）\"><a href=\"#文字形式（对象字面量）\" class=\"headerlink\" title=\"文字形式（对象字面量）\"></a>文字形式（对象字面量）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    key: value</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"构造形式\"><a href=\"#构造形式\" class=\"headerlink\" title=\"构造形式\"></a>构造形式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">myObj.key = value;</span><br></pre></td></tr></table></figure>\n<p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键值对，但是在构造形式中你必须逐个添加属性。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>在 JavaScrip t中一共有六种主要类型（语言类型）：</p>\n<ul>\n<li>string</li>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>object</li>\n</ul>\n<p>简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。 null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 “object”。实际上，<strong>null 本身是基本类型</strong>。</p>\n<blockquote>\n<p>原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。</p>\n</blockquote>\n<h3 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h3><p>JavaScript 中还有一些对象子类型，通常被称为内置对象。</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n</ul>\n<h3 id=\"自动转换\"><a href=\"#自动转换\" class=\"headerlink\" title=\"自动转换\"></a>自动转换</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strPrimitive = <span class=\"string\">\"I am a string\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( strPrimitive.length ); <span class=\"comment\">// 13</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( strPrimitive.charAt( <span class=\"number\">3</span> ) ); <span class=\"comment\">// \"m\"</span></span><br></pre></td></tr></table></figure>\n<p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为<strong>引擎自动把字面量转换成 String 对象</strong>，所以可以访问属性和方法。同样的事也会发生在数值字面量上 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式（只能通过 new Date() 创建一个 Date 对象）。</p>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"a\"</span>\\]; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>.a 语法通常被称为“<strong>属性访问</strong>”，[“a”] 语法通常被称为“<strong>键访问</strong>”。这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject\\[<span class=\"literal\">true</span>\\] = <span class=\"string\">\"foo\"</span>;</span><br><span class=\"line\">myObject\\[<span class=\"number\">3</span>\\] = <span class=\"string\">\"bar\"</span>;</span><br><span class=\"line\">myObject\\[myObject\\] = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"true\"</span>\\]; <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"3\"</span>\\]; <span class=\"comment\">// \"bar\"</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"\\[object Object\\]\"</span>\\]; <span class=\"comment\">// \"baz\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = \\[ <span class=\"string\">\"foo\"</span>, <span class=\"number\">42</span>, <span class=\"string\">\"bar\"</span> \\];</span><br><span class=\"line\">myArray.baz = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\">myArray.length; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myArray.baz; <span class=\"comment\">// \"baz\"</span></span><br></pre></td></tr></table></figure>\n<p>可以看到虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，<strong>数组的 length 值并未发生变化</strong>。但是，如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标(因此会修改数组的内容而不是添加一个属性)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = \\[ <span class=\"string\">\"foo\"</span>, <span class=\"number\">42</span>, <span class=\"string\">\"bar\"</span> \\];</span><br><span class=\"line\">myArray\\[<span class=\"string\">\"4\"</span>\\] = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\">myArray.length; <span class=\"comment\">// 5</span></span><br><span class=\"line\">myArray\\[<span class=\"number\">4</span>\\]; <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\">myArray\\[<span class=\"number\">3</span>\\]; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h3><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"a\"</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"number\">2</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h3><p>有时候你会希望属性或者对象是不可改变(无论有意还是无意)的，在 ES5 中可以通过很多种方法来实现：</p>\n<h4 id=\"对象常量\"><a href=\"#对象常量\" class=\"headerlink\" title=\"对象常量\"></a>对象常量</h4><p>结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性(不可修改、重定义或者删除):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"FAVORITE_NUMBER\"</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"number\">42</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"禁止扩展\"><a href=\"#禁止扩展\" class=\"headerlink\" title=\"禁止扩展\"></a>禁止扩展</h4><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions( myObject );</span><br><span class=\"line\">myObject.b = <span class=\"number\">3</span>;</span><br><span class=\"line\">myObject.b; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"密封\"><a href=\"#密封\" class=\"headerlink\" title=\"密封\"></a>密封</h4><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable: false。 所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。</p>\n<h4 id=\"冻结\"><a href=\"#冻结\" class=\"headerlink\" title=\"冻结\"></a>冻结</h4><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable: false，这样就无法修改它们的值。 <strong>这个方法是你可以应用在对象上的级别最高的不可变性</strong>，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。</p>\n<h4 id=\"数组上不要用for-in循环\"><a href=\"#数组上不要用for-in循环\" class=\"headerlink\" title=\"数组上不要用for..in循环\"></a>数组上不要用for..in循环</h4><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><h4 id=\"ES5中增加了一些数组的辅助迭代器：\"><a href=\"#ES5中增加了一些数组的辅助迭代器：\" class=\"headerlink\" title=\"ES5中增加了一些数组的辅助迭代器：\"></a>ES5中增加了一些数组的辅助迭代器：</h4><ol>\n<li>forEach(..)：遍历数组中的所有值并忽略回调函数的返回值</li>\n<li>every(..)：会一直运行直到回调函数返回 false</li>\n<li>some(..)：会一直运行直到回调函数返回 true</li>\n</ol>\n<h2 id=\"混合对象“类”\"><a href=\"#混合对象“类”\" class=\"headerlink\" title=\"混合对象“类”\"></a>混合对象“类”</h2><h3 id=\"类的机制\"><a href=\"#类的机制\" class=\"headerlink\" title=\"类的机制\"></a>类的机制</h3><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息(状态)。 类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。</p>\n<h4 id=\"JS中的类\"><a href=\"#JS中的类\" class=\"headerlink\" title=\"JS中的类\"></a>JS中的类</h4><p>在传统的面向类的语言中 super 有一个功能，就是<strong>从子类的构造函数中通过 super 可以直接调用父类的构造函数</strong>。通常来说这没什么问题，因为对于真正的类来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——<strong>实际上“类”是属于构造函数的</strong>(类似 Foo.prototype… 这样的类型引用)。由于<strong>JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中</strong>，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用</p>\n<blockquote>\n<p>注: 其实这一部分还蛮重要的，而原文也通过比较大量的篇幅对JS中的“类”进行了介绍，只不过我感觉没有什么与众不同之处就略过了，对这一部分还不太熟悉的童鞋可以自己研究一下。。</p>\n</blockquote>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"Prototype\"><a href=\"#Prototype\" class=\"headerlink\" title=\"[[Prototype]]\"></a>[[Prototype]]</h3><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。 而[[Prototype]]的作用是：对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个关联到 anotherObject 的对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到(并且是 enumerable)的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链(无论属性是否可枚举)</p>\n<h3 id=\"Object-prototype\"><a href=\"#Object-prototype\" class=\"headerlink\" title=\"Object.prototype\"></a>Object.prototype</h3><p><strong>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype</strong>。由于所有的“普通”(内置，不是特定主机的扩展)对象都“源于”(或者说把 [[Prototype]] 链的顶端设置为)这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。</p>\n<h3 id=\"属性屏蔽\"><a href=\"#属性屏蔽\" class=\"headerlink\" title=\"属性屏蔽\"></a>属性屏蔽</h3><p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为<strong>myObject.foo 总是会选择原型链中最底层的 foo 属性</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a++; <span class=\"comment\">// 隐式屏蔽!</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>尽管 myObject.a++ 看起来应该(通过委托)查找并增加 anotherObject.a 属性，但是别忘了<strong>++操作相当于myObject.a = myObject.a + 1</strong>。因此++操作首先会通过[[Prototype]]查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐!</p>\n<h3 id=\"“类”\"><a href=\"#“类”\" class=\"headerlink\" title=\"“类”\"></a>“类”</h3><h4 id=\"“类”函数\"><a href=\"#“类”函数\" class=\"headerlink\" title=\"“类”函数\"></a>“类”函数</h4><p>所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype; <span class=\"comment\">// &#123; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这个对象通常被称为 Foo 的原型，然而，如果是我的话就 会叫它“之前被称为 Foo 的原型的那个对象”。好吧我是开玩笑的，你觉得“<strong>被贴上‘Foo 点 prototype’标签的对象</strong>”这个名字怎么样？最直接的解释就是，这个对象是在调用new Foo()时创建的，最后会被(有点武断地)关联到这个“Foo 点 prototype”对象上。</p>\n<h4 id=\"继承与原型\"><a href=\"#继承与原型\" class=\"headerlink\" title=\"继承与原型\"></a>继承与原型</h4><p>继承意味着复制操作，JavaScript(默认)并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。委托(参见第 6 章)这个术语可以更加准确地描述 JavaScript 中对象的关联机制。</p>\n<h4 id=\"构造函数还是调用\"><a href=\"#构造函数还是调用\" class=\"headerlink\" title=\"构造函数还是调用\"></a>构造函数还是调用</h4><p>在JS中，<strong>new 会劫持所有普通函数并用构造对象的形式来调用它</strong>。换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是<strong>当且仅当使用 new 时，函数调用会变成“构造函数调用”</strong>。</p>\n<h4 id=\"constructor-并不表示被构造\"><a href=\"#constructor-并不表示被构造\" class=\"headerlink\" title=\"constructor 并不表示被构造\"></a>constructor 并不表示被构造</h4><p>function Foo() { /<em> .. </em>/ }<br>Foo.prototype = { /<em> .. </em>/ }; // 创建一个新原型对象<br>var a1 = new Foo();<br>a1.constructor === Foo; // false! a1.constructor === Object; // true!</p>\n<p>a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性(不过<strong>默认的 Foo.prototype 对象有这个属性</strong>!)，所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。 a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。</p>\n<h4 id=\"（原型）继承\"><a href=\"#（原型）继承\" class=\"headerlink\" title=\"（原型）继承\"></a>（原型）继承</h4><h3 id=\"Object-setPrototypeOf-…\"><a href=\"#Object-setPrototypeOf-…\" class=\"headerlink\" title=\"Object.setPrototypeOf(…)\"></a>Object.setPrototypeOf(…)</h3><p>ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6 之前需要抛弃默认的 Bar.prototype</span></span><br><span class=\"line\">Bar.ptototype = <span class=\"built_in\">Object</span>.create( Foo.prototype );</span><br><span class=\"line\"><span class=\"comment\">// ES6 开始可以直接修改现有的 Bar.prototype </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象关联\"><a href=\"#对象关联\" class=\"headerlink\" title=\"对象关联\"></a>对象关联</h3><p>[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。 这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p>\n<h2 id=\"行为委托\"><a href=\"#行为委托\" class=\"headerlink\" title=\"行为委托\"></a>行为委托</h2><p>委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Task = &#123;</span><br><span class=\"line\">    setID: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ID</span>) </span>&#123; <span class=\"keyword\">this</span>.id = ID; &#125;,</span><br><span class=\"line\">    outputID: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.id ); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 让XYZ委托Task</span></span><br><span class=\"line\">XYZ = <span class=\"built_in\">Object</span>.create( Task );</span><br><span class=\"line\"></span><br><span class=\"line\">XYZ.prepareTask = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ID,Label</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setID( ID );</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.label = Label;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">XYZ.outputTaskDetails = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.outputID();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.label );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ABC = Object.create( Task );</span></span><br><span class=\"line\"><span class=\"comment\">// ABC ... = ...</span></span><br></pre></td></tr></table></figure>\n<p>在上面这段代码中，Task 和 XYZ 并不是类（或者函数），它们是对象。<strong>XYZ 通过 Object. create(..) 创建，它的 [[Prototype]] 委托了 Task 对象</strong></p>\n<h3 id=\"互相委托（禁止）\"><a href=\"#互相委托（禁止）\" class=\"headerlink\" title=\"互相委托（禁止）\"></a>互相委托（禁止）</h3><p>你无法在两个或两个以上互相(双向)委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。如果你引用了一个两边都不存在的属性或者方法，那就会在 [[Prototype]] 链上产生一个<strong>无限递归的循环</strong>。 所以互相委托是被禁止的。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>JavaScript 规范并不会控制浏览器中开发者工具对于特定值或者结构的表示方式，所以浏览器和工具的解析结果并不一定相同。下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a1 = <span class=\"keyword\">new</span> Foo(); </span><br><span class=\"line\">a1; <span class=\"comment\">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>这段代码在chrome中会输出：Foo {}；而在Firefox中会得到Object {}</strong></p>\n<p>Chrome 实际上想说的是“<strong>{} 是一个空对象，由名为 Foo 的函数构造</strong>”。Firefox 想说的是“<strong>{} 是一个空对象，由 Object 构造</strong>”。之所以有这种细微的差别，是因为 <strong>Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性</strong>，但是其他浏览器并不会跟踪这些额外的信息。</p>\n<p>然而，这个行为被认定是 Chrome 的一个 bug，当你读到此书时，它可能已经被修复了。所以你看到的可能是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1; <span class=\"comment\">// Object &#123;&#125;。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h3><p>相比“类”的构造方式，<strong>对象关联可以更好地支持关注分离（separation of concerns）原则</strong>，创建和初始化并不需要合并为一个步骤。 对象关联除了能让代码看起来更简洁(并且更具扩展性)外还可以通过行为委托模式简化代码结构。</p>\n<h3 id=\"更好的语法\"><a href=\"#更好的语法\" class=\"headerlink\" title=\"更好的语法\"></a>更好的语法</h3><p>在 ES6 中，你可以使用对象的字面形式(这样就可以使用简洁方法定义)来改写之前繁琐的属性赋值语法(比如 AuthController 的定义)，然后用 Object.setPrototypeOf(..) 来修改它的 [[Prototype]]:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用更好的对象字面形式语法和简洁方法 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> AuthController = &#123;</span><br><span class=\"line\">    errors: \\[\\],</span><br><span class=\"line\">    checkAuth() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    server(url, data) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在把 AuthController 关联到 LoginController</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( AuthController, LoginController );</span><br></pre></td></tr></table></figure>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。</p>\n<p>在 js 中，instanceof 语法会产生语义困惑而且非常不直观。如果你想检查对象 a1 和某个对象的关系，那必须使用另一个引用该对象的函数才行——你不能直接判断两个对象是否关联。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* .. */</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* .. */</span> &#125;</span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create( Foo.prototype ); <span class=\"comment\">// 让Foo和Bar互相关联</span></span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype <span class=\"keyword\">instanceof</span> Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\">Bar <span class=\"keyword\">instanceof</span> Foo; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>然而，又回到上面的那个问题，<strong>如果通过对象关联的方式构造对象，内省的方法将更加简洁并且清晰</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Foo = &#123; <span class=\"comment\">/* .. */</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Bar = <span class=\"built_in\">Object</span>.create( Foo ); <span class=\"comment\">// 让Foo和Bar互相关联</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"built_in\">Object</span>.create( Bar ); <span class=\"comment\">// 让b1关联到Foo和Bar</span></span><br><span class=\"line\"></span><br><span class=\"line\">Foo.isPrototypeOf( Bar ); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf( Bar ) === Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Foo.isPrototypeOf( b1 ); <span class=\"comment\">// true </span></span><br><span class=\"line\">Bar.isPrototypeOf( b1 ); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf( b1 ) === Bar; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"ES6中的Class\"><a href=\"#ES6中的Class\" class=\"headerlink\" title=\"ES6中的Class\"></a>ES6中的Class</h3><p>除了语法更好看之外，ES6 还解决了什么问题？</p>\n<ol>\n<li>（基本上）不再引用杂乱的 .prototype 了；</li>\n<li>不再需要通过 Object.create(..) 来替换 .prototype 对象，也不需要设置 .__proto__ 或者 Object.setPrototypeOf(..)；</li>\n<li>可以通过 super(..) 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法；</li>\n<li>class 字面语法不能声明属性(只能声明方法)。看起来这是一种限制，但是它会排除掉许多不好的情况，可以帮助你避免犯错；</li>\n<li>可以通过 extends 很自然地扩展对象(子)类型，甚至是内置的对象(子)类型，比如 Array 或 RegExp。</li>\n</ol>\n<p>然而，class 语法并没有解决所有的问题，你可能会认为 ES6 的 class 语法是向 JavaScript 中引入了一种新的“类”机制，其实不是这样。class 基本上只是现有 [[Prototype]](委托!)机制的一种语法糖。 也就是说，class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你 (有意或无意)修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为<strong>它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托。</strong> 除此之外，class 还有以下问题：</p>\n<ol>\n<li><strong>class 语法无法定义类成员属性（只能定义方法）；</strong></li>\n<li>class 语法仍然面临<strong>意外屏蔽</strong>的问题；</li>\n<li>super 并不是动态绑定this的，它会在声明时“静态”绑定。（可以通过 toMethod(…) 手动修改 super 绑定）</li>\n</ol>\n<p>综上，class 最大的问题在于，像传统的类一样)它的语法有时会让你认为，定义了一个 class 后，它就变成了一个(未来会被实例化的)东西的静态定义。<strong>你会彻底忽略 C 是一个对象，是一个具体的可以直接交互的东西。</strong></p>\n<p>ES6 的 class 想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让 JavaScript 更加难以理解。</p>\n","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]}]}