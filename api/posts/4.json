{"total":114,"pageSize":10,"pageCount":12,"data":[{"title":"Git commit 中的Change-Id是什么","slug":"Git commit 中的Change-Id是什么","date":"2017-08-20T12:38:52.000Z","updated":"2019-01-29T09:23:55.528Z","comments":true,"path":"api/articles/Git commit 中的Change-Id是什么.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_91.png","content":"<p>之前在创业公司实习的时候代码管理很不规范，技术部负责人把每个人的 ssh key 添加到公司 github 中之后就可以执行 git 相关操作了，根本没有权限的概念；后来进入公司之后，才知道还有 Gerrit 这种东西，而第一次 push 代码的时候就遇到了 <code>ERROR: missing Change-Id in commit message</code> 的错误，后来才得知是因为没有 Change-Id 的缘故，下面就介绍一下 Change-Id 是什么东东：</p>\n<h2 id=\"什么是-Change-Id\"><a href=\"#什么是-Change-Id\" class=\"headerlink\" title=\"什么是 Change-Id\"></a>什么是 Change-Id</h2><p>Change-Id 其实就是一段形如 <code>I7cbfa01f5136b8815e5e2c6dc5dcda28ce49d13a</code> 的字符串，它的作用是：</p>\n<blockquote>\n<p>保证已经提交审核的修订通过审核入库后，被别的分支 cherry-pick 后再推送至服务器时不会产生新的重复的评审任务。</p>\n</blockquote>\n<p>Gerrit 设计了一套方法，即要求每个提交包含唯一的 Change-Id，这个 Change-Id 因为出现在日志中，当执行 cherry-pick 时也会保持，Gerrit 一旦发现新的提交包含了已经处理过的 Change-Id，就不再为该修订创建新的评审任务和 task-id，而直接将提交入库。<br>总之，Change-Id 就是 Gerrit 为了确保 cherry-pick 已提交审核的分支时不会在产生新的提交记录。</p>\n<h2 id=\"解决-ERROR：missing-Change-Id-in-commit-message\"><a href=\"#解决-ERROR：missing-Change-Id-in-commit-message\" class=\"headerlink\" title=\"解决 ERROR：missing Change-Id in commit message\"></a>解决 <code>ERROR：missing Change-Id in commit message</code></h2><p>在一开始我们提到过，在执行 <code>git push origin Head:refs/for/xxxx</code> 时有时会报出上面标题这样的错误，也就是在 commit Message 仅仅包含如 <code>feature：xxxx</code> 等 title 这样的信息而缺少 Change-Id。那么怎样解决呢？</p>\n<h3 id=\"临时解决\"><a href=\"#临时解决\" class=\"headerlink\" title=\"临时解决\"></a>临时解决</h3><p>git commit 有一个神奇的参数，叫做 <code>--amend</code>，如果我们遇到了上面的错误，可以执行下面的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n<p>然后我们可以看到最近一次 commit 的相关信息，在 title 下面空出一行（注意，一定要空出一行，否则 git 会把其作为 title 的一部分处理）后，将 <code>Change-Id: XXXX</code> 复制到 Message 中。然后就可以 push 了。你可能会问了，我哪知道 Change-Id 是什么呢？可以先查看一下之前的 commit 信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<p>然后你可能会看到这样一条信息：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_91.png\" alt=\"\" width=\"400\"></div>\n\n<p>现在你懂了吧，其实可以看到之前人提交 commit 信息的 Change-Id，我们只需要复制一下（注意 <code>Change-Id:</code> 后面有个空格）然后改一下其中某个字母就可以了（因为 Change-Id 不允许重复，如果重复了，可以再改一个字母，一般只需要改一个字母就可以了），这时我们就有了一个人工生成的 <code>Change-Id</code> 了。 注意，这种办法只是一种临时解决方案，下次如果你再想 commit 就需要再复制一个 Change-Id，然后 –amend 修改 commit 信息，是不是感觉每次这样修改很麻烦？没事，我们有一个永久解决方案：</p>\n<h3 id=\"自动生成-Change-Id\"><a href=\"#自动生成-Change-Id\" class=\"headerlink\" title=\"自动生成 Change-Id\"></a>自动生成 Change-Id</h3><p>其实我们可以利用 commit-msg 这个 hook 文件自动生成 Change-Id，具体做法如下：</p>\n<ul>\n<li>将文章下面的 commit-msg hook 脚本复制到 git 项目中 .git/hooks 下，并命名为 commit-msg（一般情况下 .git/hooks 下会包含一个叫 commit-msg.sample 的文件，可以把它删除）</li>\n<li>添加完之后，执行</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u+x .git/hooks/commit-msg</span><br></pre></td></tr></table></figure>\n<p>激活 hook，以后提交的时候就会自动携带 Change-Id 了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\">\\<span class=\"comment\"># From Gerrit Code Review 2.6</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># Part of Gerrit Code Review (http://code.google.com/p/gerrit/)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># Copyright (C) 2009 The Android Open Source Project</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># Licensed under the Apache License, Version 2.0 (the \"License\");</span></span><br><span class=\"line\">\\<span class=\"comment\"># you may not use this file except in compliance with the License.</span></span><br><span class=\"line\">\\<span class=\"comment\"># You may obtain a copy of the License at</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">\\<span class=\"comment\"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class=\"line\">\\<span class=\"comment\"># distributed under the License is distributed on an \"AS IS\" BASIS,</span></span><br><span class=\"line\">\\<span class=\"comment\"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class=\"line\">\\<span class=\"comment\"># See the License for the specific language governing permissions and</span></span><br><span class=\"line\">\\<span class=\"comment\"># limitations under the License.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unset</span> GREP_OPTIONS</span><br><span class=\"line\"></span><br><span class=\"line\">CHANGE\\_ID\\_AFTER=<span class=\"string\">\"Bug|Issue\"</span></span><br><span class=\"line\">MSG=<span class=\"string\">\"<span class=\"variable\">$1</span>\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">\\<span class=\"comment\"># Check for, and add if missing, a unique Change-Id</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">add_ChangeId</span></span>() &#123;</span><br><span class=\"line\">clean_message=`sed -e <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">/^diff --git a\\\\/.*/&#123;</span></span><br><span class=\"line\"><span class=\"string\">s///</span></span><br><span class=\"line\"><span class=\"string\">q</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">/^Signed-off-by:/d</span></span><br><span class=\"line\"><span class=\"string\">/^#/d</span></span><br><span class=\"line\"><span class=\"string\">'</span> <span class=\"string\">\"<span class=\"variable\">$MSG</span>\"</span> | git stripspace`</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> -z <span class=\"string\">\"<span class=\"variable\">$clean_message</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">return</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\\<span class=\"comment\"># Does Change-Id: already exist? if so, exit (no change).</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> grep -i <span class=\"string\">'^Change-Id:'</span> <span class=\"string\">\"<span class=\"variable\">$MSG</span>\"</span> &gt;/dev/null</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">return</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">id=`\\_gen\\_ChangeId`</span><br><span class=\"line\">T=<span class=\"string\">\"<span class=\"variable\">$MSG</span>.tmp.$$\"</span></span><br><span class=\"line\">AWK=awk</span><br><span class=\"line\"><span class=\"keyword\">if</span> \\[ -x /usr/xpg4/bin/awk \\]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\\<span class=\"comment\"># Solaris AWK is just too broken</span></span><br><span class=\"line\">AWK=/usr/xpg4/bin/awk</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\\<span class=\"comment\"># How this works:</span></span><br><span class=\"line\">\\<span class=\"comment\"># - parse the commit message as (textLine+ blankLine*)*</span></span><br><span class=\"line\">\\<span class=\"comment\"># - assume textLine+ to be a footer until proven otherwise</span></span><br><span class=\"line\">\\<span class=\"comment\"># - exception: the first block is not footer (as it is the title)</span></span><br><span class=\"line\">\\<span class=\"comment\"># - read textLine+ into a variable</span></span><br><span class=\"line\">\\<span class=\"comment\"># - then count blankLines</span></span><br><span class=\"line\">\\<span class=\"comment\"># - once the next textLine appears, print textLine+ blankLine* as these</span></span><br><span class=\"line\">\\<span class=\"comment\"># aren't footer</span></span><br><span class=\"line\">\\<span class=\"comment\"># - in END, the last textLine+ block is available for footer parsing</span></span><br><span class=\"line\"><span class=\"variable\">$AWK</span> <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">BEGIN &#123;</span></span><br><span class=\"line\"><span class=\"string\">\\# while we start with the assumption that textLine+</span></span><br><span class=\"line\"><span class=\"string\">\\# is a footer, the first block is not.</span></span><br><span class=\"line\"><span class=\"string\">isFooter = 0</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 0</span></span><br><span class=\"line\"><span class=\"string\">blankLines = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Skip lines starting with \"#\" without any spaces before it.</span></span><br><span class=\"line\"><span class=\"string\">/^#/ &#123; next &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Skip the line starting with the diff command and everything after it,</span></span><br><span class=\"line\"><span class=\"string\">\\# up to the end of the file, assuming it is only patch data.</span></span><br><span class=\"line\"><span class=\"string\">\\# If more than one line before the diff was empty, strip all but one.</span></span><br><span class=\"line\"><span class=\"string\">/^diff --git a/ &#123;</span></span><br><span class=\"line\"><span class=\"string\">blankLines = 0</span></span><br><span class=\"line\"><span class=\"string\">while (getline) &#123; &#125;</span></span><br><span class=\"line\"><span class=\"string\">next</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Count blank lines outside footer comments</span></span><br><span class=\"line\"><span class=\"string\">/^$/ &amp;&amp; (footerComment == 0) &#123;</span></span><br><span class=\"line\"><span class=\"string\">blankLines++</span></span><br><span class=\"line\"><span class=\"string\">next</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Catch footer comment</span></span><br><span class=\"line\"><span class=\"string\">/^\\\\\\[\\[a-zA-Z0-9-\\]+:/ &amp;&amp; (isFooter == 1) &#123;</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 1</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/\\]$/ &amp;&amp; (footerComment == 1) &#123;</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 2</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# We have a non-blank line after blank lines. Handle this.</span></span><br><span class=\"line\"><span class=\"string\">(blankLines &gt; 0) &#123;</span></span><br><span class=\"line\"><span class=\"string\">print lines</span></span><br><span class=\"line\"><span class=\"string\">for (i = 0; i &lt; blankLines; i++) &#123;</span></span><br><span class=\"line\"><span class=\"string\">print \"\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">lines = \"\"</span></span><br><span class=\"line\"><span class=\"string\">blankLines = 0</span></span><br><span class=\"line\"><span class=\"string\">isFooter = 1</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Detect that the current block is not the footer</span></span><br><span class=\"line\"><span class=\"string\">(footerComment == 0) &amp;&amp; (!/^\\\\\\[?\\[a-zA-Z0-9-\\]+:/ || /^\\[a-zA-Z0-9-\\]+:\\\\/\\\\//) &#123;</span></span><br><span class=\"line\"><span class=\"string\">isFooter = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">\\# We need this information about the current last comment line</span></span><br><span class=\"line\"><span class=\"string\">if (footerComment == 2) &#123;</span></span><br><span class=\"line\"><span class=\"string\">footerComment = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">if (lines != \"\") &#123;</span></span><br><span class=\"line\"><span class=\"string\">lines = lines \"\\\\n\";</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">lines = lines $0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\\# Footer handling:</span></span><br><span class=\"line\"><span class=\"string\">\\# If the last block is considered a footer, splice in the Change-Id at the</span></span><br><span class=\"line\"><span class=\"string\">\\# right place.</span></span><br><span class=\"line\"><span class=\"string\">\\# Look for the right place to inject Change-Id by considering</span></span><br><span class=\"line\"><span class=\"string\">\\# CHANGE\\_ID\\_AFTER. Keys listed in it (case insensitive) come first,</span></span><br><span class=\"line\"><span class=\"string\">\\# then Change-Id, then everything else (eg. Signed-off-by:).</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\">\\# Otherwise just print the last block, a new line and the Change-Id as a</span></span><br><span class=\"line\"><span class=\"string\">\\# block of its own.</span></span><br><span class=\"line\"><span class=\"string\">END &#123;</span></span><br><span class=\"line\"><span class=\"string\">unprinted = 1</span></span><br><span class=\"line\"><span class=\"string\">if (isFooter == 0) &#123;</span></span><br><span class=\"line\"><span class=\"string\">print lines \"\\\\n\"</span></span><br><span class=\"line\"><span class=\"string\">lines = \"\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">changeIdAfter = \"^(\" tolower(\"'</span><span class=\"string\">\"<span class=\"variable\">$CHANGE</span>\\_ID\\_AFTER\"</span><span class=\"string\">'\") \"):\"</span></span><br><span class=\"line\"><span class=\"string\">numlines = split(lines, footer, \"\\\\n\")</span></span><br><span class=\"line\"><span class=\"string\">for (line = 1; line &lt;= numlines; line++) &#123;</span></span><br><span class=\"line\"><span class=\"string\">if (unprinted &amp;&amp; match(tolower(footer\\[line\\]), changeIdAfter) != 1) &#123;</span></span><br><span class=\"line\"><span class=\"string\">unprinted = 0</span></span><br><span class=\"line\"><span class=\"string\">print \"Change-Id: I'</span><span class=\"string\">\"<span class=\"variable\">$id</span>\"</span><span class=\"string\">'\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">print footer\\[line\\]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">if (unprinted) &#123;</span></span><br><span class=\"line\"><span class=\"string\">print \"Change-Id: I'</span><span class=\"string\">\"<span class=\"variable\">$id</span>\"</span><span class=\"string\">'\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span> <span class=\"string\">\"<span class=\"variable\">$MSG</span>\"</span> &gt; <span class=\"string\">\"<span class=\"variable\">$T</span>\"</span> &amp;&amp; mv <span class=\"string\">\"<span class=\"variable\">$T</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$MSG</span>\"</span> || rm -f <span class=\"string\">\"<span class=\"variable\">$T</span>\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\\_gen\\<span class=\"function\"><span class=\"title\">_ChangeIdInput</span></span>() &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"tree \\`git write-tree\\`\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> parent=\\`git rev-parse <span class=\"string\">\"HEAD^0\"</span> 2&gt;/dev/null\\`</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"parent <span class=\"variable\">$parent</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"author \\`git var GIT\\_AUTHOR\\_IDENT\\`\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"committer \\`git var GIT\\_COMMITTER\\_IDENT\\`\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">'%s'</span> <span class=\"string\">\"<span class=\"variable\">$clean_message</span>\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\\_gen\\<span class=\"function\"><span class=\"title\">_ChangeId</span></span>() &#123;</span><br><span class=\"line\">\\_gen\\_ChangeIdInput |</span><br><span class=\"line\">git <span class=\"built_in\">hash</span>-object -t commit --stdin</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add_ChangeId</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[{"name":"git","path":"api/tags/git.json"},{"name":"change-id","path":"api/tags/change-id.json"}]},{"title":"在线接口地址总结","slug":"在线接口地址总结","date":"2017-08-20T12:37:00.000Z","updated":"2019-01-29T09:23:55.536Z","comments":true,"path":"api/articles/在线接口地址总结.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>我在这篇文章中总结了一些在线接口地址，这些接口可以很方便的进行在线调用，完成某些业务需求，不过由于公开 API 基本上没有盈利空间，所以有可能过一段时间就不再维护了，大家在使用之前一定要验证一下是否仍然有效</p>\n<h2 id=\"天气\"><a href=\"#天气\" class=\"headerlink\" title=\"天气\"></a>天气</h2><p>其实提供天气接口的网站很多，有人已经替我们总结好了，可以<a href=\"http://www.nohacks.cn/post-35.html\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看，有些接口是需要知道自己的城市代码的，大家可以去<a href=\"http://www.weather.com.cn/\" target=\"_blank\" rel=\"noopener\">中国天气网首页</a>进行查询，不过我更推荐<a href=\"https://www.heweather.com/\" target=\"_blank\" rel=\"noopener\">和风天气</a>，和风天气需要注册成为认证开发者才能获得免费 7 天天气预报的资格，注册还是很简单的，差不多一天就能通过。目前和风天气提供的开发者免费天气服务：</p>\n<ul>\n<li>国内 3181+ 海外 4000 热门</li>\n<li><strong>7天天气预报</strong></li>\n<li>实况天气</li>\n<li>逐三小时预报</li>\n<li>生活指数（基础 8 项）</li>\n<li>空气质量实况（国控站点）</li>\n<li>每天访问量：14959 次</li>\n<li>稳定性：99%</li>\n<li>技术支持：邮件</li>\n</ul>\n<p>虽然免费 API 有访问限制，<strong>每天不得超过14959次</strong>，但是做天气数据缓存之后就应该够用了</p>\n<h2 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h2><h3 id=\"搜狐\"><a href=\"#搜狐\" class=\"headerlink\" title=\"搜狐\"></a>搜狐</h3><p>搜狐提供了一个获取本设备 IP 地址的接口：<a href=\"http://pv.sohu.com/cityjson?ie=utf-8\" target=\"_blank\" rel=\"noopener\">http://pv.sohu.com/cityjson?ie=utf-8</a>，其返回结果类似于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> returnCitySN = &#123;<span class=\"string\">\"cip\"</span>: <span class=\"string\">\"114.255.41.188\"</span>, <span class=\"string\">\"cid\"</span>: <span class=\"string\">\"110000\"</span>, <span class=\"string\">\"cname\"</span>: <span class=\"string\">\"北京市\"</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>不知道为什么明明是 json 格式，偏偏要写的不符合规范，所以在获取到 response 之后，还需要自己解析一下。</p>\n<h3 id=\"新浪\"><a href=\"#新浪\" class=\"headerlink\" title=\"新浪\"></a>新浪</h3><p>新浪提供了一个查询指定 IP 地址所在地理位置的接口：<a href=\"http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&amp;ip=114.255.41.188\" target=\"_blank\" rel=\"noopener\">http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&amp;ip=114.255.41.188</a>，其返回结果类似于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> remote\\_ip\\_info = &#123;<span class=\"string\">\"ret\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"start\"</span>:<span class=\"number\">-1</span>,<span class=\"string\">\"end\"</span>:<span class=\"number\">-1</span>,<span class=\"string\">\"country\"</span>:<span class=\"string\">\"\\\\u4e2d\\\\u56fd\"</span>,<span class=\"string\">\"province\"</span>:<span class=\"string\">\"\\\\u5317\\\\u4eac\"</span>,<span class=\"string\">\"city\"</span>:<span class=\"string\">\"\\\\u5317\\\\u4eac\"</span>,<span class=\"string\">\"district\"</span>:<span class=\"string\">\"\"</span>,<span class=\"string\">\"isp\"</span>:<span class=\"string\">\"\"</span>,<span class=\"string\">\"type\"</span>:<span class=\"string\">\"\"</span>,<span class=\"string\">\"desc\"</span>:<span class=\"string\">\"\"</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>一些字段是 URL 编码过后的字符，所以需要使用 decodeURIComponent 来解码成中文</p>\n<h3 id=\"chaipip\"><a href=\"#chaipip\" class=\"headerlink\" title=\"chaipip\"></a>chaipip</h3><p><a href=\"http://chaipip.com/\" target=\"_blank\" rel=\"noopener\">http://chaipip.com/</a>，这是某大牛自己开发的一个根据 IP 地址查询实际地理位置的网站，不过网站加了很多防护，而且每人每天有查询次数的限制（最多 20 次），所以就用来自己使用吧- -</p>\n<h2 id=\"人脸识别\"><a href=\"#人脸识别\" class=\"headerlink\" title=\"人脸识别\"></a>人脸识别</h2><p>说到人脸识别，第一想到的肯定是 <a href=\"https://www.faceplusplus.com.cn/\" target=\"_blank\" rel=\"noopener\">Face++</a> 了，不过除了人脸识别，Face++ 目前还可以提供人体识别、文字识别和图像识别等等服务</p>\n<h2 id=\"地图\"><a href=\"#地图\" class=\"headerlink\" title=\"地图\"></a>地图</h2><p>目前我所了解的提供开放地图 API 的网站有三家：百度地图、高德地图和腾讯地图：</p>\n<ul>\n<li><a href=\"http://lbsyun.baidu.com/index.php\" target=\"_blank\" rel=\"noopener\">百度地图开放平台</a></li>\n<li><a href=\"https://lbs.amap.com/\" target=\"_blank\" rel=\"noopener\">高德地图API</a></li>\n<li><a href=\"http://lbs.qq.com/\" target=\"_blank\" rel=\"noopener\">腾讯地图API</a></li>\n</ul>\n<h2 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h2><p>目前有<a href=\"https://github.com/Binaryify/NeteaseCloudMusicApi\" target=\"_blank\" rel=\"noopener\">网易云音乐</a>（很全面，感谢作者一直在更新）和<a href=\"https://gitee.com/Tony.bin/search_web\" target=\"_blank\" rel=\"noopener\">酷狗音乐</a>，github 上有很多利用网易云音乐 API 做的项目，包括小程序、网页版、wap 版以及 electron 版，大家感兴趣的去同性交友网站上可以搜一下</p>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><p>我们知道通过 css 中的 <code>@font-face</code> 可以引入一些特殊字体，而现在 <a href=\"http://www.google.com/webfonts#ChoosePlace:select\" target=\"_blank\" rel=\"noopener\">Google Font Api</a> 也能实现，具体使用过程见大漠的文章——<a href=\"https://www.w3cplus.com/css/how-to-use-google-font-api\" target=\"_blank\" rel=\"noopener\">《Google Font的运用》</a></p>\n<h2 id=\"一句话\"><a href=\"#一句话\" class=\"headerlink\" title=\"一句话\"></a>一句话</h2><p><a href=\"http://hitokoto.cn/api\" target=\"_blank\" rel=\"noopener\">一言网</a>创立于 2016 年，隶属于萌创 Team，目前网站主要提供一句话服务。一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。或是感动，或是开心，亦或是单纯的回忆。这是一个我很喜欢的 API 服务，希望它永远不会停止吧！</p>\n<h2 id=\"北邮人论坛非官方-API\"><a href=\"#北邮人论坛非官方-API\" class=\"headerlink\" title=\"北邮人论坛非官方 API\"></a>北邮人论坛非官方 API</h2><p><a href=\"https://github.com/byr-gdp/byr-bbs-unofficial-api\" target=\"_blank\" rel=\"noopener\">北邮人论坛非官方 API</a>。基于 NodeJS，通过 <code>superagent</code> 抓取数据并用 <code>cheerio</code> 处理后返回 JSON 格式数据。目前有这些功能：</p>\n<ol>\n<li>获取十大信息</li>\n<li>获取版块主题列表</li>\n<li>获取主题回帖列表及精彩回复</li>\n<li>回复帖子</li>\n</ol>\n<p>不过好像 github 上提供的线上域名无法访问了，所以如果你需要使用的话，需要自己部署一下</p>\n<h2 id=\"名人生日\"><a href=\"#名人生日\" class=\"headerlink\" title=\"名人生日\"></a>名人生日</h2><p><a href=\"https://www.meiguoshenpo.com/shengrimingren/\" target=\"_blank\" rel=\"noopener\">美国神婆星座网</a>，提供名人生日查询、名人出生日期查询等,看看每一天都有哪些名人出生，哪些名人是和你一天出生的；不过目前只能通过爬取网页的形式来间接获取，没有开放 API 接口</p>\n<h2 id=\"表情图片\"><a href=\"#表情图片\" class=\"headerlink\" title=\"表情图片\"></a>表情图片</h2><p><a href=\"https://www.doutula.com/apidoc\" target=\"_blank\" rel=\"noopener\">斗图啦</a>，表情图片社区斗图啦提供的开放 api，调用很简单，可以很方便的结合 IM 软件开发一个表情机器人。</p>\n<h2 id=\"图片压缩\"><a href=\"#图片压缩\" class=\"headerlink\" title=\"图片压缩\"></a>图片压缩</h2><p><a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">tinypng</a>是知名的免费压缩图片的网站，而同时其也提供了压缩图片的 API 服务，API key 申请地址：<a href=\"https://tinypng.com/developers\" target=\"_blank\" rel=\"noopener\">https://tinypng.com/developers</a>，调用这个网站提供的 API 需要申请一个 API key，输入邮箱，它会把包含 API key 的网址发到你邮箱，打开其中的链接就可以看到属于你的 API key 了；调用这个网站的 API 进行图片压缩的话，每个月前 500 张是免费的，之后要收费；不过既可以压缩 png 图片，又可以压缩 jpg 图片。</p>\n<h2 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h2><p>github 的接口 api 都是开放的，我们可以借助公开 API 构建一个属于自己的项目管理工具。官方文档有 v3 和v4 2个版本，v3 是 Restful，v4 是 GraphQL，v3 版地址： <a href=\"https://api.github.com\" target=\"_blank\" rel=\"noopener\">https://api.github.com</a> 在无 token 情况下使用 github 的 api，每分钟限制是 60 次请求，如果想完整的使用 github 的api，\b可以构建一个 <a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">web application</a>，具体流程可以参考：<a href=\"https://juejin.im/post/5be5403ce51d453b6e027f06\" target=\"_blank\" rel=\"noopener\">【React 实战教程】从0到1 构建 github star管理工具</a></p>\n<h2 id=\"CDN资源\"><a href=\"#CDN资源\" class=\"headerlink\" title=\"CDN资源\"></a>CDN资源</h2><h3 id=\"cdnjs\"><a href=\"#cdnjs\" class=\"headerlink\" title=\"cdnjs\"></a>cdnjs</h3><p>具体开放 API 列表可以看这里：<a href=\"https://cdnjs.com/api\" target=\"_blank\" rel=\"noopener\">https://cdnjs.com/api</a>，你可以获取全部资源列表，也可以通过关键词进行搜索，还可以指定插件，功能比较强大</p>\n<h2 id=\"翻译\"><a href=\"#翻译\" class=\"headerlink\" title=\"翻译\"></a>翻译</h2><p><a href=\"https://github.com/matheuss/google-translate-api\" target=\"_blank\" rel=\"noopener\">google-translate-api</a>，一个免费且无限制的谷歌翻译 API 库，npm 引入一下即可使用</p>\n<h2 id=\"一些提供接口的网站\"><a href=\"#一些提供接口的网站\" class=\"headerlink\" title=\"一些提供接口的网站\"></a>一些提供接口的网站</h2><h3 id=\"HaoService数据平台\"><a href=\"#HaoService数据平台\" class=\"headerlink\" title=\"HaoService数据平台\"></a><a href=\"http://www.haoservice.com/apilist/\" target=\"_blank\" rel=\"noopener\">HaoService数据平台</a></h3><p>提供了很多数据接口服务，包括短信、语音验证码、银行卡归属地、手机归属地和天气等等，收费也比较良心，适合中小型公司使用。</p>\n<h3 id=\"RSSHub\"><a href=\"#RSSHub\" class=\"headerlink\" title=\"RSSHub\"></a><a href=\"https://docs.rsshub.app/#%E9%B8%A3%E8%B0%A2\" target=\"_blank\" rel=\"noopener\">RSSHub</a></h3><p>RSSHub 是一个轻量、易于扩展的 RSS 生成器, 可以给任何奇奇怪怪的内容生成 RSS 订阅源；同时该网页中包含了已有 RSS 内容的网址，涵盖多个领域，对于那些研究爬虫与内容订阅方向的童鞋来说是个福利。</p>\n<h3 id=\"京东万象\"><a href=\"#京东万象\" class=\"headerlink\" title=\"京东万象\"></a><a href=\"https://wx.jdcloud.com/api\" target=\"_blank\" rel=\"noopener\">京东万象</a></h3><p>向开发者提供国内外最全的金融数据、电商数据、运营商数据、京东数据、生活服务数据、应用开发数据、质检数据等接口,为开发者提供合法有效的优质 API 接口。京东万象,权威的数据交易平台。有收费的也有免费的，比如<a href=\"https://wx.jdcloud.com/search/datas?keyword=%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F\" target=\"_blank\" rel=\"noopener\">空气质量相关API</a> 就是免费提供的。</p>\n","raw":null,"categories":[{"name":"summary","path":"api/categories/summary.json"}],"tags":[{"name":"接口","path":"api/tags/接口.json"},{"name":"API","path":"api/tags/API.json"}]},{"title":"他山之石，可以攻玉，好文章推荐","slug":"他山之石，可以攻玉，好文章推荐","date":"2017-08-07T03:40:22.000Z","updated":"2019-01-29T09:23:55.536Z","comments":true,"path":"api/articles/他山之石，可以攻玉，好文章推荐.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>经常看别人的博客或者文章，有时候闲暇时间也会刷一刷微信公众号神马的（但其实微信公众号上的文章也是转载其他人的博客），所以难免会碰到一些“不想关闭”的文章，放到收藏夹里又怕哪天消失了，所以就放到这里吧，也可以节省大家寻找好文章的时间。（这些文章有些难度会比较大，不太推荐将大量的时间花费在“纠结原理”上）</p>\n<h2 id=\"人工智能相关\"><a href=\"#人工智能相关\" class=\"headerlink\" title=\"人工智能相关\"></a>人工智能相关</h2><h3 id=\"深入浅出看懂AlphaGo元\"><a href=\"#深入浅出看懂AlphaGo元\" class=\"headerlink\" title=\"深入浅出看懂AlphaGo元\"></a><a href=\"https://charlesliuyx.github.io/2017/10/18/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9C%8B%E6%87%82AlphaGo%E5%85%83/\" target=\"_blank\" rel=\"noopener\">深入浅出看懂AlphaGo元</a></h3><p>前段时间关于阿法狗的一篇文章（《今日Nature: 人工智能从0到1, 无师自通完爆阿法狗100-0 | 深度解析》）火爆了微信朋友圈，而关于阿法元是如何自我学习的，这篇文章讲述的很明白。</p>\n<h3 id=\"浅谈人工智能：现状、任务、构架与统一-正本清源\"><a href=\"#浅谈人工智能：现状、任务、构架与统一-正本清源\" class=\"headerlink\" title=\"浅谈人工智能：现状、任务、构架与统一 | 正本清源\"></a><a href=\"https://mp.weixin.qq.com/s/-wSYLu-XvOrsST8_KEUa-Q\" target=\"_blank\" rel=\"noopener\">浅谈人工智能：现状、任务、构架与统一 | 正本清源</a></h3><p>“人工智能”这个名词在沉寂了近 30 年之后，最近两年“咸鱼翻身”，成为了科技公司公关的战场、网络媒体吸睛的风口，随后受到政府的重视和投资界的追捧。于是，新闻发布会、高峰论坛接踵而来，政府战略规划出台，各种新闻应接不暇，宣告一个“智能为王”时代的到来。 到底什么是人工智能？现在的研究处于什么阶段？今后如何发展？这是大家普遍关注的问题。这篇文章用大篇幅解释了这些问题，目录如下：</p>\n<ul>\n<li>第一节 现状：正视现实</li>\n<li>第二节 未来：一只乌鸦给我们的启示</li>\n<li>第三节 历史：从“春秋五霸”到“战国六雄”</li>\n<li>第四节 统一：“小数据、大任务”范式与认知构架</li>\n<li>第五节 学科一：计算视觉 — 从“深”到“暗”</li>\n<li>第六节 学科二：认知推理 — 走进内心世界</li>\n<li>第七节 学科三：语言通讯 — 沟通的认知基础</li>\n<li>第八节 学科四：博弈伦理 — 获取、共享人类的价值观</li>\n<li>第九节 学科五：机器人学 — 构建大任务平台</li>\n<li>第十节 学科六：机器学习 — 学习的终极极限与“停机问题”</li>\n<li>第十一节 总结：智能科学 — 牛顿与达尔文的统一</li>\n</ul>\n<h2 id=\"前端相关\"><a href=\"#前端相关\" class=\"headerlink\" title=\"前端相关\"></a>前端相关</h2><h3 id=\"玉伯《从前端技术到体验科技（附演讲视频）》\"><a href=\"#玉伯《从前端技术到体验科技（附演讲视频）》\" class=\"headerlink\" title=\"玉伯《从前端技术到体验科技（附演讲视频）》\"></a><a href=\"https://cnodejs.org/topic/5a54a8a4afa0a121784a8ab0\" target=\"_blank\" rel=\"noopener\">玉伯《从前端技术到体验科技（附演讲视频）》</a></h3><p>我想，玉伯大神应该不用过多介绍了吧，从之前的 seajs 到现在的 ant design，而玉伯大神也从一名前端工程师“进化”为一名架构师，这篇文章是玉伯大神在 SEE Conf 大会上的演讲记录，同时文章末尾还有演讲视频链接，不喜欢看文字的朋友可以直接看演讲视频。</p>\n<h3 id=\"哔哩哔哩（B站）的前端之路\"><a href=\"#哔哩哔哩（B站）的前端之路\" class=\"headerlink\" title=\"哔哩哔哩（B站）的前端之路\"></a><a href=\"https://zhuanlan.zhihu.com/p/32487533\" target=\"_blank\" rel=\"noopener\">哔哩哔哩（B站）的前端之路</a></h3><p>作者总结了 B站 的前端进阶之路，前端的轮子很多，作者介绍了 B站 是如何选型的以及遇到了哪些坑。</p>\n<h3 id=\"深入剖析-WebKit\"><a href=\"#深入剖析-WebKit\" class=\"headerlink\" title=\"深入剖析 WebKit\"></a><a href=\"http://www.starming.com/2017/10/11/deeply-analyse-webkit/\" target=\"_blank\" rel=\"noopener\">深入剖析 WebKit</a></h3><p>这篇文章和他的题目一样，真的很“深入”，因为你可以看到滚轮滑动的速度。。不过图文并茂的表现形式并不会让你产生“看不下去”的感觉，来张目录感受一下是不是干货：</p>\n<div align=\"center\"><img src=\"\" alt=\"/images/hexo_post_286.png\" width=\"400\"></div>\n\n<h3 id=\"前端文章-收藏集-掘金\"><a href=\"#前端文章-收藏集-掘金\" class=\"headerlink\" title=\"前端文章- 收藏集 - 掘金\"></a><a href=\"https://segmentfault.com/a/1190000010452096\" target=\"_blank\" rel=\"noopener\">前端文章- 收藏集 - 掘金</a></h3><p>掘金上面关于前端的文章集合，闲暇时间看一下，可能会有意想不到的收获</p>\n<h3 id=\"前端工程——基础篇\"><a href=\"#前端工程——基础篇\" class=\"headerlink\" title=\"前端工程——基础篇\"></a><a href=\"https://github.com/fouber/blog/issues/10\" target=\"_blank\" rel=\"noopener\">前端工程——基础篇</a></h3><p>fis 作者张玉龙对于前端工程的理解，从组件化到资源管理都阐述了自己的观点，这是一篇 2015 年的文章，但是文中的某些观念到现在看来仍然是字字珠玑，相信看完之后的你可以对前端有更深层次的理解。</p>\n<h3 id=\"大公司里怎样开发和部署前端代码？\"><a href=\"#大公司里怎样开发和部署前端代码？\" class=\"headerlink\" title=\"大公司里怎样开发和部署前端代码？\"></a><a href=\"https://github.com/fouber/blog/issues/6\" target=\"_blank\" rel=\"noopener\">大公司里怎样开发和部署前端代码？</a></h3><p>又是张玉龙的文章，通过一个实际的场景一步步的告诉你大公司的前端代码是如何开发和部署上线的。</p>\n<h3 id=\"Web-前端知识体系精简\"><a href=\"#Web-前端知识体系精简\" class=\"headerlink\" title=\"Web 前端知识体系精简\"></a><a href=\"http://www.cnblogs.com/onepixel/p/7021506.html\" target=\"_blank\" rel=\"noopener\">Web 前端知识体系精简</a></h3><p>从前端三剑客：HTML、CSS、Javascript 的角度分析了前端的知识体系，涉及到的领域比较广泛，很适合前端新人开拓视野和寻找学习方向，同时总结的也很全面，是一篇不错的入门教材。</p>\n<h3 id=\"移动时代的前端加密\"><a href=\"#移动时代的前端加密\" class=\"headerlink\" title=\"移动时代的前端加密\"></a><a href=\"http://div.io/topic/1220\" target=\"_blank\" rel=\"noopener\">移动时代的前端加密</a></h3><p>这篇文章篇幅很长，对于前端来说，很多人感觉“加密”是莫须有的一种东西，其实这是一种误解，“加密”并不意味着绝对安全，这篇文章将从这个角度向你阐述前端加密的正确姿势。</p>\n<h3 id=\"前端疲劳\"><a href=\"#前端疲劳\" class=\"headerlink\" title=\"前端疲劳\"></a><a href=\"http://www.jianshu.com/p/a2eff3d721cb\" target=\"_blank\" rel=\"noopener\">前端疲劳</a></h3><p>有这么多不同的前端技术栈，不同的前端框架，不同的前端工具和库像水一样包裹着我，我不去学就不会，学了又学不完。在前端的海洋里越陷越深的我究竟该如何自救呢？这篇文章可能有你要的答案</p>\n<h3 id=\"精读前后端渲染之争\"><a href=\"#精读前后端渲染之争\" class=\"headerlink\" title=\"精读前后端渲染之争\"></a><a href=\"https://github.com/camsong/blog/issues/8\" target=\"_blank\" rel=\"noopener\">精读前后端渲染之争</a></h3><p>前后端渲染一直以来都是一个带有争议的话题，而该文章的作者对<a href=\"https://medium.freecodecamp.org/heres-why-client-side-rendering-won-46a349fadb52\" target=\"_blank\" rel=\"noopener\">国外一篇关于前后端渲染的文章</a>进行了精读，介绍了前后端渲染各自的优缺点，以及我们在实际项目中如何取舍。</p>\n<h3 id=\"技术雷达之「微前端」-将微服务理念扩展到前端开发\"><a href=\"#技术雷达之「微前端」-将微服务理念扩展到前端开发\" class=\"headerlink\" title=\"技术雷达之「微前端」- 将微服务理念扩展到前端开发\"></a><a href=\"https://zhuanlan.zhihu.com/p/32378432\" target=\"_blank\" rel=\"noopener\">技术雷达之「微前端」- 将微服务理念扩展到前端开发</a></h3><p>看标题就知道，这是一篇基本上看不懂的文章，不过图文并茂的形式让这篇文章生动了很多，内容很充实，覆盖面很广</p>\n<h3 id=\"理解-Web-路由\"><a href=\"#理解-Web-路由\" class=\"headerlink\" title=\"理解 Web 路由\"></a><a href=\"https://zhuanlan.zhihu.com/p/24814675\" target=\"_blank\" rel=\"noopener\">理解 Web 路由</a></h3><p>关于路由，其实是一个很抽象的概念，而这篇文章对经常提到的前端路由和后端路由的实现和区别进行了很详细很清晰的讲解，同时对动态路由和严格路由也进行了介绍。</p>\n<h3 id=\"一站到底—前端基础之网络\"><a href=\"#一站到底—前端基础之网络\" class=\"headerlink\" title=\"一站到底—前端基础之网络\"></a><a href=\"https://juejin.im/post/5b3357556fb9a00e5a4b63df\" target=\"_blank\" rel=\"noopener\">一站到底—前端基础之网络</a></h3><p>这篇文章算是近几年来我读过的信息量最大、知识点最全的文章了，作者从访问一个网址说起，为读者建立了一个健全的网络知识体系，该文章解答了以下问题：</p>\n<p><strong>必会：</strong></p>\n<ul>\n<li>http 报文都有哪些内容？</li>\n<li>HTTP 协议头含有哪些重要的部分，HTTP 状态码？</li>\n<li>HTTP 状态码状态码都有哪些？</li>\n<li>什么是强缓存？什么是弱缓存？</li>\n<li>浏览器的现缓存机制是什么？如何设置 HTTP 缓存？</li>\n<li>你知道有哪些 HTTP 方法？POST 和 PUT 有什么区别？</li>\n<li>如何对数据进行压缩（ZLIB），Gzip? 压缩的范围是什么，请求头会压缩吗？</li>\n<li>跨域，为什么 JS 会对跨域做出限制？如何允许跨域?</li>\n</ul>\n<p><strong>基础：</strong></p>\n<ul>\n<li>影响网速的原因有哪些？网络丢包的主要原因是什么？</li>\n<li>网络体系结构的五层参考模型都是什么？它们之间的关系是什么？</li>\n<li>我们常听到报文、段（分组）、数据报、帧、和数据包，它们有什么关系？</li>\n<li>Ajax 能发送 http 请求，它和 http 有什么样的关系？</li>\n<li>HTTP1.0 到 HTTP1.1 解决了什么问题？</li>\n<li>http2 有什么特性？</li>\n<li>http1.1 为什么会有队首阻塞？</li>\n<li>SSL 与 TLS 关系？HTTPS 协议如何实现？</li>\n</ul>\n<p><strong>补课与拓展：（慢慢更新）</strong></p>\n<ul>\n<li>常用的传输层协议有哪些？TCP 和 UDP 分别有什么特点？</li>\n<li>解释一下 TCP 的三次握手和四次挥手？</li>\n<li>为什么说 TCP 可能是网络通信的瓶颈？如何解决 TCP 队首阻塞？</li>\n<li>谷歌新出 QUIC 为什么要基于 UDP？</li>\n<li>QUIC 有哪些新特性，解决了什么问题？</li>\n</ul>\n<h3 id=\"WEB-服务器探究\"><a href=\"#WEB-服务器探究\" class=\"headerlink\" title=\"WEB 服务器探究\"></a><a href=\"https://wangzitian0.github.io/2017/06/27/WEB-server-explore/\" target=\"_blank\" rel=\"noopener\">WEB 服务器探究</a></h3><p>作者介绍了 web 服务器的基本概念，和常见的服务端演替路线。图文并茂的方式很容易理解，干货满满。</p>\n<h3 id=\"网站性能优化实战——从12-67s到1-06s的故事\"><a href=\"#网站性能优化实战——从12-67s到1-06s的故事\" class=\"headerlink\" title=\"网站性能优化实战——从12.67s到1.06s的故事\"></a><a href=\"http://imweb.io/topic/5b6fd3c13cb5a02f33c013bd\" target=\"_blank\" rel=\"noopener\">网站性能优化实战——从12.67s到1.06s的故事</a></h3><p>作者将<a href=\"http://jerryonlyzrj.com/resume/\" target=\"_blank\" rel=\"noopener\">自己的在线简历</a>进行了性能优化，首屏时间从 12.67s 降低到了 1.06s，这个过程中作者踩了很多坑，翻阅了很多书籍，最终总结出了这篇文章。文章涉及到的知识点比较全面，对性能优化进行了系统的介绍。</p>\n<h3 id=\"现代-Web-开发基础与工程实践\"><a href=\"#现代-Web-开发基础与工程实践\" class=\"headerlink\" title=\"现代 Web 开发基础与工程实践\"></a><a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">现代 Web 开发基础与工程实践</a></h3><p>前端大牛@王下邀月熊的著作，对 Web 开发基础与工程实践的相关博客、示例代码与开源项目、整理成的系列书籍等内容进行了总结，信息量异常庞大，包含以下篇章：</p>\n<ul>\n<li><a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/%E5%AF%BC%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">导论篇</a>: Web 开发简史与运行机制，数据流驱动的界面，模块化与组件化，工具化与工程化，前后端分离与 GraphQL，大前端与 WebAssembly。</li>\n<li><a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/%E5%9F%BA%E7%A1%80\" target=\"_blank\" rel=\"noopener\">基础篇</a>: 对于 HTML、CSS、DOM 等 Web 开发中涉及的基础知识与理念的总结介绍。</li>\n<li><a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5\" target=\"_blank\" rel=\"noopener\">工程实践篇</a>: 构建工具，测试，安全，WebAssembly。</li>\n<li><a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8C%96%E7%AF%87\" target=\"_blank\" rel=\"noopener\">架构优化篇</a>: 组件化，状态管理，性能优化，PWA。</li>\n<li><a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/React\" target=\"_blank\" rel=\"noopener\">React 篇</a>：近年来前端领域百花齐放，各种技术方案争妍斗艳，各领风骚。本书立足于其中的佼佼者 React，深入浅出的介绍 React、Webpack 、 ES6、Redux 、 MobX 等常见前端开发工具与开发库的用法，帮助初学者能够迅速成为一名合格前端工程师。而本书也不仅局限于工具使用的层面，探寻各种技术方案背后蕴含的设计思想与架构模式，从前端工程化的角度讨论前端开发者在进阶过程中需要掌握的工程实践、模块化与组件化、质量保障、性能优化等知识要点。最终帮助开发者在前端开发中能够因地制宜的指定合理方案，以尽可能快的速度实现可信赖的产品。</li>\n<li><a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/Vue\" target=\"_blank\" rel=\"noopener\">Vue 篇</a>：本部分目前正逐步启动，笔者的初衷是希望能够保证本书章节与 <a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/React\" target=\"_blank\" rel=\"noopener\">React 与前端工程化实践</a>尽可能一致，从而更方便地去介绍不同技术栈下相通的设计理念；目前本书的目录只是拷贝自 <a href=\"https://github.com/wxyyxc1992/Web-Series/blob/master/React\" target=\"_blank\" rel=\"noopener\">React 与前端工程化实践</a>，未来笔者会逐步完善。</li>\n</ul>\n<h3 id=\"雅虎前端优化35条规则翻译\"><a href=\"#雅虎前端优化35条规则翻译\" class=\"headerlink\" title=\"雅虎前端优化35条规则翻译\"></a><a href=\"https://github.com/creeperyang/blog/issues/1\" target=\"_blank\" rel=\"noopener\">雅虎前端优化35条规则翻译</a></h3><p>本文是大名鼎鼎的雅虎前端优化规则（<strong>Yslow</strong>）的翻译。作者对其中的一些例子进行了精简。</p>\n<h3 id=\"前端知识体系目录\"><a href=\"#前端知识体系目录\" class=\"headerlink\" title=\"前端知识体系目录\"></a><a href=\"http://hao.jser.com/archive/5314/\" target=\"_blank\" rel=\"noopener\">前端知识体系目录</a></h3><p>从基础到进阶，从 HTML、CSS、JS 到 HTTP，简单的总结了前端领域需要了解的知识点，同时推荐了一些书籍，对于那些想要入坑前端的童鞋来说是一份不错的指引文档。</p>\n<h3 id=\"微前端的那些事儿\"><a href=\"#微前端的那些事儿\" class=\"headerlink\" title=\"微前端的那些事儿\"></a><a href=\"https://github.com/phodal/microfrontends\" target=\"_blank\" rel=\"noopener\">微前端的那些事儿</a></h3><blockquote>\n<p>微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为<strong>多个小型前端应用聚合为一的应用</strong>。各个前端应用还可以<strong>独立运行</strong>、<strong>独立开发</strong>、<strong>独立部署</strong>。</p>\n</blockquote>\n<p>这篇文章是 phodal 对于微前端的解读，包括其实现方式以及方案对比，而微服务与前端的结合会有多大的优势，值得期待。</p>\n<h3 id=\"2018-前端常见题汇总\"><a href=\"#2018-前端常见题汇总\" class=\"headerlink\" title=\"2018 前端常见题汇总\"></a><a href=\"https://github.com/qianbin01/frontend_train\" target=\"_blank\" rel=\"noopener\">2018 前端常见题汇总</a></h3><p>汇总了前端一些问题，作者不定时更新，建议收藏</p>\n<ol>\n<li><a href=\"https://github.com/qianbin01/frontend_train#html\" target=\"_blank\" rel=\"noopener\">HTML 相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#css\" target=\"_blank\" rel=\"noopener\">CSS 相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#javascript\" target=\"_blank\" rel=\"noopener\">JAVASCRIPT 相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#dom\" target=\"_blank\" rel=\"noopener\">DOM 相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#http\" target=\"_blank\" rel=\"noopener\">HTTP 相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#vue\" target=\"_blank\" rel=\"noopener\">VUE 相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#sort\" target=\"_blank\" rel=\"noopener\">算法相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#web\" target=\"_blank\" rel=\"noopener\">网络安全相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#webpack\" target=\"_blank\" rel=\"noopener\">webpack 相关</a></li>\n<li><a href=\"https://github.com/qianbin01/frontend_train#other\" target=\"_blank\" rel=\"noopener\">其他</a></li>\n</ol>\n<h3 id=\"InfoQ-趋势报告之-JavaScript-和-Web-开发\"><a href=\"#InfoQ-趋势报告之-JavaScript-和-Web-开发\" class=\"headerlink\" title=\"InfoQ 趋势报告之 JavaScript 和 Web 开发\"></a><a href=\"https://www.infoq.cn/article/TFXQXkWbPPM*cK5KFJrW\" target=\"_blank\" rel=\"noopener\">InfoQ 趋势报告之 JavaScript 和 Web 开发</a></h3><p>文章简单介绍了 Javascript 生态系统的现状和发展历程，文中提到了很多名词和框架，是一篇很不错的“扫盲”文章。</p>\n<h3 id=\"2019-Web开发技术指南和趋势\"><a href=\"#2019-Web开发技术指南和趋势\" class=\"headerlink\" title=\"2019 - Web开发技术指南和趋势\"></a><a href=\"https://www.jianshu.com/p/062c978d9f04\" target=\"_blank\" rel=\"noopener\">2019 - Web开发技术指南和趋势</a></h3><p>这是一个 2019 年你成为前端，后端或全栈开发者的进阶指南:</p>\n<ol>\n<li>你不需要学习所有的技术成为一个 web 开发者</li>\n<li>这个指南只是通过简单分类列出了技术选项</li>\n<li>我将从我的经验和参考中给出建议</li>\n<li>首选我们会介绍通用的知识, 最后介绍 2019 年的 Web 的一些趋势</li>\n</ol>\n<p>要想知道更多细节, 请看 Youtube 视频: <a href=\"https://www.youtube.com/watch?v=UnTQVlqmDQ0&amp;t=18s\" target=\"_blank\" rel=\"noopener\">Web Development in 2019</a></p>\n<h3 id=\"前端模块化详解-完整版\"><a href=\"#前端模块化详解-完整版\" class=\"headerlink\" title=\"前端模块化详解(完整版)\"></a><a href=\"https://juejin.im/post/5c17ad756fb9a049ff4e0a62\" target=\"_blank\" rel=\"noopener\">前端模块化详解(完整版)</a></h3><p>这篇文章内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范，并且介绍下开发中最流行的 CommonJS, AMD, ES6、CMD 规范。作者试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望屏幕前的你阅读后，对模块化编程有个全新的认识和理解！</p>\n<h3 id=\"2018-前端性能优化清单\"><a href=\"#2018-前端性能优化清单\" class=\"headerlink\" title=\"2018 前端性能优化清单\"></a><a href=\"https://cherryblog.site/front-end-performance-checklist-2018.html\" target=\"_blank\" rel=\"noopener\">2018 前端性能优化清单</a></h3><p>英文原文：<a href=\"https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/\" target=\"_blank\" rel=\"noopener\">https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/</a>，文章较长，需要比较长的时间才能读完，涉及到的地方非常全面，五星推荐。</p>\n<h3 id=\"列一份前端知识架构图\"><a href=\"#列一份前端知识架构图\" class=\"headerlink\" title=\"列一份前端知识架构图\"></a><a href=\"https://time.geekbang.org/column/article/77804\" target=\"_blank\" rel=\"noopener\">列一份前端知识架构图</a></h3><p>计算机之子“Winter”列的一份前端知识框架图</p>\n<h3 id=\"茴字的四种写法—移动适配方案的进化\"><a href=\"#茴字的四种写法—移动适配方案的进化\" class=\"headerlink\" title=\"茴字的四种写法—移动适配方案的进化\"></a><a href=\"https://segmentfault.com/a/1190000014309664\" target=\"_blank\" rel=\"noopener\">茴字的四种写法—移动适配方案的进化</a></h3><p>这是一篇一站式的文章，可以系统的了解前端适配的演进。</p>\n<h3 id=\"现代前端开发路线图：从零开始，一步步成为前端工程师\"><a href=\"#现代前端开发路线图：从零开始，一步步成为前端工程师\" class=\"headerlink\" title=\"现代前端开发路线图：从零开始，一步步成为前端工程师\"></a><a href=\"https://36kr.com/p/5128487.html\" target=\"_blank\" rel=\"noopener\">现代前端开发路线图：从零开始，一步步成为前端工程师</a></h3><p>很多人都想学编程。但是苦于没有具体的步骤和指导。比如想找份前端开发的工作，却不知道应该先学习什么再学习什么，也不知道该选择什么样的工具。因为经常被人问到类似的问题，全栈开发者Kamran Ahmed索性在github上制订了一份<a href=\"https://github.com/kamranahmedse/developer-roadmap\" target=\"_blank\" rel=\"noopener\">现代前端开发的路线图</a>，并且用<a href=\"https://medium.com/tech-tajawal/modern-frontend-developer-in-2018-4c2072fa2b9c\" target=\"_blank\" rel=\"noopener\">一篇文章</a>对前端开发的整个学习过程进行了详细解释。感兴趣的初学者不容错过。</p>\n<p>而这篇文章的目的就是依次解释路线图的每一个步骤，对于前端初学者来说具有指引作用。</p>\n<h2 id=\"JS相关\"><a href=\"#JS相关\" class=\"headerlink\" title=\"JS相关\"></a>JS相关</h2><h3 id=\"统一回复《怎么学JavaScript？》\"><a href=\"#统一回复《怎么学JavaScript？》\" class=\"headerlink\" title=\"统一回复《怎么学JavaScript？》\"></a><a href=\"http://www.qdfuns.com/notes/17398/d3f6dd40e2d3ff15b209810dfa98be0b:storey-71.html\" target=\"_blank\" rel=\"noopener\">统一回复《怎么学JavaScript？》</a></h3><p>作者通过自己的经历告诉大家：如何学习前端。这是一篇很不错的前端入门文章，作者推荐了一些前端方面的书籍，同时还注明了这些书籍适合什么时候阅读以及适合怎样阅读，建议仍然不知道如何学前端的你好好看一下这篇文章</p>\n<h3 id=\"javascript-的-12-个怪癖（quirks）\"><a href=\"#javascript-的-12-个怪癖（quirks）\" class=\"headerlink\" title=\"javascript 的 12 个怪癖（quirks）\"></a><a href=\"http://justjavac.com/javascript/2013/04/08/12-javascript-quirks.html\" target=\"_blank\" rel=\"noopener\">javascript 的 12 个怪癖（quirks）</a></h3><p>实际上 javascript 是一个相当简洁的语言，但是也难免会有一些怪癖（quirks）。这是作者翻译的国外一个开发者的系列文章，同时在我发布之前（2017-8-7），作者还没有翻译团队，如果有英语比较好的前端小伙伴，欢迎加入翻译的队伍中，像我这种英语“战五渣”表示只能“拿来”了。。</p>\n<h3 id=\"80-应聘者都不及格的-JS-面试题\"><a href=\"#80-应聘者都不及格的-JS-面试题\" class=\"headerlink\" title=\"80% 应聘者都不及格的 JS 面试题\"></a><a href=\"https://juejin.im/post/58cf180b0ce4630057d6727c\" target=\"_blank\" rel=\"noopener\">80% 应聘者都不及格的 JS 面试题</a></h3><p>从最简单的 setTimeout() 执行队列，到自执行函数产生闭包，再到 ES6 中的 promise 以及 ES7 中的 async 和 await，作者通过一道不断延伸出来的js面试题讲解了在面试中经常遇到的问题，同时对以上的这些知识点进行了概括总结</p>\n<h3 id=\"翻译-We-have-a-problem-with-promises\"><a href=\"#翻译-We-have-a-problem-with-promises\" class=\"headerlink\" title=\"[翻译] We have a problem with promises\"></a><a href=\"http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/?qq-pf-to=pcqq.c2c\" target=\"_blank\" rel=\"noopener\">[翻译] We have a problem with promises</a></h3><p>promise 一直是被认为判断一名“前端工程师”是否仍然处在“初级”的利器，而这篇文章通过 promise 相关的四段代码对 promise 进行了深入剖析，这是一篇译文，英文原文可以<a href=\"http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看</p>\n<h3 id=\"学用-JavaScript-设计模式\"><a href=\"#学用-JavaScript-设计模式\" class=\"headerlink\" title=\"学用 JavaScript 设计模式\"></a><a href=\"http://wiki.jikexueyuan.com/project/javascript-design-patterns/constructor-mode.html\" target=\"_blank\" rel=\"noopener\">学用 JavaScript 设计模式</a></h3><p>设计模式的概念很早之前就有了，而 JS 虽然之前一直被认为是“做网页”的语言，但是JS中也有设计模式的思想，相信看完这个系列的文章之后，你会对 JS 有更加深入的理解，该系列文章对于没有“面向对象”语言基础的童鞋来说可能会有些难度，建议在看的过程中及时查阅其他资料。</p>\n<h3 id=\"ajax跨域，这应该是最全的解决方案了\"><a href=\"#ajax跨域，这应该是最全的解决方案了\" class=\"headerlink\" title=\"ajax跨域，这应该是最全的解决方案了\"></a><a href=\"https://segmentfault.com/a/1190000012469713\" target=\"_blank\" rel=\"noopener\">ajax跨域，这应该是最全的解决方案了</a></h3><p>看题目就很屌，恩。。</p>\n<h3 id=\"jQuery的document-ready与-onload事件——你真的思考过吗？\"><a href=\"#jQuery的document-ready与-onload事件——你真的思考过吗？\" class=\"headerlink\" title=\"jQuery的document ready与 onload事件——你真的思考过吗？\"></a><a href=\"https://www.cnblogs.com/lovesong/p/5641834.html\" target=\"_blank\" rel=\"noopener\">jQuery的document ready与 onload事件——你真的思考过吗？</a></h3><p>虽然题目看似和 jQuery 关系很大，但其实作者探究了很多 JS 相关问题，包括加载顺序以及 load 事件的产生原因，内容短小精悍，值得一看。下面这些问题是作者在文中所阐述探索的：</p>\n<ol>\n<li>window.onload 到底是什么加载完触发？</li>\n<li>body 为什么会有 onload 事件？</li>\n<li>为什么是 window.onload，而不是 document.onload？</li>\n<li>document ready到底是什么 ready，DOM 渲染完成？</li>\n<li>jQuery 怎么实现 $(document).ready？</li>\n<li>jQuery 的 ready，还能 ready 什么？</li>\n<li>jQuery 的 document ready 就一定比 window.onload 快吗？</li>\n<li>为什么外部 script 文件放页面内容后面好，是一定的吗？</li>\n</ol>\n<h3 id=\"10-分钟了解-JS-堆、栈以及事件循环的概念\"><a href=\"#10-分钟了解-JS-堆、栈以及事件循环的概念\" class=\"headerlink\" title=\"10 分钟了解 JS 堆、栈以及事件循环的概念\"></a><a href=\"https://github.com/BooheeFE/weekly/issues/2\" target=\"_blank\" rel=\"noopener\">10 分钟了解 JS 堆、栈以及事件循环的概念</a></h3><p>作者通过 <code>JS的内存机制</code>以及<code>事件机制</code>和<code>大量的（例子）</code>来讲解栈、堆究竟是个什么玩意。概念比较多，不用死读，把所有的实例代码手敲一遍就很清楚了，作者讲的很透彻，该文章来自于<a href=\"https://github.com/BooheeFE/weekly\" target=\"_blank\" rel=\"noopener\">薄荷前端周刊</a>，该周刊发布的文章都蛮不错的，建议阅读~</p>\n<h3 id=\"7-分钟理解-JS-的节流、防抖及使用场景\"><a href=\"#7-分钟理解-JS-的节流、防抖及使用场景\" class=\"headerlink\" title=\"7 分钟理解 JS 的节流、防抖及使用场景\"></a><a href=\"https://juejin.im/post/5b8de829f265da43623c4261?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">7 分钟理解 JS 的节流、防抖及使用场景</a></h3><p>防抖和节流是两个很重要也经常会用到的知识点，这篇文章的重点并不是介绍它们的实现原理，而是着眼于它们的应用效果和应用场景，文中对于防抖和节流产生效果的总结很通俗易懂：</p>\n<blockquote>\n<p>函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。<br>函数节流就是 fps 游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</p>\n</blockquote>\n<h3 id=\"精读-The-Cost-of-JavaScript\"><a href=\"#精读-The-Cost-of-JavaScript\" class=\"headerlink\" title=\"精读 The Cost of JavaScript\"></a><a href=\"https://zhuanlan.zhihu.com/p/41292532\" target=\"_blank\" rel=\"noopener\">精读 The Cost of JavaScript</a></h3><p>Addy 在 <a href=\"https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4\" target=\"_blank\" rel=\"noopener\">The Cost of JavaScript In 2018</a>一文中分享了在保证用户友好交互体验的前提下如何高效分发 JavaScript 的开发经验，而我现在推荐的这篇文章是一篇导读文章，原文作者首先将全文的内容压缩成几条观点总结出来，之后从用户体验为 Web 带来的变化开始说起，到 JavaScript 的成本有哪些、它们为何如此高昂、如何降低开销以及持续集成，全文形成一个非常完整的优化流程：</p>\n<ol>\n<li>写在开头的话</li>\n<li>膨胀的 JavaScript 与 Web 现状</li>\n<li>JavaScript 的成本所在</li>\n<li>页面交互性解释与建议</li>\n<li>处理 JavaScript 成本为何如此昂贵</li>\n<li>千差万别的移动用户与应对策略</li>\n<li>分发更少 JavaScript 的常见技巧</li>\n<li>持续集成四部曲</li>\n</ol>\n<h3 id=\"深入理解javascript原型和闭包系列\"><a href=\"#深入理解javascript原型和闭包系列\" class=\"headerlink\" title=\"深入理解javascript原型和闭包系列\"></a><a href=\"http://www.cnblogs.com/wangfupeng1988/p/4001284.html\" target=\"_blank\" rel=\"noopener\">深入理解javascript原型和闭包系列</a></h3><p>本系列有 16 篇文章，外加两篇后补的，一共 18 篇文章。将原型和闭包相关知识都进行了讲解，知识点很全，图文并茂。</p>\n<h3 id=\"JavaScript-模块化七日谈\"><a href=\"#JavaScript-模块化七日谈\" class=\"headerlink\" title=\"JavaScript 模块化七日谈\"></a><a href=\"https://github.com/Huxpro/js-module-7day\" target=\"_blank\" rel=\"noopener\">JavaScript 模块化七日谈</a></h3><p>作者以 slide 的形式讲解了 JS 模块化的发展历程，目录：</p>\n<ul>\n<li>第一日 上古时期 <em><strong>Module?</strong></em> 从设计模式说起</li>\n<li>第二日 石器时代 <em><strong>Script Loader</strong></em> 只有封装性可不够，我们还需要加载</li>\n<li>第三日 蒸汽朋克 <em><strong>Module Loader</strong></em> 模块化架构的工业革命</li>\n<li>第四日 号角吹响 <em><strong>CommonJS</strong></em> 征服世界的第一步是跳出浏览器</li>\n<li>第五日 双塔奇兵 <em><strong>AMD/CMD</strong></em> 浏览器环境模块化方案</li>\n<li>第六日 精灵宝钻 <em><strong>Browserify/Webpack</strong></em> 大势所趋，去掉这层包裹！</li>\n<li>第七日 王者归来 <em><strong>ES6 Module</strong></em> 最后的战役</li>\n</ul>\n<h3 id=\"写了-10-年-Javascript-未必全了解的连续赋值运算\"><a href=\"#写了-10-年-Javascript-未必全了解的连续赋值运算\" class=\"headerlink\" title=\"写了 10 年 Javascript 未必全了解的连续赋值运算\"></a><a href=\"https://yanhaijing.com/javascript/2012/04/05/javascript-continuous-assignment-operator/\" target=\"_blank\" rel=\"noopener\">写了 10 年 Javascript 未必全了解的连续赋值运算</a></h3><p><code>a.x = a = {n:2}</code> 是一个连续赋值表达式。 这个连续赋值表达式在引擎内部究竟发生了什么？是如何解释的？作者从这一问题出发，对 JS 中的变量定义规则进行了研究。</p>\n<h3 id=\"每个-JavaScript-工程师都应懂的33个概念\"><a href=\"#每个-JavaScript-工程师都应懂的33个概念\" class=\"headerlink\" title=\"每个 JavaScript 工程师都应懂的33个概念\"></a><a href=\"https://github.com/stephentian/33-js-concepts\" target=\"_blank\" rel=\"noopener\">每个 JavaScript 工程师都应懂的33个概念</a></h3><p>这篇文章是参照 @leonardomso 创立，英文版项目地址在<a href=\"https://github.com/leonardomso/33-js-concepts\" target=\"_blank\" rel=\"noopener\">这里</a>。 由于原版资源都要翻墙，所以作者创立了一个中文版，附上关于 JS 中的 33 个概念在国内的一些文章和视频。所以这可以看做是一个文章 / 视频集合，闲来无事的时候可以看一下巩固一下基础概念。</p>\n<h3 id=\"前端网老姚浅谈：怎么学-JavaScript？\"><a href=\"#前端网老姚浅谈：怎么学-JavaScript？\" class=\"headerlink\" title=\"前端网老姚浅谈：怎么学 JavaScript？\"></a><a href=\"https://zhuanlan.zhihu.com/p/23265155\" target=\"_blank\" rel=\"noopener\">前端网老姚浅谈：怎么学 JavaScript？</a></h3><p>前端老姚对如何学习JS这一问题的解答，主要回答了以下几个问题：</p>\n<ul>\n<li>看书有啥好处</li>\n<li>看什么书</li>\n<li>怎么看书</li>\n<li>看书的层次</li>\n<li>利用源码进行学习</li>\n<li>时间、兴趣等问题</li>\n</ul>\n<h3 id=\"Effective-JavaScript\"><a href=\"#Effective-JavaScript\" class=\"headerlink\" title=\"Effective JavaScript\"></a><a href=\"https://github.com/dreamapplehappy/effective-javascript\" target=\"_blank\" rel=\"noopener\">Effective JavaScript</a></h3><p>关于原生 JS 的 68 个实例，理论上,实践过下面的 68 个项目之后,你的JS能力应该有一个质的飞跃</p>\n<h3 id=\"how-javascript-works\"><a href=\"#how-javascript-works\" class=\"headerlink\" title=\"how javascript works\"></a><a href=\"https://github.com/Troland/how-javascript-works\" target=\"_blank\" rel=\"noopener\">how javascript works</a></h3><p>本文是翻译介绍 JavaScript 的工作原理的，该系列原文还在更新中，原文见<a href=\"https://blog.sessionstack.com/tagged/tutorial\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h3 id=\"JavaScript-This-的六道坎\"><a href=\"#JavaScript-This-的六道坎\" class=\"headerlink\" title=\"JavaScript This 的六道坎\"></a><a href=\"https://blog.crimx.com/2016/05/12/understanding-this/\" target=\"_blank\" rel=\"noopener\">JavaScript This 的六道坎</a></h3><p>鉴于 this 风骚的运作方式，对 this 的理解是永不过时的话题，该文试图通过将其大卸六块来钉住这个磨人的妖精。通过六个成语对 this 进行了剖析讲解，非常清晰明了。</p>\n<h3 id=\"从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理\"><a href=\"#从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理\" class=\"headerlink\" title=\"从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理\"></a><a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></h3><ol>\n<li>展现形式：由于是属于系统梳理型，就没有由浅入深了，而是从头到尾的梳理知识体系，重点是将关键节点的知识点串联起来，而不是仅仅剖析某一部分知识。</li>\n<li>内容是：从浏览器进程，再到浏览器内核运行，再到 JS 引擎单线程，再到 JS 事件循环机制，从头到尾系统的梳理一遍，摆脱碎片化，形成一个知识体系</li>\n<li>目标是：看完这篇文章后，对浏览器多进程，JS 单线程，JS 事件循环机制这些都能有一定理解，有一个知识体系骨架，而不是似懂非懂的感觉。</li>\n<li>另外，本文适合有一定经验的前端人员，<strong>新手请规避</strong>，避免受到过多的概念冲击。可以先存起来，有了一定理解后再看，也可以分成多批次观看，避免过度疲劳。</li>\n</ol>\n<p><strong>大纲</strong>：</p>\n<ul>\n<li>区分进程和线程</li>\n<li>浏览器是多进程的<ul>\n<li>浏览器都包含哪些进程？</li>\n<li>浏览器多进程的优势</li>\n<li>重点是浏览器内核（渲染进程）</li>\n<li>Browser进程和浏览器内核（Renderer进程）的通信过程</li>\n</ul>\n</li>\n<li>梳理浏览器内核中线程之间的关系<ul>\n<li>GUI渲染线程与JS引擎线程互斥</li>\n<li>JS阻塞页面加载</li>\n<li>WebWorker，JS的多线程？</li>\n<li>WebWorker与SharedWorker</li>\n</ul>\n</li>\n<li>简单梳理下浏览器渲染流程<ul>\n<li>load事件与DOMContentLoaded事件的先后</li>\n<li>css加载是否会阻塞dom树渲染？</li>\n<li>普通图层和复合图层</li>\n</ul>\n</li>\n<li>从Event Loop谈JS的运行机制<ul>\n<li>事件循环机制进一步补充</li>\n<li>单独说说定时器</li>\n<li>setTimeout而不是setInterval</li>\n</ul>\n</li>\n<li>事件循环进阶：macrotask与microtask</li>\n<li>写在最后的话</li>\n</ul>\n<h3 id=\"关于-Promise-的-9-个提示\"><a href=\"#关于-Promise-的-9-个提示\" class=\"headerlink\" title=\"关于 Promise 的 9 个提示\"></a><a href=\"https://mp.weixin.qq.com/s/1ILwZ6BecgBFA49c4YvTRQ\" target=\"_blank\" rel=\"noopener\">关于 Promise 的 9 个提示</a></h3><p>通过 9 个鲜活的案例，我们可以加深对 Promise 的理解</p>\n<h2 id=\"HTML相关\"><a href=\"#HTML相关\" class=\"headerlink\" title=\"HTML相关\"></a>HTML相关</h2><h3 id=\"常用的-HTML-头部标签\"><a href=\"#常用的-HTML-头部标签\" class=\"headerlink\" title=\"常用的 HTML 头部标签\"></a><a href=\"https://github.com/yisibl/blog/issues/1\" target=\"_blank\" rel=\"noopener\">常用的 HTML 头部标签</a></h3><p>曾几何时，我们已经不再手写 HTML 标签。Emmet、Markdown 等工具让我们「健步如飞」，但是我们真的了解这些标签了吗？这篇文章着重介绍了一些我们容易忽视和用错的头部标签，特别是 iOS 等针对移动设备的一些标签。这是一篇非常基础的标签索引，其中 iOS 设备部分对设计师也有参考作用。</p>\n<h3 id=\"H5-项目常见问题汇总及解决方案\"><a href=\"#H5-项目常见问题汇总及解决方案\" class=\"headerlink\" title=\"H5 项目常见问题汇总及解决方案\"></a><a href=\"https://github.com/FrontEndRoad/HTML5-FAQ\" target=\"_blank\" rel=\"noopener\">H5 项目常见问题汇总及解决方案</a></h3><p>这是一篇还算比较新的文章（2017-3-26），作者总结了一些前端开发过程中的常见问题，虽然有些问题可能不算是“常见”，但是看过一遍之后留下点印象也是可行的，到时候如果真遇到了不会解决的问题就知道去哪里找答案了~</p>\n<h3 id=\"HTML5-进阶系列：文件上传下载\"><a href=\"#HTML5-进阶系列：文件上传下载\" class=\"headerlink\" title=\"HTML5 进阶系列：文件上传下载\"></a><a href=\"https://juejin.im/post/59598ecf5188250d8d141fff\" target=\"_blank\" rel=\"noopener\">HTML5 进阶系列：文件上传下载</a></h3><p>HTML5 中提供的文件API在前端中有着丰富的应用，上传、下载、读取内容等在日常的交互中很常见。而且在各个浏览器的兼容也比较好，包括移动端。作者在该文中介绍了一些上传下载的 API，包括 FileList 对象和 file 对象、Blob 对象和 FileReader 对象等。</p>\n<h3 id=\"图片上传知识点梳理\"><a href=\"#图片上传知识点梳理\" class=\"headerlink\" title=\"图片上传知识点梳理\"></a><a href=\"https://juejin.im/post/5be023b651882516bc47762e\" target=\"_blank\" rel=\"noopener\">图片上传知识点梳理</a></h3><p>在日常项目开发中，图片上传是一个十分常见的场景。在这篇文章中，作者通过简单的代码，解析了图片上传的各个知识点，包括样式自定义、图片校验、图片上传预览、图片上传与上传进度展示和拖拽上传。</p>\n<h3 id=\"requestAnimationFrame-知多少？\"><a href=\"#requestAnimationFrame-知多少？\" class=\"headerlink\" title=\"requestAnimationFrame 知多少？\"></a><a href=\"www.cnblogs.com/onepixel/p/7078617.html\">requestAnimationFrame 知多少？</a></h3><p>html5 提供了一个专门用于请求动画的 API，即 requestAnimationFrame（rAF），顾名思义就是 “请求动画帧”。这篇文章就是带你深入理解 rAF 背后的原理。</p>\n<h2 id=\"CSS相关\"><a href=\"#CSS相关\" class=\"headerlink\" title=\"CSS相关\"></a>CSS相关</h2><h3 id=\"写-CSS-的姿势\"><a href=\"#写-CSS-的姿势\" class=\"headerlink\" title=\"写 CSS 的姿势\"></a><a href=\"https://www.w3cplus.com/css/css-evolution.html\" target=\"_blank\" rel=\"noopener\">写 CSS 的姿势</a></h3><p>作者-大漠，内容很丰富，放在第一位是有原因的。。</p>\n<h3 id=\"CSS-实现长宽比的几种方案\"><a href=\"#CSS-实现长宽比的几种方案\" class=\"headerlink\" title=\"CSS 实现长宽比的几种方案\"></a><a href=\"https://www.w3cplus.com/css/aspect-ratio.html\" target=\"_blank\" rel=\"noopener\">CSS 实现长宽比的几种方案</a></h3><p>作者是传说中的大漠孤秋，介绍了单纯用CSS实现定比例长宽图形的几种方案</p>\n<h3 id=\"实用的-CSS-—-贝塞尔曲线-cubic-bezier\"><a href=\"#实用的-CSS-—-贝塞尔曲线-cubic-bezier\" class=\"headerlink\" title=\"实用的 CSS — 贝塞尔曲线(cubic-bezier)\"></a><a href=\"http://joveyzheng.com/2016/03/16/css-cubic-bezier/\" target=\"_blank\" rel=\"noopener\">实用的 CSS — 贝塞尔曲线(cubic-bezier)</a></h3><p>贝塞尔曲线在 CSS 动画中应用较广，了解一下对于 CSS 动画效果会有更深的理解</p>\n<h3 id=\"探究-CSS-解析原理\"><a href=\"#探究-CSS-解析原理\" class=\"headerlink\" title=\"探究 CSS 解析原理\"></a><a href=\"http://jartto.wang/2017/11/13/Exploring-the-principle-of-CSS-parsing/index.html\" target=\"_blank\" rel=\"noopener\">探究 CSS 解析原理</a></h3><p>作者对浏览器的渲染过程和 CSS 的解析原理进行了详细解释，代码很多，干货满满</p>\n<h3 id=\"改变用户体验的滚动新特性\"><a href=\"#改变用户体验的滚动新特性\" class=\"headerlink\" title=\"改变用户体验的滚动新特性\"></a><a href=\"https://www.w3cplus.com/css/new-scroll-features-that-change-the-user-experience.html\" target=\"_blank\" rel=\"noopener\">改变用户体验的滚动新特性</a></h3><p>作者是大漠，他在文中介绍了时至今日，CSS 中为浏览器滚动提供的相关新特性究竟能给用户带来哪些新的体验。图片和代码较多，慎用流量</p>\n<h3 id=\"说说CSS学习中的瓶颈\"><a href=\"#说说CSS学习中的瓶颈\" class=\"headerlink\" title=\"说说CSS学习中的瓶颈\"></a><a href=\"https://www.zhangxinxu.com/wordpress/2012/07/bottleneck-css-study/\" target=\"_blank\" rel=\"noopener\">说说CSS学习中的瓶颈</a></h3><p>张鑫旭 2012 年的文章，虽然年代比较久远了，但是至今看来还是颇受启发，如果你有“CSS好难”、“为什么CSS那么多属性”、“怎么让它垂直居中啊”等疑问，推荐你看这篇文章。</p>\n<h3 id=\"「前端那些事儿」③-CSS-布局方案\"><a href=\"#「前端那些事儿」③-CSS-布局方案\" class=\"headerlink\" title=\"「前端那些事儿」③ CSS 布局方案\"></a><a href=\"https://juejin.im/post/5bd805e6f265da0acd2107d7\" target=\"_blank\" rel=\"noopener\">「前端那些事儿」③ CSS 布局方案</a></h3><p>作者几乎罗列了日常工作中遇到的所有类型的布局，并附上了详细的代码，其中包括：居中布局、多列布局、并排等分，单排对齐靠左布局和圣杯布局&amp;双飞翼布局等。源码传送门：<a href=\"https://github.com/willspace/css-layout/tree/master/demo-1\" target=\"_blank\" rel=\"noopener\">https://github.com/willspace/css-layout/tree/master/demo-1</a></p>\n<h3 id=\"深入了解-CSS3-新特性\"><a href=\"#深入了解-CSS3-新特性\" class=\"headerlink\" title=\"深入了解 CSS3 新特性\"></a><a href=\"https://www.ibm.com/developerworks/cn/web/1202_zhouxiang_css3/\" target=\"_blank\" rel=\"noopener\">深入了解 CSS3 新特性</a></h3><p>这篇文章介绍了 Web 开发中关于 CSS3 的一些内容，由浅入深的逐步引出 CSS3 的各种相关属性。基于各个 CSS3 属性的原理，通过实际的源代码介绍各个 CSS3 新特性的特点，使用方式以及使用中需要注意的地方</p>\n<h3 id=\"You-need-to-know-css\"><a href=\"#You-need-to-know-css\" class=\"headerlink\" title=\"You need to know css\"></a><a href=\"https://lhammer.cn/You-need-to-know-css/#/\" target=\"_blank\" rel=\"noopener\">You need to know css</a></h3><p>作者把自己的收获和工作中常用的一些 CSS 小样式总结成了这份文档，包含了 43 个 CSS 的小样式。</p>\n<h3 id=\"06期：前端布局基础概述\"><a href=\"#06期：前端布局基础概述\" class=\"headerlink\" title=\"06期：前端布局基础概述\"></a><a href=\"https://mp.weixin.qq.com/s/-LcNZWFFty2lWuND6uuNNA\" target=\"_blank\" rel=\"noopener\">06期：前端布局基础概述</a></h3><p>作者找到了W3C组织对初始化包含块的官方定义，为了让刚入前端圈的同学少走一些弯路，于是系统地分享一下，同时掺杂了作者本人在前端布局基础方面积累的经验。（因为是系统概述，所以篇幅会比较长，希望各位读者有心理准备）</p>\n<h3 id=\"在-css-中什么是好的注释？\"><a href=\"#在-css-中什么是好的注释？\" class=\"headerlink\" title=\"在 css 中什么是好的注释？\"></a><a href=\"https://mp.weixin.qq.com/s/963TnTMNAXstdIPYCTsrqQ\" target=\"_blank\" rel=\"noopener\">在 css 中什么是好的注释？</a></h3><blockquote>\n<p>注释就意味着代码无法自说明 —— Robert C. Martin</p>\n</blockquote>\n<p>Martin在文中详细讨论了代码注释，他的意思是，这些注释是注定会过时的。程序执行时会忽视注释，所以无法保证这些说明注释会准确的描述代码作用。所以最好的方式是让代码自说明，如此，按照代码逻辑，程序员和程序获取到的信息是一致的。读完这篇文章后，我们就知道该怎么写注释了。</p>\n<h2 id=\"框架相关\"><a href=\"#框架相关\" class=\"headerlink\" title=\"框架相关\"></a>框架相关</h2><h3 id=\"react-组件的生命周期\"><a href=\"#react-组件的生命周期\" class=\"headerlink\" title=\"react 组件的生命周期\"></a><a href=\"https://segmentfault.com/a/1190000003691119\" target=\"_blank\" rel=\"noopener\">react 组件的生命周期</a></h3><p>作者详细介绍了和 react 生命周期的一些函数执行时机以及它们的作用，通过实例的方式进行了讲解，个人感觉讲解的非常清晰</p>\n<h3 id=\"Gulp-和-Webpack-对比\"><a href=\"#Gulp-和-Webpack-对比\" class=\"headerlink\" title=\"Gulp 和 Webpack 对比\"></a><a href=\"http://www.jianshu.com/p/b1022d224817\" target=\"_blank\" rel=\"noopener\">Gulp 和 Webpack 对比</a></h3><p>作者通过实际的代码对比了 gulp 和 webpack 在功能、原理以及模块化方面的优缺点</p>\n<h3 id=\"webpack-常用插件及其作用\"><a href=\"#webpack-常用插件及其作用\" class=\"headerlink\" title=\"webpack 常用插件及其作用\"></a><a href=\"http://www.monster1935.site/blog/2017/08/24/webpack%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">webpack 常用插件及其作用</a></h3><p>介绍了 webpack 经常用到的一些插件和它们的作用，美中不足的是没有具体代码以及介绍的插件有点少</p>\n<h3 id=\"webpack-源码阅读——npm-脚本运行-webpack-与命令行输入-webpack-的区别\"><a href=\"#webpack-源码阅读——npm-脚本运行-webpack-与命令行输入-webpack-的区别\" class=\"headerlink\" title=\"webpack 源码阅读——npm 脚本运行 webpack 与命令行输入 webpack 的区别\"></a><a href=\"http://www.monster1935.site/blog/2017/09/07/webpack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-npm%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8Cwebpack%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5webpack%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/\" target=\"_blank\" rel=\"noopener\">webpack 源码阅读——npm 脚本运行 webpack 与命令行输入 webpack 的区别</a></h3><p>虽然是一个小知识点，不过作者读源码的精神可嘉</p>\n<h3 id=\"webpack-收藏集-掘金\"><a href=\"#webpack-收藏集-掘金\" class=\"headerlink\" title=\"webpack - 收藏集 - 掘金\"></a><a href=\"https://segmentfault.com/a/1190000009435832\" target=\"_blank\" rel=\"noopener\">webpack - 收藏集 - 掘金</a></h3><p>掘金上面的 webpack 相关文章，webpack 本身实在太复杂，还是需要一些文章差补缺漏的</p>\n<h3 id=\"Vue-js——60分钟快速入门\"><a href=\"#Vue-js——60分钟快速入门\" class=\"headerlink\" title=\"Vue.js——60分钟快速入门\"></a><a href=\"http://www.cnblogs.com/keepfool/p/5619070.html\" target=\"_blank\" rel=\"noopener\">Vue.js——60分钟快速入门</a></h3><p>vue 入门教程，还有另外两篇文章，文章最后有链接，个人认为是目前为止看到的最舒服的 vue 入门教程，排版配色都很不错</p>\n<h3 id=\"深入到源码：解读-redux-的设计思路与用法\"><a href=\"#深入到源码：解读-redux-的设计思路与用法\" class=\"headerlink\" title=\"深入到源码：解读 redux 的设计思路与用法\"></a><a href=\"https://github.com/Lucifier129/Lucifier129.github.io/issues/9\" target=\"_blank\" rel=\"noopener\">深入到源码：解读 redux 的设计思路与用法</a></h3><p>一直都没搞明白 redux，后来看了这篇文章，讲的很详细，而且讲解了一部分源码，推荐！（下面一段话取自该文章） 组织 <code>redux</code> 的流程莫过于：</p>\n<ul>\n<li>设计全局 state 的数据结构</li>\n<li>设计更改 state 数据的 actionTypes 常量以及其他跟视图展现相关的 actionTypes 常量</li>\n<li>根据 actionTypes 常量，书写 actionCreator 。</li>\n<li>根据各个 actionCreator 的返回值，涉及 reducer 做数据的最后处理</li>\n<li>在有了 reducer 函数之后，createStore(reducer, initState) 得到 store 对象</li>\n<li>用 bindActionCreators 函数将 actionCreators 和 store.dispatch 绑定起来，得到一组能修改全局状态的函数</li>\n<li>分发各个状态修改函数到各个 DOM 事件中。</li>\n</ul>\n<h3 id=\"Vue-生命周期深入\"><a href=\"#Vue-生命周期深入\" class=\"headerlink\" title=\"Vue 生命周期深入\"></a><a href=\"https://segmentfault.com/a/1190000014705819\" target=\"_blank\" rel=\"noopener\">Vue 生命周期深入</a></h3><p>这篇博客会从下面四个常见的应用诠释了组件的生命周期，以及各个生命周期应该干什么事，博主写的很不错，直观易懂，很适合接触 vue 不深的童鞋。</p>\n<ol>\n<li>单组件的生命周期</li>\n<li>父子组件的生命周期</li>\n<li>兄弟组件的生命周期</li>\n<li>宏 mixin 的生命周期</li>\n</ol>\n<h3 id=\"2019-年-Vue-学习路线图\"><a href=\"#2019-年-Vue-学习路线图\" class=\"headerlink\" title=\"2019 年 Vue 学习路线图\"></a><a href=\"https://mp.weixin.qq.com/s/jGmJndL-oK3i5lYLiQROIg\" target=\"_blank\" rel=\"noopener\">2019 年 Vue 学习路线图</a></h3><p>作者我将在这篇文章中展示了一个高级“知识地图”，它包含了与 Vue 开发相关的关键领域，你可以使用这张地图作为 2019 年学习 Vue 的图鉴。英文原文：<a href=\"https://vuejsdevelopers.com/2018/12/04/vue-js-2019-knowledge-map/\" target=\"_blank\" rel=\"noopener\">https://vuejsdevelopers.com/2018/12/04/vue-js-2019-knowledge-map/</a></p>\n<h3 id=\"一口-很长的-气了解-babel\"><a href=\"#一口-很长的-气了解-babel\" class=\"headerlink\" title=\"一口(很长的)气了解 babel\"></a><a href=\"https://juejin.im/post/5c19c5e0e51d4502a232c1c6\" target=\"_blank\" rel=\"noopener\">一口(很长的)气了解 babel</a></h3><p>作者详细介绍了 babel 究竟是做什么的，以及 babel 的一些配套工具的作用，同时还介绍了如何争取地进行配置和使用 babel。</p>\n<h3 id=\"Which-of-the-635000-npm-modules-do-I-choose\"><a href=\"#Which-of-the-635000-npm-modules-do-I-choose\" class=\"headerlink\" title=\"Which of the 635000 npm modules do I choose?\"></a><a href=\"https://www.coreycleary.me/which-of-the-635000-npm-modules-do-i-choose/\" target=\"_blank\" rel=\"noopener\">Which of the 635000 npm modules do I choose?</a></h3><p>npm 现在已经有 60 多万个库，如何在如此繁杂的 module 中选择合适自己的感觉是件难事，而作者就基于此对一些比较大型使用比较多的库进行了横向比较，会对你在技术上的选择起到帮助作用。</p>\n<h3 id=\"2019-年-React-学习路线图\"><a href=\"#2019-年-React-学习路线图\" class=\"headerlink\" title=\"2019 年 React 学习路线图\"></a><a href=\"https://mp.weixin.qq.com/s/PWSeeqDwu8QOcamlo_FJrA\" target=\"_blank\" rel=\"noopener\">2019 年 React 学习路线图</a></h3><p>和上面的 Vue 学习路线图类似，建议搭配食用，英文原文：<a href=\"https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02\" target=\"_blank\" rel=\"noopener\">https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02</a></p>\n<h3 id=\"细说-webpack-之流程篇\"><a href=\"#细说-webpack-之流程篇\" class=\"headerlink\" title=\"细说 webpack 之流程篇\"></a><a href=\"http://taobaofed.org/blog/2016/09/09/webpack-flow/\" target=\"_blank\" rel=\"noopener\">细说 webpack 之流程篇</a></h3><p>淘宝 FED 这篇博客，对 webpack 的整体流程梳理的非常清晰，以及 webpack 的基础架构讲解的很细致，对 compiler 和 complation 对象也做了很细致的剖析。</p>\n<h3 id=\"React-是怎样炼成的\"><a href=\"#React-是怎样炼成的\" class=\"headerlink\" title=\"React 是怎样炼成的\"></a><a href=\"https://segmentfault.com/a/1190000013365426\" target=\"_blank\" rel=\"noopener\">React 是怎样炼成的</a></h3><p>文章主要讲述 React 的诞生过程和优化思路。内容整理自 2014 年的 <a href=\"https://speakerdeck.com/vjeux/oscon-react-architecture\" target=\"_blank\" rel=\"noopener\">OSCON - React Architecture by vjeux</a>，虽然从今天来看可能会有点历史感，但仍然值得学习了解。以史为鉴，从中也可以管窥 Facebook 优秀的工程管理文化。</p>\n<h2 id=\"浏览器相关\"><a href=\"#浏览器相关\" class=\"headerlink\" title=\"浏览器相关\"></a>浏览器相关</h2><h3 id=\"浏览器进程？线程？傻傻分不清楚！\"><a href=\"#浏览器进程？线程？傻傻分不清楚！\" class=\"headerlink\" title=\"浏览器进程？线程？傻傻分不清楚！\"></a><a href=\"http://www.imweb.io/topic/58e3bfa845e5c13468f567d5\" target=\"_blank\" rel=\"noopener\">浏览器进程？线程？傻傻分不清楚！</a></h3><p>什么是多进程架构浏览器？为什么浏览器内核是多线程？Javascript 是单线程又是什么鬼？进程和线程是否分得清楚呢？文章干货和知识点比较多，需要查阅相关知识才能完全消化。</p>\n<h3 id=\"WebView-性能、体验分析与优化\"><a href=\"#WebView-性能、体验分析与优化\" class=\"headerlink\" title=\"WebView 性能、体验分析与优化\"></a><a href=\"https://tech.meituan.com/WebViewPerf.html\" target=\"_blank\" rel=\"noopener\">WebView 性能、体验分析与优化</a></h3><p>来自美团的技术文档，对 webview 的方方面面都进行了详细的介绍，同时指出了其存在的问题，相信看完之后对于 webview 会有更深层次的理解~</p>\n<h3 id=\"浅析-HTTP-缓存的机制-浏览器缓存\"><a href=\"#浅析-HTTP-缓存的机制-浏览器缓存\" class=\"headerlink\" title=\"浅析 HTTP 缓存的机制-浏览器缓存\"></a><a href=\"http://obkoro1.com/2018/06/09/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\" target=\"_blank\" rel=\"noopener\">浅析 HTTP 缓存的机制-浏览器缓存</a></h3><p>在浏览器众多缓存中的 HTTP 缓存可能很多人对这个的概念并没有很清晰，每个人都知道进入一次网页之后再刷新一次页面，加载速度会比首次加载快非常多，每个人都知道这是浏览器缓存的 magic，但是对此背后的原因可能不甚了解；作者结合状态码介绍了强缓存和弱缓存的区别和触发条件，篇幅短小精悍，值得一读。</p>\n<h3 id=\"深入理解-JSCore\"><a href=\"#深入理解-JSCore\" class=\"headerlink\" title=\"深入理解 JSCore\"></a><a href=\"https://juejin.im/post/5b7f6a27e51d4538b063f233?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">深入理解 JSCore</a></h3><p>目前业界流行的动态化方案，如 Facebook 的 React Native，阿里巴巴的 Weex 都采用了前端系的 DSL 方案，而它们在 iOS 系统上能够顺利的运行，都离不开一个背后的功臣：JavaScriptCore（以下简称 JSCore），它建立起了 Objective-C（以下简称OC）和 JavaScript（以下简称 JS）两门语言之间沟通的桥梁。作者从浏览器谈起，对 Webkit 内核的工作原理和组成进行了详细介绍，同时介绍了 JSCore 的组成部分：词法分析、语法分析和解释执行，后面还介绍了 iOS 中的 JSCore 的应用和一些机制，篇幅较长，但是干货满满，如果你对浏览器渲染引擎感兴趣，这篇文章值得一看~</p>\n<h3 id=\"H5-唤起-APP-指南-附开源唤端库\"><a href=\"#H5-唤起-APP-指南-附开源唤端库\" class=\"headerlink\" title=\"H5 唤起 APP 指南(附开源唤端库)\"></a><a href=\"https://juejin.im/post/5b7efb2ee51d45388b6af96c?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">H5 唤起 APP 指南(附开源唤端库)</a></h3><p>唤端的定义：引导已下载用户打开 APP，引导未下载用户下载 APP。对于用户留存来讲，唤起 App 是一种很重要的手段，这篇文章可以说把所有和唤端相关的知识点都介绍了，最后还给自己的工具打了一发广告。。</p>\n<h3 id=\"当···时发生了什么？\"><a href=\"#当···时发生了什么？\" class=\"headerlink\" title=\"当···时发生了什么？\"></a><a href=\"https://github.com/skyline75489/what-happens-when-zh_CN\" target=\"_blank\" rel=\"noopener\">当···时发生了什么？</a></h3><p>这个仓库试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？不过作者不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。包括一些硬件知识也包含其中，我相信如果面试官问到你这道题，然后你的回答是这篇文章里面描述的话，面试官肯定会大吃一惊！</p>\n<h3 id=\"HTTP-HTTP2-0-SPDY-HTTPS-你应该知道的一些事\"><a href=\"#HTTP-HTTP2-0-SPDY-HTTPS-你应该知道的一些事\" class=\"headerlink\" title=\"HTTP, HTTP2.0, SPDY, HTTPS 你应该知道的一些事\"></a><a href=\"http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/\" target=\"_blank\" rel=\"noopener\">HTTP, HTTP2.0, SPDY, HTTPS 你应该知道的一些事</a></h3><p>作为一个经常和 web 打交道的程序员，了解这些协议是必须的，而这篇文章就向大家介绍了一下这些协议的区别和基本概念，文中不局限于前端知识，还包括一些运维，协议方面的知识。</p>\n<h3 id=\"浏览器的工作原理：新式网络浏览器幕后揭秘\"><a href=\"#浏览器的工作原理：新式网络浏览器幕后揭秘\" class=\"headerlink\" title=\"浏览器的工作原理：新式网络浏览器幕后揭秘\"></a><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_browser_main_functionality\" target=\"_blank\" rel=\"noopener\">浏览器的工作原理：新式网络浏览器幕后揭秘</a></h3><p>这是一篇全面介绍 WebKit 和 Gecko 内部操作的入门文章，是以色列开发人员塔利·加希尔大量研究的成果。在过去的几年中，她查阅了所有公开发布的关于浏览器内部机制的数，并花了很多时间来研读网络浏览器的源代码。 网络浏览器很可能是使用最广的软件。在这篇入门文章中，作者将会介绍它们的幕后工作原理。我们会了解到，从在地址栏输入 <code>google.com</code> 直到在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。文章讲解的很详细，篇幅较长，需要比较大的耐心才能看下去。</p>\n<h3 id=\"HTTP-请求头中的-X-Forwarded-For\"><a href=\"#HTTP-请求头中的-X-Forwarded-For\" class=\"headerlink\" title=\"HTTP 请求头中的 X-Forwarded-For\"></a><a href=\"https://imququ.com/post/x-forwarded-for-header-in-http.html\" target=\"_blank\" rel=\"noopener\">HTTP 请求头中的 X-Forwarded-For</a></h3><p>这篇文章对 HTTP 请求头中的 X-Forwarded-For（XFF）进行了详细的讲解，当我们需要取到用户的真实 IP 时，对这个请求头的理解和使用就显得尤为重要了，而从这个应用场景出发，作者还对请求头中的 x-real-ip 字段以及 Remote Address 进行了介绍。作者还有关于 HTTP 的其他文章，可以<a href=\"https://imququ.com/post/series.html\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看更多。</p>\n<h3 id=\"图解浏览器的基本工作原理\"><a href=\"#图解浏览器的基本工作原理\" class=\"headerlink\" title=\"图解浏览器的基本工作原理\"></a><a href=\"https://zhuanlan.zhihu.com/p/47407398\" target=\"_blank\" rel=\"noopener\">图解浏览器的基本工作原理</a></h3><p>可能每一个前端工程师都想要理解浏览器的工作原理。我们希望知道从在浏览器地址栏中输入 url 到页面展现的短短几秒内浏览器究竟做了什么；我们希望了解平时常常听说的各种代码优化方案是究竟为什么能起到优化的作用；我们希望更细化的了解浏览器的渲染流程。那么这篇文章就解答了上面的所有问题，文章较长，图文并茂。</p>\n<h3 id=\"Content-Security-Policy-An-Introduction\"><a href=\"#Content-Security-Policy-An-Introduction\" class=\"headerlink\" title=\"Content Security Policy - An Introduction\"></a><a href=\"https://scotthelme.co.uk/content-security-policy-an-introduction/\" target=\"_blank\" rel=\"noopener\">Content Security Policy - An Introduction</a></h3><p>一篇介绍 CSP 的文章，介绍了我们为什么需要 CSP，以及涉及到 CSP 的一些协议头等等相关信息。</p>\n<h3 id=\"认识-HTTP—-Cookie-和-Session-篇\"><a href=\"#认识-HTTP—-Cookie-和-Session-篇\" class=\"headerlink\" title=\"认识 HTTP—-Cookie 和 Session 篇\"></a><a href=\"https://zhuanlan.zhihu.com/p/27669892https://zhuanlan.zhihu.com/p/27669892https://zhuanlan.zhihu.com/p/27669892https://zhuanlan.zhihu.com/p/27669892\" target=\"_blank\" rel=\"noopener\">认识 HTTP—-Cookie 和 Session 篇</a></h3><p>虽然内容大多来自《图解HTTP》一书，但是条理清楚分明，文笔很好，作者解释的很清晰。</p>\n<h3 id=\"图解基于-HTTPS-的-DNS\"><a href=\"#图解基于-HTTPS-的-DNS\" class=\"headerlink\" title=\"图解基于 HTTPS 的 DNS\"></a><a href=\"https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https\" target=\"_blank\" rel=\"noopener\">图解基于 HTTPS 的 DNS</a></h3><p>这是关于 dns 查询的过程讲解，配上插图和文字，可以对 dns 的查询过程有一个大概了解。</p>\n<h3 id=\"理解-WebKit-和-Chromium\"><a href=\"#理解-WebKit-和-Chromium\" class=\"headerlink\" title=\"理解 WebKit 和 Chromium\"></a><a href=\"https://blog.csdn.net/milado_nju/article/details/7216067\" target=\"_blank\" rel=\"noopener\">理解 WebKit 和 Chromium</a></h3><p>系统的描述了 Chrome 浏览器的信息，可以更加全面的了解 Chrome 浏览器，最给力的是有很多工具的使用介绍。</p>\n<h3 id=\"你真的了解回流和重绘吗\"><a href=\"#你真的了解回流和重绘吗\" class=\"headerlink\" title=\"你真的了解回流和重绘吗?\"></a><a href=\"https://github.com/chenjigeng/blog/blob/master/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%E5%90%97.md\" target=\"_blank\" rel=\"noopener\">你真的了解回流和重绘吗?</a></h3><p>这篇文章主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，可以帮助读者更好的理解回流重绘。</p>\n<h3 id=\"这样使用GPU动画\"><a href=\"#这样使用GPU动画\" class=\"headerlink\" title=\"这样使用GPU动画\"></a><a href=\"https://www.w3cplus.com/animation/gpu-animation-doing-it-right.html\" target=\"_blank\" rel=\"noopener\">这样使用GPU动画</a></h3><p><a href=\"https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/\" target=\"_blank\" rel=\"noopener\">《GPU Animation: Doing It Right》</a>的译文，这篇文章能帮助你更好地了解浏览器如何使用GPU来渲染，这样你就可以创作能在所有设备上快速运行的令人印象深刻的网站。著作权归作者所有。</p>\n<h2 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h2><h3 id=\"编码简介：utf8-utf16-以及其它\"><a href=\"#编码简介：utf8-utf16-以及其它\" class=\"headerlink\" title=\"编码简介：utf8, utf16 以及其它\"></a><a href=\"https://github.com/creeperyang/blog/issues/4\" target=\"_blank\" rel=\"noopener\">编码简介：utf8, utf16 以及其它</a></h3><p>作者对 utf8 和 utf16 以及其它相关知识进行了介绍，前端同学可能很少会关注到字符编码规则，但是有时候我们经常会遇到乱码等问题和 Bug，而在阅读完这篇文章之后，相信你对字符编码这类知识会有一个很深的理解。</p>\n<h3 id=\"可以说的秘密-那些我们该讨论的前端加密方法\"><a href=\"#可以说的秘密-那些我们该讨论的前端加密方法\" class=\"headerlink\" title=\"可以说的秘密-那些我们该讨论的前端加密方法\"></a><a href=\"https://juejin.im/entry/5bc93545e51d450e5f3dceff\" target=\"_blank\" rel=\"noopener\">可以说的秘密-那些我们该讨论的前端加密方法</a></h3><p>这篇文章介绍了前端开发中常用的加密方法并给出了其适用场景。包括 Base64 编码、哈希算法、加盐、慢哈希函数、密钥哈希、XOR 和加密（Encrypt）等加密方法，</p>\n<h3 id=\"一个由正则表达式引发的血案（解决版）\"><a href=\"#一个由正则表达式引发的血案（解决版）\" class=\"headerlink\" title=\"一个由正则表达式引发的血案（解决版）\"></a><a href=\"https://zhuanlan.zhihu.com/p/46294360\" target=\"_blank\" rel=\"noopener\">一个由正则表达式引发的血案（解决版）</a></h3><p>正则表达式一直以来是广大码农处理字符串的福音，但与此同时，也容易引发血案。这篇文章从一则实例出发，对正则表达式可能引发的 CPU 爆表问题进行了分析，同时作者还介绍了一种遗传算法，该算法解决了如下问题：</p>\n<blockquote>\n<p>给定一个正则引擎和一个正则表达式，为这个正则表达式找到一个攻击字符串，它可以最大化正则引擎的匹配时间。</p>\n</blockquote>\n<p>感兴趣的童鞋可以认真研究一下这篇文章，或者作者发表的论文。</p>\n<h3 id=\"计算的本质：赋值和流的杂谈\"><a href=\"#计算的本质：赋值和流的杂谈\" class=\"headerlink\" title=\"计算的本质：赋值和流的杂谈\"></a><a href=\"https://mp.weixin.qq.com/s/UYOy9dCCci5P_Cc7OVp5sg\" target=\"_blank\" rel=\"noopener\">计算的本质：赋值和流的杂谈</a></h3><p>写了这么久的程序，不少人肯定会有疑问，<strong>计算的本质</strong>是什么？对一台图灵机来说，那就是无限长的纸带和能够自如移动的读写头，但这太抽象了。作者换了一种方式去理解计算并总结出了这篇文章，稍微有一些晦涩难懂，不过看完大有裨益。</p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"漫画：什么是动态规划？\"><a href=\"#漫画：什么是动态规划？\" class=\"headerlink\" title=\"漫画：什么是动态规划？\"></a><a href=\"https://mp.weixin.qq.com/s/uHlSIPDrzwlyyGTwnkslbQ\" target=\"_blank\" rel=\"noopener\">漫画：什么是动态规划？</a></h3><p>以漫画的形式生动形象的解释了动态规划是什么，以及其解法。虽然篇幅较长，但是漫画看起来一点都不枯燥。</p>\n<h3 id=\"漫画：如何求根号2（爱奇艺面试题）\"><a href=\"#漫画：如何求根号2（爱奇艺面试题）\" class=\"headerlink\" title=\"漫画：如何求根号2（爱奇艺面试题）\"></a><a href=\"https://mp.weixin.qq.com/s/is7ffzf1pofMchpT3azsOg\" target=\"_blank\" rel=\"noopener\">漫画：如何求根号2（爱奇艺面试题）</a></h3><p>用漫画的形式讲解了二分法和牛顿迭代法，最后还给出了源码</p>\n<h3 id=\"2018汇总数据结构算法篇\"><a href=\"#2018汇总数据结构算法篇\" class=\"headerlink\" title=\"2018汇总数据结构算法篇\"></a><a href=\"https://mp.weixin.qq.com/s/7WweVX6j_ZMyaSnYr8q5Ug\" target=\"_blank\" rel=\"noopener\">2018汇总数据结构算法篇</a></h3><p>用图文的方式对一些数据结构进行了通俗易懂的解释，内容非常基础和全面。</p>\n<h2 id=\"服务层相关\"><a href=\"#服务层相关\" class=\"headerlink\" title=\"服务层相关\"></a>服务层相关</h2><h3 id=\"node-基础面试事件环？微任务、宏任务？一篇带你飞\"><a href=\"#node-基础面试事件环？微任务、宏任务？一篇带你飞\" class=\"headerlink\" title=\"node 基础面试事件环？微任务、宏任务？一篇带你飞\"></a><a href=\"https://juejin.im/post/5b35cdfa51882574c020d685\" target=\"_blank\" rel=\"noopener\">node 基础面试事件环？微任务、宏任务？一篇带你飞</a></h3><p>这是一篇很干货的文章，作者介绍了 node 的应用场景以及特性，同时还顺带着介绍了同步/异步、阻塞/非阻塞、微任务/宏任务这些 node 面试中经常遇到的知识点，虽然篇幅不是很长，但是涵盖的范围比较广，对于刚入门前端的童鞋来说有比较大的难度，不过对于那些已使用 node 一段时间的童鞋来说是一篇不错的总结类文章。</p>\n<h3 id=\"Error-Handling-in-Node-js\"><a href=\"#Error-Handling-in-Node-js\" class=\"headerlink\" title=\"Error Handling in Node.js\"></a><a href=\"https://www.joyent.com/node-js/production/design/errors\" target=\"_blank\" rel=\"noopener\">Error Handling in Node.js</a></h3><p>关于 NodeJS 中异常的种类，以及应该如何处理异常方面的设计文章，比较长，而且是英文的，但比较受益。（有没有大佬翻译一把？）</p>\n<h3 id=\"开发者需要了解的-nodejs-中-require-的机制\"><a href=\"#开发者需要了解的-nodejs-中-require-的机制\" class=\"headerlink\" title=\"开发者需要了解的 nodejs 中 require 的机制\"></a><a href=\"https://juejin.im/post/5bdea6b1518825170f50c485\" target=\"_blank\" rel=\"noopener\">开发者需要了解的 nodejs 中 require 的机制</a></h3><p>对 nodejs 中的模块加载进行了详细的讲解，同时对 exports 和 module.exports 的区别和正确使用方式也进行了讲解，是一篇非常不错的 nodejs 模块方面的文章，该文为译文，原文地址：<a href=\"https://medium.freecodecamp.org/requiring-modules-in-node-js-everything-you-need-to-know-e7fbd119be8\" target=\"_blank\" rel=\"noopener\">https://medium.freecodecamp.org/requiring-modules-in-node-js-everything-you-need-to-know-e7fbd119be8</a></p>\n<h3 id=\"CDN-技术详解\"><a href=\"#CDN-技术详解\" class=\"headerlink\" title=\"CDN 技术详解\"></a><a href=\"https://www.cnblogs.com/losbyday/p/5843960.html\" target=\"_blank\" rel=\"noopener\">CDN 技术详解</a></h3><p>《CDN技术详解》绝对是带你进入 CDN 行业的那盏最亮的明灯。因此，虽然只是纯粹的重点抄录，作者还是把《CDN技术详解》中的精华总结成了这篇文章。</p>\n<h3 id=\"漫画-从搬家到容器技术-Docker-应用场景解析\"><a href=\"#漫画-从搬家到容器技术-Docker-应用场景解析\" class=\"headerlink\" title=\"漫画 | 从搬家到容器技术 Docker 应用场景解析\"></a><a href=\"https://mp.weixin.qq.com/s/wHEVltlOOAffWILB1hqFjg\" target=\"_blank\" rel=\"noopener\">漫画 | 从搬家到容器技术 Docker 应用场景解析</a></h3><p>通过漫画的方式对 Docker 的原理和应用场景进行了比较详细的介绍和讲解</p>\n<h3 id=\"不仅仅是前端er——折腾服务器武装自己\"><a href=\"#不仅仅是前端er——折腾服务器武装自己\" class=\"headerlink\" title=\"不仅仅是前端er——折腾服务器武装自己\"></a><a href=\"https://segmentfault.com/a/1190000013242438\" target=\"_blank\" rel=\"noopener\">不仅仅是前端er——折腾服务器武装自己</a></h3><p>作者从购买服务器和购买域名讲起，将搭建网站的详细过程进行了介绍，同时还包括 nginx 配置文件的修改以及持续部署的配置。</p>\n<h2 id=\"Mac相关\"><a href=\"#Mac相关\" class=\"headerlink\" title=\"Mac相关\"></a>Mac相关</h2><h3 id=\"EffectiveMac\"><a href=\"#EffectiveMac\" class=\"headerlink\" title=\"EffectiveMac\"></a><a href=\"https://mac.bestswifter.com/\" target=\"_blank\" rel=\"noopener\">EffectiveMac</a></h3><p>作者是在今日头条任职的 iOS 高级工程师，在这篇文章里介绍了 Mac 的一些使用技巧以及配置指南，包括 Vim、Git、Zsh 等工具的使用方式，是截止到目前为止我看过的最全面、最实用的 Mac 教程，经常用 Mac 的童鞋一定要抽空看一看！</p>\n<h2 id=\"前沿\"><a href=\"#前沿\" class=\"headerlink\" title=\"前沿\"></a>前沿</h2><h3 id=\"GraphQL-and-Relay-浅析\"><a href=\"#GraphQL-and-Relay-浅析\" class=\"headerlink\" title=\"GraphQL and Relay 浅析\"></a><a href=\"https://zhuanlan.zhihu.com/p/20638731\" target=\"_blank\" rel=\"noopener\">GraphQL and Relay 浅析</a></h3><p>相信大部分人都没听说过 GraphQL 和 Relay 吧，这篇文章就对这两样东西进行了介绍，同时文章结尾还有一些扩展阅读链接</p>\n<h3 id=\"译文：Puppeteer-与-Chrome-Headless-——-从入门到爬虫\"><a href=\"#译文：Puppeteer-与-Chrome-Headless-——-从入门到爬虫\" class=\"headerlink\" title=\"译文：Puppeteer 与 Chrome Headless —— 从入门到爬虫\"></a><a href=\"http://csbun.github.io/blog/2017/09/puppeteer/\" target=\"_blank\" rel=\"noopener\">译文：Puppeteer 与 Chrome Headless —— 从入门到爬虫</a></h3><p><a href=\"https://github.com/GoogleChrome/puppeteer\" target=\"_blank\" rel=\"noopener\"><code>Puppeteer</code></a> 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具。正因为这个官方声明，许多业内自动化测试库都已经停止维护，包括 <strong><a href=\"http://phantomjs.org/\" target=\"_blank\" rel=\"noopener\">PhantomJS</a></strong>。<strong><a href=\"https://addons.mozilla.org/en-US/firefox/addon/selenium-ide/\" target=\"_blank\" rel=\"noopener\">Selenium IDE for Firefox</a></strong> 项目也因为缺乏维护者而终止。</p>\n<h3 id=\"初探-Headless-Chrome\"><a href=\"#初探-Headless-Chrome\" class=\"headerlink\" title=\"初探 Headless Chrome\"></a><a href=\"https://zhuanlan.zhihu.com/p/27100187\" target=\"_blank\" rel=\"noopener\">初探 Headless Chrome</a></h3><p>Headless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序。相比于现代浏览器，Headless Chrome 更加方便测试 web 应用，获得网站的截图，做爬虫抓取信息等。相比于出道较早的 PhantomJS，SlimerJS 等，Headless Chrome 则更加贴近浏览器环境。</p>\n<h3 id=\"译-React-Native-vs-Cordova、PhoneGap、Ionic，等等\"><a href=\"#译-React-Native-vs-Cordova、PhoneGap、Ionic，等等\" class=\"headerlink\" title=\"[译] React Native vs. Cordova、PhoneGap、Ionic，等等\"></a>[译] React Native vs. Cordova、PhoneGap、Ionic，等等</h3><p>原文链接：<a href=\"https://learnreact.design/2018/02/14/react-native-vs-cordova-phone-gap-ionic-etc\" target=\"_blank\" rel=\"noopener\">https://learnreact.design/2018/02/14/react-native-vs-cordova-phone-gap-ionic-etc</a>，主要解释了以下几个问题：</p>\n<ul>\n<li>什么是原生应用？</li>\n<li>什么是 WebView UI ？</li>\n<li>更原生化的框架的优势和劣势分别是什么？原生化更少的框架呢？</li>\n<li>React Native 与 Cordova 相比如何？</li>\n</ul>\n<h2 id=\"求职\"><a href=\"#求职\" class=\"headerlink\" title=\"求职\"></a>求职</h2><h3 id=\"如何写面向互联网公司的求职简历\"><a href=\"#如何写面向互联网公司的求职简历\" class=\"headerlink\" title=\"如何写面向互联网公司的求职简历\"></a><a href=\"http://blog.devtang.com/2013/12/22/how-to-write-resume-for-it-company/\" title=\"如何写面向互联网公司的求职简历\" target=\"_blank\" rel=\"noopener\">如何写面向互联网公司的求职简历</a></h3><p>作者在 IT 公司工作了六年，有着三年面试官的经历。文章主要内容为：</p>\n<ul>\n<li>简历的页数不要超过两页（最好一页）<ul>\n<li>删掉不必要的信息</li>\n<li>如果你实在太牛逼，最多写 2 页</li>\n</ul>\n</li>\n<li>重要的信息写在最前面<ul>\n<li>你的联系方式</li>\n<li>你最重要的工作经历</li>\n</ul>\n</li>\n<li>不要简单罗列工作经历<ul>\n<li>列出你的工作中有价值的细节（有哪些技术上的困难等）</li>\n</ul>\n</li>\n<li>不要写任何虚假或夸大的信息<ul>\n<li>类似精通 java，精通 C/C++ 等</li>\n</ul>\n</li>\n<li>不要附加任何可能带来负面印象的信息<ul>\n<li>不要加照片</li>\n<li>不要写政治面貌</li>\n<li>不要写奇怪的爱好（打游戏，喝酒，抽烟）</li>\n<li>不要写参加过某某培训公司的 iOS 培训</li>\n<li>尽量用专业邮箱</li>\n<li>用 PDF 格式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"让-BAT-的-Offer-不再难拿\"><a href=\"#让-BAT-的-Offer-不再难拿\" class=\"headerlink\" title=\"让 BAT 的 Offer 不再难拿\"></a><a href=\"https://github.com/bestswifter/blog/commit/40885de8e065b774973ac52ef3f72de84cb19f69\" title=\"[Add] 让 BAT 的 Offer 不再难拿\" target=\"_blank\" rel=\"noopener\">让 BAT 的 Offer 不再难拿</a></h3><p>作者是软件工程专业，对 Web 前端感兴趣，目前从事 iOS 开发，对开发效率的提升以及工具的使用有很深入研究和思考，相信他总结的这篇面经一定不会让你失望。</p>\n<h3 id=\"一篇文章搞定前端面试\"><a href=\"#一篇文章搞定前端面试\" class=\"headerlink\" title=\"一篇文章搞定前端面试\"></a><a href=\"https://juejin.im/post/5bbaa549e51d450e827b6b13\" target=\"_blank\" rel=\"noopener\">一篇文章搞定前端面试</a></h3><p>这篇文章旨在用最通俗的语言讲述最枯燥的基本知识，文章提纲：</p>\n<ol>\n<li>TCP</li>\n<li>UDP</li>\n<li>套接字 socket</li>\n<li>HTTP 协议</li>\n<li>DNS 解析</li>\n<li>HTTP 请求发起和响应</li>\n<li>页面渲染的过程</li>\n<li>页面的性能优化</li>\n</ol>\n<h3 id=\"OpenDoc-前端简历评级标准\"><a href=\"#OpenDoc-前端简历评级标准\" class=\"headerlink\" title=\"OpenDoc - 前端简历评级标准\"></a><a href=\"https://zhuanlan.zhihu.com/p/27996237\" target=\"_blank\" rel=\"noopener\">OpenDoc - 前端简历评级标准</a></h3><p>美团团队从工作意向、工作经历、教育经历、技术栈、基础知识五个维度评价简历，仅供参考。</p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><h3 id=\"严选Redesign\"><a href=\"#严选Redesign\" class=\"headerlink\" title=\"严选Redesign\"></a><a href=\"https://www.zcool.com.cn/work/ZMjAxNjc4ODQ=.html\" target=\"_blank\" rel=\"noopener\">严选Redesign</a></h3><p>这篇文章来自站酷，介绍了网易严选的设计风格和思路，包括一些颜色规范、版面设计和图标选择\b等等。</p>\n<h3 id=\"移动端设计样式库-导航设计（二）\"><a href=\"#移动端设计样式库-导航设计（二）\" class=\"headerlink\" title=\"移动端设计样式库-导航设计（二）\"></a><a href=\"https://mp.weixin.qq.com/s/MVvh9dh0BGK1w2mnqnmURg\" target=\"_blank\" rel=\"noopener\">移动端设计样式库-导航设计（二）</a></h3><p>作者对移动端界面设计中另一个常见的导航模式-瞬时导航进行了介绍，对导航的实现方式以及优缺点进行了十分详细的介绍。</p>\n<h3 id=\"斗鱼5-0全新升级\"><a href=\"#斗鱼5-0全新升级\" class=\"headerlink\" title=\"斗鱼5.0全新升级\"></a><a href=\"https://www.zcool.com.cn/work/ZMzIxNDAxNjg=.html\" target=\"_blank\" rel=\"noopener\">斗鱼5.0全新升级</a></h3><p>来自站酷，文章篇幅较长，详细介绍了斗鱼 APP 和网页的设计思路。</p>\n<h3 id=\"有哪些好看的字体可以免费用？看完这篇就知道了（附字体安装包）\"><a href=\"#有哪些好看的字体可以免费用？看完这篇就知道了（附字体安装包）\" class=\"headerlink\" title=\"有哪些好看的字体可以免费用？看完这篇就知道了（附字体安装包）\"></a><a href=\"https://mp.weixin.qq.com/s/-YTanYeFMuoPYrMG7F5RfA\" target=\"_blank\" rel=\"noopener\">有哪些好看的字体可以免费用？看完这篇就知道了（附字体安装包）</a></h3><p>目录：</p>\n<ul>\n<li>为什么字体需要收费？</li>\n<li>有哪些免费商用字体？</li>\n<li>使用字体时需要注意什么？</li>\n</ul>\n<h3 id=\"PPT中的图片不会排版-给你这份超全设计模板\"><a href=\"#PPT中的图片不会排版-给你这份超全设计模板\" class=\"headerlink\" title=\"PPT中的图片不会排版?给你这份超全设计模板\"></a><a href=\"https://mp.weixin.qq.com/s/Mu9guK8ppCjIyJOikWilJA\" target=\"_blank\" rel=\"noopener\">PPT中的图片不会排版?给你这份超全设计模板</a></h3><p>关于PPT排版，每天都有很多人问，图片应该怎么排版？而这篇文章，就是为你展示这些图片排版的范例。文章非常详细的介绍了 PPT 中有不同数量的图片时的排版技巧，干货满满。</p>\n<h2 id=\"文章集合\"><a href=\"#文章集合\" class=\"headerlink\" title=\"文章集合\"></a>文章集合</h2><h3 id=\"奇文共欣赏，疑义相与析\"><a href=\"#奇文共欣赏，疑义相与析\" class=\"headerlink\" title=\"奇文共欣赏，疑义相与析\"></a><a href=\"https://github.com/jawil/blog/issues/6\" target=\"_blank\" rel=\"noopener\">奇文共欣赏，疑义相与析</a></h3><p>总结了很多不错的前端文章，领域包括ES6、前端基础、React、Webpack、TypeScript 等等，大概 100 篇左右，信息量很大。</p>\n<h3 id=\"年终回顾，为你汇总一份「前端技术清单」\"><a href=\"#年终回顾，为你汇总一份「前端技术清单」\" class=\"headerlink\" title=\"年终回顾，为你汇总一份「前端技术清单」\"></a><a href=\"https://juejin.im/post/5bdfb387e51d452c8e0aa902\" target=\"_blank\" rel=\"noopener\">年终回顾，为你汇总一份「前端技术清单」</a></h3><p>作者对前端基础相关好文以及前沿技术类文章进行了汇总，框架类的文章较少，期待作者继续补充完善。</p>\n<h3 id=\"微信网络技术的一些整理与思考\"><a href=\"#微信网络技术的一些整理与思考\" class=\"headerlink\" title=\"微信网络技术的一些整理与思考\"></a><a href=\"https://mp.weixin.qq.com/s/SHQay5wlz2fQ1xwQoh5eBA\" target=\"_blank\" rel=\"noopener\">微信网络技术的一些整理与思考</a></h3><p>在弱网情况下所有 app 中微信是几乎唯一一个能够正常工作的，大家都比较好奇为什么微信能够达到这样的效果。\b而作者收集了一些微信公开的网络优化相关的材料，特地分享于此。</p>\n<h3 id=\"五星推荐的系列文章清单\"><a href=\"#五星推荐的系列文章清单\" class=\"headerlink\" title=\"五星推荐的系列文章清单\"></a><a href=\"https://juejin.im/post/5c1f01fef265da61587723f4\" target=\"_blank\" rel=\"noopener\">五星推荐的系列文章清单</a></h3><p>大部分文章需要翻墙，文章有一些难度，需要一定的基础知识。</p>\n<h3 id=\"年度榜单！我整理了2018年所有文章和素材资源。\"><a href=\"#年度榜单！我整理了2018年所有文章和素材资源。\" class=\"headerlink\" title=\"年度榜单！我整理了2018年所有文章和素材资源。\"></a><a href=\"https://mp.weixin.qq.com/s/nKgeQ5guQJvmoeD5fTPdUA\" target=\"_blank\" rel=\"noopener\">年度榜单！我整理了2018年所有文章和素材资源。</a></h3><p>公众号【三顿】整理出的2018年这一年中全网值得一看的 PPT 文章。如果你对 PPT 感兴趣或者想寻找一些素材和创意，不妨在年末照着这份榜单，给自己充充电吧~</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"单点登录原理与简单实现\"><a href=\"#单点登录原理与简单实现\" class=\"headerlink\" title=\"单点登录原理与简单实现\"></a><a href=\"https://www.jianshu.com/p/a2c4b877be7d\" target=\"_blank\" rel=\"noopener\">单点登录原理与简单实现</a></h3><p>很多产品中都会有 SSO（单点登录）的实现，而本篇文章就十分详尽的介绍了 SSO 的原理，同时介绍了实现方式。</p>\n<h3 id=\"区块链，将如何重新定义世界？\"><a href=\"#区块链，将如何重新定义世界？\" class=\"headerlink\" title=\"区块链，将如何重新定义世界？\"></a><a href=\"https://mp.weixin.qq.com/s/ikPBVTsOhOWyyJKJBf021w\" target=\"_blank\" rel=\"noopener\">区块链，将如何重新定义世界？</a></h3><p>最近，区块链真的很火，同时区块链结束被认为是继蒸汽机、电力、互联网之后，下一代颠覆性的核心技术。在这篇文章里，作者用最容易理解的方式解答了以下 4 个问题：</p>\n<ol>\n<li>区块链的本质到底是什么？</li>\n<li>区块链技术带来的三大巨变。</li>\n<li>区块链面临的两大技术挑战。</li>\n<li>区块链技术未来的发展脉络。</li>\n</ol>\n<p>不过，文章篇幅较长，做好心理准备……</p>\n<h3 id=\"也许，这样理解-HTTPS-更容易\"><a href=\"#也许，这样理解-HTTPS-更容易\" class=\"headerlink\" title=\"也许，这样理解 HTTPS 更容易\"></a><a href=\"http://showme.codes/2017-02-20/understand-https/\" target=\"_blank\" rel=\"noopener\">也许，这样理解 HTTPS 更容易</a></h3><p>作者从一个经常遇到的例子开始介绍为什么我们需要 HTTPS，同时推荐一本书《HTTP权威指南》</p>\n<h3 id=\"做为技术人员为什么要写博客\"><a href=\"#做为技术人员为什么要写博客\" class=\"headerlink\" title=\"做为技术人员为什么要写博客\"></a><a href=\"http://www.cnblogs.com/zery/p/3343893.html\" target=\"_blank\" rel=\"noopener\">做为技术人员为什么要写博客</a></h3><p>技术人员写博客这件事本身就很据争议，有人认为真正的大牛是不需要写博客来博人眼球的，也有人认为水平不够还写博客就是个笑话。而这篇文章就为你解释了上面这两个问题，最后和这篇文章一样，附上一句名言：<strong>有些事情你现在不去做，可能以后都不会有机会了！</strong></p>\n<h3 id=\"从苹果公开-macOS-和-iOS-内核源码说起，分享一些开源知识\"><a href=\"#从苹果公开-macOS-和-iOS-内核源码说起，分享一些开源知识\" class=\"headerlink\" title=\"从苹果公开 macOS 和 iOS 内核源码说起，分享一些开源知识\"></a><a href=\"https://mp.weixin.qq.com/s/4ma3tHBBSC_pINOtcpQtYA\" target=\"_blank\" rel=\"noopener\">从苹果公开 macOS 和 iOS 内核源码说起，分享一些开源知识</a></h3><p>聊了聊开源精神、介绍了些开源社区，分享了点开源项目，仅此而已（还嫌不够？）</p>\n<h3 id=\"高质量文章精选-收藏集-掘金\"><a href=\"#高质量文章精选-收藏集-掘金\" class=\"headerlink\" title=\"高质量文章精选 - 收藏集 - 掘金\"></a><a href=\"https://segmentfault.com/a/1190000010448008\" target=\"_blank\" rel=\"noopener\">高质量文章精选 - 收藏集 - 掘金</a></h3><p>掘金发到 segmentfault 上的高质量文章集合，涵盖了编程领域的各个方面</p>\n<h3 id=\"程序员字典：「牛逼」\"><a href=\"#程序员字典：「牛逼」\" class=\"headerlink\" title=\"程序员字典：「牛逼」\"></a><a href=\"https://zhuanlan.zhihu.com/p/25050829\" target=\"_blank\" rel=\"noopener\">程序员字典：「牛逼」</a></h3><p>作者通过他在招人时的“奇葩”条件展开阐述了到底如何定义一个“牛逼”的程序员，从作者的字里行间可以看出，作者是一名资深程序员，同时更是一名资深面试官和 team leader，所以这篇文章对于入门级程序员和骨灰级程序猿来说都是极好的</p>\n<h3 id=\"给网站加-HTTPS-完全指南\"><a href=\"#给网站加-HTTPS-完全指南\" class=\"headerlink\" title=\"给网站加 HTTPS 完全指南\"></a><a href=\"https://ksmx.me/letsencrypt-ssl-https/\" target=\"_blank\" rel=\"noopener\">给网站加 HTTPS 完全指南</a></h3><p>作者介绍了如何给自己的个人网站加 https，虽然具体是否可行我还没有尝试，但是如果你有这个需求，这篇文章也许会帮到你。</p>\n<h3 id=\"反击爬虫，前端工程师的脑洞可以有多大？\"><a href=\"#反击爬虫，前端工程师的脑洞可以有多大？\" class=\"headerlink\" title=\"反击爬虫，前端工程师的脑洞可以有多大？\"></a><a href=\"http://litten.me/2017/07/09/prevent-spiders/\" target=\"_blank\" rel=\"noopener\">反击爬虫，前端工程师的脑洞可以有多大？</a></h3><p>对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。 而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是<strong>爬虫与反爬虫</strong>这一话题的由来。 作为前端工程师，我们可以增加一下游戏难度，设计出一些<strong>很(sang)有(xin)意(bing)思(kuang)</strong>的反爬虫策略。</p>\n<h3 id=\"原创译文-2016年学习Javascript是一种什么样的体验？\"><a href=\"#原创译文-2016年学习Javascript是一种什么样的体验？\" class=\"headerlink\" title=\"[原创译文] 2016年学习Javascript是一种什么样的体验？\"></a><a href=\"https://mp.weixin.qq.com/s/sYFhD55nHsxtjN_f_wfPLA\" target=\"_blank\" rel=\"noopener\">[原创译文] 2016年学习Javascript是一种什么样的体验？</a></h3><p>与其说这是一篇好文章，还不如说这是一篇好吐槽，和上面那篇类似，作者想表达的都是“前端疲劳”这件事，只不过通过对话的形式让画风变得轻松愉快。</p>\n<h3 id=\"17-张程序员壁纸推荐\"><a href=\"#17-张程序员壁纸推荐\" class=\"headerlink\" title=\"17 张程序员壁纸推荐\"></a><a href=\"http://www.runoob.com/w3cnote/17-wallpaper-for-programmer.html\" target=\"_blank\" rel=\"noopener\">17 张程序员壁纸推荐</a></h3><p>不算是一篇好文章，但是这 17 张壁纸着实不错~</p>\n<h3 id=\"前后端分离实践（一）\"><a href=\"#前后端分离实践（一）\" class=\"headerlink\" title=\"前后端分离实践（一）\"></a><a href=\"https://segmentfault.com/a/1190000009329474\" target=\"_blank\" rel=\"noopener\">前后端分离实践（一）</a></h3><p>很多人都不理解甚至误解了“前后端分离”这一概念，相信这篇文章可以让你搞明白到底什么是前后端分离以及我们在什么业务场景下需要前后端分离和如何做才算前后端分离。</p>\n<h3 id=\"程序员怎么升职？\"><a href=\"#程序员怎么升职？\" class=\"headerlink\" title=\"程序员怎么升职？\"></a><a href=\"https://www.zhihu.com/question/20259295\" target=\"_blank\" rel=\"noopener\">程序员怎么升职？</a></h3><p>知乎上关于“程序员怎么升职”这个问题的回答，我认认真真的阅读了获得最高赞的那个回答，感觉说的很对，其中有很多道理是我一直保持认同的，希望每一位从事这个行业的人都可以花时间看一下并思考。</p>\n<h3 id=\"当你练习表达的时候，开场白是怎样去设计呢\"><a href=\"#当你练习表达的时候，开场白是怎样去设计呢\" class=\"headerlink\" title=\"当你练习表达的时候，开场白是怎样去设计呢\"></a><a href=\"http://www.jianshu.com/p/f76c540e3158\" target=\"_blank\" rel=\"noopener\">当你练习表达的时候，开场白是怎样去设计呢</a></h3><p>不管你从事什么职业，表达自己都是一项必备技能。而如何表达自己，如何吸引听众呢？这篇文章从生物学的角度阐述了开场白的重要性以及什么样的开场白才会吸引到听众，同时作者还有同一类型的其他文章，感兴趣的话可以多读读。</p>\n<h3 id=\"程序员的鄙视链\"><a href=\"#程序员的鄙视链\" class=\"headerlink\" title=\"程序员的鄙视链\"></a><a href=\"http://www.techug.com/post/look-down-chains-of-programmer.html\" target=\"_blank\" rel=\"noopener\">程序员的鄙视链</a></h3><p>如果你看了以上这些惨绝人寰的鄙视链之后，仍然没有击倒你想要学习 coding 的心，那我必须提醒你一件最重要的事：先去交一个女朋友，再来学写程序；因为一旦你成为软件工程师之后，就交不到女朋友了。</p>\n<h3 id=\"JavaScript-疲劳终极指南：我们行业的真相\"><a href=\"#JavaScript-疲劳终极指南：我们行业的真相\" class=\"headerlink\" title=\"JavaScript 疲劳终极指南：我们行业的真相\"></a><a href=\"http://www.zcfy.cc/article/3914\" target=\"_blank\" rel=\"noopener\">JavaScript 疲劳终极指南：我们行业的真相</a></h3><p>抱怨 JS 疲劳就像是在抱怨人类发明了太多解决问题的工具：从邮件到飞机到宇宙飞船。<strong>这篇文章的目的是希望改变你对软件工程行业的普遍的看法，助你在你可能工作的领域上一臂之力</strong>。</p>\n<h3 id=\"超大型-JavaScript-应用的设计哲学\"><a href=\"#超大型-JavaScript-应用的设计哲学\" class=\"headerlink\" title=\"超大型 JavaScript 应用的设计哲学\"></a><a href=\"https://zhuanlan.zhihu.com/p/35929167\" target=\"_blank\" rel=\"noopener\">超大型 JavaScript 应用的设计哲学</a></h3><p>这篇文章为译文，基于 <a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40cramforce\" target=\"_blank\" rel=\"noopener\">Malte Ubl</a> 在 JSConf Australia 的演讲速记稿和现场视频整理而来，<a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DZZmUwXEiPm4\" target=\"_blank\" rel=\"noopener\">你可以在 YouTube 上观看完整演讲</a>。这篇文章很长，文中讨论了前端领域很多热门的话题与技术，知识点很多很密集。</p>\n<h3 id=\"图解Git\"><a href=\"#图解Git\" class=\"headerlink\" title=\"图解Git\"></a><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">图解Git</a></h3><p>图解 git 中的最常用命令。如果你稍微理解 git 的工作原理，这篇文章能够让你理解的更透彻。</p>\n<h3 id=\"如何成为一名优秀的全栈工程师\"><a href=\"#如何成为一名优秀的全栈工程师\" class=\"headerlink\" title=\"如何成为一名优秀的全栈工程师\"></a><a href=\"https://www.jianshu.com/p/f0d134ed7fd0\" target=\"_blank\" rel=\"noopener\">如何成为一名优秀的全栈工程师</a></h3><p>现在感觉“全栈工程师”已经成为了一个梗，然而，实际上全栈工程师是真实存在的，并且是一类对产品和业务发展起到很重要作用的工程师，该文章有点鸡汤，理论偏多。</p>\n<h3 id=\"路由器爱国上网、屏蔽广告与宽带提速\"><a href=\"#路由器爱国上网、屏蔽广告与宽带提速\" class=\"headerlink\" title=\"路由器爱国上网、屏蔽广告与宽带提速\"></a><a href=\"http://fullstack.blog/2018/03/27/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%88%B1%E5%9B%BD%E4%B8%8A%E7%BD%91%E3%80%81%E5%B1%8F%E8%94%BD%E5%B9%BF%E5%91%8A%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8F%90%E9%80%9F/\" target=\"_blank\" rel=\"noopener\">路由器爱国上网、屏蔽广告与宽带提速</a></h3><p>作者介绍了利用小米路由器实现爱国上网的具体操作流程，而路由器经过改造之后，所有接入的终端就都可以实现爱国上网了，简直是一劳永逸，而且作者在文章末尾还介绍了宽带提速的方法，每月只要十几块钱，就可以享受 100M 网络了，效果非常明显。</p>\n<h3 id=\"中文文案排版指北\"><a href=\"#中文文案排版指北\" class=\"headerlink\" title=\"中文文案排版指北\"></a><a href=\"https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">中文文案排版指北</a></h3><p>提供统一中文文案、排版的相关用法，降低团队成员之间的沟通成本。</p>\n<h3 id=\"前端开发工程师必读书籍有哪些值得推荐？\"><a href=\"#前端开发工程师必读书籍有哪些值得推荐？\" class=\"headerlink\" title=\"前端开发工程师必读书籍有哪些值得推荐？\"></a><a href=\"https://www.zhihu.com/question/22591993\" target=\"_blank\" rel=\"noopener\">前端开发工程师必读书籍有哪些值得推荐？</a></h3><p>来自知乎，书荒的童鞋不妨一看。</p>\n<h3 id=\"提问的智慧\"><a href=\"#提问的智慧\" class=\"headerlink\" title=\"提问的智慧\"></a><a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md\" target=\"_blank\" rel=\"noopener\">提问的智慧</a></h3><p>原文网址：<a href=\"http://www.catb.org/~esr/faqs/smart-questions.html\" target=\"_blank\" rel=\"noopener\">http://www.catb.org/~esr/faqs/smart-questions.html</a>，文章比较长，但是看完会很有收获，提问也是有很多需要注意的地方的，好的提问方式不仅能够更快的获得想要的答案，还可以提高自己的情商，获得他人的认可。</p>\n<h3 id=\"个人分享–web-前端学习资源分享\"><a href=\"#个人分享–web-前端学习资源分享\" class=\"headerlink\" title=\"个人分享–web 前端学习资源分享\"></a><a href=\"https://juejin.im/post/5a0c1956f265da430a501f51\" target=\"_blank\" rel=\"noopener\">个人分享–web 前端学习资源分享</a></h3><p>掘金-守候i分享的前端学习资源，包括一些不错的教程和文章、大牛博客、前端团队博客、推荐书籍、推荐社区、公众号、推荐关注项目和综合项目教程等等。</p>\n<h3 id=\"理解-OAuth-2-0\"><a href=\"#理解-OAuth-2-0\" class=\"headerlink\" title=\"理解 OAuth 2.0\"></a><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解 OAuth 2.0</a></h3><p><a href=\"http://en.wikipedia.org/wiki/OAuth\" target=\"_blank\" rel=\"noopener\">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。在这篇文章中，阮一峰对 OAuth 2.0 的设计思路和运行流程，做了一个简明通俗的解释。</p>\n<h3 id=\"以色列简史，简到崩溃，笑到流泪！\"><a href=\"#以色列简史，简到崩溃，笑到流泪！\" class=\"headerlink\" title=\"以色列简史，简到崩溃，笑到流泪！\"></a><a href=\"https://mp.weixin.qq.com/s/8Kvgu6sSU57U1q-1K1G-XA\" target=\"_blank\" rel=\"noopener\">以色列简史，简到崩溃，笑到流泪！</a></h3><p>以图文和人物对话的方式对巴以冲突的历史原因以及以色列的历史进行了介绍，风趣幽默，通过一种别样的方式了解历史，我很喜欢。</p>\n<h3 id=\"97-Things-Every-Programmer-Should-Know\"><a href=\"#97-Things-Every-Programmer-Should-Know\" class=\"headerlink\" title=\"97 Things Every Programmer Should Know\"></a><a href=\"https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/\" target=\"_blank\" rel=\"noopener\">97 Things Every Programmer Should Know</a></h3><p>同事推荐的文章，97 个程序员需要知道的理论，文章内容较长，读起来可能比较枯燥，而且暂时没有看到中文版本。。</p>\n<h3 id=\"为什么你统计-PV-的方式是错的？\"><a href=\"#为什么你统计-PV-的方式是错的？\" class=\"headerlink\" title=\"为什么你统计 PV 的方式是错的？\"></a><a href=\"https://juejin.im/post/58ef1fcc570c3500561c2e89\" target=\"_blank\" rel=\"noopener\">为什么你统计 PV 的方式是错的？</a></h3><p>翻译自 Google 工程师 Philip Walton 的<a href=\"https://philipwalton.com/articles/how-we-track-pageviews-is-all-wrong/\" target=\"_blank\" rel=\"noopener\">文章</a>。该文会帮你剖析为什么你常用的统计方式是错的？然后给出可行的解决方案。</p>\n<h3 id=\"编程语言拟人化\"><a href=\"#编程语言拟人化\" class=\"headerlink\" title=\"编程语言拟人化\"></a><a href=\"http://blog.jobbole.com/63311/\" target=\"_blank\" rel=\"noopener\">编程语言拟人化</a></h3><p>作者将各种语言都拟人化了，并赋予了他们一些特征，很有意思。</p>\n<h3 id=\"入门前端一周年总结-我是如何快速入门前端的知识分享\"><a href=\"#入门前端一周年总结-我是如何快速入门前端的知识分享\" class=\"headerlink\" title=\"入门前端一周年总结-我是如何快速入门前端的知识分享\"></a><a href=\"https://juejin.im/post/5c2c18116fb9a049fb43c32c\" target=\"_blank\" rel=\"noopener\">入门前端一周年总结-我是如何快速入门前端的知识分享</a></h3><p>作者虽然入门前端才一年，但是已经有 14K star 的开源项目，面试了几十人，拥有丰富的面试经验，在这篇总结里作者分享了一下自己的学习方式和资源，值得学习与研究。</p>\n<h3 id=\"从平面设计师到前端工程师：五个月的转变历程\"><a href=\"#从平面设计师到前端工程师：五个月的转变历程\" class=\"headerlink\" title=\"从平面设计师到前端工程师：五个月的转变历程\"></a><a href=\"https://mp.weixin.qq.com/s/JGADqRL56xfHM37Cix4VEw\" target=\"_blank\" rel=\"noopener\">从平面设计师到前端工程师：五个月的转变历程</a></h3><p>作者通过自己的转行经历对前端知识路线进行了概括，同时还提供了一些很好的自学资源，包括视频和文章。原文：<a href=\"https://medium.com/@vinceshao/graphic-designer-to-front-end-developer-ch-3e1ac681eea8\" target=\"_blank\" rel=\"noopener\">https://medium.com/@vinceshao/graphic-designer-to-front-end-developer-ch-3e1ac681eea8</a></p>\n","raw":null,"categories":[{"name":"summary","path":"api/categories/summary.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"推荐","path":"api/tags/推荐.json"}]},{"title":"JS中的对象系统","slug":"JS中的对象系统","date":"2017-08-07T02:10:23.000Z","updated":"2019-01-29T09:23:55.532Z","comments":true,"path":"api/articles/JS中的对象系统.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_111.png","content":"<p>转载自<a href=\"http://www.jianshu.com/p/d0930dc0f95d\" target=\"_blank\" rel=\"noopener\">简书-浅析JavaScript的对象系统</a> 首先，你肯定在不少地方看到过这句话：</p>\n<blockquote>\n<p>JavaScript 中一切皆对象</p>\n</blockquote>\n<p>这句话是很有道理的（废话，要不然能在不少地方都看到吗。。），你可能没有意识到，在 JavaScript（以下简称 JS）中，你声明一个变量 <code>let a = 3</code>，此时的 a 其实是一个对象，因为你可以将它当做对象一样去调用 <code>toString()</code> 方法，这其中的答案都在 JS 对象系统中，请看下面这张图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_111.png\" alt=\"\" width=\"600\"></div>\n\n<p>下面我们就结合这张图来分析一下 JS 对象系统的结构</p>\n<h2 id=\"本地对象\"><a href=\"#本地对象\" class=\"headerlink\" title=\"本地对象\"></a>本地对象</h2><p>“本地对象”的说法可能比较陌生，也可以叫做“原生对象”、“内置对象”、“内建对象”，但其实指的都是 native object。ECMA-262 对于 native object 的定义为：</p>\n<blockquote>\n<p>独立于宿主环境的 ECMAScript 实现提供的对象</p>\n</blockquote>\n<p>我们知道，“宿主”一般指浏览器，而“独立于宿主环境”，也就是说与浏览器环境不相关，这就是说：native object 与浏览器不相关，只要这个浏览器按照 ECMAScript 规范实现了JS，那就必然实现了规范中的所有 native object。换句话说就是：<strong>本地对象（native object）是语言本身实现和提供的对象，和语言运行在哪个环境无关</strong>。也就是说，不管你的JS代码在哪里跑，你都可以 <code>new</code> 出 native object 并使用它。照此理解，我觉得其实把 native object 翻译成“原生对象”最合意。</p>\n<h3 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h3><blockquote>\n<p>到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且，Object 也是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。——《JavaScript高级程序设计（第3版）》</p>\n</blockquote>\n<p>“万物从无到有”，JS 中的大多数引用类型值都是 Object 类型的实例，而 Object 的原型就是 null 了（可以在 chrome 控制台中打印 Object.prototype.__proto__），Object 是所有其他对象类型的基础类型，提供了 toString() 等基础方法</p>\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><p>数组类型</p>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>日期类型</p>\n<h3 id=\"RegExp\"><a href=\"#RegExp\" class=\"headerlink\" title=\"RegExp\"></a>RegExp</h3><p>正则类型</p>\n<h3 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h3><blockquote>\n<p>说起来 ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。——《J3》</p>\n</blockquote>\n<p>没错，请注意大小写，Function 是一种对象类型，而 function 则是一个对象实例，见如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>() <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>);    <span class=\"comment\">//true(构造函数Function()是Function类型的实例)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>() <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);    <span class=\"comment\">//true(构造函数Function()当然也是Object类型的实例)</span></span><br></pre></td></tr></table></figure>\n<p>事实上，任何一个函数都是函数对象的实例，而函数类型本身就是一种对象类型，所以：<strong>函数也是对象</strong>。</p>\n<h3 id=\"Error-等各种错误类对象\"><a href=\"#Error-等各种错误类对象\" class=\"headerlink\" title=\"Error 等各种错误类对象\"></a>Error 等各种错误类对象</h3><p>Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 等错误类型的对象。</p>\n<h3 id=\"String、Number、Boolean\"><a href=\"#String、Number、Boolean\" class=\"headerlink\" title=\"String、Number、Boolean\"></a>String、Number、Boolean</h3><p>之所以将这三类放到一起，是因为它们属于JS中的基本数据类型，但其实它们也是一种对象类型，这样你才能像使用对象一般操作字符串、数值、布尔值，见下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">str = str.substr(<span class=\"number\">0</span>,<span class=\"number\">5</span>);    <span class=\"comment\">//调用substr()方法截取字符串，我是字符串，但实际上是一个对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str);    <span class=\"comment\">//'Hello'</span></span><br></pre></td></tr></table></figure>\n<p>所以，当我们通过变量声明的方式去声明一个字符串、数字、布尔值的时候，其实后台帮我们创建了一个对象：</p>\n<blockquote>\n<p>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据 ——《J3》</p>\n</blockquote>\n<p>书上一语道明。注意一下这句话中的“读取”和“对应”两个词。“读取”是指进入读取模式，即从内存中去读取这个字符串值的时候；“对应”指的是基本类型值是哪种类型，后台自动给你创建的基本包装类型就是哪种对应的类型，比如这里的基本类型值是 <code>String</code> 类型，那后台创建的基本包装类型也就是 <code>String</code> 包装类型。 因为这一机制，上面代码的实际执行情况其实是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\"><span class=\"comment\">//str = str.substr(0,5);    //(str进入读取模式，准备创建基本包装类型对象)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'Hello World'</span>);</span><br><span class=\"line\">str = _str.substr(<span class=\"number\">0</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">_str = <span class=\"literal\">null</span>;    <span class=\"comment\">//使用完后台会立即将该包装对象销毁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str);    <span class=\"comment\">//'Hello'</span></span><br></pre></td></tr></table></figure>\n<p>这里只展示了 String 包装类型，其实 Number 和 Boolean 也是完全一样的原理</p>\n<h3 id=\"内置对象（单体内置对象）（built-in-object）\"><a href=\"#内置对象（单体内置对象）（built-in-object）\" class=\"headerlink\" title=\"内置对象（单体内置对象）（built-in object）\"></a>内置对象（单体内置对象）（built-in object）</h3><p>这个叫 built-in object，上面那个叫 native object，那么它们有什么区别呢，还是看一下《J3》这本书中的解释吧：</p>\n<blockquote>\n<p>ECMA-262 对内置对象的定义是：“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。——《J3》</p>\n</blockquote>\n<p>这是 ECMA-262 对于 built-in object 的定义。对比 native object 的定义：“独立于宿主环境的 ECMAScript 实现提供的对象”，可以看出，built-in object 是更加特殊的 native object，built-in object 属于 native object。ECMA-262 定义了两种 built-in object：Global 对象、Math 对象。</p>\n<h4 id=\"Global-对象\"><a href=\"#Global-对象\" class=\"headerlink\" title=\"Global 对象\"></a>Global 对象</h4><p>事实上，js 中并不存在所谓的全局变量以及完全独立的函数。没错，你定义的所有全局变量其实都是 Global 对象的属性，<strong>你在全局作用域下定义的所有函数其实都是 Global 对象的方法</strong>。</p>\n<blockquote>\n<p>ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象” 来定义的。换句话说，不属于任何其他对象的属性和方法，终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。——《J3》</p>\n</blockquote>\n<p>parseInt()、eval()、encodeURIComponent() 这些函数实际上都是 Global 对象的方法，在使用这些方法的时候无需通过对象去调用，直接就可以使用。引文说过：“这些对象在 ECMAScript 程序执行之前就已经存在了。”这也算 build-in object 的一个特别之处，《J3》将 build-in object 定义为“单体内置对象”，这个“单体”是否就是指无需手动实例化这一点？ Global 对象的所有属性如下表：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_103.png\" alt=\"\" width=\"400\"></div>\n\n<p>好吧，特殊值 undefined 居然是 Global 对象的一个属性值 - -。乍看之下可能会有点诧异，不过仔细想想，我们之所以说 JavaScript 中一切皆对象是有原因的，你看，就连 undefined 都是对象的属性值。从表中还可以看到，所有原生引用类型的构造函数也都是 Global 对象的属性。这怎么理解？其实也很好理解，比如说当你想要创建一个日期类型的变量时，直接上构造函数 <code>var date = new Date();</code> 就可以了，可是你想过没有，Date() 构造函数本身是一个函数，而前面我们说过，JS并不存在完全独立的函数，任何函数其实都是挂在某个对象下的方法，哪怕它是一个构造函数。而这些原生构造函数，其“挂载”的对象正是 Global 对象。 介绍了这么多关于 Global 对象的内容，是不是还是不清楚它是个什么玩意儿？这是因为我们在浏览器中并不能直接访问这个对象。好在浏览器为我们实现了一个包含了 Global 对象的 window 对象。</p>\n<blockquote>\n<p>ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性。——《J3》</p>\n</blockquote>\n<p>window 对象包含了 Global 对象的所有内容，同时扩展了大量自身需要的属性和方法（比如常用的 <code>alert()</code>）。因此，在浏览器中我们可以通过 window 对象随意访问上述的属性和方法。请看下面代码并加以理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">window</span>.Date();    <span class=\"comment\">//window是对Global对象的扩展实现，构造函数Date()确实是挂在window上面的</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date);    <span class=\"comment\">//Mon Aug 07 2017 10:07:28 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>\n<p>其实你也可以在控制台中打印一下 window，你就可以发现它确实包含了上述属性和构造函数</p>\n<h4 id=\"Math-对象\"><a href=\"#Math-对象\" class=\"headerlink\" title=\"Math     对象\"></a>Math     对象</h4><p>Math 对象是一个保存着必要的数学操作的 build-in object。里面保存着常量 e、圆周率 π 等的值作为属性，同时提供了取整 Math.floor()、取随机数 Math.random()、求平方根等等数学方法。和 Global 对象一样，这些属性和方法都可以在任何时候任何地方直接访问和调用，只不过其形式统一为：Math.***。</p>\n<h2 id=\"宿主对象\"><a href=\"#宿主对象\" class=\"headerlink\" title=\"宿主对象\"></a>宿主对象</h2><p>宿主对象是指宿主环境所实现和提供的对象。所有非本地对象（native object）都是宿主对象。我之所以在结构图中把自定义对象挂到了宿主对象下正是基于此，不过这并非定死的，你若将自定义对象拎出来和本地对象、宿主对象并列放也并非不可。 <strong>所谓宿主，就是指 JS 代码所在的运行环境</strong>。对于浏览器环境而言，我们显示一个页面需要 HTML，所以浏览器实现了 DOM 对象 —— window.document；我们还需要浏览器本身给我们提供一些必要的东西，比如 URL 地址相关的 location、设备屏幕相关的 screen 等，所以浏览器又为我们提供了 BOM 对象 —— window。这些对象，就是 host object。等等，怎么 window 对象又出场了？上面不是说过了，window 对象是浏览器对 Global 对象的扩展实现，是 Global 对象的超集，那这玩意儿究竟该挂到 build-in object 上，还是宿主对象下的 BOM 上？答案当然是后者。可以明确的是，window 对象本就是浏览器所实现的，那它当然属于浏览器对象模型（BOM）了！只不过，window 把 ECMAScript 规定的 Global 对象也给一并实现了而已。还有，DOM 对象即是 window.document，而 window.document 就是 DOM 的根节点，从这点来讲，我们可以理解为 BOM 包含了 DOM。 如此，我们终于找到最终对象了 - -，它正是 BOM —— window。你几乎可以在这个对象中找到一切。全局变量、自定义对象、JSON 对象（ECMA262-5 引入为规范）、Math 对象、原生构造函数、Global 的东西。。。 万物合一，世界清静了。 最后，可以把最开始给的图修正更新一下了：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_112.png\" alt=\"\" width=\"600\"></div>\n\n<p>从图上可以看到多了一个 JSON 对象，原因是 ECMA262-5 已经将 JSON 对象纳 入native object 了。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"对象","path":"api/tags/对象.json"}]},{"title":"let和var到底有什么区别？","slug":"let和var到底有什么区别？","date":"2017-08-04T08:10:14.000Z","updated":"2019-01-29T09:23:55.532Z","comments":true,"path":"api/articles/let和var到底有什么区别？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>问题来自于stackoverflow：<a href=\"https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var-to-declare-a-variable\" target=\"_blank\" rel=\"noopener\">What’s the difference between using “let” and “var” to declare a variable?</a> 我们都知道 ES6 中引入了 let 声明，而 let 也一直被认为是声明“局部变量”，那么 let 和 var 到底有什么区别呢？</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>首先，从其定义本身，其区别之一是起作用的范围： var 起作用的范围是其最近的方法体，而 let 起作用的范围是其最近的包围块，所谓的“包围块”是有可能比方法体小的。但是<strong>如果都是全局作用域上声明的话，var 和 let 起作用的范围其实是一样的</strong> 除此之外，用 let 声明的变量在它们被声明之前是无法访问到的（有点类似于严格模式），举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'globalVar: '</span> + globalVar);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'globalLet: '</span> + globalLet);</span><br><span class=\"line\"><span class=\"keyword\">var</span> globalVar = <span class=\"string\">'globalVar'</span>;  <span class=\"comment\">//globalVar: undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> globalLet = <span class=\"string\">'globalLet'</span>;  <span class=\"comment\">//Uncaught ReferenceError: globalLet is not defined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"作为全局变量\"><a href=\"#作为全局变量\" class=\"headerlink\" title=\"作为全局变量\"></a>作为全局变量</h2><p>和 var 不同，用 let 声明的“全局变量”将不会作为属性赋给 window，简单的栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'go'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"string\">'able'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.me); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.i); <span class=\"comment\">// 'able'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在函数中声明\"><a href=\"#在函数中声明\" class=\"headerlink\" title=\"在函数中声明\"></a>在函数中声明</h2><p>当它们在函数体中声明时是一样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ingWithinEstablishedParameters</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> funclet = <span class=\"string\">'funclet'</span>; <span class=\"comment\">//作用域为函数体内部</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> funcvar = <span class=\"string\">'funcvar'</span>; <span class=\"comment\">//作用域为函数体内部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在循环体中声明\"><a href=\"#在循环体中声明\" class=\"headerlink\" title=\"在循环体中声明\"></a>在循环体中声明</h2><p>当我们在循环体中声明变量（例如 for）时，var 和 let 是有显著区别的：let 只在循环体内部可访问，而 var 在整个方法体中都可访问。还是个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allyIlliterate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//tuce在这里不可访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> tuce = <span class=\"number\">0</span>; tuce &lt; <span class=\"number\">5</span>; tuce++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//tuce只能在这里访问得到</span></span><br><span class=\"line\">        <span class=\"comment\">//所以每次循环之后tuce的值都会变</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//tuce在这里也不可访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">byE40</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//nish在这里可以访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">var</span> nish = <span class=\"number\">0</span>; nish &lt; <span class=\"number\">5</span>; nish++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//nish在整个方法体中都可以访问得到</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//nish在这里也可以访问</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明覆盖\"><a href=\"#声明覆盖\" class=\"headerlink\" title=\"声明覆盖\"></a>声明覆盖</h2><p>在严格模式下，var 允许你重新给一个变量赋值，但是 let 不允许：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'bar'</span>; <span class=\"comment\">// SyntaxError: Identifier 'me' has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"string\">'bar'</span>; <span class=\"comment\">// 没毛病，现在me就是bar了</span></span><br></pre></td></tr></table></figure>\n<p>虽然 let 和 var 在某些情况下是一样的行为表现，但还是推荐大家多使用 let，逐渐放弃 var 的使用。</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"ES6","path":"api/tags/ES6.json"}]},{"title":"在JS中如何清空一个数组？","slug":"在JS中如何清空一个数组？","date":"2017-08-04T07:30:29.000Z","updated":"2019-01-29T09:23:55.536Z","comments":true,"path":"api/articles/在JS中如何清空一个数组？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_277.png","content":"<p>问题来源于stackoverflow：<a href=\"https://stackoverflow.com/questions/1232040/how-do-i-empty-an-array-in-javascript\" target=\"_blank\" rel=\"noopener\">How do I empty an array in JavaScript?</a>。更多关于JS中数组的相关操作参见：<a href=\"/20170322/summary-of-array-method-in-js.html\">JS中数组方法总结</a> 比如我有如下数组：<code>A = [1, 2, 3, 4]</code>; 我如何清空它？</p>\n<h2 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A = [];\"></a>A = [];</h2><p>这个答案应该很好想到，因为很符合“从问题本身出发”的逻辑，既然我们想清空数组 A，那就清空喽~ 但是这个方法有一个弊端：如果你之前通过引用的方式 copy 了数组A，那么即使通过 <code>A = []</code> 将数组 A 清空了，你的引用变量也还是 A 原来的值，理论知识总是难理解，举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1;  <span class=\"comment\">//arr2是arr1的一个引用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2 === arr1)  <span class=\"comment\">//arr2和arr1共享内存地址</span></span><br><span class=\"line\">arr1 = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);  <span class=\"comment\">//['a', 'b', 'c', 'd', 'e', 'f']，此时arr2和arr1就互相不认识了</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"A-length-0\"><a href=\"#A-length-0\" class=\"headerlink\" title=\"A.length = 0\"></a>A.length = 0</h2><p>因为在 JS 中数组其实也是一个对象（所谓的“数组对象”），而每个数组都有一个 length 属性，这是一个可读写的属性，将其置为 0 之后就可以清空数组。同时它的引用变量也将被清空：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'f'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1;  <span class=\"comment\">// 我胡汉三又来引用了</span></span><br><span class=\"line\">arr1.length = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);  <span class=\"comment\">//[]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);  <span class=\"comment\">//[]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1 === arr2)  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"A-splice-0-A-length\"><a href=\"#A-splice-0-A-length\" class=\"headerlink\" title=\"A.splice(0, A.length)\"></a>A.splice(0, A.length)</h2><p>和上面的通过 length 清空类似，该方法也将同时清空数组 arr2。不同点在于，.splice() 方法将返回一个数组</p>\n<h2 id=\"while-和-pop\"><a href=\"#while-和-pop\" class=\"headerlink\" title=\"while 和 .pop()\"></a>while 和 .pop()</h2><p>这是一个比较“愚蠢”的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(A.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    A.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法同样会清空数组 arr2，但是也是效率最低的一种方法</p>\n<h2 id=\"while和-shift\"><a href=\"#while和-shift\" class=\"headerlink\" title=\"while和.shift()\"></a>while和.shift()</h2><p>一般“愚蠢”的方法不止一种。。：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(A.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    A.shift();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h2><p>可以<a href=\"http://jsben.ch/hyj65\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看这四种方法的性能测试结果，或者直接看下图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_277.png\" alt=\"\" width=\"500\"></div>\n\n<p>从图中可以很明显的看出来，<code>A.length = 0;</code> 这种方法是效率最高的，效率最低的是 pop 和 shift（不出所料啊。。）</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"数组","path":"api/tags/数组.json"}]},{"title":"jQuery事件：不要再(滥)用return false了","slug":"jQuery事件：不要再(滥)用return false了","date":"2017-08-03T10:25:21.000Z","updated":"2019-01-29T09:23:55.532Z","comments":true,"path":"api/articles/jQuery事件：不要再(滥)用return false了.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>无意中在 stackoverflow 上看到一个<a href=\"https://stackoverflow.com/questions/1357118/event-preventdefault-vs-return-false\" target=\"_blank\" rel=\"noopener\">关于jQuery中event.preventDefault()和return false的提问</a>，后来从评论中发现一篇<a href=\"https://web.archive.org/web/20160614140933/http://fuelyourcoding.com/jquery-events-stop-misusing-return-false/\" target=\"_blank\" rel=\"noopener\">关于这个问题的很不错的文章</a>，遂翻译了一下，希望能够帮助大家更好的理解 jQuery 中的 return false；当你刚开始学习 jQuery 中的事件时，也许你首先碰到的知识点就是“取消浏览器的默认行为”这一概念。比如，一个讲 click 的初级教程里可能会有如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a.toggle\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">\"#mydiv\"</span>).toggle();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 禁止浏览器访问'#'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面这个方法动态的控制 #mydiv 的显示与隐藏，然后取消了浏览器的默认行为——访问锚标签的 href，这是一个非常简单的例子，同时也让很多前端小白养成了使用 return false 取消浏览器默认行为的习惯。关于取消浏览器事件这一问题，我将从以下两个主题重点讲解：</p>\n<ul>\n<li>使用正确的方法：return false、preventDefault、stopPropagation 和 stopImmediatePropagation</li>\n<li>头部、底部或中间某个位置：我们应该在事件回调函数的哪个位置取消默认行为？</li>\n</ul>\n<h2 id=\"使用正确的方法\"><a href=\"#使用正确的方法\" class=\"headerlink\" title=\"使用正确的方法\"></a>使用正确的方法</h2><p>之所以 return false 被大量滥用，是因为它确实满足了我们的需求——超链接不再跳转，表单也不再提交等等，那么为什么我说好多人都误用了呢？</p>\n<h3 id=\"return-false-到底做了什么\"><a href=\"#return-false-到底做了什么\" class=\"headerlink\" title=\"return false 到底做了什么\"></a>return false 到底做了什么</h3><p>首先，大部分人都没有搞明白的是，jQuery 中的 return false 其实做了下面三件事：</p>\n<ol>\n<li><strong>event.preventDefault();</strong></li>\n<li><strong>event.stopPropagation();</strong></li>\n<li><strong>阻止剩下的代码执行，同时立即返回</strong></li>\n</ol>\n<p>“等一下”。你是不是很惊讶，大部分人用 return false 其实只是为了阻止默认行为，也就是上面的第一件事，另外两件其实根本不需要。上面3件事中，只有 event.preventDefault() 会取消默认行为。除非你真的打算阻止事件冒泡，否则使用 return false 将大大增加你的代码的脆弱性。让我们来看看现实应用中这种滥用是如何产生的： 我们有如下HTML代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"post\"</span>&gt;</span><br><span class=\"line\">    &lt;h2&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path/to/page\"</span>&gt;</span>My Page<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"content\"</span>&gt;</span><br><span class=\"line\">        Teaser text...</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>div&gt;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"post\"</span>&gt;</span><br><span class=\"line\">    &lt;h2&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path/to/other_page\"</span>&gt;</span>My Other Page<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"content\"</span>&gt;</span><br><span class=\"line\">        Teaser text...</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>现在我们想实现这样的功能：当用户点击标题链接时，跳转到相应的 div.content 上面，我们可能会写出这样的 jQuery 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$</span>) </span>&#123;</span><br><span class=\"line\">   $(<span class=\"string\">\"div.post h2 a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> a = $(<span class=\"keyword\">this</span>),</span><br><span class=\"line\">          href = a.attr(<span class=\"string\">'href'</span>), <span class=\"comment\">// \b获取href,</span></span><br><span class=\"line\">          content  = a.parent().next();</span><br><span class=\"line\">      content.load(href + <span class=\"string\">\" #content\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 取消链接跳转这种默认行为</span></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>目前，我们的页面一切正常。然后，我们又想要添加一个功能：当 div.post（或者它的子元素）被点击时，给当前被点击的 div.post 添加一个 “active” 类。所以，我们需要添加一个 click 事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> posts = $(<span class=\"string\">\"div.post\"</span>);</span><br><span class=\"line\">posts.click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    posts.removeClass(<span class=\"string\">\"active\"</span>);  <span class=\"comment\">// \b移除所有div.post的active类</span></span><br><span class=\"line\">    $(<span class=\"keyword\">this</span>).addClass(<span class=\"string\">\"active\"</span>);  <span class=\"comment\">// 给当前的div.post添加active类</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在测试一下，当我们点击标题链接的时候，它会起作用吗？不会！它不能起作用的原因是我们在点击事件中 return false 了。而 return false 实际上意味着执行了 event.preventDefault() 和 event.stopPropagation()。所以点击事件不会冒泡到 div.post 上，从而我们新添加的事件将不起作用。 当我们将正常绑定的事件和 live 以及 delegate 绑定的事件混用时，它也会出现问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).live(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的代码将不起作用</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"我们真正想要实现什么？\"><a href=\"#我们真正想要实现什么？\" class=\"headerlink\" title=\"我们真正想要实现什么？\"></a>我们真正想要实现什么？</h3><h4 id=\"preventDefault\"><a href=\"#preventDefault\" class=\"headerlink\" title=\"preventDefault()\"></a>preventDefault()</h4><p>在大多数场景下，当我们使用 return false 的时候，我们真正想要的其实是 e.preventDefault()。使用 preventDefault 的前提是你允许在你的函数中访问事件对象（在后面的例子中以 e 表示事件对象）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// e代表我们的事件对象</span></span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个方法就可以是实现取消默认行为，但是它不能阻止事件冒泡。但是，代码的功能越单一，它的可维护性就更强</p>\n<h4 id=\"stopPropagation\"><a href=\"#stopPropagation\" class=\"headerlink\" title=\"stopPropagation()\"></a>stopPropagation()</h4><p>有些时候我们只是想阻止事件冒泡，比如下面的栗子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"post\"</span>&gt;</span></span><br><span class=\"line\">    Normal text and then a <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path\"</span>&gt;</span>link<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> and then more text.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在，比如我们有一个非常“奇特”的需求：我们想让用户点击 div 中除了链接之外的任何地方都干一件事（可能是重定向到其他页面），然后还想让用户点击链接的时候可以正常跳转（从可用性的角度来看，这是一个非常糟糕的 idea。因为如果用户本意想点击链接却点到了其他地方，接下来发生的事情可能会让用户很吃惊，影响用户体验）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"div.post\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div.post a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在这里不要取消默认行为</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要阻止事件冒泡</span></span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，如果我们用 return false，那 div 的点击事件将永远不会触发，这样用户就不会被引导到正确的页面。</p>\n<h4 id=\"stopImmediatePropagation\"><a href=\"#stopImmediatePropagation\" class=\"headerlink\" title=\"stopImmediatePropagation()\"></a>stopImmediatePropagation()</h4><p>这个函数将阻止事件的进一步执行，即使是同一对象上绑定的不同事件。因为绑定到一个 dom 元素的所有事件都将按照它们被绑定的顺序执行。下面是一个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Do something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Do something else</span></span><br><span class=\"line\">   e.stopImmediatePropagation();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 这里将不会执行</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 这里也不会执行</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你认为这个例子看起来太假了，不得不说，是很假。然而，有时候这种情况确实会发生。当你构造更加复杂的代码时，代码结构会变得比较混乱，不同的组件和插件可能会给同一个 dom 元素添加事件。在这种情况下，正确的理解和使用 stopImmediatePropagation() 就显得尤为重要了。</p>\n<h4 id=\"return-false\"><a href=\"#return-false\" class=\"headerlink\" title=\"return false\"></a>return false</h4><p>只有当你同时需要 preventDefault() 和 stopPaopagation() 时，才需要使用 return false。与此同时，你的代码应该保证只有到回调函数的尾部才取消默认行为。我强烈反对您在为 jQuery 小白编写的实例中使用这个 return false。它会误导一些入门开发者，因为只有很清楚它的功能你才能正确的使用它。</p>\n<h2 id=\"头部，底部还是中间的某个地方？\"><a href=\"#头部，底部还是中间的某个地方？\" class=\"headerlink\" title=\"头部，底部还是中间的某个地方？\"></a>头部，底部还是中间的某个地方？</h2><p>之前，当你(滥)用 return false 时，它总是出现在函数的底部，或者至少在某个特定逻辑行的结尾处，因为它会组织后面的代码执行。但是我们有 e.preventDefault，所以我们有了更多选择。e.preventDefault 可以在函数执行过程中的任何时候调用。那么应该把它放在哪里呢？</p>\n<h3 id=\"在开发环境，它应该总是放在第一行\"><a href=\"#在开发环境，它应该总是放在第一行\" class=\"headerlink\" title=\"在开发环境，它应该总是放在第一行\"></a>在开发环境，它应该总是放在第一行</h3><p>对于一个表单，你想做的最后一件事往往是，你希望通过 ajax 的方式将表单提交到另一个网页，同时你尝试在回调函数中调试 JavaScript 产生的 bug</p>\n<h3 id=\"在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\"><a href=\"#在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\" class=\"headerlink\" title=\"在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\"></a>在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾</h3><p>如果你是在一个开发完的页面上添加功能，那么你的链接点击事件或者表单提交事件需要对于不支持 JS 的浏览器的服务器端的反馈。这里的好处在于，与不支持 JS 的浏览器无关，而是你的代码在那些浏览器中会抛出错误。下面有一个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.preventDefault(); <span class=\"comment\">// 取消默认行为</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 抛出一个错误，因为my是undefined</span></span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append(data.my.link);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 链接将不起作用</span></span><br><span class=\"line\">    <span class=\"comment\">// JS的执行将终端，用户将不知所措</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在，让我们看一下同样的问题出现在 preventDefault 放在末尾时候的表现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// \b抛出错误，因为my是undefined</span></span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append(data.my.link);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 这里将不会执行，此时你的网页将使用“href”</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    e.preventDefault(); <span class=\"comment\">// 取消默认行为</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个例子同样适用于表单提交事件，可以让你有适当的回退选择。所以，千万不要指望你的代码永远都会正确执行。计划好回退方案比盼望着不会报错要好得多！</p>\n<h3 id=\"在生产环境中，如果你的功能只与-JS-有关，请放在第一行\"><a href=\"#在生产环境中，如果你的功能只与-JS-有关，请放在第一行\" class=\"headerlink\" title=\"在生产环境中，如果你的功能只与 JS 有关，请放在第一行\"></a>在生产环境中，如果你的功能只与 JS 有关，请放在第一行</h3><p>它不一定是函数中的第一行，但是它应该在你的程序逻辑中的最开始位置。原因是这样的：如果功能的这一部分一开始是与 JS 相关的，那么回退就不是那么必要了。在这种情况下，回退只是会造成一个随机的“#”出现在 URL 中或者页面跳转的区别。很明显，我们需要做的事提供尽可能多的错误处理方案，从而确保用户不会觉得它们的努力是白费的。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我希望这篇文章在你对于取消事件进行选择时提供了足够多的信息。记住只有在你真正需要 return false 时采去使用它，同时确保在你的回调函数的正确位置取消了默认行为。程序员的目标就是让你的代码尽可能的灵活，所以不要再用 return false 了！</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"jQuery","path":"api/tags/jQuery.json"}]},{"title":"JS中的apply、call和bind","slug":"JS中的apply、call和bind","date":"2017-08-03T08:30:08.000Z","updated":"2019-01-29T09:23:55.528Z","comments":true,"path":"api/articles/JS中的apply、call和bind.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>关于 JS 中的 apply、call 和 bind，网上的相关文章实在是太多了，但是对于我这种比较重视基础的人来说，感觉大部分文章都讲不到点子上，不乏无脑复制粘贴之辈，所以我在参考了一些资料之后，决定用比较容易理解的方式来讲解，同时会用更多的实例来说明它们之间的区别。</p>\n<h2 id=\"为什么会有它们仨\"><a href=\"#为什么会有它们仨\" class=\"headerlink\" title=\"为什么会有它们仨\"></a>为什么会有它们仨</h2><p>首先，哲学中有一句话：</p>\n<blockquote>\n<p>存在即合理</p>\n</blockquote>\n<p>所以，JS 中为什么会有它们仨呢？让我们来一看一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cat</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cat.prototype=&#123;     </span><br><span class=\"line\">    food:<span class=\"string\">\"fish\"</span>,     </span><br><span class=\"line\">    say: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;          </span><br><span class=\"line\">    alert(<span class=\"string\">\"I love \"</span>+<span class=\"keyword\">this</span>.food);     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> blackCat = <span class=\"keyword\">new</span> cat;</span><br><span class=\"line\">blackCat.say();</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，也是我们经常会碰到的，就是我们定义了一个 cat 类，然后 blackCat 是 cat 类的一个实例， cat 类有一个 say 方法。那么问题来了，如果我们又有一个对象叫做 <code>whiteDog={food:&quot;bone&quot;}</code>，我们想让 whiteDog 也有 cat 类的 say 方法，那应该怎么办呢？所以这时候就体验出它们仨的作用了，我们可以通过下面的方式让 whiteDog 也有 say 方法：</p>\n<ul>\n<li>blackCat.say.call(whiteDog)</li>\n<li>blackCat.say.apply(whiteDog)</li>\n<li>blackCat.say.bind(whiteDog)()</li>\n</ul>\n<p>通过上面这个“猫与狗”的栗子，我们可以总结出 apply、call 和 bind 的共同点，就是它们都是为了改变函数体内部 this 的指向，也就是为了改变某个函数运行时的上下文（context）而存在的（JavaScript 的函数存在【定义时上下文】、【运行时上下文】和【上下文是可以改变的】这样的概念，具体参见简书-波同学的文章：<a href=\"http://www.jianshu.com/p/a6d37c77e8db\" target=\"_blank\" rel=\"noopener\">前端基础进阶（二）：执行上下文详细图解</a>）</p>\n<h2 id=\"bind-的独特性\"><a href=\"#bind-的独特性\" class=\"headerlink\" title=\"bind 的独特性\"></a>bind 的独特性</h2><p>通过上面的调用方式你可能发现了一些端倪，就是 bind 在调用之后还需要加一个“()”，这就是 call、apply 它们和 bind 的区别了：</p>\n<ul>\n<li>只传一个参数时，call 和 apply 都是对函数的直接调用</li>\n<li>而 bind 方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以</li>\n</ul>\n<p>也许你又有疑问了，一般我们的方法都会有参数的，如果有参数的话应该如何调用呢？我们再举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'asd'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">29</span> ,</span><br><span class=\"line\">  sayname: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i, j</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.name + <span class=\"string\">'是'</span> + <span class=\"keyword\">this</span>.age+i+j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 =&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'aaa'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">30</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.sayname.apply(obj2,\\[<span class=\"string\">'男'</span>,<span class=\"number\">180</span>\\]);</span><br><span class=\"line\">obj1.sayname.call(obj2,<span class=\"string\">'女'</span>,<span class=\"number\">167</span>);</span><br><span class=\"line\">obj1.sayname.bind(obj2,<span class=\"string\">'x'</span>,<span class=\"number\">150</span>)();</span><br><span class=\"line\">obj1.sayname.bind(obj2)(<span class=\"string\">'y'</span>,<span class=\"number\">110</span>);</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，我们可以直观的总结出如下几个知识点：</p>\n<ul>\n<li>call 后面的参数与 sayname 方法中是一一对应的</li>\n<li>apply 的第二个参数是一个数组，数组中的元素是和 sayname 方法中一一对应的（<strong>这其实就是和 call 最大的区别</strong>）</li>\n<li>bind 可以像 call 那样传参，但是由于 bind 返回的仍然是一个函数，还可以在调用的时候再进行传参</li>\n</ul>\n<h2 id=\"apply、call-的区别\"><a href=\"#apply、call-的区别\" class=\"headerlink\" title=\"apply、call 的区别\"></a>apply、call 的区别</h2><p>通过上面的栗子，我们可以看到，bind 和 apply、call 是有本质上的区别的，所以我们先讲 apply 和 call 这一对“近亲”。对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg1 + arg2);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过如下方式来调用：</p>\n<ul>\n<li>func.call(this, arg1, arg2);</li>\n<li>func.apply(this, [arg1, arg2]);</li>\n</ul>\n<p>其中 this 是你想指定的上下文，它可以是任何一个 JavaScript 对象，而不同点在于：call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 因此，如果你的参数明确知道数量的话，就用 call。而不确定的时候用 apply，然后把参数 push 进数组再传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数，所以也有人用一句话区分 apply 和 call：<code>foo.call(this, arg1, arg2, arg3) == foo.apply(this, arguments) == this.foo(arg1, arg2, arg3)</code></p>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><p>JS 中存在一种名为伪数组的对象结构，比较特别的是 arguments 对象，还有像调用 getElementsByTagName，document.childNodes 之类的，它们返回 NodeList 对象都属于<strong>伪数组（也有文章描述这类对象为“类数组对象”）</strong>，不能应用 Array 下的 push，pop 等方法。但是我们能够通过 Array.prototype.slice.call 将带有 length 属性的对象转换为真正的数组，这样 domNodes 就可以应用 Array 下的所有方法了。</p>\n<h2 id=\"一道面试题\"><a href=\"#一道面试题\" class=\"headerlink\" title=\"一道面试题\"></a>一道面试题</h2><p>可能你还是不太理解上面的“当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数”这句话，下面通过一道面试题，来更深入的理解 apply 和 call：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们定义一个log方法，让它可以代理console.log方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">msg</span>)　</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">1</span>);    <span class=\"comment\">//1</span></span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>上面定义的方法可以解决最基本的需求，但是有一个问题在于：当传入参数的个数是不确定的时候，上面的方法就失效了。这个时候，因为传入多少个参数是不确定的，所以使用 apply：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">log(<span class=\"number\">1</span>);    <span class=\"comment\">//1</span></span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">//1 2</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们又有一个需求，就是给每一个 log 信息添加一个 “(app)” 的前缀，比如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"string\">\"hello world\"</span>);    <span class=\"comment\">//(app)hello world</span></span><br></pre></td></tr></table></figure>\n<p>我们该如何实现呢？这个时候需要想到 arguments 参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法 unshift，像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  args.unshift(<span class=\"string\">'(app)'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"bind-详解\"><a href=\"#bind-详解\" class=\"headerlink\" title=\"bind 详解\"></a>bind 详解</h2><p>apply 和 call 就介绍完了，下面我们再介绍一下有些特殊的 bind。MDN 上对于 bind 的解释是：</p>\n<blockquote>\n<p>bind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n</blockquote>\n<p>我表示看完还是不懂，所以还是直接看实例来的痛快：在常见的单例模式中，通常我们会使用 _this, that, self 等保存 this，这样我们可以在改变了上下文之后继续引用到它。像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar : <span class=\"number\">1</span>,</span><br><span class=\"line\">    eventBind: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        $(<span class=\"string\">'.someClass'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(_this.bar);     <span class=\"comment\">//1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 Javascript 特有的机制，上下文环境在 eventBind: function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar : <span class=\"number\">1</span>,</span><br><span class=\"line\">    eventBind: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'.someClass'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.bar);      <span class=\"comment\">//1</span></span><br><span class=\"line\">        &#125;.bind(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码里，bind() 创建了一个函数，当这个 click 事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用 bind() 时传入的参数）。因此，这里我们传入想要的上下文 this (其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。</p>\n<h3 id=\"再来一个简单的栗子：\"><a href=\"#再来一个简单的栗子：\" class=\"headerlink\" title=\"再来一个简单的栗子：\"></a>再来一个简单的栗子：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo);</span><br><span class=\"line\">func(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。</p>\n<h3 id=\"连续-bind\"><a href=\"#连续-bind\" class=\"headerlink\" title=\"连续 bind()\"></a>连续 bind()</h3><p>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sed = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo).bind(sed);</span><br><span class=\"line\">func(); <span class=\"comment\">//?</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> fiv = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class=\"line\">func(); <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure>\n<p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在 Javascript 中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind(),故第二次以后的 bind 是无法生效的。</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h2><p>最近发现“总结一下”很好用，因为可以堂而皇之的给自己的文章增加很多篇幅，同时还可以显得高大上：</p>\n<ul>\n<li><strong>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</strong></li>\n<li><strong>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</strong></li>\n<li><strong>apply 、 call 、bind 三者都可以利用后续参数传参；</strong></li>\n<li><strong>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。</strong></li>\n</ul>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/coco1s/p/4833199.html\" target=\"_blank\" rel=\"noopener\">【优雅代码】深入浅出 妙用Javascript中apply、call、bind</a></li>\n<li><a href=\"http://www.jianshu.com/p/f17a7b5efc5d\" target=\"_blank\" rel=\"noopener\">javascript call apply bind this指向和区别</a></li>\n<li><a href=\"http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html\" target=\"_blank\" rel=\"noopener\">关于javascript中apply()和call()方法的区别</a></li>\n<li><a href=\"https://www.zhihu.com/question/20289071\" target=\"_blank\" rel=\"noopener\">如何理解和熟练运用js中的call及apply？</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply\" target=\"_blank\" rel=\"noopener\">What is the difference between call and apply?</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"}]},{"title":"理解JS中的内存分配","slug":"理解JS中的内存分配","date":"2017-08-03T02:06:42.000Z","updated":"2019-01-29T09:23:55.540Z","comments":true,"path":"api/articles/理解JS中的内存分配.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_113.jpeg","content":"<h2 id=\"原始值和引用值\"><a href=\"#原始值和引用值\" class=\"headerlink\" title=\"原始值和引用值\"></a>原始值和引用值</h2><p>在 ECMAScript 中，变量可以存放两种类型的值，即原始值和引用值；原始值：原始数据类型（简单类型）的值，即undefined、null、Number、String、Boolean 类型所表示的值；引用值：复合数据类型（对象类型）的值，即Object、Function、Array 以及自定义对象等</p>\n<h2 id=\"栈和堆\"><a href=\"#栈和堆\" class=\"headerlink\" title=\"栈和堆\"></a>栈和堆</h2><p>与原始值和引用值对应存在两种结构的内存，即栈和堆</p>\n<h3 id=\"栈和原始值\"><a href=\"#栈和原始值\" class=\"headerlink\" title=\"栈和原始值\"></a>栈和原始值</h3><p>栈是一种后进先出的数据结构，在 JS 中可以通过 Array（数组）来模拟栈的行为 原始值是存储在栈中的简单数据，也就是说，它们的值直接存储在变量访问的位置</p>\n<h3 id=\"堆和引用值\"><a href=\"#堆和引用值\" class=\"headerlink\" title=\"堆和引用值\"></a>堆和引用值</h3><p>堆是基于散列算法的数据结构，在 JS 中，引用值是存放在堆中的 引用值是存储在堆中的对象，也就是说，存储在变量处的值（即指向对象的变量，存储在栈中）是一个指针，指向存储在堆中的实际对象</p>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><p>通过上面的讲解，我们可以得到如下简单的结论：</p>\n<ul>\n<li><strong>简单类型都放在栈里</strong></li>\n<li><strong>对象类型都放在堆里，指向对象的指针放在栈里</strong></li>\n</ul>\n<p>假如我们有如下几个变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = &#123; <span class=\"attr\">m</span>: <span class=\"number\">20</span> &#125;  <span class=\"comment\">//地址假设为0x0012ff7c</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> e = &#123; <span class=\"attr\">m</span>: <span class=\"number\">20</span> &#125;  <span class=\"comment\">//重新开辟一段内存空间假设为0x0012ff8f</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e==d);  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>它们在实际存储时的内存空间占用是这样的：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_113.jpeg\" alt=\"\" width=\"600\"></div>\n\n<p>看到这里，你可能会问：为什么引用值要放在堆中，而原始值要放在栈中，不都是在内存中吗，为什么不放在一起呢？接下来，让我们来探索问题的答案！ 首先，请允许我再举个栗子:）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">id, name, age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bol = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = \\[<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"number\">100</span>,<span class=\"string\">\"笨蛋的座右铭\"</span>,<span class=\"number\">25</span>);</span><br></pre></td></tr></table></figure>\n<p>然后，我们来看一下分析图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_38.jpeg\" alt=\"\" width=\"400\"></div>\n\n<p>从上图我们可以看到，我们无法直接操纵堆中的数据，也就是说我们无法直接操纵对象，但我们可以通过栈中对对象的引用来操纵对象。</p>\n<h2 id=\"答案揭晓\"><a href=\"#答案揭晓\" class=\"headerlink\" title=\"答案揭晓\"></a>答案揭晓</h2><p>现在让我们来回答为什么引用值要放在堆中，而原始值要放在栈中的问题： 记住一句话：</p>\n<blockquote>\n<p>能量是守恒的，无非是时间换空间，空间换时间的问题</p>\n</blockquote>\n<p>堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008432611\" target=\"_blank\" rel=\"noopener\">从[]==![]为true来剖析JavaScript各种蛋疼的类型转换</a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html\" target=\"_blank\" rel=\"noopener\">理解js内存分配</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"数据结构","path":"api/tags/数据结构.json"},{"name":"内存","path":"api/tags/内存.json"}]},{"title":"JS中的==、===和Object.is","slug":"JS中的==、===和Object.is","date":"2017-08-02T12:07:47.000Z","updated":"2019-01-29T09:23:55.528Z","comments":true,"path":"api/articles/JS中的==、===和Object.is.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_51.png","content":"<p>在查阅了很多资料之后，我将在这篇文章对于 JS 中的 ==、===、Object.is 进行详细的讲解，所以这很有可能是一篇很长很长的“唠叨文”，但是我相信你一定可以从这篇文章中收货很多，所以抖擞精神，往下看吧！</p>\n<h2 id=\"比较操作\"><a href=\"#比较操作\" class=\"headerlink\" title=\"比较操作\"></a>比较操作</h2><p>首先，你需要知道 JavaScript 提供了三种不同的值比较操作：</p>\n<ul>\n<li>严格相等（’triple equals’或’identity’），即 “===”</li>\n<li>宽松相等（’double equals’），即 “==”</li>\n<li>Object.js（ECMAScript 2015/ES6 新特性）</li>\n</ul>\n<p>现在考虑表达式 x==y，当 x 和 y 的类型相同时，x==y 可以转化为 x===y，而对于后者是很简单的，因为不涉及到类型转换，只需要注意：</p>\n<ul>\n<li>+0 ==(=) -0  //true</li>\n<li>NaN ==(=) NaN  //false</li>\n</ul>\n<p>对于上面这两种，你可以理解为 JavaScript 设计的问题（其实还是那句老话，王八的屁股——规定！），所以只需要死记硬背就可以了，当然还有两个长得像的 Object 也不相等，表现在：</p>\n<ul>\n<li>[] ==(=) []  //false</li>\n<li>{} ==(=) {}  //false</li>\n</ul>\n<p>之所以两个长得像的对象和数组都不相等，是因为在JS中，数组和对象是复杂数据类型，所以其实比较的是引用值，所以任意两个长得像的对象都不相等，具体参见：<a href=\"/20170803/understanding-memory-allocation-in-js.html\">理解JS中的内存分配</a>。ES6 中新增了 Object.is() 方法，它和 “===” 是基本相同的，除了下面这两种情况：</p>\n<ul>\n<li>Object.is(+0, -0)  //false</li>\n<li>Object.is(NaN, NaN)  //true</li>\n</ul>\n<p>所以你可以理解为 Object.is() 其实是对 “===” 的修正。“===” 和 Object.is() 介绍完了，下面就着重介绍一下 “==”（因为 JS 中的 “==” 会将等号两边进行类型转换，所以情况比较复杂）</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h2><p>“==” 在比较前会将比较的值转换为相同类型，在转换后（等式的一边或两边都可能被转换），最终的比较方式就等同于全等操作符 “===”。同时请注意，“===” 满足交换律，但是 “==” 不满足交换律（比如![]和{}）。先来看一张吊炸天的图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_51.png\" alt=\"\" width=\"600\"></div>\n\n<p><strong>我们接下来的讲解都建立在这张图上面：</strong></p>\n<h3 id=\"有和无\"><a href=\"#有和无\" class=\"headerlink\" title=\"有和无\"></a>有和无</h3><p>从这张图我们可以明显的看出，它们被分成了两个阵营：</p>\n<ul>\n<li>String、Number、Boolean 和 Object（对应左侧）</li>\n<li>undefined 和 null（对应右侧）</li>\n</ul>\n<p>分组的依据是什么呢？就是左侧是一个存在的世界，右侧是一个空的世界。所以就有如下规则：</p>\n<ul>\n<li>左侧任意 == 右侧任意  // false</li>\n</ul>\n<p>也就是左右两个世界中的任意值做 “==” 比较的结果都是 false</p>\n<h3 id=\"空和空\"><a href=\"#空和空\" class=\"headerlink\" title=\"空和空\"></a>空和空</h3><p>JavaScript 中的 undefined 和 null 是另一个经常让我们崩溃的地方。通常它被认为是一个设计缺陷，这一点我们不去深究。不过我曾听说，JavaScript 的作者最初是这样想的：</p>\n<blockquote>\n<p>假如你打算把一个变量赋予对象类型的值，但是现在还没有赋值，那么你可以用 null 表示此时的状态(证据之一就是 typeof null 的结果是 ‘object’)；相反，假如你打算把一个变量赋予原始类型的值，但是现在还没有赋值，那么你可以用 undefined 表示此时的状态。</p>\n</blockquote>\n<p>不管这个传闻是否可信，它们两者做 == 比较的结果是 true 是很合理的。(见上图中右侧垂直线上标的 true，也就是 <code>undefined == null</code>)</p>\n<h3 id=\"P和N\"><a href=\"#P和N\" class=\"headerlink\" title=\"P和N\"></a>P和N</h3><p>依然是上面那张图，从图中可以看到两个符号：大写字母 N 和 P：N 表示 ToNumber 操作，即将操作数转为数字。它是规范中的抽象操作，但我们可以用 JS 中的 Number() 函数来等价替代；P 表示 ToPrimitive 操作，即将操作数转为原始类型的值。它也是规范中的抽象操作，同样也可以翻译成等价的 JS 代码，但是会比 ToNumber 复杂一些，所以我们后面会详细解释。  </p>\n<h4 id=\"ToPrimitive\"><a href=\"#ToPrimitive\" class=\"headerlink\" title=\"ToPrimitive\"></a>ToPrimitive</h4><p>我们先讲 ToPrimitive，因为 ToNumber 中会用到 ToPrimitive，下面是关于 ToPrimitive 的规范：</p>\n<blockquote>\n<p>ToPrimitive 运算符接受一个值和一个可选的期望类型作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原始类型，可以使用可选的期望类型来暗示那个类型。根据下表完成转换：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>null</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>String</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>返回该对象的默认值。对象的默认值由把期望类型传入作为hint参数调用对象的内部方法 <code>[[DefaultValue]]</code> 得到</td>\n</tr>\n</tbody>\n</table>\n<p>对于 Object 这种输入类型，上面的表格中的描述不够清楚，我查了一些资料，概括如下：MDN 上对于 ToPrimitive 的语法规范定位为：</p>\n<blockquote>\n<p>ToPrimitive(obj, preferredType)</p>\n</blockquote>\n<p><strong>在执行 ToPrimitive(obj, preferredType) 时如果第二个参数为空并且 obj 为 Date 的实例时，此时 preferredType 会被设置为 String，其他情况下 preferredType 都会被设置为 Number</strong>。如果 preferredType 为 Number，ToPrimitive 执行过程如下：</p>\n<ol>\n<li>如果 obj 为原始值，直接返回；</li>\n<li>否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</li>\n<li>否则调用 obj.toString()，如果执行结果是原始值，返回之；</li>\n<li>否则抛异常。</li>\n</ol>\n<p>如果 preferredType 为 String，将上面的第 2 步和第 3 步调换，即：</p>\n<ol>\n<li>如果 obj 为原始值，直接返回；</li>\n<li>否则调用 obj.toString()，如果执行结果是原始值，返回之；</li>\n<li>否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</li>\n<li>否则抛异常。</li>\n</ol>\n<p>接下来我们就开始介绍v alueOf() 和 toString() 以及原始值了：</p>\n<h3 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf()\"></a>valueOf()</h3><p>valueOf 方法返回对象的原始值，可能是字符串、数值或 bool 值等，看具体的对象。还是看具体的例子吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"obj\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.valueOf());<span class=\"comment\">//Object &#123;name: \"obj\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = \\[<span class=\"number\">1</span>\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.valueOf());<span class=\"comment\">//\\[1\\]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date.valueOf());<span class=\"comment\">//1456638436303</span></span><br><span class=\"line\"><span class=\"comment\">//如代码所示，三个不同的对象实例调用valueOf返回不同的数据</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>toString 方法用来返回对象的字符串表示</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString());<span class=\"comment\">//\\[object Object\\]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = \\[\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.toString());<span class=\"comment\">//\"\"，即空字符串</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date.toString());<span class=\"comment\">//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>\n<p>这个方法具体的运行机制是个比较复杂的过程，我之后会专门写一篇文章讲解这两个方法，可以尝试搜索一下。（当然，也可以自己在控制台敲一下，加深印象）</p>\n<h3 id=\"原始值（Primitive）\"><a href=\"#原始值（Primitive）\" class=\"headerlink\" title=\"原始值（Primitive）\"></a>原始值（Primitive）</h3><p>“原始值”这三个字虽然听上去很高大上，其实很容易理解，就是指 null、undefined、String、Boolean、Number 这五种基本数据类型之一。 花了这么大力气终于把 ToPrimitive 介绍完了，下面我们介绍一下 ToNumber：</p>\n<h3 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h3><p>ToNumber 运算符根据下表将其参数转换为数值类型的值：</p>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>null</td>\n<td>+0</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>如果参数是true，结果为1。如果参数是false，结果为+0</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>String</td>\n<td>下面会介绍</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>“应用下列步骤：1.设原始值为ToPrimitive(输入参数，暗示数值类型)；2.返回ToNumber(上面的原始值)”</td>\n</tr>\n</tbody>\n</table>\n<p>上面表格已经很清楚了，但是还有个 ToNumber(String 类型)没有介绍：</p>\n<h4 id=\"字符转数字\"><a href=\"#字符转数字\" class=\"headerlink\" title=\"字符转数字\"></a>字符转数字</h4><p>字符转数字的规则是这样的：把字符串两边的空白字符去掉，然后把两边的引号去掉，看它能否组成一个合法的数字。如果能，转化结果就是这个数字，否则结果就是 NaN。举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'123'</span>) <span class=\"comment\">//结果123</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'1.2e3'</span>) <span class=\"comment\">//结果1200</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'123abc'</span>) <span class=\"comment\">//结果NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'\\\\r\\\\n\\\\t123\\\\v\\\\f'</span>) <span class=\"comment\">//结果123</span></span><br></pre></td></tr></table></figure>\n<p>当然也有例外，比如空白字符串转换为数字的结果是 0。即：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">''</span>) <span class=\"comment\">// 结果+0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'\\\\r\\\\n\\\\t \\\\v\\\\f'</span>) <span class=\"comment\">// 结果+0</span></span><br></pre></td></tr></table></figure>\n<p>到目前为止，我们介绍完了 ToPrimitive 和 ToNumber，所以上面那张图的内容基本上就介绍完了。但是还有个运算符没有讲，就是 “!” 取非操作，下面就介绍一下这个看似简单的取非操作：</p>\n<h3 id=\"ToBoolean\"><a href=\"#ToBoolean\" class=\"headerlink\" title=\"ToBoolean\"></a>ToBoolean</h3><p>取非其实是执行了 ToBoolean 运算符之后再取反，ToBoolean 运算符根据下表将其参数转换为布尔值类型的值：</p>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>false</td>\n</tr>\n<tr>\n<td>null</td>\n<td>false</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>结果等于输入的参数</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>如果参数是+0，-0或NaN，结果为false；否则结果为true</td>\n</tr>\n<tr>\n<td>String</td>\n<td>如果参数时空字符串（长度为零），结果为false；否则为true</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"没图你说个\"><a href=\"#没图你说个\" class=\"headerlink\" title=\"没图你说个**\"></a>没图你说个**</h3><p>相等操作符 (==) 对于不同类型的值，进行的比较如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_276.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"万物皆数\"><a href=\"#万物皆数\" class=\"headerlink\" title=\"万物皆数\"></a>万物皆数</h2><p>我们再来看上面那张图，里面标有 N 或 P 的那几条连线是没有方向的。假如我们在这些线上表上箭头，使得连线从标有 N 或 P 的那一端指向另一端，那么就会得到：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_50.png\" alt=\"\" width=\"300\"></div>\n\n<p>聪明的你肯定发现了，在 == 运算过程中，所有类型的值都有一种向数字类型转化的趋势。毕竟有这样一句名言：</p>\n<blockquote>\n<p>万物皆数</p>\n</blockquote>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>前面废话一堆，还不如举个实例来的痛快：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] == ![]</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">首先你需要明确的是上面这段代码执行的顺序，这就涉及到运算符的优先级了：`</span>! &gt; ==<span class=\"string\">`。所以 ! 取反运算符的优先级会高于 ==，那让我们先来看等号右边的 “!\\[\\]”，根据上面的 ToBoolean，**\\[\\]是一个对象**，那么 ToBoolean(\\[\\]) 就是 true，!\\[\\] 就是 false 了 然后，我们根据上面那张图，等号左边的 \\[\\] 是 Object，等号右边的 !\\[\\] 是一个 Boolean 值，所以最终就成为了 ToPrimitive(\\[\\]) == ToNumber(false) 了；而 ToPrimitive 默认调用 toString 方法，于是 ToPrimitive(\\[\\]) 就是空字符串，而 ToNumber(false) 就是 0；那么最后就成为了 \"\" == 0，这种形态，此时是 String 和 Number 之间的比较，很明显就是 toNumber(\"\") == 0 的比较了，根据 ToNumber 的转换规则，toNumber(\"\")=0，于是 \\[\\] == !\\[\\] 最后成了 0 == 0 的问题，答案显而易见为 true。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 总结一下</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">最后，我们总结一下 == 运算的规则：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* undefined == null，结果是 true。且它俩与所有其他值比较的结果都是 false。</span></span><br><span class=\"line\"><span class=\"string\">* String == Boolean，需要两个操作数同时转为 Number。</span></span><br><span class=\"line\"><span class=\"string\">* String/Boolean == Number，需要 String/Boolean 转为 Number。</span></span><br><span class=\"line\"><span class=\"string\">* Object == Primitive，需要 Object 转为 Primitive(具体通过 valueOf 和 toString方法)。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">所以，其实只有 4 条规则！只要我们完全理解了这四条规则，以后再遇到 == 就不会头疼了！</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 一些经典题目</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">\\[\\]==\\[\\]  <span class=\"comment\">//false</span></span><br><span class=\"line\">&#123;&#125;==&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">\\[\\]==!\\[\\]  <span class=\"comment\">//true</span></span><br><span class=\"line\">&#123;&#125;==!&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">&#123;&#125;==!\\[\\]  <span class=\"comment\">//VM1896:1 Uncaught SyntaxError: Unexpected token ==</span></span><br><span class=\"line\">!\\[\\]==&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">\\[\\]==!&#123;&#125;  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span>==<span class=\"literal\">null</span>  <span class=\"comment\">//true</span></span><br><span class=\"line\">+<span class=\"number\">0</span> === <span class=\"number\">-0</span>  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>  <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> !== <span class=\"literal\">false</span>  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>更新自2017-8-4：根据<a href=\"https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric\" target=\"_blank\" rel=\"noopener\">stackoverflow上的一个讨论</a>，我发现还有如下规则：2e308 === Infinity，原因是<strong>2e308 &gt; Number.MAX_VALUE</strong>，所以其相当于是无穷大，负无穷大同理。</p>\n</blockquote>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness\" target=\"_blank\" rel=\"noopener\">JavaScript 中的相等性判断</a></li>\n<li><a href=\"http://dorey.github.io/JavaScript-Equality-Table/\" target=\"_blank\" rel=\"noopener\">JS比较表</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008432611\" target=\"_blank\" rel=\"noopener\">从[]==![]为true来剖析JavaScript各种蛋疼的类型转换</a></li>\n<li><a href=\"http://www.admin10000.com/document/9242.html\" target=\"_blank\" rel=\"noopener\">通过一张简单的图，让你彻底地、永久地搞懂JS的==运算</a></li>\n<li><a href=\"https://www.zhihu.com/question/31442029\" target=\"_blank\" rel=\"noopener\">Javascript 中 == 和 === 区别是什么？</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"面试","path":"api/tags/面试.json"},{"name":"运算符","path":"api/tags/运算符.json"}]}]}