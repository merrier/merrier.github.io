{"total":114,"pageSize":10,"pageCount":12,"data":[{"title":"JS中数组方法总结","slug":"JS中数组方法总结","date":"2017-03-22T14:12:57.000Z","updated":"2019-01-27T10:07:12.316Z","comments":true,"path":"api/articles/JS中数组方法总结.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>因为刷 leetcode 的时候，发现会经常用到数组，因为 JS 中没有明确的栈和队列，所以需要用数组进行模拟，在刷算法题的过程中碰到了好多关于数组的计算方法，所以就打算对算法中经常用的数组方法进行总结，可能会对刚开始用 JS 刷 Leetcode 的码农有好处，如果你有任何补充，请留言评论或直接给我发邮件。</p>\n<h2 id=\"JS-自带数组方法\"><a href=\"#JS-自带数组方法\" class=\"headerlink\" title=\"JS 自带数组方法\"></a>JS 自带数组方法</h2><ul>\n<li>concat() =&gt; 连接两个或更多的数组，并返回结果。</li>\n<li>join() =&gt; 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</li>\n<li>pop() =&gt; 删除并返回数组的最后一个元素</li>\n<li>push() =&gt; 向数组的末尾添加一个或更多元素，并返回新的长度。</li>\n<li>reverse() =&gt; 颠倒数组中元素的顺序。</li>\n<li>shift() =&gt; 删除并返回数组的第一个元素</li>\n<li>slice() =&gt; 从某个已有的数组返回选定的元素</li>\n<li>sort() =&gt; 对数组的元素进行排序</li>\n<li>splice() =&gt; 删除元素，并向数组添加新元素。</li>\n<li>toSource() =&gt; 返回该对象的源代码。</li>\n<li>toString() =&gt; 把数组转换为字符串，并返回结果。</li>\n<li>toLocaleString() =&gt; 把数组转换为本地数组，并返回结果。</li>\n<li>unshift() =&gt; 向数组的开头添加一个或更多元素，并返回新的长度。</li>\n<li>valueOf() =&gt; 返回数组对象的原始值</li>\n</ul>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>JS 数组对象排序有内置方法 sort()，但是默认以字符串方式排序:</p>\n<h3 id=\"简单数组简单排序\"><a href=\"#简单数组简单排序\" class=\"headerlink\" title=\"简单数组简单排序\"></a>简单数组简单排序</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrSimple = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">arrSimple.sort();  <span class=\"comment\">// [1,6,7,8]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"简单数组自定义排序\"><a href=\"#简单数组自定义排序\" class=\"headerlink\" title=\"简单数组自定义排序\"></a>简单数组自定义排序</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrSimple2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">arrSimple2.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123; <span class=\"keyword\">return</span> b - a &#125;);  <span class=\"comment\">// [8,7,6,1]</span></span><br><span class=\"line\"><span class=\"comment\">// 解释：a, b表示数组中的任意两个元素，若return &gt; 0 b 前 a 后；reutrn &lt; 0 a 前 b 后；a = b 时存在浏览器兼容</span></span><br><span class=\"line\"><span class=\"comment\">// 简化一下：a-b 输出从小到大排序，b-a 输出从大到小排序。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除重复的元素只保留一个（两种实现思路）\"><a href=\"#删除重复的元素只保留一个（两种实现思路）\" class=\"headerlink\" title=\"删除重复的元素只保留一个（两种实现思路）\"></a>删除重复的元素只保留一个（两种实现思路）</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：遍历要删除的数组arr, 把元素分别放入另一个数组tmp中，在判断该元素在arr中不存在才允许放入tmp中用到两个函数：for ...in 和 indexOf()</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"a\"</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique1</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历arr，把元素分别放入tmp数组(不存在才放)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> arr)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该元素在tmp内部不存在才允许追加</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp.indexOf(arr[i])==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            tmp.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unique1(test);  <span class=\"comment\">// [2,4,5,\"a\"]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法二：把目标数组arr的元素值和键的位置调换 自动就把重复的元素给删除掉了，调换后的样子：array('qiang'=&gt;1,'ming'=&gt;1,'tao'=&gt;1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique2</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> m <span class=\"keyword\">in</span> arr)&#123;</span><br><span class=\"line\">        tmp[arr[m]]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 再把键和值的位置再次调换</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmparr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> n <span class=\"keyword\">in</span> tmp)&#123;</span><br><span class=\"line\">        tmparr.push(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmparr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unique2(test);  <span class=\"comment\">//[2,4,5,\"a\"]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法三：返回新数组，保证类型不变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique3</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hash=[],arr=[];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">        hash[a[i]]!=<span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!hash[a[i]])&#123;</span><br><span class=\"line\">            arr.push(a[i]);</span><br><span class=\"line\">            hash[a[i]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unique3(test);<span class=\"comment\">// [2, 4, 5, \"a\"]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取数组中的最大值和最小值\"><a href=\"#获取数组中的最大值和最小值\" class=\"headerlink\" title=\"获取数组中的最大值和最小值\"></a>获取数组中的最大值和最小值</h3><p>可以用传统的遍历，也可以用math</p>\n<p>首先定义一个数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">54</span>,<span class=\"number\">65</span>,<span class=\"number\">43</span>,<span class=\"number\">21</span>,<span class=\"number\">12</span>,<span class=\"number\">34</span>,<span class=\"number\">45</span>,<span class=\"number\">58</span>,<span class=\"number\">97</span>,<span class=\"number\">24</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一、字符串拼接法</span></span><br><span class=\"line\"><span class=\"comment\">// 利用toString和join把数组转换为字符串，再和Math的max和min方法分别进行拼接，最后执行eval方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = <span class=\"built_in\">eval</span>(<span class=\"string\">\"Math.max(\"</span> + arr.toString() + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = <span class=\"built_in\">eval</span>(<span class=\"string\">\"Math.min(\"</span> + arr.toString() + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = <span class=\"built_in\">eval</span>(<span class=\"string\">\"Math.max(\"</span> + arr.join() + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = <span class=\"built_in\">eval</span>(<span class=\"string\">\"Math.min(\"</span> + arr.join() + <span class=\"string\">\")\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法二、排序法</span></span><br><span class=\"line\"><span class=\"comment\">// 先把数组从小到大排序，数组第一个即为最小值，最后一个即为最大值</span></span><br><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;<span class=\"keyword\">return</span> a-b;&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = arr[arr.length<span class=\"number\">-1</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三-1\"><a href=\"#方法三-1\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法三、假设法</span></span><br><span class=\"line\"><span class=\"comment\">// 假设数组第一个为最大（或最小值），和后边进行比较，若后边的值比最大值大（或比最小值小），则替换最大值（或最小值）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cur = arr[i];</span><br><span class=\"line\">    cur&gt;maxN ? maxN=cur : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    cur&lt;minN ? minN=cur : <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法四\"><a href=\"#方法四\" class=\"headerlink\" title=\"方法四\"></a>方法四</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法四、Math的max和min方法</span></span><br><span class=\"line\"><span class=\"comment\">// 使用apply方法使数组可以作为传递的参数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>,arr);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = <span class=\"built_in\">Math</span>.min.apply(<span class=\"literal\">null</span>,arr);</span><br><span class=\"line\"><span class=\"comment\">// 多维数组可以这样做：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,[<span class=\"number\">5</span>,<span class=\"number\">6</span>],[<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>]];</span><br><span class=\"line\"><span class=\"keyword\">var</span> ta=a.join(<span class=\"string\">\",\"</span>).split(<span class=\"string\">\",\"</span>);<span class=\"comment\">// 转化为一维数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>,ta);<span class=\"comment\">// 最大值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = <span class=\"built_in\">Math</span>.min.apply(<span class=\"literal\">null</span>,ta);<span class=\"comment\">// 最小值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展：增加原型方法，同时为了避免其他库也实现了同名的原型方法，可以在生成函数之前进行重名判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype[<span class=\"string\">'max'</span>] == <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max.apply(&#123;&#125;,<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype[<span class=\"string\">'min'</span>] == <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.min.apply(&#123;&#125;,<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化二维数组\"><a href=\"#初始化二维数组\" class=\"headerlink\" title=\"初始化二维数组\"></a>初始化二维数组</h3><h4 id=\"方法一-2\"><a href=\"#方法一-2\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：直接定义并且初始化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _TheArray = [[<span class=\"string\">\"0-1\"</span>,<span class=\"string\">\"0-2\"</span>],[<span class=\"string\">\"1-1\"</span>,<span class=\"string\">\"1-2\"</span>],[<span class=\"string\">\"2-1\"</span>,<span class=\"string\">\"2-2\"</span>]]</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-2\"><a href=\"#方法二-2\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法二：未知长度的二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tArray = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();  <span class=\"comment\">// 先声明一维</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;k&lt;i;k++)&#123;    <span class=\"comment\">// 一维长度为i,i为变量，可以根据实际情况改变</span></span><br><span class=\"line\">    tArray[k]=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();  <span class=\"comment\">// 声明二维，每一个一维数组里面的一个元素都是一个数组；</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=<span class=\"number\">0</span>;j&lt;p;j++)&#123;   <span class=\"comment\">// 一维数组里面每个元素数组可以包含的数量p，p也是一个变量；</span></span><br><span class=\"line\">        tArray[k][j]=<span class=\"string\">\"\"</span>;    <span class=\"comment\">// 这里将变量初始化，我这边统一初始化为空，后面在用所需的值覆盖里面的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三-2\"><a href=\"#方法三-2\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以上方法都有问题，推荐方法三</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> r = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;k&lt;length;k++)&#123;    </span><br><span class=\"line\">   r[k]= [];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组随机排序\"><a href=\"#数组随机排序\" class=\"headerlink\" title=\"数组随机排序\"></a>数组随机排序</h3><h4 id=\"Fisher–Yates-shuffle-算法\"><a href=\"#Fisher–Yates-shuffle-算法\" class=\"headerlink\" title=\"Fisher–Yates shuffle 算法\"></a>Fisher–Yates shuffle 算法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shuffle</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = arr.length, t, j;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i) &#123;</span><br><span class=\"line\">    j = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * i--);</span><br><span class=\"line\">    t = arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来自——<a href=\"https://blog.oldj.net/2017/01/23/shuffle-an-array-in-javascript/\" target=\"_blank\" rel=\"noopener\">关于JavaScript的数组随机排序</a></p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"数组","path":"api/tags/数组.json"}]},{"title":"一些位操作的技巧","slug":"一些位操作的技巧","date":"2017-03-21T14:11:27.000Z","updated":"2019-01-27T10:07:12.320Z","comments":true,"path":"api/articles/一些位操作的技巧.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这篇文章大部分是从英文翻译过来的，是在刷 leetcode 的时候看到的一个 solution，感觉作者讲的很好，只不过英文的读起来有点费劲，在网上搜了一下，发现也没有翻译的版本，于是就想做第一个吃螃蟹的人，然后再加一些其他文章中的位操作技巧进行总结，最终形成了这个版本（文末有原文链接，英文好的可以去看一下，毕竟看原文才不会被误导）</p>\n<h2 id=\"位操作介绍\"><a href=\"#位操作介绍\" class=\"headerlink\" title=\"位操作介绍\"></a>位操作介绍</h2><p>位操作是对少于一个字母的数据段或位数进行算法层面的计算。在计算机工程领域，用到位操作任务有低等级设备控制、误差检测和校正算法，数据压缩、加密算法和优化算法。对于大多数任务而言，现在编程语言允许程序员直接用高级语言而不是位操作。位操作的源码使用位运算：<strong>AND、OR、XOR、NOT 和移位</strong> 由于位操作是可以并行处理的，所以在某些情况下可以减少甚至避免对于某数据结构的循环操作，从而在速度上会有较大提升，但是代码将变得很难书写和理解。</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>位操作的核心是位运算符 &amp;（和）、|（或）、~（不）、^（异或）以及移位运算符 a &lt;&lt; b 和 a &gt;&gt; b（异或通常缩写为 XOR）。</p>\n<ul>\n<li>取并集：A | B</li>\n<li>取交集：A &amp; B</li>\n<li>取补集：A &amp; ~B</li>\n<li>所有位数取反：^A 或者~A</li>\n<li>设置某位：A | = 1 &lt;&lt; bit</li>\n<li>清除某位：A &amp; = ~（1 &lt;&lt; bit）</li>\n<li>检验某位：(A &amp; 1 &lt;&lt; bit) != 0</li>\n<li>提取最后一位：A &amp; -A 或者 A &amp; ~ (A-1) 或者x ^ (x &amp; (x-1))</li>\n<li>移除最后一位：A &amp; (A-1)</li>\n<li>所有位数为1：~0</li>\n</ul>\n<h2 id=\"位操作的基本技巧\"><a href=\"#位操作的基本技巧\" class=\"headerlink\" title=\"位操作的基本技巧\"></a>位操作的基本技巧</h2><ul>\n<li>用异或操作符 ^ 可以删除完全相同的数字然后保存剩余的，或者保存不同位然后移除相同位</li>\n<li>用 | 操作符可以留存尽可能多的 1</li>\n<li>用 &amp; 可以筛选出指定位</li>\n</ul>\n<h3 id=\"1-检查整数是奇数还是偶数\"><a href=\"#1-检查整数是奇数还是偶数\" class=\"headerlink\" title=\"1. 检查整数是奇数还是偶数\"></a>1. 检查整数是奇数还是偶数</h3><p>只要整数的最后一位比特是 1，那它就是奇数，反之就是偶数。即最低位要么是 1 要么是 0，x 和 1 与（&amp;）运算，保留最低位，如果最低位是 1，x 是奇数，如果最低位是 0 ，x 是偶数。<br>例如 43，二进制表示为 00101011，注意\b它的最低位为 1，我们将 43 与 1 做 &amp; 运算：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    00101011</span><br><span class=\"line\">&amp;   00000001   (note: 1 is the same as 00000001)</span><br><span class=\"line\">    --------</span><br><span class=\"line\">    00000001</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-测试第-n-位比特\"><a href=\"#2-测试第-n-位比特\" class=\"headerlink\" title=\"2. 测试第 n 位比特\"></a>2. 测试第 n 位比特</h3><p>只要将与运算的 1 向左平移相应的位数即可。假设向左平移 n 位，接下来的与运算就是只保留第 n 位，其它位都清零了。<br>比如：122 的第三位比特是 1 吗？（从 0 开始数）可以这样做：122 &amp; (1 &lt;&lt; 3)，122 的二进制表示是 01111010，(1 &lt;&lt; 3)即 1 向左平移 3 比特 00001000。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    01111010</span><br><span class=\"line\">&amp;   00001000</span><br><span class=\"line\">    --------</span><br><span class=\"line\">    00001000</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-将第-n-位设为-1-或不变\"><a href=\"#3-将第-n-位设为-1-或不变\" class=\"headerlink\" title=\"3. 将第 n 位设为 1 或不变\"></a>3. 将第 n 位设为 1 或不变</h3><p>和前面的技巧一样，只是把与运算（&amp;）换成了或运算（|）。与 1 进行或运算将参与运算的位置设为 1，与 0 进行或运算参与预算的位不变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x | (1 &lt;&lt; n)</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-将第-n-位设为-0\"><a href=\"#4-将第-n-位设为-0\" class=\"headerlink\" title=\"4. 将第 n 位设为 0\"></a>4. 将第 n 位设为 0</h3><p>这个方法的关键就是 ~(1 &lt;&lt; n)，它将第 n 位设为 0，其它位全部为 1。看下面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x &amp; ~(1 &lt;&lt; n)</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-将第-n-位取反\"><a href=\"#5-将第-n-位取反\" class=\"headerlink\" title=\"5. 将第 n 位取反\"></a>5. 将第 n 位取反</h3><p>这次使用的是异或运算，如果异或运算的两个操作数相同，运算结果是 0，两个操作数不同，结果是 1。怎样将第 n 位取反呢？如果第 n 位比特为 1，将它与 1 进行异或运算结果就是 0，如果它是 0，那么它与 1 异或运算的结果就是 1。于是这一位就取反了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x ^ (1 &lt;&lt; n)</span><br></pre></td></tr></table></figure>\n<h2 id=\"位操作在数字运算中的应用\"><a href=\"#位操作在数字运算中的应用\" class=\"headerlink\" title=\"位操作在数字运算中的应用\"></a>位操作在数字运算中的应用</h2><h3 id=\"1-计算某二进制数中的-1-的数量\"><a href=\"#1-计算某二进制数中的-1-的数量\" class=\"headerlink\" title=\"1. 计算某二进制数中的 1 的数量\"></a>1. 计算某二进制数中的 1 的数量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count_one</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">        n = n&amp;(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-判断某数字是否为-4-的-n-次方-n-≥-0-，是就返回该数，不是就返回-0-或-false\"><a href=\"#2-判断某数字是否为-4-的-n-次方-n-≥-0-，是就返回该数，不是就返回-0-或-false\" class=\"headerlink\" title=\"2. 判断某数字是否为 4 的 n 次方(n ≥ 0)，是就返回该数，不是就返回 0 或 false\"></a>2. 判断某数字是否为 4 的 n 次方(n ≥ 0)，是就返回该数，不是就返回 0 或 false</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">bool <span class=\"title\">isPowerOfFour</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(n&amp;(n-<span class=\"number\">1</span>)) &amp;&amp; (n&amp;<span class=\"number\">0x55555555</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-使用-和-amp-来求两个数字的和\"><a href=\"#3-使用-和-amp-来求两个数字的和\" class=\"headerlink\" title=\"3. 使用 ^ 和 &amp; 来求两个数字的和\"></a>3. 使用 ^ 和 &amp; 来求两个数字的和</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b==<span class=\"number\">0</span>? a:getSum(a^b, (a&amp;b)&lt;&lt;<span class=\"number\">1</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-寻找丢失数字：给你一个包括从-0-到-n-的各不相同的-n-元数组，从中找出丢失的那个数字，比如给你的数组为-0-1-3-，那么应该返回-2（当然，你也可以用数学方法解决）\"><a href=\"#4-寻找丢失数字：给你一个包括从-0-到-n-的各不相同的-n-元数组，从中找出丢失的那个数字，比如给你的数组为-0-1-3-，那么应该返回-2（当然，你也可以用数学方法解决）\" class=\"headerlink\" title=\"4. 寻找丢失数字：给你一个包括从 0 到 n 的各不相同的 n 元数组，从中找出丢失的那个数字，比如给你的数组为 [0, 1, 3]，那么应该返回 2（当然，你也可以用数学方法解决）\"></a>4. 寻找丢失数字：给你一个包括从 0 到 n 的各不相同的 n 元数组，从中找出丢失的那个数字，比如给你的数组为 [0, 1, 3]，那么应该返回 2（当然，你也可以用数学方法解决）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">        ret ^= i;</span><br><span class=\"line\">        ret ^= nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret^=nums.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-给定一个自然数-N，找到小于等于-N-的-2-的最大倍数\"><a href=\"#5-给定一个自然数-N，找到小于等于-N-的-2-的最大倍数\" class=\"headerlink\" title=\"5. 给定一个自然数 N，找到小于等于 N 的 2 的最大倍数\"></a>5. 给定一个自然数 N，找到小于等于 N 的 2 的最大倍数</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">largest_power</span><span class=\"params\">(<span class=\"keyword\">long</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将所有右侧位变为1.</span></span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">4</span>);</span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">8</span>);</span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (N+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-将一个-32-位的无符号数进行反转\"><a href=\"#6-将一个-32-位的无符号数进行反转\" class=\"headerlink\" title=\"6. 将一个 32 位的无符号数进行反转\"></a>6. 将一个 32 位的无符号数进行反转</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint32_t <span class=\"title\">reverseBits</span><span class=\"params\">(uint32_t n)</span> </span>&#123;</span><br><span class=\"line\">    unsigned <span class=\"keyword\">int</span> mask = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &amp; <span class=\"number\">1</span>) res |= mask;</span><br><span class=\"line\">        mask &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">uint32_t <span class=\"title\">reverseBits</span><span class=\"params\">(uint32_t n)</span> </span>&#123;</span><br><span class=\"line\">\tuint32_t mask = <span class=\"number\">1</span>, ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i)&#123;</span><br><span class=\"line\">\t\tret &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(mask &amp; n) ret |= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tmask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-给定一个范围-m-n-，其中-0-lt-m-lt-n-lt-2147483647，返回在这个范围内的所有数的按位进行-AND-操作之后的数字，比如范围为-5-7-，那返回的应该是按位进行计算的-5-6-7，结果是-4（100）\"><a href=\"#7-给定一个范围-m-n-，其中-0-lt-m-lt-n-lt-2147483647，返回在这个范围内的所有数的按位进行-AND-操作之后的数字，比如范围为-5-7-，那返回的应该是按位进行计算的-5-6-7，结果是-4（100）\" class=\"headerlink\" title=\"7. 给定一个范围[m, n]，其中 0&lt;=m&lt;=n&lt;=2147483647，返回在这个范围内的所有数的按位进行 AND 操作之后的数字，比如范围为 [5, 7]，那返回的应该是按位进行计算的 5+6+7，结果是 4（100）\"></a>7. 给定一个范围[m, n]，其中 0&lt;=m&lt;=n&lt;=2147483647，返回在这个范围内的所有数的按位进行 AND 操作之后的数字，比如范围为 [5, 7]，那返回的应该是按位进行计算的 5+6+7，结果是 4（100）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeBitwiseAnd</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m != n) &#123;</span><br><span class=\"line\">        m &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m&lt;&lt;a; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-求一个无符号数的汉明距离（即二进制表示中的-1-的个数）\"><a href=\"#8-求一个无符号数的汉明距离（即二进制表示中的-1-的个数）\" class=\"headerlink\" title=\"8. 求一个无符号数的汉明距离（即二进制表示中的 1 的个数）\"></a>8. 求一个无符号数的汉明距离（即二进制表示中的 1 的个数）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(uint32_t n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">\t\tn = n&amp;(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tcount++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(uint32_t n)</span> </span>&#123;</span><br><span class=\"line\">    ulong mask = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mask &amp; n) count++;</span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-用位操作交换变量\"><a href=\"#9-用位操作交换变量\" class=\"headerlink\" title=\"9. 用位操作交换变量\"></a>9. 用位操作交换变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = a ^ b; </span><br><span class=\"line\">b = a ^ b;  <span class=\"comment\">// 实际上是(a^b)^b 也就是a异或了b两次，等号右边是a的值</span></span><br><span class=\"line\">a = a ^ b;  <span class=\"comment\">// 此时b里面已经是“果汁”，实际上是(a^b)^a，也就是b异或了a两次，是b</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"位操作更复杂的应用\"><a href=\"#位操作更复杂的应用\" class=\"headerlink\" title=\"位操作\b更复杂的应用\"></a>位操作\b更复杂的应用</h2><h3 id=\"1-查找-DNA-重复序列\"><a href=\"#1-查找-DNA-重复序列\" class=\"headerlink\" title=\"1. 查找 DNA 重复序列\"></a>1. 查找 DNA 重复序列</h3><p>所有的 DNA 是由一系列简写为 A、C、G 和 T 核苷酸组成的，比如 “ACGAATTCCG”，当我们研究 DNA 时，有时候识别 DNA 中的重复序列是有用的，设计一个方法可以找出所有在 DNA 分子中出现不止一次的 10 字母长的序列（或子序列）</p>\n<p>举个例子：<br>Given s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT” Return: [“AAAAACCCCC”, “CCCCCAAAAA”]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">findRepeatedDnaSequences</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sLen = s.length();</span><br><span class=\"line\">        vector&lt;string&gt; v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sLen &lt; <span class=\"number\">11</span>) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> keyMap[<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">21</span>]&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hashKey = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; ++i) hashKey = (hashKey&lt;&lt;<span class=\"number\">2</span>) | (s[i]-<span class=\"string\">'A'</span>+<span class=\"number\">1</span>)%<span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">9</span>; i &lt; sLen; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(keyMap[hashKey = ((hashKey&lt;&lt;<span class=\"number\">2</span>)|(s[i]-<span class=\"string\">'A'</span>+<span class=\"number\">1</span>)%<span class=\"number\">5</span>)&amp;<span class=\"number\">0xfffff</span>]++ == <span class=\"number\">1</span>)</span><br><span class=\"line\">                v.push_back(s.substr(i-<span class=\"number\">9</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-多数单元\"><a href=\"#2-多数单元\" class=\"headerlink\" title=\"2. 多数单元\"></a>2. 多数单元</h3><p>给定一个 n 元数组，多数单元式在该数组中出现次数多于 ⌊n/2⌋ 次的数（一般采用位运算，但是在这里我们也可以采用分组和穆尔投票算法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = sizeof(<span class=\"keyword\">int</span>)*<span class=\"number\">8</span>, size = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>, mask = <span class=\"number\">1</span>, ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; size; ++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mask &amp; nums[j]) count++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count &gt; size/<span class=\"number\">2</span>) ret |= mask;</span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-找数字\"><a href=\"#3-找数字\" class=\"headerlink\" title=\"3. 找数字\"></a>3. 找数字</h3><p>给定整数数组，每个元素都出现了三次，除了一个元素，找到这个元素（这种问题通过位运算可以迎刃而解）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inspired by logical circuit design and boolean algebra;</span></span><br><span class=\"line\"><span class=\"comment\">// counter - unit of 3;</span></span><br><span class=\"line\"><span class=\"comment\">// current   incoming  next</span></span><br><span class=\"line\"><span class=\"comment\">// a b            c    a b</span></span><br><span class=\"line\"><span class=\"comment\">// 0 0            0    0 0</span></span><br><span class=\"line\"><span class=\"comment\">// 0 1            0    0 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1 0            0    1 0</span></span><br><span class=\"line\"><span class=\"comment\">// 0 0            1    0 1</span></span><br><span class=\"line\"><span class=\"comment\">// 0 1            1    1 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1 0            1    0 0</span></span><br><span class=\"line\"><span class=\"comment\">// a = a&amp;~b&amp;~c + ~a&amp;b&amp;c;</span></span><br><span class=\"line\"><span class=\"comment\">// b = ~a&amp;b&amp;~c + ~a&amp;~b&amp;c;</span></span><br><span class=\"line\"><span class=\"comment\">// return a|b since the single number can appear once or twice;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"number\">0</span>, a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">        t = (a&amp;~b&amp;~nums[i]) | (~a&amp;b&amp;nums[i]);</span><br><span class=\"line\">        b = (~a&amp;b&amp;~nums[i]) | (~a&amp;~b&amp;nums[i]);</span><br><span class=\"line\">        a = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a | b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-字符长度的最大积\"><a href=\"#4-字符长度的最大积\" class=\"headerlink\" title=\"4. 字符长度的最大积\"></a>4. 字符长度的最大积</h3><p>给定一个包含几个字符串的数组，找到 length(word[i])*length(word[j]) 的最大值，其中这两个字符串没有共同的字符。假定每个字符串的字符均为小写，如果没有这样的两个字符，返回 0</p>\n<h4 id=\"实例：\"><a href=\"#实例：\" class=\"headerlink\" title=\"实例：\"></a>实例：</h4><ol>\n<li>Example 1: Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”] Return 16 The two words can be “abcw”, “xtfn”. </li>\n<li>Example 2: Given [“a”, “ab”, “abc”, “d”, “cd”, “bcd”, “abcd”] Return 4 The two words can be “ab”, “cd”.</li>\n<li>Example 3: Given [“a”, “aa”, “aaa”, “aaaa”] Return 0 No such pair of words.</li>\n</ol>\n<h4 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h4><p>因为我们要非常频繁的用到字符串的长度，并且我们要比较两个字符串中的字符来检测他们是否有相同的字符，所以：</p>\n<ul>\n<li>使用一个 int 型数组来保存每个字符串的长度</li>\n<li>因为 int 型数字有 4 比特，可以有 32 位，而字母只有 26 中，所以我们仅仅使用一位就可以代表字母在字符串中的存在与否</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">mask</span><span class=\"params\">(words.size()</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">lens</span><span class=\"params\">(words.size()</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; words.size(); ++i) lens[i] = words[i].length();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;words.size(); ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : words[i])</span><br><span class=\"line\">            mask[i] |= <span class=\"number\">1</span> &lt;&lt; (c - <span class=\"string\">'a'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;i; ++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(mask[i] &amp; mask[j]))</span><br><span class=\"line\">                result = max(result, lens[i]*lens[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二进制在趣味数学中的应用\"><a href=\"#二进制在趣味数学中的应用\" class=\"headerlink\" title=\"二进制在趣味数学中的应用\"></a>二进制在趣味数学中的应用</h2><h3 id=\"1-一工人工作-7-天，老板有一段黄金，每天要给工人-1-7-的黄金作为工资，老板只能切这段黄金-2-刀，请问怎样切才能每天都给工人-1-7-的黄金？\"><a href=\"#1-一工人工作-7-天，老板有一段黄金，每天要给工人-1-7-的黄金作为工资，老板只能切这段黄金-2-刀，请问怎样切才能每天都给工人-1-7-的黄金？\" class=\"headerlink\" title=\"1. 一工人工作 7 天，老板有一段黄金，每天要给工人 1/7 的黄金作为工资，老板只能切这段黄金 2 刀，请问怎样切才能每天都给工人 1/7 的黄金？\"></a>1. 一工人工作 7 天，老板有一段黄金，每天要给工人 1/7 的黄金作为工资，老板只能切这段黄金 2 刀，请问怎样切才能每天都给工人 1/7 的黄金？</h3><p>因为 7 &lt; 2^3 = 8，所以只要使用 2^0，2^1，2^2 三个数，就可以表示 1 到 7 之间的所有数。那么我们只要把金条分成三份，比例为 1:2:4，也就是第一刀切下金条的七分之一（设为黄金 A），第二刀切下金条的七分之二（设为黄金 B），剩下的部分刚好为金条的七分之四（设为黄金 C）。我们只要按照如下的方法发放工资，就解决问题了：</p>\n<ol>\n<li>第一天：给长工黄金 A；（1 = 2^0）</li>\n<li>第二天：给长工黄金 B，并把黄金 A 拿回来；（2 = 2^1）</li>\n<li>第三天：给长工黄金 A；（3 = 2^0 + 2^1）</li>\n<li>第四天：给长工黄金 C，并把黄金 A 和黄金 B 拿回来；（4 = 2^2）</li>\n<li>第五天：给长工黄金 A；（5 = 2^0 + 2^2）</li>\n<li>第六天：给长工黄金 B，并把黄金 A 拿回来；（6 = 2^1 + 2^2）</li>\n<li>第七天：给长工黄金 A。（5 = 2^0 + 2^1 + 2^2）</li>\n</ol>\n<h3 id=\"2-用天平称-1-63-克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？\"><a href=\"#2-用天平称-1-63-克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？\" class=\"headerlink\" title=\"2. 用天平称 1~63 克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？\"></a>2. 用天平称 1~63 克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？</h3><p>没有学过二进制的人是很难想到答案的，可是如果你知道二进制数，那就不难了。我们知道二进制中只有 0 和 1 两个数字，它的各位数字的权值从小到大依次为 2^0，2^1，2^2，2^3。。。。我们用一个数的每位数字乘以其权值所得到的乘积之和来表示这个数。对于一个具有 8 位的二进制数来说，它可以表示的数据范围是 0~2^8。63 = 2^6 – 1 = 2^0 + 2^1 + 2^2 + 2^3 + 2^4 + 2^5 所以，我们只需配备 2^0 =1，2^1 = 2，2^2 = 4，2^3 = 8，2^4 = 16，2^5 = 32 五种不同克数的砝码各一个。</p>\n<h3 id=\"3-药瓶问题\"><a href=\"#3-药瓶问题\" class=\"headerlink\" title=\"3. 药瓶问题\"></a>3. 药瓶问题</h3><p>一家药店收到运来的某种药品十瓶。每瓶装药丸 1000 粒。药剂师怀特先生刚把药瓶送上架子，一封电报接踵而来。怀特先生把电报念给药店经理布莱克小姐听。怀特先生：“特急！所有药瓶须检查后方能出售。由于失误，其中有一瓶药丸每粒超重 10 毫克。请即退回分量有误的那瓶药。怀特先生很气恼。怀特先生：“倒霉极了，我只好从每瓶中取出一粒来称一下。真是胡闹。怀特先生刚要动手，布莱克小姐拦住了他。布莱克小姐：“等一下，没必要称十次，只需称一次就够了。”这怎么可能呢？<br>布莱克小姐的妙主意是从第一瓶中取出1粒，从第二瓶中取出 2 粒，第三瓶中取出 3 粒，以此类推，直至从第十瓶中取出 10 粒。把这 55 粒药丸放在秤上，记下总重量。如果重 5510 毫克，也就是超过规格 10 毫克，她当即明白其中只有一粒是超重的，并且是从第一瓶中取出的。如果总重量超过规格 20 毫克，则其中有 2 粒超重，并且是从第二瓶中取出的，以此类推进行判断。所以布莱克小姐只要称一次，不是吗？<br>六个月后，药店又收到此种药品十瓶。一封加急电报又接踵而至，指出发生了一个更糟糕的错误。这一次，药丸每粒超重仍然是 10 毫克，但是对超重药丸的瓶数无可奉告，也就是说可能有好几个药瓶超重。怀特先生气恼极了。怀特先生：“布莱克小姐，怎么办？我们上次的方法不中用了。布莱克小姐没有立即回答，她在思索这个问题。布莱克小姐：“不错。但如果把那个方法改变一下，我们仍然只需称一次就能把分量有误的药品识别出来。这回布莱克小姐又有什么好主意？<br>为了解决第二个问题，我们必须用一个数字序列把每瓶药单独标上某个数字，且此序列中的每一个子集必须有一个单独的和。有没有这样的序列？有的，最简单的就是下列二重序列：1，2，4，8，16，。。。这些数字是 2 的连续次幂，这一序列为二进制记数法奠定了基础。在这个问题中，解法是把药瓶排成一行，从第一瓶中取出 1 粒，从第二瓶中取出 2 粒，从第三瓶中取出 4 粒，以此类推。取出的药丸放在秤上称一下。假设总重量超重 270 毫克，由于每粒分量有误的药丸超重 10 毫克，所以我们把 270 除以 10，得到 27，即为超重药丸的粒数。把 27 化成二进制数：11011 。在 11011 中自右至左，第一，二，四，五位上的“1”表示其权值分别为 1，2，8，16。因此分量有误的药瓶是第一，二，四，五瓶。</p>\n<h3 id=\"4-简单的扑克魔术\"><a href=\"#4-简单的扑克魔术\" class=\"headerlink\" title=\"4. 简单的扑克魔术\"></a>4. 简单的扑克魔术</h3><p>请别人把一副牌洗过，然后放进你的口袋，再请人说出一个 1 至 15 以内的数字。然后你把手插进你的口袋里，一伸手就取出一组牌，其数值相加正好等于他所说的数字。<br>此秘密简单的很。在耍魔术之前，预先取出 A，2，4，8 各一张放入口袋。这副牌缺少区区四张，不大可能为人察觉。洗过的牌放入口袋后，暗中将其排置于原先已经放在口袋中的四张牌的后面。请别人说出一个数字，你用心算将此数表示成 2 的幂的和。如果是 10，那你就应想到：8+2=10，随即伸手入袋，取出 2 和 8 的牌示众。</p>\n<h3 id=\"5-心灵感应游戏\"><a href=\"#5-心灵感应游戏\" class=\"headerlink\" title=\"5. 心灵感应游戏\"></a>5. 心灵感应游戏</h3><p>心灵感应游戏的依据也是二进制原理，准备五张卡片，分别记为 A，B，C，D，E，上面写着 1~31 之间的一些整数。请一位观众想好此范围内的一个数字（例如某个人的年龄），然后请他把所有上面有此数字的卡片都交给你。你随即说出他心中所想的那个数字。<br>卡片如下： </p>\n<ul>\n<li>A：1   3   5   7  9   11  13  15  17  19  21  23  25  27  29  31</li>\n<li>B：2   3   6   7  10  11  14  15  18  19  22  23  26  27  30  31</li>\n<li>C：4   5   6   7  12  13  14  15  20  21  22  23  28  29  30  31</li>\n<li>D：8   9  10   11  12  13  14  15  24  25  26  27  28  29  30  31</li>\n<li>E：16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31</li>\n</ul>\n<p>秘诀就是把每张卡片上 2 的幂的第一个数字相加。例如，如果把卡片 C 和 E 交给你，你只要将上面第一个数字 4 和 16 相加，便知道别人心中所想的数字是 20。这是为什么呢？<br>我们观察卡片上的数字，可以发现这样一个规律：<br>第一张卡片 (A) 上的数字如果用五位二进制表示，则分别为：<br>00001，00011，00101，00111，01001，01011，01101，01111，10001，10011，10101，10111，11001，11011，11101，11111。<br>第二张卡片 (B) 上的数字如果用五位二进制表示，则分别为：<br>00010，00011，00110，00111，01010，01011，01110，01111，10010，10011，10110，10111，11010，11011，11110，11111。<br>第三张卡片 (C) 上的数字如果用五位二进制表示，则分别为：<br>00100，00101，00110，00111，01100，01101，01110，01111，10100，10101，10110，10111，11100，11101，11110，11111。<br>请大家注意观察，第一张卡片上每个二进制数的右起第一位都是 “1”，第二张卡片上每个二进制数的右起第二位都是 “1”，第三张卡片上每个二进制数的右起第三位都是 “1”。依此类推，我们可以发现第 n 张卡片上每个二进制数的右起第 n 位都是 “1”。观众所想的数字和卡片的关系只有“有”和“无”两种状态，正好与二进制数码 0 与 1 一一对应。“有”我们就记为 “1”，“无”我们就记为 “0”，这样观众交给我们的卡片组合，就对应一个二进制数，如把卡片 C 和 E 交给你，那卡片组合就是“有无有无无”，对应二进制数为 10100”，即十进制数 “20”。又如把卡片A，B 和 E 交给你，那卡片组合就是“有无无有有”，对应二进制数为 “10011”，即十进制数 “19”。 二进制数的位数越多，能够表示的数值就越大，如果有 6 张卡片，则表示的数字范围扩大到 1~63，7 张卡片则可以表示 1~127。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently\" target=\"_blank\" rel=\"noopener\">A summary: how to use bit manipulation to solve problems easily and efficiently</a></li>\n</ul>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://graphics.stanford.edu/~seander/bithacks.html\" target=\"_blank\" rel=\"noopener\">Bit Twiddling Hacks</a></li>\n<li><a href=\"http://lab.polygonal.de/2007/05/10/bitwise-gems-fast-integer-math/\" target=\"_blank\" rel=\"noopener\">Bitwise gems – fast integer math</a></li>\n</ul>\n","raw":null,"categories":[{"name":"computer-base","path":"api/categories/computer-base.json"}],"tags":[{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"位操作","path":"api/tags/位操作.json"}]},{"title":"前端面试系列（3）——HTTP/2新特性","slug":"前端面试系列（3）——HTTP2新特性","date":"2017-03-19T13:18:57.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/前端面试系列（3）——HTTP2新特性.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_37.png","content":"<p>如果你认为前端不需要了解 HTTP 的话你就大错特错了，根据师兄师姐们的面试经验反馈，前端面试时关于 HTTP 的问题提问的几率也很大，而且对于更高一层的 tcp/ip 协议的认知也是前端开发者需要掌握的，所以我打算把关于 HTTP/2 新特性的文章作为前端面试系列的第三篇文章，如果想对 HTTP/2 协议有更深入的了解，可以点击文末的扩展阅读链接。</p>\n<h2 id=\"HTTP-2-源自-SPDY2\"><a href=\"#HTTP-2-源自-SPDY2\" class=\"headerlink\" title=\"HTTP/2 源自 SPDY2\"></a>HTTP/2 源自 SPDY2</h2><p>SPDY 系列协议由谷歌开发，于 2009 年公开。它的设计目标是降低 50% 的页面加载时间。当下很多著名的互联网公司，例如百度、淘宝、<a href=\"https://www.upyun.com/\" target=\"_blank\" rel=\"noopener\">UPYUN</a> 都在自己的网站或 APP 中采用了 SPDY 系列协议（当前最新版本是 SPDY/3.1），因为它对性能的提升是显而易见的。主流的浏览器（谷歌、火狐、Opera）也都早已经支持 SPDY，它已经成为了工业标准，HTTP Working-Group 最终决定以 SPDY/2 为基础，开发 HTTP/2。 但是，HTTP/2 跟 SPDY 仍有不同的地方，主要是以下两点：</p>\n<ol>\n<li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>\n<li>HTTP/2 消息头的压缩算法采用 <a href=\"http://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"noopener\">HPACK</a>，而非 SPDY 采用的 <a href=\"http://zh.wikipedia.org/wiki/DEFLATE\" target=\"_blank\" rel=\"noopener\">DELEFT</a></li>\n</ol>\n<h2 id=\"HTTP-2-的优势\"><a href=\"#HTTP-2-的优势\" class=\"headerlink\" title=\"HTTP/2 的优势\"></a>HTTP/2 的优势</h2><h3 id=\"1-HTTP-是一个二进制协议\"><a href=\"#1-HTTP-是一个二进制协议\" class=\"headerlink\" title=\"1. HTTP 是一个二进制协议\"></a>1. HTTP 是一个二进制协议</h3><p>基于二进制的 HTTP/2 可以使成帧的使用变得更为便捷。在 HTTP1.1 和其他基于文本的协议中，对帧的起始和结束识别起来相当复杂。而另一方面，这项决议同样使得我们可以更加便捷的从帧结构中分离出那部分协议本身的内容。而在 HTTP1 中，各个部分相互交织，犹如一团乱麻。</p>\n<p>HTTP/2 会发送有着不同类型的二进制帧，但他们都有如下的公共字段：Type, Length, Flags, Steam Identifier 和 frame payload；规范中一共定义了 10 种不同的帧，其中最基础的两种分别对应于 HTTP 1.1 的 DATA 和 HEADERS。之后我会更详细的介绍它们其中的一部分。</p>\n<p>二进制协议的优势显而易见：解析开销更小，描述协议也更高效。</p>\n<h3 id=\"2-多路复用的流\"><a href=\"#2-多路复用的流\" class=\"headerlink\" title=\"2. 多路复用的流\"></a>2. 多路复用的流</h3><p>流是一个逻辑上的联合，一个独立的，双向的帧序列可以通过一个 HTTP/2 的连接在服务端与客户端之间不断的交换数据。</p>\n<p>每个单独的 HTTP/2 连接都可以包含多个并发的流，这些流中<strong>交错</strong>的包含着来自两端的帧。流既可以被客户端/服务器端单方面的建立和使用，也可以被双方共享，或者被任意一边关闭。在流里面，<strong>每一帧发送的顺序非常关键</strong>。接收方会按照收到帧的顺序来进行处理。</p>\n<p>流的多路复用意味着在同一连接中来自各个流的数据包会被混合在一起。就好像两个（或者更多）独立的“数据列车”被拼凑到了一辆列车上，但它们最终会在终点站被分开。</p>\n<h3 id=\"3-优先级和依赖性\"><a href=\"#3-优先级和依赖性\" class=\"headerlink\" title=\"3. 优先级和依赖性\"></a>3. 优先级和依赖性</h3><p>每个流都包含一个优先级（也就是“权重”），它被用来告诉对端哪个流更重要。当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流。</p>\n<p>借助于 PRIORITY 帧（关于 HTTP/2 中帧的介绍可以查看文末扩展阅读），客户端同样可以告知服务器当前的流依赖于其他哪个流。该功能让客户端能建立一个优先级“树”，所有“子流”会依赖于“父流”的传输完成情况。</p>\n<p>优先级和依赖关系可以在传输过程中被动态的改变。这样当用户滚动一个全是图片的页面的时候，浏览器就能够指定哪个图片拥有更高的优先级。或者是在你切换标签页的时候，浏览器可以提升新切换到的页面所包含流的优先级。</p>\n<h3 id=\"4-头压缩\"><a href=\"#4-头压缩\" class=\"headerlink\" title=\"4. 头压缩\"></a>4. 头压缩</h3><p>HTTP 是一种无状态的协议。简而言之，这意味着每个请求必须要携带服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。因为 HTTP/2 并没有改变这个范式，所以它也需要这样（携带所有细节）。</p>\n<p>这也保证了 HTTP 可重复性。当一个客户端从同一服务器请求了大量资源（例如页面的图片）的时候，所有这些请求看起来几乎都是一致的，而这些大量一致的东西则正好值得被压缩。</p>\n<p>当每个页面资源的个数上升的时候，cookies 和请求的大小都会增加，而每个请求都会包含的 cookie 几乎是一模一样的。</p>\n<p>HTTP 1.1 请求的大小正变得越来越大，有时甚至会大于 TCP 窗口的初始大小，这会严重拖累发送请求的速度。因为它们需要等待带着 ACK 的响应回来以后，才能继续被发送。这也是另一个需要压缩的理由。</p>\n<p>HTTP/2 对消息头采用 <strong>HPACK</strong> 进行压缩传输，能够节省消息头占用的网络的流量。如果我们约定将常用的请求头的参数用一些特殊的编号来表示，比如 GET /index.html 用一个 1 来表示，POST /index.html 用 2 来表示。那么是不是可以节省很多字节？ 为 HTTP/2 的专门量身打造的 HPACK 便是类似这样的思路延伸。它使用一份索引表来定义常用的 HTTP Header。把常用的 HTTP Header 存放在表里。请求的时候便只需要发送在表里的索引位置即可。例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示。</p>\n<h3 id=\"5-重置\"><a href=\"#5-重置\" class=\"headerlink\" title=\"5. 重置\"></a>5. 重置</h3><p>HTTP 1.1 有一个缺点是：当一个含有确切值的 Content-Length 的 HTTP 消息被送出之后，你就很难中断它了。当然，通常你可以断开整个 TCP 链接（但也不总是可以这样），但这样导致的代价就是需要通过三次握手来重新建立一个新的 TCP 连接。</p>\n<p>一个更好的方案是只终止当前传输的消息并重新发送一个新的。在 HTTP/2 里面，我们可以通过发送 RST_STREAM 帧来实现这种需求，从而避免浪费带宽和中断已有的连接。</p>\n<h3 id=\"6-服务器推送\"><a href=\"#6-服务器推送\" class=\"headerlink\" title=\"6.服务器推送\"></a>6.服务器推送</h3><p>这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源 X，而服务器知道它很可能也需要资源 Z 的情况下，服务器可以在客户端发送请求前，主动将资源 Z 推送给客户端。这个功能帮助客户端将 Z 放进缓存以备将来之需。</p>\n<p>服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否需要中断该推送的流。如果不需要的话，客户端可以通过发送一个 RST_STREAM 帧来中止。</p>\n<h3 id=\"7-流量控制\"><a href=\"#7-流量控制\" class=\"headerlink\" title=\"7. 流量控制\"></a>7. 流量控制</h3><p>HTTP/2 上面每个流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有更多的空间来接受新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p>\n<p>而只有数据帧会受到流量控制。</p>\n<h3 id=\"8-HTTP-2-的基石-Frame\"><a href=\"#8-HTTP-2-的基石-Frame\" class=\"headerlink\" title=\"8. HTTP/2 的基石-Frame\"></a>8. HTTP/2 的基石-Frame</h3><p>Frame 是 HTTP/2 二进制格式的基础，基本可以把它理解为它 TCP 里面的数据包一样。HTTP/2 之所以能够有如此多的新特性，正是因为底层数据格式的改变。 Frame 的基本格式如下（图中的数字表示所占位数，内容摘自  <a href=\"https://tools.ietf.org/html/draft-ietf-httpbis-http2-17\" target=\"_blank\" rel=\"noopener\">http2-draft-17</a>）:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------------------------------------+</span><br><span class=\"line\">| Length (24) |</span><br><span class=\"line\">+---------------+---------------+---------------+</span><br><span class=\"line\">| Type (8) | Flags (8) |</span><br><span class=\"line\">+-+-------------+---------------+-------------------+</span><br><span class=\"line\">|R| Stream Identifier (31) |</span><br><span class=\"line\">+=+=================================================+</span><br><span class=\"line\">| Frame Payload (0...) ...</span><br><span class=\"line\">+---------------------------------------------------+</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>Length</strong>：表示 Frame Payload 部分的长度，另外 Frame Header 的长度是固定的 9 字节（Length + Type + Flags + R + Stream Identifier = 72 bit）。</li>\n<li><strong>Type</strong>：区分这个 Frame Payload 存储的数据是属于 HTTP Header 还是 HTTP Body；另外 HTTP/2 新定义了一些其他的 Frame Type，例如，这个字段为 0 时，表示 DATA 类型（即 HTTP/1.x 里的 Body 部分数据）</li>\n<li><strong>Flags</strong>：共 8 位， 每位都起标记作用。每种不同的 Frame Type 都有不同的 Frame Flags。例如发送最后一个 DATA 类型的 Frame 时，就会将 Flags 最后一位设置 1（<code>flags &amp;= 0x01</code>），表示 END_STREAM，说明这个 Frame 是流的最后一个数据包。</li>\n<li><strong>R</strong>：保留位。</li>\n<li><strong>Stream Identifier</strong>：流 ID，当客户端和服务端建立 TCP 链接时，就会先发送一个 Stream ID = 0 的流，用来做些初始化工作。之后客户端和服务端从 1 开始发送请求/响应。</li>\n</ul>\n<p>Frame 由 Frame Header 和 Frame Payload 两部分组成。不论是原来的 HTTP Header 还是 HTTP Body，在 HTTP/2 中，都将这些数据存储到 Frame Payload，组成一个个 Frame，再发送响应 / 请求。通过 Frame Header 中的 Type 区分这个 Frame 的类型。由此可见语义并没有太大变化，而是数据的格式变成二进制的 Frame。二者的转换和关系如下图:</p>\n<div align=\"center\"><img src=\"/images/hexo_post_37.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"9-HTTP-2-对-web-开发的影响\"><a href=\"#9-HTTP-2-对-web-开发的影响\" class=\"headerlink\" title=\"9.HTTP/2 对 web 开发的影响\"></a>9.HTTP/2 对 web 开发的影响</h3><p>到目前为止，HTTP/2 还没被大范围部署使用，我们也无法确定到底会发生什么变化。</p>\n<p>HTTP/2 减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了 head of line blocking（线头阻塞）的困扰。它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p>\n<p>所有这些加起来，页面载入时间和站点的响应速度都会更快。简而言之，它们都代表着更好的 web 体验。</p>\n<p>然而这里的问题在于：对于网站的开发者而言，在短期内开发和部署同一套前端来支持 HTTP 1.1 和 HTTP/2 的客户端访问并获得最大性能将会是一个挑战。考虑到这些问题，<strong>彻底发掘 HTTP/2 的潜力还有很长一段路要走</strong>。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://bagder.gitbooks.io/http2-explained/content/zh/\" target=\"_blank\" rel=\"noopener\">http2讲解（中文）</a></li>\n<li><a href=\"https://http2.github.io/\" target=\"_blank\" rel=\"noopener\">HTTP/2 官网</a></li>\n<li><a href=\"https://http2.akamai.com/demo\" target=\"_blank\" rel=\"noopener\">官方给出的关于 HTTP/2 性能的例子</a></li>\n<li><a href=\"http://blog.csdn.net/jianfyun/article/details/48549939\" target=\"_blank\" rel=\"noopener\">HTTP/2 的各种帧定义</a></li>\n</ul>\n","raw":null,"categories":[{"name":"HTTP","path":"api/categories/HTTP.json"}],"tags":[{"name":"面试","path":"api/tags/面试.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"十大排序算法的Javascript实现","slug":"十大排序算法的Javascript实现","date":"2017-03-18T15:13:55.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/十大排序算法的Javascript实现.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_220.png","content":"<p>我是在微信公众号-前端大全上面看到这篇文章的，大概过去半年时间了，之前看过好多关于排序算法的 JS 版，但是这篇文章是内容最全的，而且还有动图演示，对于算法“白痴”来说理解起来会更容易，所以强烈推荐这篇文章；前端开发者也可以关注一下这个微信公众号，基本上每天都会更新，而且有很多原创的文章，其中不乏面试经验以及关于 JS 和 CSS 的技巧规范以及前端未来发展趋势等等，是一个很好的前端学习工具。 原作者是伯乐在线专栏作者，而十大排序算法的 JS 代码在作者的 github 上也有一个库，想看源码的可以<a href=\"https://github.com/damonare/Sorts\" target=\"_blank\" rel=\"noopener\">戳这里</a>，配合文章会加深对这些排序算法的理解</p>\n<h2 id=\"排序算法说明\"><a href=\"#排序算法说明\" class=\"headerlink\" title=\"排序算法说明\"></a>排序算法说明</h2><h3 id=\"对于评述算法优劣术语的说明\"><a href=\"#对于评述算法优劣术语的说明\" class=\"headerlink\" title=\"对于评述算法优劣术语的说明\"></a>对于评述算法优劣术语的说明</h3><p><strong>稳定</strong>：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；<br><strong>不稳定</strong>：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；<br><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；<br><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>\n<h3 id=\"排序算法图片总结\"><a href=\"#排序算法图片总结\" class=\"headerlink\" title=\"排序算法图片总结\"></a>排序算法图片总结</h3><div align=\"center\"><img src=\"/images/hexo_post_220.png\" alt=\"\" width=\"550\"></div>\n\n<p>图片名词解释：</p>\n<ul>\n<li>n：数据规模</li>\n<li>k：“桶”的个数</li>\n<li>In-place：占用常熟内存，不占用额外内存</li>\n<li>Out-place：占用额外内存</li>\n</ul>\n<h3 id=\"排序分类\"><a href=\"#排序分类\" class=\"headerlink\" title=\"排序分类\"></a>排序分类</h3><div align=\"center\"><img src=\"/images/hexo_post_139.png\" alt=\"\" width=\"450\"></div>\n\n<h2 id=\"1-冒泡排序（bubble-Sort）\"><a href=\"#1-冒泡排序（bubble-Sort）\" class=\"headerlink\" title=\"1. 冒泡排序（bubble Sort）\"></a>1. 冒泡排序（bubble Sort）</h2><h3 id=\"算法简介\"><a href=\"#算法简介\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<h3 id=\"算法具体描述\"><a href=\"#算法具体描述\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤 1~3，直到排序完成。</li>\n</ol>\n<h3 id=\"动画演示\"><a href=\"#动画演示\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_90.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码\"><a href=\"#Javascript-源代码\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：该方法为原始算法*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; len - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;        <span class=\"comment\">//相邻元素两两对比</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> temp = arr[j+<span class=\"number\">1</span>];        <span class=\"comment\">//元素交换</span></span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bubbleSort(arr1));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：该方法为改进算法（设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort2</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = arr.length<span class=\"number\">-1</span>;  <span class=\"comment\">//初始时,最后位置保持不变</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( i&gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> pos= <span class=\"number\">0</span>; <span class=\"comment\">//每趟开始时,无记录交换</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j= <span class=\"number\">0</span>; j&lt; i; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                pos= j; <span class=\"comment\">//记录交换的位置</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> tmp = arr[j]; arr[j]=arr[j+<span class=\"number\">1</span>];arr[j+<span class=\"number\">1</span>]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        i= pos; <span class=\"comment\">//为下一趟排序作准备</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bubbleSort2(arr2));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：该方法为改进算法（传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort3</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> high= arr.length<span class=\"number\">-1</span>; <span class=\"comment\">//设置变量的初始值</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp,j;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'2.改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j= low; j&lt; high; ++j) <span class=\"comment\">//正向冒泡,找到最大者</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                tmp = arr[j]; arr[j]=arr[j+<span class=\"number\">1</span>];arr[j+<span class=\"number\">1</span>]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        --high;                 <span class=\"comment\">//修改high值, 前移一位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=high; j&gt;low; --j) <span class=\"comment\">//反向冒泡,找到最小者</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&lt;arr[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                tmp = arr[j]; arr[j]=arr[j<span class=\"number\">-1</span>];arr[j<span class=\"number\">-1</span>]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ++low;                  <span class=\"comment\">//修改low值,后移一位</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'2.改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bubbleSort3(arr3));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析\"><a href=\"#算法复杂度分析\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(n) =&gt; 当输入的数据已经是正序时</li>\n<li>最差情况：T(n)=O(n2) =&gt; 当输入的数据是反序时</li>\n<li>平均情况：T(n)=O(n2)</li>\n</ul>\n<h2 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2. 选择排序\"></a>2. 选择排序</h2><h3 id=\"算法简介-1\"><a href=\"#算法简介-1\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>选择排序（Selection-sort）是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h3 id=\"算法具体描述-1\"><a href=\"#算法具体描述-1\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>初始状态：无序区为 R[1..n]，有序区为空；</li>\n<li>第 i 趟排序 (i=1,2,3…n-1) 开始时，当前有序区和无序区分别为 R[1..i-1] 和 R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i] 和 R[i+1..n) 分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；</li>\n<li>n-1 趟结束，数组有序化了。</li>\n</ol>\n<h3 id=\"动画演示-1\"><a href=\"#动画演示-1\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_219.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-1\"><a href=\"#Javascript-源代码-1\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：选择排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> minIndex, temp;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'选择排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class=\"comment\">//寻找最小的数</span></span><br><span class=\"line\">                minIndex = j;                 <span class=\"comment\">//将最小数的索引保存</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'选择排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(selectionSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度排序\"><a href=\"#算法复杂度排序\" class=\"headerlink\" title=\"算法复杂度排序\"></a>算法复杂度排序</h3><ul>\n<li>最佳情况：T(n)=O(n2)</li>\n<li>最差情况：T(n)=O(n2)</li>\n<li>平均情况：T(n)=O(n2)</li>\n</ul>\n<h2 id=\"3-插入排序\"><a href=\"#3-插入排序\" class=\"headerlink\" title=\"3. 插入排序\"></a>3. 插入排序</h2><h3 id=\"算法简介-2\"><a href=\"#算法简介-2\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>\n<h3 id=\"算法具体描述-2\"><a href=\"#算法具体描述-2\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>将新元素插入到该位置后；</li>\n<li>重复步骤 2~5。</li>\n</ol>\n<h3 id=\"动画演示-2\"><a href=\"#动画演示-2\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_110.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-2\"><a href=\"#Javascript-源代码-2\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：插入排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.time(<span class=\"string\">'插入排序耗时：'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> key = array[i];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">                array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'插入排序耗时：'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(insertionSort(arr1));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：插入排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：改进后的算法（查找插入位置时使用二分查找的方式）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binaryInsertionSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.time(<span class=\"string\">'二分插入排序耗时：'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> key = array[i], left = <span class=\"number\">0</span>, right = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> middle = <span class=\"built_in\">parseInt</span>((left + right) / <span class=\"number\">2</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key &lt; array[middle]) &#123;</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>; j &gt;= left; j--) &#123;</span><br><span class=\"line\">                array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[left] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'二分插入排序耗时：'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryInsertionSort(arr2));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-1\"><a href=\"#算法复杂度分析-1\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(n) =&gt; 输入数组按升序排列</li>\n<li>最差情况：T(n)=O(n2) =&gt; 输入数组按降序排列</li>\n<li>平均情况：T(n)=O(n2)</li>\n</ul>\n<h2 id=\"4-希尔排序\"><a href=\"#4-希尔排序\" class=\"headerlink\" title=\"4. 希尔排序\"></a>4. 希尔排序</h2><h3 id=\"算法简介-3\"><a href=\"#算法简介-3\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者 Robert Sedgewick 提出的。</p>\n<h3 id=\"算法具体描述-3\"><a href=\"#算法具体描述-3\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1；</li>\n<li>按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ol>\n<h3 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h3><div align=\"center\"><img src=\"/images/hexo_post_225.jpeg\" alt=\"\" width=\"550\"></div>\n\n<h3 id=\"Javascript-源代码-3\"><a href=\"#Javascript-源代码-3\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：希尔排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length,</span><br><span class=\"line\">        temp,</span><br><span class=\"line\">        gap = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(gap &lt; len/<span class=\"number\">5</span>) &#123;          <span class=\"comment\">//动态定义间隔序列</span></span><br><span class=\"line\">        gap =gap*<span class=\"number\">5</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (gap; gap &gt; <span class=\"number\">0</span>; gap = <span class=\"built_in\">Math</span>.floor(gap/<span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i-gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class=\"line\">                arr[j+gap] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j+gap] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shellSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-2\"><a href=\"#算法复杂度分析-2\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n) = O(nlog2n)</li>\n<li>最差情况：T(n) = O(nlog2n)</li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<h2 id=\"5-归并排序\"><a href=\"#5-归并排序\" class=\"headerlink\" title=\"5. 归并排序\"></a>5. 归并排序</h2><h3 id=\"算法简介-4\"><a href=\"#算法简介-4\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。</p>\n<h3 id=\"算法具体描述-4\"><a href=\"#算法具体描述-4\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。</li>\n</ol>\n<h3 id=\"动画演示-3\"><a href=\"#动画演示-3\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_119.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-4\"><a href=\"#Javascript-源代码-4\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：归并排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">arr</span>) </span>&#123;  <span class=\"comment\">//采用自上而下的递归方法</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> middle = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>),</span><br><span class=\"line\">        left = arr.slice(<span class=\"number\">0</span>, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[<span class=\"number\">0</span>] &lt;= right[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mergeSort(arr));</span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-3\"><a href=\"#算法复杂度分析-3\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(n)</li>\n<li>最差情况：T(n)=O(nlogn)</li>\n<li>平均情况：T(n)=O(nlogn)</li>\n</ul>\n<h2 id=\"6-快速排序\"><a href=\"#6-快速排序\" class=\"headerlink\" title=\"6. 快速排序\"></a>6. 快速排序</h2><h3 id=\"算法简介-5\"><a href=\"#算法简介-5\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<h3 id=\"算法具体描述-5\"><a href=\"#算法具体描述-5\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ol>\n<h3 id=\"动画演示-4\"><a href=\"#动画演示-4\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_217.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-5\"><a href=\"#Javascript-源代码-5\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><h4 id=\"方法一-2\"><a href=\"#方法一-2\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：快速排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：方法一*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array, left, right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'1.快速排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span> &amp;&amp; <span class=\"keyword\">typeof</span> left === <span class=\"string\">'number'</span> &amp;&amp; <span class=\"keyword\">typeof</span> right === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> x = array[right],</span><br><span class=\"line\">                i = left - <span class=\"number\">1</span>,</span><br><span class=\"line\">                temp;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = left; j &lt;= right; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt;= x) &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    temp = array[i];</span><br><span class=\"line\">                    array[i] = array[j];</span><br><span class=\"line\">                    array[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            quickSort(array, left, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            quickSort(array, i - <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'1.快速排序耗时'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array or left or right is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-2\"><a href=\"#方法二-2\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：快速排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：方法二*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort2</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'2.快速排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pivotIndex = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pivot = arr.splice(pivotIndex, <span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'2.快速排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> quickSort2(left).concat([pivot], quickSort2(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">47</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">50</span>, <span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(quickSort(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(quickSort2(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-4\"><a href=\"#算法复杂度分析-4\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(nlogn)</li>\n<li>最差情况：T(n)=O(n2)</li>\n<li>平均情况：T(n)=O(nlogn)</li>\n</ul>\n<h2 id=\"7-堆排序\"><a href=\"#7-堆排序\" class=\"headerlink\" title=\"7. 堆排序\"></a>7. 堆排序</h2><h3 id=\"算法简介-6\"><a href=\"#算法简介-6\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<h3 id=\"算法具体描述-6\"><a href=\"#算法具体描述-6\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1,R2,……Rn-1) 和新的有序区 (Rn),且满足 R[1,2…n-1]&lt;=R[n]；</li>\n<li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 R1,R2,……Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。</li>\n</ol>\n<h3 id=\"动画演示-5\"><a href=\"#动画演示-5\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_106.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-6\"><a href=\"#Javascript-源代码-6\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：堆排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'堆排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//建堆</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> heapSize = array.length, temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(heapSize / <span class=\"number\">2</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            heaping(array, i, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//堆排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = heapSize - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            temp = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">            array[<span class=\"number\">0</span>] = array[j];</span><br><span class=\"line\">            array[j] = temp;</span><br><span class=\"line\">            heaping(array, <span class=\"number\">0</span>, --heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'堆排序耗时'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 方法说明：维护堆的性质</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> x-数组下标</span></span><br><span class=\"line\"><span class=\"comment\"> len-堆大小</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heaping</span>(<span class=\"params\">arr, x, len</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(arr).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span> &amp;&amp; <span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> l = <span class=\"number\">2</span> * x + <span class=\"number\">1</span>,</span><br><span class=\"line\">            r = <span class=\"number\">2</span> * x + <span class=\"number\">2</span>,</span><br><span class=\"line\">            largest = x,</span><br><span class=\"line\">            temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heaping(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">47</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">50</span>, <span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(heapSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-5\"><a href=\"#算法复杂度分析-5\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(nlogn)</li>\n<li>最差情况：T(n)=O(nlogn)</li>\n<li>平均情况：T(n)=O(nlogn)</li>\n</ul>\n<h2 id=\"8-计数排序\"><a href=\"#8-计数排序\" class=\"headerlink\" title=\"8. 计数排序\"></a>8. 计数排序</h2><h3 id=\"算法简介-7\"><a href=\"#算法简介-7\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。</p>\n<h3 id=\"算法具体描述-7\"><a href=\"#算法具体描述-7\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>\n<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</li>\n</ol>\n<h3 id=\"动画演示-6\"><a href=\"#动画演示-6\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_95.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-7\"><a href=\"#Javascript-源代码-7\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：计数排序</span></span><br><span class=\"line\"><span class=\"comment\">   参数：array-排序数组</span></span><br><span class=\"line\"><span class=\"comment\">   说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = array.length,</span><br><span class=\"line\">        B = [],</span><br><span class=\"line\">        C = [],</span><br><span class=\"line\">        min = array[<span class=\"number\">0</span>],</span><br><span class=\"line\">        max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'计数排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i =<span class=\"number\">0</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        min= min&lt;=array[i] ? min:array[i];</span><br><span class=\"line\">        max = max &gt;=array[i] ? max : array[i];</span><br><span class=\"line\">        C[array[i]] = C[array[i]] ? C[array[i]] +<span class=\"number\">1</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = min; j&lt; max;j++)&#123;</span><br><span class=\"line\">        C[j+<span class=\"number\">1</span>] = (C[j+<span class=\"number\">1</span>] || <span class=\"number\">0</span>) + (C[j] || <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = len <span class=\"number\">-1</span> ;k &gt;=<span class=\"number\">0</span>; k--)&#123;</span><br><span class=\"line\">        B[C[array[k]] - <span class=\"number\">1</span>] = array[k];</span><br><span class=\"line\">        C[array[k]] --;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'计数排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(countingSort(arr));<span class=\"comment\">//[1,1,2,2,2,2,2,2,2,2,3,3,4,4,6,7,7,8,8,9,9]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-6\"><a href=\"#算法复杂度分析-6\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>\n<ul>\n<li>最佳情况：T(n)=O(n+k)</li>\n<li>最差情况：T(n)=O(n+k)</li>\n<li>平均情况：T(n)=O(n+k)</li>\n</ul>\n<h2 id=\"9-桶排序\"><a href=\"#9-桶排序\" class=\"headerlink\" title=\"9. 桶排序\"></a>9. 桶排序</h2><h3 id=\"算法简介-8\"><a href=\"#算法简介-8\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>桶排序（Bucket sort）的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p>\n<h3 id=\"算法具体描述-8\"><a href=\"#算法具体描述-8\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶进行排序；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。</li>\n</ol>\n<h3 id=\"图示-1\"><a href=\"#图示-1\" class=\"headerlink\" title=\"图示\"></a>图示</h3><div align=\"center\"><img src=\"/images/hexo_post_318.jpeg\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-8\"><a href=\"#Javascript-源代码-8\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：桶排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> num-桶的数量</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：无*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">array, num</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = array.length,</span><br><span class=\"line\">        buckets = [],</span><br><span class=\"line\">        result = [],</span><br><span class=\"line\">        min = array[<span class=\"number\">0</span>],</span><br><span class=\"line\">        max = array[<span class=\"number\">0</span>],</span><br><span class=\"line\">        regex = <span class=\"string\">'/^[1-9]+[0-9]*$/'</span>,</span><br><span class=\"line\">        space,</span><br><span class=\"line\">        n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    num = num || ((num &gt; <span class=\"number\">1</span> &amp;&amp; regex.test(num)) ? num : <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'桶排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        min = min &lt;= array[i] ? min : array[i];</span><br><span class=\"line\">        max = max &gt;= array[i] ? max : array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    space = (max - min + <span class=\"number\">1</span>) / num;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"built_in\">Math</span>.floor((array[j] - min) / space);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buckets[index]) &#123; <span class=\"comment\">//非空桶，插入排序</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> k = buckets[index].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</span><br><span class=\"line\">                buckets[index][k + <span class=\"number\">1</span>] = buckets[index][k];</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            buckets[index][k + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//空桶，初始化</span></span><br><span class=\"line\">            buckets[index] = [];</span><br><span class=\"line\">            buckets[index].push(array[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &lt; num) &#123;</span><br><span class=\"line\">        result = result.concat(buckets[n]);</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'桶排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">47</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">50</span>, <span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bucketSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-7\"><a href=\"#算法复杂度分析-7\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>\n<ul>\n<li>最佳情况：T(n)=O(n+k)</li>\n<li>最差情况：T(n)=O(n+k)</li>\n<li>平均情况：T(n)=O(n2)</li>\n</ul>\n<h2 id=\"10-基数排序\"><a href=\"#10-基数排序\" class=\"headerlink\" title=\"10. 基数排序\"></a>10. 基数排序</h2><h3 id=\"算法简介-9\"><a href=\"#算法简介-9\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>\n<h3 id=\"算法具体描述-9\"><a href=\"#算法具体描述-9\" class=\"headerlink\" title=\"算法具体描述\"></a>算法具体描述</h3><ol>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr 为原始数组，从最低位开始取每个位组成 radix 数组；</li>\n<li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</li>\n</ol>\n<h3 id=\"动画演示-7\"><a href=\"#动画演示-7\" class=\"headerlink\" title=\"动画演示\"></a>动画演示</h3><div align=\"center\"><img src=\"/images/hexo_post_218.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"Javascript-源代码-9\"><a href=\"#Javascript-源代码-9\" class=\"headerlink\" title=\"Javascript 源代码\"></a>Javascript 源代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 方法说明：基数排序</span></span><br><span class=\"line\"><span class=\"comment\"> 参数：arr-排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> maxDigit-最大位数</span></span><br><span class=\"line\"><span class=\"comment\"> 说明：基数排序适用于：</span></span><br><span class=\"line\"><span class=\"comment\"> （1）数据范围较小，建议小于1000</span></span><br><span class=\"line\"><span class=\"comment\"> （2）每个数值都要大于等于0*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">radixSort</span>(<span class=\"params\">arr, maxDigit</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mod = <span class=\"number\">10</span>,</span><br><span class=\"line\">        dev = <span class=\"number\">1</span>,</span><br><span class=\"line\">        counter = [];</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'基数排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; maxDigit; i++, dev *= <span class=\"number\">10</span>, mod *= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bucket = <span class=\"built_in\">parseInt</span>((arr[j] % mod) / dev);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (counter[bucket] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                counter[bucket] = [];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            counter[bucket].push(arr[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; counter.length; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (counter[k] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((value = counter[k].shift()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                arr[pos++] = value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'基数排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">47</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">50</span>, <span class=\"number\">48</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(radixSort(arr));<span class=\"comment\">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算法复杂度分析-8\"><a href=\"#算法复杂度分析-8\" class=\"headerlink\" title=\"算法复杂度分析\"></a>算法复杂度分析</h3><ul>\n<li>最佳情况：T(n)=O(n*k)</li>\n<li>最差情况：T(n)=O(n*k)</li>\n<li>平均情况：T(n)=O(n*k)</li>\n</ul>\n","raw":null,"categories":[{"name":"algorithm","path":"api/categories/algorithm.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"排序","path":"api/tags/排序.json"}]},{"title":"八大排序算法的python实现","slug":"八大排序算法的python实现","date":"2017-03-18T14:17:57.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/八大排序算法的python实现.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>其实我的 python 水平相当于初学者，但是由于要找实习，所以刷算法是必然的，而经常刷 leetcode 的小伙伴应该知道，用 javascript 实现各种复杂算法的人比较少（排序算法还好，尤其是那些比较知名的排序算法，想看 Javascript 代码实现排序算法的可以点下面那个链接），所以就导致没有思路的时候也看不到别人是如何用 JS 代码实现的，所以必须要懂其他一种语言才能行，而 python 同样作为一种脚本语言，其语法非常简单，也很适合算法的实现，所以就决定在学习 JS 的同时兼顾 python 的学习。<br>这篇文章当然不是我的原创，而是在逛伯乐在线的时候看到的，感觉总结的很好，代码也很规范，故转载至此处，如果作者不允许转载，将及时处理；如果没弄明白排序算法的步骤，想理解的更生动的话，可以查看我的另外一篇文章：<a href=\"/20170318/js-implementation-of-ten-sorting-algorithms.html\">十大排序算法的Javascript实现</a>。</p>\n<h2 id=\"1-插入排序\"><a href=\"#1-插入排序\" class=\"headerlink\" title=\"1. 插入排序\"></a>1. 插入排序</h2><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 插入排序</span></span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, count):</span><br><span class=\"line\">        key = lists[i]</span><br><span class=\"line\">        j = i - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt; key:</span><br><span class=\"line\">                lists[j + <span class=\"number\">1</span>] = lists[j]</span><br><span class=\"line\">                lists[j] = key</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-希尔排序\"><a href=\"#2-希尔排序\" class=\"headerlink\" title=\"2. 希尔排序\"></a>2. 希尔排序</h2><p>希尔排序（Shell Sort）是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因 DL．Shell 于 1959 年提出而得名。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 希尔排序</span></span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    step = <span class=\"number\">2</span></span><br><span class=\"line\">    group = count / step</span><br><span class=\"line\">    <span class=\"keyword\">while</span> group &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, group):</span><br><span class=\"line\">            j = i + group</span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; count:</span><br><span class=\"line\">                k = j - group</span><br><span class=\"line\">                key = lists[j]</span><br><span class=\"line\">                <span class=\"keyword\">while</span> k &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> lists[k] &gt; key:</span><br><span class=\"line\">                        lists[k + group] = lists[k]</span><br><span class=\"line\">                        lists[k] = key</span><br><span class=\"line\">                    k -= group</span><br><span class=\"line\">                j += group</span><br><span class=\"line\">        group /= step</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-冒泡排序\"><a href=\"#3-冒泡排序\" class=\"headerlink\" title=\"3. 冒泡排序\"></a>3. 冒泡排序</h2><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 冒泡排序</span></span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, count):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + <span class=\"number\">1</span>, count):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[i] &gt; lists[j]:</span><br><span class=\"line\">                lists[i], lists[j] = lists[j], lists[i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-快速排序\"><a href=\"#4-快速排序\" class=\"headerlink\" title=\"4. 快速排序\"></a>4. 快速排序</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(lists, left, right)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 快速排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &gt;= right:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lists</span><br><span class=\"line\">    key = lists[left]</span><br><span class=\"line\">    low = left</span><br><span class=\"line\">    high = right</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> lists[right] &gt;= key:</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">        lists[left] = lists[right]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> lists[left] &lt;= key:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        lists[right] = lists[left]</span><br><span class=\"line\">    lists[right] = key</span><br><span class=\"line\">    quick_sort(lists, low, left - <span class=\"number\">1</span>)</span><br><span class=\"line\">    quick_sort(lists, left + <span class=\"number\">1</span>, high)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-直接选择排序\"><a href=\"#5-直接选择排序\" class=\"headerlink\" title=\"5. 直接选择排序\"></a>5. 直接选择排序</h2><p>基本思想：第 1 趟，在待排序记录 r1 ~ r[n] 中选出最小的记录，将它与 r1 交换；第 2 趟，在待排序记录 r2 ~ r[n] 中选出最小的记录，将它与 r2 交换；以此类推，第 i 趟在待排序记录 r[i] ~ r[n] 中选出最小的记录，将它与 r[i] 交换，使有序序列不断增长直到全部排序完毕。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 选择排序</span></span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, count):</span><br><span class=\"line\">        min = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + <span class=\"number\">1</span>, count):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[min] &gt; lists[j]:</span><br><span class=\"line\">                min = j</span><br><span class=\"line\">        lists[min], lists[i] = lists[i], lists[min]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-堆排序\"><a href=\"#6-堆排序\" class=\"headerlink\" title=\"6. 堆排序\"></a>6. 堆排序</h2><p>堆排序（Heapsort）是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即 A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">adjust_heap</span><span class=\"params\">(lists, i, size)</span>:</span></span><br><span class=\"line\">    lchild = <span class=\"number\">2</span> * i + <span class=\"number\">1</span></span><br><span class=\"line\">    rchild = <span class=\"number\">2</span> * i + <span class=\"number\">2</span></span><br><span class=\"line\">    max = i</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &lt; size / <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lchild &lt; size <span class=\"keyword\">and</span> lists[lchild] &gt; lists[max]:</span><br><span class=\"line\">            max = lchild</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rchild &lt; size <span class=\"keyword\">and</span> lists[rchild] &gt; lists[max]:</span><br><span class=\"line\">            max = rchild</span><br><span class=\"line\">        <span class=\"keyword\">if</span> max != i:</span><br><span class=\"line\">            lists[max], lists[i] = lists[i], lists[max]</span><br><span class=\"line\">            adjust_heap(lists, max, size)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_heap</span><span class=\"params\">(lists, size)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, (size/<span class=\"number\">2</span>))[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        adjust_heap(lists, i, size)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    size = len(lists)</span><br><span class=\"line\">    build_heap(lists, size)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, size)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        lists[<span class=\"number\">0</span>], lists[i] = lists[i], lists[<span class=\"number\">0</span>]</span><br><span class=\"line\">        adjust_heap(lists, <span class=\"number\">0</span>, i)</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-归并排序\"><a href=\"#7-归并排序\" class=\"headerlink\" title=\"7. 归并排序\"></a>7. 归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>归并过程为：比较 a[i] 和 a[j] 的大小，若 a[i] ≤ a[j]，则将第一个有序表中的元素 a[i] 复制到 r[k] 中，并令 i 和 k 分别加上 1；否则将第二个有序表中的元素 a[j] 复制到 r[k] 中，并令 j 和 k 分别加上 1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到 r 中从下标 k 到下标 t 的单元。归并排序的算法我们通常用递归实现，先把待排序区间 [s,t] 以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间 [s,t]。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(left, right)</span>:</span></span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; len(left) <span class=\"keyword\">and</span> j &lt; len(right):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left[i] &lt;= right[j]:</span><br><span class=\"line\">            result.append(left[i])</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result.append(right[j])</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    result += left[i:]</span><br><span class=\"line\">    result += right[j:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 归并排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(lists) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lists</span><br><span class=\"line\">    num = len(lists) / <span class=\"number\">2</span></span><br><span class=\"line\">    left = merge_sort(lists[:num])</span><br><span class=\"line\">    right = merge_sort(lists[num:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(left, right)</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-基数排序\"><a href=\"#8-基数排序\" class=\"headerlink\" title=\"8. 基数排序\"></a>8. 基数排序</h2><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为 O(nlog(r)m)，其中 r 为所采取的基数，而 m 为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">radix_sort</span><span class=\"params\">(lists, radix=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class=\"line\">    bucket = [[] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(radix)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            bucket[j/(radix**(i<span class=\"number\">-1</span>)) % (radix**i)].append(j)</span><br><span class=\"line\">        <span class=\"keyword\">del</span> lists[:]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> z <span class=\"keyword\">in</span> bucket:</span><br><span class=\"line\">            lists += z</span><br><span class=\"line\">            <span class=\"keyword\">del</span> z[:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"algorithm","path":"api/categories/algorithm.json"}],"tags":[{"name":"算法","path":"api/tags/算法.json"},{"name":"python","path":"api/tags/python.json"},{"name":"排序","path":"api/tags/排序.json"}]},{"title":"前端面试系列（2）——CSS3新特性","slug":"前端面试系列（2）——CSS3新特性","date":"2017-03-18T10:37:57.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/前端面试系列（2）——CSS3新特性.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_138.png","content":"<p>CSS3 是 CSS 的 v3 版本，这套新标准提供了更加丰富且实用的规范，如：盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等等；和 HTML5 不同，CSS3 的新特性基本上得到了广泛应用，而知道并熟练运用这些新特性已经成为前端人员的必修课：</p>\n<h2 id=\"更方便快捷的选择器\"><a href=\"#更方便快捷的选择器\" class=\"headerlink\" title=\"更方便快捷的选择器\"></a>更方便快捷的选择器</h2><blockquote>\n<p>:nth-child、:nth-last-child、:nth-of-type、:last-child、:only-child、:empty</p>\n</blockquote>\n<p>CSS3 新增的选择器有很多，就不一一介绍了，这里有一篇关于 CSS3 新增选择器的文章总结的很好：<a href=\"http://www.cnblogs.com/libingql/p/4375354.html\" target=\"_blank\" rel=\"noopener\">CSS系列：CSS3新增选择器</a></p>\n<h2 id=\"框模型\"><a href=\"#框模型\" class=\"headerlink\" title=\"框模型\"></a>框模型</h2><blockquote>\n<p>border-radius（圆角）、box-shadow（盒子阴影）、border-image（边框图片）</p>\n</blockquote>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><blockquote>\n<p>background-size（背景大小）、background-origin（背景的定位）、background-clip（背景的绘制区域）、支持多重背景图片（background-image: url(bg_flower.gif), url(bg_flower_2.gif);）</p>\n</blockquote>\n<h2 id=\"渐变效果\"><a href=\"#渐变效果\" class=\"headerlink\" title=\"渐变效果\"></a>渐变效果</h2><p>gradient 属性可以非常方便的实现渐变色，同时可以设置渐变的方向和渐变方式等，实现各种复杂的效果。文末有一篇讲解 gradient 的文章讲的很不错，感兴趣的可以去瞅瞅。</p>\n<h2 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a>文本效果</h2><blockquote>\n<p>text-shadow（文本阴影）、word-break（规定非中日韩文本的换行规则）、word-wrap（允许对长的不可分割的单词进行分割并换行到下一行）</p>\n</blockquote>\n<p>CSS3 的文本属性比较多，还是用一张图片代替吧（来自 w3c）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_138.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"font-face\"><a href=\"#font-face\" class=\"headerlink\" title=\"@font-face\"></a>@font-face</h2><p>可以在网页中使用除默认字体之外的其他字体，先定义字体的名称，然后引入字体文件，在需要使用该字体的时候就通过 font-family 属性引用字体的名称</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> </span></span><br><span class=\"line\"><span class=\"css\">@<span class=\"keyword\">font-face</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  font-family: myFirstFont;</span></span><br><span class=\"line\"><span class=\"undefined\">  src: url('Sansation_Light.ttf'),</span></span><br><span class=\"line\"><span class=\"undefined\">      url('Sansation_Light.eot'); /* IE9+ */</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">div&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  font-family: myFirstFont;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h2><p>我认为这是 CSS3 最“好用”的特性，也正是因为这个属性（当然，下面那个属性也功不可没），通过 CSS3 转换就可以能够堆元素进行移动、缩放、转动、拉长或拉伸；同时结合对持续时间和延迟时间的控制，可以“创造”出非常炫的动画效果，大大提升了网页的展示效果。同时分为 2D 和 3D 转换，由于内容繁多，就不一一介绍了，感兴趣的小伙伴可以点击文末的链接进行进一步的学习。</p>\n<h2 id=\"transtion\"><a href=\"#transtion\" class=\"headerlink\" title=\"transtion\"></a>transtion</h2><p>当元素从一种样式变换为另一种样式时为元素添加效果，使动画更加“圆润”流畅</p>\n<h2 id=\"keyframes\"><a href=\"#keyframes\" class=\"headerlink\" title=\"@keyframes\"></a>@keyframes</h2><p>这是个面试中会经常问到的属性，原因是其应用领域非常广泛，因为如今用户的时间非常宝贵，同时网络上的信息又是鱼龙混杂，如何在有限的时间内抓住用户眼球是一个重要的课题，而 @keyframes 就可以让自己的网页焕然一新并且与众不同，通过 @keyframes 规则可以创建关键帧动画，再结合 animation 就可以使元素“动”起来。</p>\n<h2 id=\"多列布局\"><a href=\"#多列布局\" class=\"headerlink\" title=\"多列布局\"></a>多列布局</h2><p>通过column-count（列数）、column-fill（如何填充列）、column-gap（列之间的间隔）、column-width（列的宽度）可以创建多个列来对文本进行布局，就像报纸那样。</p>\n<h2 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a>用户界面</h2><ul>\n<li>resize：是否可由用户调整元素尺寸</li>\n<li>box-sizing：border-box / content-box，这个属性我也很喜欢，可以改变传统的“盒子模型”，方便进行布局</li>\n<li>outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓（轮廓不占用空间并且可能是非矩形，这两点和边框不同）</li>\n</ul>\n<h2 id=\"Flex-弹性布局\"><a href=\"#Flex-弹性布局\" class=\"headerlink\" title=\"Flex 弹性布局\"></a>Flex 弹性布局</h2><p>这个属性让开发者非常头疼的“居中”问题找到了一种十分简便的答案，可以非常方便地实现让一个或多个元素在其父元素中垂直居中，建议大家去看阮一峰对其的讲解，很全面并且简单易懂（链接在文末）。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://www.w3school.com.cn/css3/index.asp\" target=\"_blank\" rel=\"noopener\">CSS3 教程</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">Flex 布局教程：语法篇</a></li>\n<li><a href=\"http://www.w3cplus.com/css3/new-css3-radial-gradient.html\" target=\"_blank\" rel=\"noopener\">再说CSS3渐变——径向渐变</a></li>\n</ul>\n","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（1）——HTML5新特性","slug":"前端面试系列（1）——HTML5新特性","date":"2017-03-18T10:32:25.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/前端面试系列（1）——HTML5新特性.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这道问题被问的比较少，因为在如今前端框架大行其道的趋势下，对于 HTML 的理解似乎已经变得不那么重要了，况且浏览器对 H5（是的，我们通常说的 H5 其实就是 HTML5，5 代表版本）的支持还不那么完美，但是了解一下还是有助于自己前端水平的提升的，在查阅资料的过程中我发现有些特性我也是第一次知道，不过有些特性已经显示了其强大之处，比如：canvas，高能预警，大量干货：</p>\n<h2 id=\"摒弃了旧特性\"><a href=\"#摒弃了旧特性\" class=\"headerlink\" title=\"摒弃了旧特性\"></a>摒弃了旧特性</h2><h3 id=\"1-原-HTML-声明方式将失效，将采用简单的声明方式\"><a href=\"#1-原-HTML-声明方式将失效，将采用简单的声明方式\" class=\"headerlink\" title=\"1. 原 HTML 声明方式将失效，将采用简单的声明方式\"></a>1. 原 HTML 声明方式将失效，将采用简单的声明方式</h3><p>原来：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" </span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-脚本和链接无需-type，在-HTML5-中，你只需要用简化的代码来给你的网页添加-CSS-和-JavaScript-文件，而不再需要指定类型属性\"><a href=\"#2-脚本和链接无需-type，在-HTML5-中，你只需要用简化的代码来给你的网页添加-CSS-和-JavaScript-文件，而不再需要指定类型属性\" class=\"headerlink\" title=\"2. 脚本和链接无需 type，在 HTML5 中，你只需要用简化的代码来给你的网页添加 CSS 和 JavaScript 文件，而不再需要指定类型属性\"></a>2. 脚本和链接无需 type，在 HTML5 中，你只需要用简化的代码来给你的网页添加 CSS 和 JavaScript 文件，而不再需要指定类型属性</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"path/to/stylesheet.css\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/script.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"新的内容元素\"><a href=\"#新的内容元素\" class=\"headerlink\" title=\"新的内容元素\"></a>新的内容元素</h2><h3 id=\"1-figure\"><a href=\"#1-figure\" class=\"headerlink\" title=\"1. figure\"></a>1. figure</h3><p>可以更加语义化地表示带标题的图片</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">figure</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">”path/to/image”</span> <span class=\"attr\">alt</span>=<span class=\"string\">”About</span> <span class=\"attr\">image</span>” /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">figcaption</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is an image of something interesting. <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">figcaption</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-hgroup\"><a href=\"#2-hgroup\" class=\"headerlink\" title=\"2. hgroup\"></a>2. hgroup</h3><p>一般在 header 里面用来将一组标题组合在一起</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hgroup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span> Recall Fan Page <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span> Only for people who want the memory of a lifetime. <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">hgroup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-mark\"><a href=\"#3-mark\" class=\"headerlink\" title=\"3. mark\"></a>3. mark</h3><p>高亮的作用，比如用户的搜索内容可以在文章中用 <code>&lt;mark&gt;</code> 进行修饰</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span> Search Results <span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span> They were interrupted, just after Quato said, <span class=\"tag\">&lt;<span class=\"name\">mark</span>&gt;</span>”Open your Mind”<span class=\"tag\">&lt;/<span class=\"name\">mark</span>&gt;</span>. <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-output\"><a href=\"#4-output\" class=\"headerlink\" title=\"4. output\"></a>4. output</h3><p>用来显示计算结果，也有一个和 label 一样的 for 属性</p>\n<h3 id=\"5-small\"><a href=\"#5-small\" class=\"headerlink\" title=\"5. small\"></a>5. small</h3><p>重新定义了 <code>&lt;small&gt;</code>，现在被用来表示小的排版，如网站底部的版权声明</p>\n<h3 id=\"6-article\"><a href=\"#6-article\" class=\"headerlink\" title=\"6. article\"></a>6. article</h3><p>定义文章</p>\n<h3 id=\"7-footer\"><a href=\"#7-footer\" class=\"headerlink\" title=\"7. footer\"></a>7. footer</h3><p>定义尾部</p>\n<h3 id=\"8-header\"><a href=\"#8-header\" class=\"headerlink\" title=\"8. header\"></a>8. header</h3><p>定义头部</p>\n<h3 id=\"9-nav\"><a href=\"#9-nav\" class=\"headerlink\" title=\"9. nav\"></a>9. nav</h3><p>定义导航栏</p>\n<h3 id=\"10-section\"><a href=\"#10-section\" class=\"headerlink\" title=\"10. section\"></a>10. section</h3><p>定义 section 区域</p>\n<h2 id=\"新的属性：\"><a href=\"#新的属性：\" class=\"headerlink\" title=\"新的属性：\"></a>新的属性：</h2><h3 id=\"1-contenteditable\"><a href=\"#1-contenteditable\" class=\"headerlink\" title=\"1. contenteditable\"></a>1. contenteditable</h3><p>让你的内容可编辑</p>\n<h3 id=\"2-placeholder\"><a href=\"#2-placeholder\" class=\"headerlink\" title=\"2. placeholder\"></a>2. placeholder</h3><p>不必通过javascript就可以显示提示内容了</p>\n<h3 id=\"3-input-的-新type\"><a href=\"#3-input-的-新type\" class=\"headerlink\" title=\"3. input 的 新type\"></a>3. input 的 新type</h3><p>包括 email（如果给 input 的 type 设置为 email，浏览器就会验证这个输入是否是 email 类型）、range（可以创建滑块，它接受 min，max，step 和 value 属性）、color（颜色选择器）等等</p>\n<h3 id=\"4-input-的新属性\"><a href=\"#4-input-的新属性\" class=\"headerlink\" title=\"4. input 的新属性\"></a>4. input 的新属性</h3><p>包括 autocomplete（on / off，是否使用输入字段的自动完成功能）、autofocus（规定输入字段在页面加载时是否获得焦点，但不试用于 type=”hidden”）、required（指示输入字段的值是必须的）、form（规定输入字段所属的一个或多个表单）-&gt; 其实新属性还有很多，可以点击文末 w3c 官网链接进行查看</p>\n<h3 id=\"5-pattern-属性\"><a href=\"#5-pattern-属性\" class=\"headerlink\" title=\"5. pattern 属性\"></a>5. pattern 属性</h3><p>可以在 input 里直接使用正则表达式验证了</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">”</span>\" <span class=\"attr\">method</span>=<span class=\"string\">”post”</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">”username”</span>&gt;</span>Create a Username: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">”text”</span> <span class=\"attr\">name</span>=<span class=\"string\">”username”</span> <span class=\"attr\">id</span>=<span class=\"string\">”username”</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">”4-10″</span> <span class=\"attr\">pattern</span>=<span class=\"string\">”\\[A-Za-z\\]&#123;4,10&#125;”</span> <span class=\"attr\">autofocus</span> <span class=\"attr\">required</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">”submit”</span>&gt;</span>Go <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"新的重要的元素\"><a href=\"#新的重要的元素\" class=\"headerlink\" title=\"新的重要的元素\"></a>新的重要的元素</h2><h3 id=\"1-canvas\"><a href=\"#1-canvas\" class=\"headerlink\" title=\"1. canvas\"></a>1. canvas</h3><p>使用 Javascript 在网页上绘制图像，canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法；将在游戏、图表制作、banner 广告、模拟器、远程计算机控制、字体设计、图形编辑器、其他可嵌入网站的内容等方面大有可为；</p>\n<h4 id=\"SVG-与-Canvas-两者间的区别：\"><a href=\"#SVG-与-Canvas-两者间的区别：\" class=\"headerlink\" title=\"SVG 与 Canvas 两者间的区别：\"></a>SVG 与 Canvas 两者间的区别：</h4><ol>\n<li>SVG 是一种使用 XML 描述 2D 图形的语言。Canvas 通过 JavaScript 来绘制 2D 图形。</li>\n<li>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</li>\n<li>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</li>\n</ol>\n<p>下表列出了 canvas 与 SVG 之间的一些不同之处：</p>\n<table>\n<thead>\n<tr>\n<th>Canvas</th>\n<th>SVG</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>依赖分辨率</td>\n<td>不依赖分辨率</td>\n</tr>\n<tr>\n<td>不支持事件处理器</td>\n<td>支持事件处理器</td>\n</tr>\n<tr>\n<td>弱的文本渲染能力</td>\n<td>最适合带有大型渲染区域的应用程序（比如谷歌地图）</td>\n</tr>\n<tr>\n<td>能够以 .png 或 .jpg 格式保存结果图像</td>\n<td>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</td>\n</tr>\n<tr>\n<td>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</td>\n<td>不适合游戏应用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-视频-video-元素\"><a href=\"#2-视频-video-元素\" class=\"headerlink\" title=\"2. 视频 video 元素\"></a>2. 视频 video 元素</h3><p>今天，大多数视频是通过插件（比如 Flash）来显示的。然而，并非所有浏览器都拥有同样的插件。通用的视频播放解决方案是 flash 和 flv（flash 从 9 开始支持 h.264 的 mp4）。但是随着 iOS 设备的流行，flash 已经不是万能药了，越来越多的视频网站提供多元的解决方案，而且偏向于 HTML5：也就是说，通过检测 agent 是否支持 html5 来决定使用 video 还是 flash。在面对 IE8 以下的浏览器时，flash 几乎是唯一的选择(silverlight 的接受度普遍不高)。</p>\n<h3 id=\"3-音频-audio-元素\"><a href=\"#3-音频-audio-元素\" class=\"headerlink\" title=\"3. 音频 audio 元素\"></a>3. 音频 audio 元素</h3><p>同理可见 video 元素</p>\n<h2 id=\"对本地离线存储的更好的支持\"><a href=\"#对本地离线存储的更好的支持\" class=\"headerlink\" title=\"对本地离线存储的更好的支持\"></a>对本地离线存储的更好的支持</h2><h3 id=\"1-Web-worker\"><a href=\"#1-Web-worker\" class=\"headerlink\" title=\"1. Web worker\"></a>1. Web worker</h3><p>运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>\n<h3 id=\"2-Web-Storage\"><a href=\"#2-Web-Storage\" class=\"headerlink\" title=\"2. Web Storage\"></a>2. Web Storage</h3><p>将数据存储在本地，而不会和服务器发生任何交互，使得数据操作更加简便</p>\n<ul>\n<li>Web Storage 与 Cookie 相比存在不少的优势，概括为以下几点：存储空间更大，能提供 5MB 的存储空间（不同浏览器的提供的空间不同），Cookie 仅 4KB</li>\n<li>存储内容不会发送到服务器：当设置了 Cookie 后，Cookie 的内容会随着请求一并发送的服务器，这对于本地存储的数据是一种带宽浪费。而 Web Storage 中的数据则仅仅是存在本地，不会与服务器发生任何交互。</li>\n<li>更多丰富易用的接口：Web Storage 提供了一套更为丰富的接口，使得数据操作更为简便。(开发者的福利)</li>\n<li>独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。</li>\n</ul>\n<h3 id=\"3-Application-Cache\"><a href=\"#3-Application-Cache\" class=\"headerlink\" title=\"3. Application Cache\"></a>3. Application Cache</h3><p>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本，HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势：</p>\n<ul>\n<li>离线浏览 - 用户可在应用离线时使用它们</li>\n<li>速度 - 已缓存资源加载得更快</li>\n<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>\n</ul>\n<h2 id=\"地理位置-API\"><a href=\"#地理位置-API\" class=\"headerlink\" title=\"地理位置 API\"></a>地理位置 API</h2><p>Geolacation API 用于获得用户的地理位置，实例：</p>\n<ul>\n<li>更新本地信息</li>\n<li>显示用户周围的兴趣点</li>\n<li>交互式车载导航系统（GPS）</li>\n</ul>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://www.w3school.com.cn/html5/index.asp\" target=\"_blank\" rel=\"noopener\">HTML 5 教程</a></li>\n</ul>\n","raw":null,"categories":[{"name":"html","path":"api/categories/html.json"}],"tags":[{"name":"HTML","path":"api/tags/HTML.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"JS几种数组遍历方式","slug":"JS几种数组遍历方式","date":"2017-03-18T08:50:29.000Z","updated":"2019-01-27T10:07:12.320Z","comments":true,"path":"api/articles/JS几种数组遍历方式.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这是从 Lichun Dai 博客中看到的一篇文章，作者对 JS 中的数组遍历方式进行了总结，同时进行了性能对比。但根据评论者的回答，性能分析需要结合具体环境，单纯在浏览器中进行测试是难下结论的，所以我只会展示实现的方式，至于在浏览器中的性能可以点击文末的链接跳转至原作者的分析工具 demo。</p>\n<h2 id=\"第一种：普通-for-循环\"><a href=\"#第一种：普通-for-循环\" class=\"headerlink\" title=\"第一种：普通 for 循环\"></a>第一种：普通 for 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简要说明：最简单的一种，也是使用频率最高的一种，虽然性能不弱，但仍有优化空间</p>\n<h2 id=\"第二种：优化版-for-循环\"><a href=\"#第二种：优化版-for-循环\" class=\"headerlink\" title=\"第二种：优化版 for 循环\"></a>第二种：优化版 for 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>,len=arr.length; j &lt; len; j++) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简要说明: 使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。 <strong>这种方法基本上是所有循环遍历方法中性能最高的一种</strong></p>\n<h2 id=\"第三种：弱化版-for-循环\"><a href=\"#第三种：弱化版-for-循环\" class=\"headerlink\" title=\"第三种：弱化版 for 循环\"></a>第三种：弱化版 for 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; arr\\[j\\]!=<span class=\"literal\">null</span>; j++) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简要说明: 这种方法其实严格上也属于 for 循环，只不过是没有使用 length 判断，而使用变量本身判断 <strong>实际上，这种方法的性能要远远小于普通 for 循环</strong></p>\n<h2 id=\"第四种：foreach-循环\"><a href=\"#第四种：foreach-循环\" class=\"headerlink\" title=\"第四种：foreach 循环\"></a>第四种：foreach 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;  </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简要说明: 数组自带的 foreach 循环，使用频率较高，实际上性能比普通 for 循环弱</p>\n<h2 id=\"第五种：foreach-变种\"><a href=\"#第五种：foreach-变种\" class=\"headerlink\" title=\"第五种：foreach 变种\"></a>第五种：foreach 变种</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.forEach.call(arr,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>)</span>&#123;  </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简要说明: 由于 foreach 是 Array 型自带的，对于一些非这种类型的，无法直接使用(如 NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有 foreach 功能。 实际性能要比普通 foreach 弱</p>\n<h2 id=\"第六种：forin-循环\"><a href=\"#第六种：forin-循环\" class=\"headerlink\" title=\"第六种：forin 循环\"></a>第六种：forin 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简要说明: 这个循环很多人爱用，但实际上，经分析测试，在众多的循环遍历方式中 <strong>它的效率是最低的</strong></p>\n<h2 id=\"第七种：map-遍历\"><a href=\"#第七种：map-遍历\" class=\"headerlink\" title=\"第七种：map 遍历\"></a>第七种：map 遍历</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>)</span>&#123;  </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简要说明: 这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上 foreach</p>\n<h2 id=\"第八种：forof-遍历（ES6）\"><a href=\"#第八种：forof-遍历（ES6）\" class=\"headerlink\" title=\"第八种：forof 遍历（ES6）\"></a>第八种：forof 遍历（ES6）</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> arr) &#123;  </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简要说明: 这种方式是 ES6 里面用到的，性能要好于 forin，但仍然比不上普通 for 循环</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p><strong>普通 for 循环才是最优雅的</strong></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://dailc.github.io/2016/11/25/baseKnowlenge_javascript_jsarrayGoThrough.html\" target=\"_blank\" rel=\"noopener\">JS几种数组遍历方式以及性能分析对比</a></li>\n<li><a href=\"https://dailc.github.io/jsfoundation-perfanalysis/html/performanceAnalysis/demo_performanceAnalysis_jsarrayGoThrough.html\" target=\"_blank\" rel=\"noopener\">Js中几种常用数组遍历方式分析比较工具</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"数组","path":"api/tags/数组.json"}]},{"title":"前端面试系列","slug":"前端面试系列","date":"2017-03-17T09:19:17.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/前端面试系列.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>首先声明一下，这个系列的文章基本上都是摘抄自其他途径的，包括一些大牛小牛的博客、微信公众号或其他人的文章里，而且我会争取持续更新，最后形成一篇对前端基础薄弱的同学也友好的讲解文章，如果该系列中的任何一个知识点能够帮到你（我相信肯定会帮到我的，因为我也要开始找实习了。。），就达到我的目的了；而且该系列文章只会涉及到前端的技术点，像算法和智力题那种是不会涉及的，至于智力题的话，根据我的经验，只能 practice makes perfect (<em>^__^</em>) </p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><a href=\"/20170318/new-features-of-html5.html\">HTML5新特性</a></li>\n<li><a href=\"/20170318/new-features-of-css3.html\">CSS3新特性</a></li>\n<li><a href=\"/20170319/new-features-of-http2.html\">HTTP2新特性</a></li>\n<li><a href=\"/20170403/css-selector.html\">CSS选择器</a></li>\n<li><a href=\"/20170403/css-box-model.html\">CSS盒子模型</a></li>\n<li><a href=\"/20170404/status-code-of-http-request.html\">HTTP请求的状态码</a></li>\n<li><a href=\"/20170404/session-and-cookie.html\">session&amp;cookie</a></li>\n<li><a href=\"/20170405/tcp-three-handshakes-and-four-breakups.html\">TCP的三次握手与四次分手</a></li>\n<li><a href=\"/20170405/js-implements-inheritance.html\">JS实现继承</a></li>\n<li><a href=\"/20170405/closure-in-js.html\">JS中的闭包</a></li>\n<li><a href=\"/20170412/the-difference-between-window.onload-and-document.read.html\">window.onload和document.ready的区别</a></li>\n<li><a href=\"/20170416/front-end-performance-optimization.html\">前端性能优化</a></li>\n</ul>\n<h2 id=\"其他面试题整理\"><a href=\"#其他面试题整理\" class=\"headerlink\" title=\"其他面试题整理\"></a>其他面试题整理</h2><ul>\n<li><a href=\"https://yuchengkai.cn/docs/\" target=\"_blank\" rel=\"noopener\">InterviewMap</a></li>\n<li><a href=\"http://markyun.github.io/2015/Front-end-Developer-Questions/\" target=\"_blank\" rel=\"noopener\">前端工程师面试题汇总</a></li>\n<li><a href=\"http://blog.poetries.top/2017/03/12/front-end-interview-summary/\" target=\"_blank\" rel=\"noopener\">前端面试题整理</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008785931\" target=\"_blank\" rel=\"noopener\">20个必会的JavaScript面试题</a></li>\n<li><a href=\"http://markyun.github.io/2015/Front-end-Developer-Questions/\" target=\"_blank\" rel=\"noopener\">Front End Developer Questions</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyMjE0ODQ0OQ==&amp;mid=2651552755&amp;idx=1&amp;sn=d89fd543a549d53678ae984a93e759ba\" target=\"_blank\" rel=\"noopener\">魔法哥 2013 前端笔试题曝光（附完整解答）</a></li>\n<li><a href=\"https://www.reddit.com/r/cscareerquestions/comments/20ahfq/heres_a_pretty_big_list_of_programming_interview/\" target=\"_blank\" rel=\"noopener\">关于4种数据结构的算法面试问题列表</a></li>\n<li><a href=\"https://www.nowcoder.com/discuss/35805\" target=\"_blank\" rel=\"noopener\">阿里巴巴2018秋招面经之前端岗(1~5面)</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PrHwzQBrQCEx_w_8HcSNgg\" target=\"_blank\" rel=\"noopener\">阿里-蚂蚁金服三轮面试总结</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/HzS7bPeLTbBwlJacNv7uSA\" target=\"_blank\" rel=\"noopener\">技术面试宝典：很全面的算法和数据结构知识（含代码实现）</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011172965\" target=\"_blank\" rel=\"noopener\">18届校招求职面经及总结</a></li>\n</ul>\n","raw":null,"categories":[{"name":"series","path":"api/categories/series.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"JS","path":"api/tags/JS.json"},{"name":"HTML","path":"api/tags/HTML.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"游戏心得&伪攻略","slug":"游戏心得&伪攻略","date":"2017-03-17T08:20:58.000Z","updated":"2019-01-27T10:07:12.328Z","comments":true,"path":"api/articles/游戏心得&伪攻略.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>自认为玩过了好多游戏，从最开始的英雄联盟、天下3到后来的全民超神、王者荣耀以及各种大型小型 RPG、MOBA、CAG、SIM 类游戏，当然有时候也会查查攻略看看平民适合什么职业，或者玩过一阵子之后会等新区冲个排名，也会因为队友的菜b操作而心生愤懑。<br>细细算来，自己的游戏生涯也有 15 年左右了吧，从小学时候的抢滩登陆、美丽的伊苏？（具体名字我忘了，不过记得是一个角色冒险类游戏，还是蛮经典的），到中学时候的 DNF（现在有时候还会登一下，都开到 90 级了啊）、跑跑卡丁车，后来高中流行的穿越火线、QQ炫舞、QQ音乐，再后来大学和舍友们一起玩过的天下3、英雄联盟，到如今的守望先锋、风暴英雄（现在也还是没火起来啊），这些游戏陪伴了我们十几年，基本上见证了我们的青春和成长。淡已经扯够了，进入正题吧：</p>\n<blockquote>\n<p>更新自 2017-10-10：我发现竟然有很多人会看我的这篇文章，要知道我的个人博客可是技术型的啊~！所以这让我坚定了一个信念，就是——好好打游戏，好好写攻略。</p>\n</blockquote>\n<h2 id=\"手游\"><a href=\"#手游\" class=\"headerlink\" title=\"手游\"></a>手游</h2><h3 id=\"通用套路\"><a href=\"#通用套路\" class=\"headerlink\" title=\"通用套路\"></a>通用套路</h3><ol>\n<li>周卡（6元），月卡（30元）-&gt; 基本上是目前为止所有手游都会有的吧，不管是什么类型的游戏，但是究竟是从哪个手游开始的呢？</li>\n<li>首冲送好礼 -&gt; 这个和周卡月卡类似，但是首冲的钱不定</li>\n<li>装备升级、升阶、升星 -&gt; 这个在 RPG 游戏里会比较常见，当然有些 MOBA 类游戏也会有（比如说全民超神）</li>\n<li>十连抽必中好东西 -&gt; 这个玩卡牌游戏的人肯定不陌生吧，当然有的游戏十连比较简单，有的游戏十连可就得攒个十天半月了</li>\n</ol>\n<h3 id=\"狂暴之翼（iOS）\"><a href=\"#狂暴之翼（iOS）\" class=\"headerlink\" title=\"狂暴之翼（iOS）\"></a>狂暴之翼（iOS）</h3><p>狂暴之翼就是一款数值游戏，前期数值基本上都比较固定</p>\n<h4 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"></a>感受</h4><ol>\n<li>主线任务会提示百分比，譬如任务：寻找小仙女（90%），这样可以对玩家起到一定的心理暗示</li>\n</ol>\n<h4 id=\"首先：主线先到-17-级\"><a href=\"#首先：主线先到-17-级\" class=\"headerlink\" title=\"首先：主线先到 17 级\"></a>首先：主线先到 17 级</h4><p>然后扫荡地图，全身装备精炼到全身到5，再打第三章，第三章通关后扫荡全身精炼到全身到 10，以此类推；装备图纸和石头不够的魔晶商店可以购买，只买自己需要的，扫荡卷不够的黑钻买。(注意！有强迫症的孩子就打慢一点，把装备做完在推图，第二章的 13 节请手动，自动是过不去的)</p>\n<h4 id=\"22-级进公会拿升星石\"><a href=\"#22-级进公会拿升星石\" class=\"headerlink\" title=\"22 级进公会拿升星石\"></a>22 级进公会拿升星石</h4><p>公会钻石膜拜每次 6 个，转 4-5 只神兽每次 10 个(注意！打底转 4 个龙)，全身装备都升 1 星后，做戒指和项链先到 5 星，然后再平均精炼升星上去。(注意！一定要戒指和项链升星先到 5 星)</p>\n<h4 id=\"关于钻石\"><a href=\"#关于钻石\" class=\"headerlink\" title=\"关于钻石\"></a>关于钻石</h4><p>前期幸运转盘是最超值的来源，建议在把装盘的次数耗尽后再开始使用钻石，平民玩家建议在转三次转盘之前都不要花钻石，然后商店和 7 日目标买体力和升星石头，然后再单抽一次 288 钻石的宝藏得 4 阶装备</p>\n<h3 id=\"王者荣耀（iOS-android）\"><a href=\"#王者荣耀（iOS-android）\" class=\"headerlink\" title=\"王者荣耀（iOS / android）\"></a>王者荣耀（iOS / android）</h3><h4 id=\"感受-1\"><a href=\"#感受-1\" class=\"headerlink\" title=\"感受\"></a>感受</h4><ol>\n<li>画面比类似游戏要精致，阴影和怪物做的细节都很到位，同时英雄的打击动作也比较真实有料</li>\n<li>社交系统蛮不错的，仅仅通过一起打几局游戏就可以结为恋人，相比其他游戏而言真的良心</li>\n<li>吐槽一下装备系统，魔抗装备实在太少，这使得大家都比较喜欢玩法师，同时在 ban pick 中也是绝大部分都是法师，不知道为什么这样设计</li>\n</ol>\n<blockquote>\n<p>更新自2017-9-23：开发者们似乎听到了我内心的呐喊，现在魔抗装备稍微多了点。。</p>\n</blockquote>\n<p>以下介绍的攻略仅仅限于平民或小资玩家，目的是让你通过这篇攻略可以更快的获取金币、钻石、铭文碎片，从而可以购买更多的英雄，而不是教你怎么快速升王者，因为对于 MOBA 类游戏来说，“熟能生巧”是唯一真理。</p>\n<h4 id=\"前期\"><a href=\"#前期\" class=\"headerlink\" title=\"前期\"></a>前期</h4><p>首先，王者荣耀的新手任务很简单，可以很快速的获取一定量的金币，所以一定要完成；同时，师徒任务给的奖励很丰厚，最好在开始的时候找个师傅，然后按照师徒任务每天打几局，这样基本上一周之内就完成 13 个师徒任务了，可以获取大量金币和大量钻石<br>至于钻石夺宝，我的建议是每周就来个五连抽就行，因为可以领取88钻石的奖励，同时还可以涨幸运度，抽再多次的话就不划算了<br>活动最好抽时间完成，王者荣耀的活动很频繁，基本上每周都有，而且有时候会有免费英雄兑换活动，这种机会千万不要错过，你要知道这可是钱啊~！</p>\n<h4 id=\"中期\"><a href=\"#中期\" class=\"headerlink\" title=\"中期\"></a>中期</h4><p>王者荣耀每周通过对战获取金币数是有限制的（如果没有挂机等违规记录的话，每周上限 4200），所以最好保证每周把这 4200 都拿到，如果没有时间对战的话，可以尝试刷冒险（我一般刷精英难度的“稷下战场”，如果铭文比较好的话，可以尝试大师难度的“稷下战场”，具体如何刷可以自行搜索）；<br>而除了对战获取金币，每天的活跃度奖励也有很多金币、钻石、铭文碎片可以拿到，所以最好保证每天满活跃度以及一周满 1000 活跃度，其实王者荣耀的活跃度很容易打满，没时间的话可以找个战队的人组队打 3 局人机，然后把黄色任务完成（黄色任务加 30 活跃度，击杀 10 英雄、20 助攻、塔伤 10000 是可以人机完成的，其他类型的任务需要打对战，所以从概率学上讲还是很好完成的）<br>另外最好和认识的同学或同事一个战队，这样的话活跃度会比较简单地完成。同时别忘了战队商店可以拿活跃度换东西的，我是先换了高渐离，后面就一直换铭文碎片大宝箱了，一般 2-3 周就可以换一个宝箱了（500 铭文碎片）。每周的战队赛参加 4 次和获胜 1 次也有铭文碎片奖励，有时间的话可以参加一下。</p>\n<h4 id=\"后期\"><a href=\"#后期\" class=\"headerlink\" title=\"后期\"></a>后期</h4><p>我是不建议钻石抽铭文碎片的，因为抽到 5 级铭文的几率实在太小了，而且王者荣耀有时候会办那种消耗钻石兑换奖励的活动，这时候再消耗钻石的话不仅可以抽东西，还可以间接地参加活动获取奖励（我记得 9 月份的时候王者荣耀就出了类似的活动，我直接把攒的 12000 多钻石全抽铭文了）<br>相信几个月下来，你一定积攒了很多铭文碎片了，这时候可以根据自己的实际情况合成5级铭文了，如果你比较喜欢玩物理系的英雄，可以尝试合成“百穿”，如果你喜欢法师系的英雄，就合成一套法师通用铭文就可以了<br>如果你的排位等级比较靠前同时在线时间比较长，可以加一个排名比较靠前的战队，这样每周、每赛季获取的奖励都会有很多，同时战队赛也更容易组到人。</p>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p>王者荣耀不是一个烧钱的游戏（这条广告没有钱），但是没有铭文和有铭文是两个游戏，所以如果没有钱就花时间吧。。</p>\n<h3 id=\"阴阳师（iOS-android）\"><a href=\"#阴阳师（iOS-android）\" class=\"headerlink\" title=\"阴阳师（iOS / android）\"></a>阴阳师（iOS / android）</h3><h4 id=\"感受-2\"><a href=\"#感受-2\" class=\"headerlink\" title=\"感受\"></a>感受</h4><ol>\n<li>新服预约活动，这个不算是亮点，但是经常玩手游的人一般是喜欢去新区玩的，这样可以冲一下排名，而在官网有着很明显的新服预约页面可以让玩家省去找新区开服时间的麻烦</li>\n<li>一些副本的动画可以快进也可以暂停，这样可以让玩家暂停截图留念，同样对于那些老玩家来说，也可以快进节省时间。</li>\n<li>战斗的时间有点太长，如果可以跳过动画或者直接出一个扫荡的选项会节省玩家很多时间</li>\n</ol>\n<h3 id=\"全民超神（iOS-android）\"><a href=\"#全民超神（iOS-android）\" class=\"headerlink\" title=\"全民超神（iOS / android）\"></a>全民超神（iOS / android）</h3><h4 id=\"感受-3\"><a href=\"#感受-3\" class=\"headerlink\" title=\"感受\"></a>感受</h4><ol>\n<li>活动很良心，会各种送皮肤，玩家只需要在一段时间打一阵子游戏就可以获得，同时钻石获得也很容易，只要花一些时间，就可以购买很多喜欢的英雄</li>\n<li>可以向其他游戏学习，当击杀数或助攻数到达一定数量，比如 8888，6666，10000 的时候进行提示（在游戏中就算了，如果打完游戏正好达到就可以），并生成一张比较有纪念意义的图片，可以提升用户粘性</li>\n<li>为什么镜头不能拖拽呢，只能看到自己周围而无法看到其他地方的话会很影响用户体验，可以向王者荣耀学习一下。</li>\n<li>希望可以交换英雄，这样可以使玩家更大几率玩到自己喜欢玩的英雄，同时也有助于排位赛的发展</li>\n<li>目前对于挂机掉线的惩罚太轻，而且举报之后没有反馈，这一点根本比不上王者荣耀</li>\n<li>游戏内聊天系统有问题，连续输入4个汉字时会直接变成英文</li>\n</ol>\n<h3 id=\"soul-knight（iOS、单机）\"><a href=\"#soul-knight（iOS、单机）\" class=\"headerlink\" title=\"soul knight（iOS、单机）\"></a>soul knight（iOS、单机）</h3><h4 id=\"感受-4\"><a href=\"#感受-4\" class=\"headerlink\" title=\"感受\"></a>感受</h4><ol>\n<li>作为一个单机游戏，却内容很庞大，不仅有成就系统，还有多种多样的武器</li>\n<li>摒弃了之前职业差距很大的惯例，多种职业之间的差距仅仅在于大招不同，而每种职业也只有一个技能，但是鉴于此款游戏考验的是玩家的走位，所以技能只有一个也就无伤大雅了</li>\n<li>武器之间的差距并不在于颜色，需要玩家在实战中进行实验而且可以考验玩家对武器的理解，因为打小怪和打 boss 时不同类型的武器会有不同的表现</li>\n</ol>\n<h3 id=\"龙之谷（iOS）\"><a href=\"#龙之谷（iOS）\" class=\"headerlink\" title=\"龙之谷（iOS）\"></a>龙之谷（iOS）</h3><h4 id=\"感受-5\"><a href=\"#感受-5\" class=\"headerlink\" title=\"感受\"></a>感受</h4><ol>\n<li>在 rpg 游戏中加入观战系统是个很不错的 idea，可以看其他玩家的 pvp 或者副本攻打策略</li>\n</ol>\n<h3 id=\"卧虎藏龙\"><a href=\"#卧虎藏龙\" class=\"headerlink\" title=\"卧虎藏龙\"></a>卧虎藏龙</h3><h4 id=\"感受-6\"><a href=\"#感受-6\" class=\"headerlink\" title=\"感受\"></a>感受</h4><ol>\n<li>是我所见过玩过的游戏中 3D 场景做的最好的</li>\n</ol>\n<h3 id=\"英雄战歌（卡牌）\"><a href=\"#英雄战歌（卡牌）\" class=\"headerlink\" title=\"英雄战歌（卡牌）\"></a>英雄战歌（卡牌）</h3><h4 id=\"感受-7\"><a href=\"#感受-7\" class=\"headerlink\" title=\"感受\"></a>感受</h4><ol>\n<li>不敢说抄袭，但是玩过炉石传说的人就都知道这游戏该怎么玩了</li>\n<li>将卡牌收藏和 3D 攻击动画特效结合到一起，虽然特效差强人意，但有此心实属不易</li>\n<li>惯用的首冲月卡，但是月卡并没有让我有买的冲动，因为月卡带来的福利并不是玩家能够<strong>迅速</strong>并且<strong>明显</strong>看到价值的</li>\n<li>玩家可以通过每天的对战或者“星星”，然后 5 个星星就可以获得一个宝箱，宝箱需要时间来解锁，从而获得卡牌，同时每一个宝箱都有相应的积分获得，当积分满足一定条件时就可以或者比较丰厚的奖励，为期一个月，不得不说，我被这个活动吸引了，因为作为一个卡牌收藏游戏，玩家还是希望自己能够有更多“稀有”的卡，这也是卡牌收藏游戏的成就感来源，所以腾讯的这个 idea 让我有了很多新的思路，就是结合游戏的成就感来源去吸引用户、“黏住”用户，那样才能先保证不亏钱的情况下再赚钱</li>\n<li>和炉石不同的是，卡包真的好贵，而且目前来看好的卡牌包只能用点券购买（简直就是个土豪才玩得起的游戏嘛），不知道后面会不会有活动赠送点券，先玩一个月再看</li>\n</ol>\n","raw":null,"categories":[{"name":"game","path":"api/categories/game.json"}],"tags":[{"name":"心得","path":"api/tags/心得.json"},{"name":"游戏","path":"api/tags/游戏.json"}]}]}