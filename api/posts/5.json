{"total":114,"pageSize":10,"pageCount":12,"data":[{"title":"函数声明VS函数表达式","slug":"函数声明VS函数表达式","date":"2017-08-02T07:16:07.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/函数声明VS函数表达式.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>本篇文章译自某大牛的文章：<a href=\"https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/\" target=\"_blank\" rel=\"noopener\">Function Declarations vs. Function Expressions</a>，推荐英语不是很差的童鞋点击前面链接看原文。首先先做个小测验，下面四个例子的 alert 输出分别是什么？</p>\n<p><strong>例子一：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>例子二：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>例子三：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(foo());</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>例子四：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p>我就直接公布答案了：8，3，3 和 [Type Error:bar is not a function]。如果你没有完全答对或者直接翻到这里看答案，那你可以继续往下看了。</p>\n<h2 id=\"什么是函数声明-function-declaration\"><a href=\"#什么是函数声明-function-declaration\" class=\"headerlink\" title=\"什么是函数声明(function declaration)\"></a>什么是函数声明(function declaration)</h2><p>函数声明定义了一个命名的函数变量，而不需要变量赋值。函数声明是一种独特的结构，并且不能嵌套在非函数体中。我们可以将函数声明看做是变量声明的另一种形式，就像变量声明必须以 “var” 开头一样，函数声明必须以 “function” 关键字开头。下面就是一个很简单的函数声明实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ECMA 5(13.0) 中对于函数声明的定义：</p>\n<blockquote>\n<p>function_Identifier_ ( _FormalParameterList_opt ) { <em>FunctionBody</em> }</p>\n</blockquote>\n<p>需要注意的是，函数名在它本身的作用于以及它的父级作用域都是可见的（这是一个很不错的规则，因为不然的话在外面将无法访问到该函数）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">bar() <span class=\"comment\">//3</span></span><br><span class=\"line\">bar  <span class=\"comment\">//function</span></span><br><span class=\"line\">bar === <span class=\"built_in\">window</span>.bar  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是函数表达式-function-expression\"><a href=\"#什么是函数表达式-function-expression\" class=\"headerlink\" title=\"什么是函数表达式(function expression)\"></a>什么是函数表达式(function expression)</h2><p>函数表达式将一个函数定义为一个很长的表达式的一部分（通常是一个变量赋值表达式）。以“函数表达式”方式命名的函数可以是命名的也可以是匿名函数。<strong>函数表达式不能以 “function” 关键字开头</strong>（所以下面的第三个表达式需要用 “()” 包裹）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//匿名函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//命名函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//自调用函数表达式</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"hello!\"</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>和函数声明相反，<strong>函数表达式的函数名（如果有的话）在它的作用域之外是不可见的</strong></p>\n<h2 id=\"那函数语句-function-statement-又是什么呢？\"><a href=\"#那函数语句-function-statement-又是什么呢？\" class=\"headerlink\" title=\"那函数语句(function statement)又是什么呢？\"></a>那函数语句(function statement)又是什么呢？</h2><p>函数语句有时候只是函数声明的另一种叫法。然而，按照<a href=\"http://yura.thinkweb2.com/named-function-expressions/#function-statements\" target=\"_blank\" rel=\"noopener\">Kangax的说法</a>，Mozilla 认为函数语句是对于函数声明的扩展，它允许在任何允许使用语句的地方使用函数声明这种语法。但是，这是非行业标准，所以不推荐用于生产环境。</p>\n<h2 id=\"好像忘了上面四个例子\"><a href=\"#好像忘了上面四个例子\" class=\"headerlink\" title=\"好像忘了上面四个例子\"></a>好像忘了上面四个例子</h2><p>让我们回到文章开头那四个例子 首先，<strong>例子一是两个函数声明，所以这两个函数声明被“提升”了</strong></p>\n<h3 id=\"等一下，什么叫做被“提升”？\"><a href=\"#等一下，什么叫做被“提升”？\" class=\"headerlink\" title=\"等一下，什么叫做被“提升”？\"></a>等一下，什么叫做被“提升”？</h3><p>援引 <a href=\"http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting\" target=\"_blank\" rel=\"noopener\">Ben Cherry文章</a>中的一段话：</p>\n<blockquote>\n<p>Function declarations and function variables are always moved (‘hoisted’) to the top of their JavaScript scope by the JavaScript interpreter</p>\n</blockquote>\n<p>翻译一下就是：函数声明和函数变量总会被 Javascript 解释器移动（提升）到它们的 JavaScript 作用域的顶端（我希望你能够认认真真的理解一下上面这句话，如果还是不理解，没关系，继续向下看）;当函数声明被提升时，整个函数体都将随之提升。所以在解释器对例子一中的代码进行解析过后，它其实是这样的（建议回过头看一下例子一的代码，对比着看会更容易理解）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例子一实际执行时的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//\b第一次定义函数bar</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//第二次定义函数bar，将之前的定义覆盖</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//return调用结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar(); <span class=\"comment\">//8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>但是，我们一直以来的“常识”是return语句后面的代码是不会执行的啊？</strong></p>\n<p>这就涉及到“执行上下文”和“执行过程”的概念了，ECMA5 将“执行上下文”分为“词法环境”、“变量环境 ”和“绑定 this”，而“执行过程”是指最终的代码执行过程。当执行到声明语句的时候，此时的声明语句就会进入到“变量环境”，它们与语句（比如说 return 语句）是不同的，是不受所谓的“前面代码先执行，后面代码后执行”的约束的。 （“执行上下文”这一概念对于本篇文章来说是个重点，如果依然不理解的话，可以读一下<a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/13/2308101.html\" target=\"_blank\" rel=\"noopener\">汤姆大叔</a>和<a href=\"http://www.jianshu.com/p/a6d37c77e8db\" target=\"_blank\" rel=\"noopener\">简书-波同学</a>的文章加深理解）</p>\n<h3 id=\"那么，函数表达式也会提升吗\"><a href=\"#那么，函数表达式也会提升吗\" class=\"headerlink\" title=\"那么，函数表达式也会提升吗\"></a>那么，函数表达式也会提升吗</h3><p>这取决于表达式本身，让我们继续看以下例子二中的第一个表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>左边的 var bar 是一个变量声明。根据上面的规则，变量声明会被提升，但是赋值表达式却没有（和函数声明不同，函数声明会将整个函数体提升）。因此当 bar 这个变量被提升时，解释器会将 bar 初始化为 <code>undefined：var bar = undefined</code>。所以例子二中的代码实际上以下面的顺序执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例子二实际执行时的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//函数表达式的变量声明（被提升，同时被解释器赋初始值undefined）</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"comment\">//第一个函数表达式被执行</span></span><br><span class=\"line\">    bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//第一个函数表达式创建的函数被执行了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"comment\">//第二个函数表达式将不会执行（但是变量声明被提升了，就在上面）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo()); <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"目前你应该已经理解的差不多了，但是如果你在-Firebug-中运行例子三的代码会不符合预期，这又是为什么呢？\"><a href=\"#目前你应该已经理解的差不多了，但是如果你在-Firebug-中运行例子三的代码会不符合预期，这又是为什么呢？\" class=\"headerlink\" title=\"目前你应该已经理解的差不多了，但是如果你在 Firebug 中运行例子三的代码会不符合预期，这又是为什么呢？\"></a>目前你应该已经理解的差不多了，但是如果你在 Firebug 中运行例子三的代码会不符合预期，这又是为什么呢？</h3><p>你可以试着将例子三的代码保存在一个 HTML 文件中，然后用 firefox 浏览器打开，或者在 IE 8，Chrome 或者 Safari 的 console 中执行。你就会发现，Firebug 的 console 并没有像其他浏览器一样在全局作用域（其实并不是全局作用域，而是特殊的 “Firebug” 作用域。。可以试着在 firebug 的控制台中打印一下 “this == window” 你就明白了）中有函数体提升的表现 所以，抛开 firefox 的“灵异表现”不管，例子三和例子一其实是相同的道理，只不过是函数 foo 被提升了而已。</p>\n<h3 id=\"现在我们可以看一下例子四了\"><a href=\"#现在我们可以看一下例子四了\" class=\"headerlink\" title=\"现在我们可以看一下例子四了\"></a>现在我们可以看一下例子四了</h3><p>很明显，例子四是没有函数提升的，但是变量提升是存在的（而且是两个），那么此时 bar 的声明就会提升，但是它的值没有定义（undefined），所以最后相当于执行 undefined()。最后当然就会报错了：<code>bar is not a function</code>。</p>\n<h2 id=\"那还应该注意些什么呢？\"><a href=\"#那还应该注意些什么呢？\" class=\"headerlink\" title=\"那还应该注意些什么呢？\"></a>那还应该注意些什么呢？</h2><p>目前，你应该能完全理解上面的四个例子了。还需要注意的一点是，函数声明在非函数体（如 if）中是被明令禁止的。然而，所有的浏览器其实都允许这样做，并且更可怕的是，<strong>每个浏览器对这种不符合规定的语法的解释还不同！</strong>，举个栗子，下面的代码片断在 firefox 3.6 中会抛出一个错误，因为它将函数声明解析为函数语句（函数语句已经在上面介绍过了），所以 x is not defined。然而在 IE8，Chrome5 和 Safari5 中，函数 x 被正常 return 了（就像标准的函数声明一样）。当然，鉴于这篇文章的原文年代比较久远，具体的还是要自己在 dev tool 中运行一下才能得出结论（可以试着将 if 中的 true 替换为 false 再运行一下看看）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<h2 id=\"既然函数声明会造成混论，那它的好处在哪里？\"><a href=\"#既然函数声明会造成混论，那它的好处在哪里？\" class=\"headerlink\" title=\"既然函数声明会造成混论，那它的好处在哪里？\"></a>既然函数声明会造成混论，那它的好处在哪里？</h2><p>通过上面的讨论，你会发现函数声明是“宽松”的——如果你在某个函数声明之前就调用它，“函数提升”的机制将使函数得到正常调用而不会报错。但是这种“宽松”缺乏严谨性，同时从长远来看，禁止“声明前调用”将更有利于开发者的编程习惯的养成（就像所谓的“弱类型”）。毕竟，开发者需要养成以特定的顺序编写代码的习惯。</p>\n<h2 id=\"函数表达式的优势呢？\"><a href=\"#函数表达式的优势呢？\" class=\"headerlink\" title=\"函数表达式的优势呢？\"></a>函数表达式的优势呢？</h2><p>说出来你可能不信:）首先，函数声明的方式好像在模仿 Java 中的方法声明，然而 Java 的方法和 JS 中的函数是两码事啊（原文是：<strong>Java methods are very different animals</strong>）：在 JavaScript 中，函数是具有值的 living object，而 Java 中的方法只是元数据存储结构。下面的两段代码片断都定义了函数但是只有函数表达式表明我们在创建一个对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b&#125;;</span><br><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b&#125;;</span><br></pre></td></tr></table></figure>\n<p>其次，<strong>函数表达式的用途更多</strong>。一个函数声明只能解释为一段孤立的语句。它能做的仅仅是创建一个以当前作用域为父域的变量对象。与之相反，函数表达式是一种更复杂的结构。如果你想创建一个匿名函数或者将某个函数分配给一个原型对象亦或作为某个其他对象的属性的话，你就可以用函数表达式来实现。每当你使用高阶应用程序（比如 curry 或 compose）创建一个函数时，你其实都是在应用函数表达式。所以，<strong>函数表达式和函数编程其实是密不可分的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHello = alert.curry(<span class=\"string\">\"hello!\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数表达式有缺点吗？\"><a href=\"#函数表达式有缺点吗？\" class=\"headerlink\" title=\"函数表达式有缺点吗？\"></a>函数表达式有缺点吗？</h2><p>一般情况下，通过函数表达式方式创建的函数都是匿名的。比如下面这段代码创建的函数是匿名的，today 只是对于匿名函数的引用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;</span><br></pre></td></tr></table></figure>\n<p>那匿名不匿名关系大吗？大多数情况下是没有的，但是正如 <a href=\"http://fitzgeraldnick.com/weblog/\" target=\"_blank\" rel=\"noopener\">Nick Fitzgerald</a> 所说，使用匿名函数进行调试有可能会很痛苦。所以他建议使用命名函数表达式（NFEs）作为一种替代方案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">today</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，正如 Asen Bozhilov 所说（以及 <a href=\"http://yura.thinkweb2.com/named-function-expressions/#jscript-bugs\" target=\"_blank\" rel=\"noopener\">Kangax 的文章</a>），NFEs 在 IE9 以下的浏览器中无法正常运行（在我看来，这并不是个大问题）</p>\n<h2 id=\"MD终于到结尾了\"><a href=\"#MD终于到结尾了\" class=\"headerlink\" title=\"MD终于到结尾了\"></a>MD终于到结尾了</h2><p>在错误的位置进行函数声明会误导别人，而且很少有（如果有）这种情况，就是你不能通过函数表达式的方法创建函数而必须用函数声明。当然，如果你必须要用函数声明，请将它们放在作用域顶端，这样可以减小误导性。同时，我绝不会在 if 语句中进行函数声明（这是明令禁止的）。 说了这么多（译者注：确实很多，翻译了好几个小时），你可能依然觉得有时候还是宁愿用函数声明。这其实很正常，盲目的遵守某些规则是愚蠢的，而且有时候会导致自己的代码很“丑陋”。最重要的是，你理解了上面介绍的这些概念和知识点，从而能够让你做出明智的决定。我希望这篇文章在这个方面能够对你有所帮助。 欢迎评论，如果你觉得我哪里说得不对（或者翻译的不对:））以及还有哪里需要补充的，欢迎留言或者通过其他方式联系我。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"函数","path":"api/tags/函数.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"为什么随机字符串“chucknorris”会被识别为红色？","slug":"为什么随机字符串“chucknorris”会被识别为红色？","date":"2017-08-01T10:35:30.000Z","updated":"2019-01-27T10:07:12.320Z","comments":true,"path":"api/articles/为什么随机字符串“chucknorris”会被识别为红色？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_274.png","content":"<p>这个问题来源于 <a href=\"https://stackoverflow.com/questions/8318911/why-does-html-think-chucknorris-is-a-color\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>，就是有位学者无意中发现随机字符串会被 html 识别为特定的一些颜色，于是就在 stackoverflow 发起了讨论，这个问题也引起了我的兴趣，虽然是一个比较偏的知识点，但是了解一下还是没坏处的。</p>\n<h2 id=\"题目解释\"><a href=\"#题目解释\" class=\"headerlink\" title=\"题目解释\"></a>题目解释</h2><p>从下图我们可以看到，“chucknorris” 是一个随机的字符串，但是 body 却被渲染成了红色，是不是很有趣？</p>\n<div align=\"center\"><img src=\"/images/hexo_post_274.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先你需要知道 css 中的颜色值是十六进制的（比如最通常的白色：”#FFFFFF”，黑色：”#000000”），所以对于随机的字符串来说，其中有可能会包含不属于十六进制字母的那些字母（比如 h、u、k 等等），那么就会有如下的规则对“随机字符串颜色”进行替换（以随机字符串 “chucknorris” 为例）：</p>\n<h3 id=\"首先，用’0’替换所有的非十六进制字母\"><a href=\"#首先，用’0’替换所有的非十六进制字母\" class=\"headerlink\" title=\"首先，用’0’替换所有的非十六进制字母\"></a>首先，用’0’替换所有的非十六进制字母</h3><p>chucknorris -&gt; c00c0000000  </p>\n<h3 id=\"然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加-‘0’，比如上面的-“c00c0000000”-就只有-11-个字母，需要在尾部添加一个-‘0’）\"><a href=\"#然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加-‘0’，比如上面的-“c00c0000000”-就只有-11-个字母，需要在尾部添加一个-‘0’）\" class=\"headerlink\" title=\"然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加 ‘0’，比如上面的 “c00c0000000” 就只有 11 个字母，需要在尾部添加一个 ‘0’）\"></a>然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加 ‘0’，比如上面的 “c00c0000000” 就只有 11 个字母，需要在尾部添加一个 ‘0’）</h3><p>c00c 0000 0000  </p>\n<h3 id=\"最后，对于每一组内的字符串，只取前两位字母作为最终的-“R”、“G”、“B”-的值\"><a href=\"#最后，对于每一组内的字符串，只取前两位字母作为最终的-“R”、“G”、“B”-的值\" class=\"headerlink\" title=\"最后，对于每一组内的字符串，只取前两位字母作为最终的 “R”、“G”、“B” 的值\"></a>最后，对于每一组内的字符串，只取前两位字母作为最终的 “R”、“G”、“B” 的值</h3><p>c00c 0000 0000 -&gt; RGB(c0, 00, 00)</p>\n<p>所以，最终的结果是 #c00000/rgb(192,0,0),就是最开始那张图显示的深红色。</p>\n<h2 id=\"还没完\"><a href=\"#还没完\" class=\"headerlink\" title=\"还没完\"></a>还没完</h2><p>所以这个问题的答案就是一个歇后语：王八的屁股——规定！当然了，对于那种不足六个字母的颜色值来说，就会有额外的处理规则了：#aaa -&gt; #aaaaaa、#aaa3 -&gt; #aaa300、#aaa35 -&gt; #aaa350，有一个“很有想法”的哥们专门为这个转换做了一个网页，可以<a href=\"http://randomstringtocsscolor.com/\" target=\"_blank\" rel=\"noopener\">点击这里</a>试玩一下，输入任意的字符串可以看到背景颜色的变化，同时可以看到最终的颜色值</p>\n<div align=\"center\"><img src=\"/images/hexo_post_275.png\" alt=\"\" width=\"500\"></div>","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"}]},{"title":"JS中判断字符串中是否含有一个子串","slug":"JS中判断字符串中是否含有一个子串","date":"2017-08-01T07:33:27.000Z","updated":"2019-01-27T10:07:12.316Z","comments":true,"path":"api/articles/JS中判断字符串中是否含有一个子串.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_273.png","content":"<p>题目我就不过多解释了，这篇文章是对 <a href=\"https://stackoverflow.com/questions/1789945/how-to-check-whether-a-string-contains-a-substring-in-javascript\" target=\"_blank\" rel=\"noopener\">stackoverflow 上一个问题</a>的总结，如果英文不是特别差的话，推荐大家点击上面链接看大家对这个问题的详细讨论</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">string.indexOf(substring) !== <span class=\"number\">-1</span>;</span><br></pre></td></tr></table></figure>\n<p>String 的原型方法，返回一个字符串在另一个字符串中的位置，如果没有找到的话就返回 -1；也是大家经常用的方案</p>\n<h3 id=\"ES6-的-includes\"><a href=\"#ES6-的-includes\" class=\"headerlink\" title=\"ES6 的 includes\"></a>ES6 的 includes</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">string.includes(substring);</span><br></pre></td></tr></table></figure>\n<p>ES6 中新增的 String 原型方法（其实 Array 原型也有 includes 方法），可以<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看文档</p>\n<h3 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search\"></a>search</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;</span><br><span class=\"line\">string.search(expr);</span><br></pre></td></tr></table></figure>\n<p>String.prototype.search() 执行正则表达式和 String 对象之间的一个搜索匹配，所以参数需要是正则表达式，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看中文文档</p>\n<h3 id=\"lodash-的-includes\"><a href=\"#lodash-的-includes\" class=\"headerlink\" title=\"lodash 的 includes\"></a>lodash 的 includes</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">_.includes(string, substring);</span><br></pre></td></tr></table></figure>\n<p>lodash 是一个前端库，其提供了一些更加拥抱未来的方法，其中就有 _.includes(str,substr)</p>\n<h3 id=\"RegExp-和-test\"><a href=\"#RegExp-和-test\" class=\"headerlink\" title=\"RegExp 和 test\"></a>RegExp 和 test</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;  <span class=\"comment\">// no quotes here</span></span><br><span class=\"line\">expr.test(string);</span><br></pre></td></tr></table></figure>\n<p>“正则表达式是万能的”，RegExp.prototype.test(str)</p>\n<h3 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;</span><br><span class=\"line\">string.match(expr);</span><br></pre></td></tr></table></figure>\n<p>和上面的 test 正好相反，match 方式是 String 的原型方法，String.prototype.match(expr)</p>\n<h2 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h2><p>既然有这么多方法都可以实现，那么哪一种才是“性能最优”的方法呢？早就有前辈替我们做了测试，可以<a href=\"http://jsben.ch/#/RVYk7\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看测试结果，或者直接看下面这张图片：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_273.png\" alt=\"\" width=\"500\"></div>\n\n<p>不出所料，果然原生方法 indexOf() 是最快的，所以我们以后就还尽量用 indexOf() 吧！</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"}]},{"title":"总有那么一句话……","slug":"总有那么一句话……","date":"2017-08-01T03:34:27.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/总有那么一句话…….json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_272.png","content":"<p>曾经有记者问朴灵：如果不做程序员，你最想做什么职业？朴灵是这样回答的：“如果不做程序员，我可能想做一个写作者。或者是教师。觉得骨子里有种将好东西分享出去的冲动。”其实在这一点上，我和朴灵是类似的，虽然高考语文只考了 108 分，但是我如果没有踏进互联网大门的话，可能会将更多的时间用在写作分享上。所以，这篇文章就是我用来和大家分享我想到、听到、看到的那些“一句话真言”，或哲理、或深刻、或讽刺、或扎心。你可以在闲暇时来看一下这篇文章，因为这篇文章会持续更新……</p>\n<blockquote>\n<p>叩首问路，码梦为生</p>\n</blockquote>\n<p>细心的同学可能发现了，我的个人博客的 title 就是这句话，这句话出自朴灵，后来被很多“文艺型码农”引用：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_272.png\" alt=\"\" width=\"500\"></div>\n\n<blockquote>\n<p>钱总要挣，家总要成，奔走红尘，莫忘曾经是书生</p>\n</blockquote>\n<p>这句话是一副对联的下联，原对联是“<strong>史亦尝考，文亦尝校，答辩近了，犹思几度改论稿；家总要成，钱总要挣，奔走红尘，莫忘曾经是书生。</strong>”出自<a href=\"http://www.thepaper.cn/newsDetail_forward_1422430\" target=\"_blank\" rel=\"noopener\">复旦大学教授陈正宏</a>，提醒我们在众多红尘琐事之外不要丢了书生本色。</p>\n<blockquote>\n<p>来了不后悔，走了不想再来</p>\n</blockquote>\n<p>这是微信公众号<a href=\"http://mp.weixin.qq.com/s/OcTtk9FWKrdRhDioGjtMYA\" target=\"_blank\" rel=\"noopener\">“十一姐的涂鸦馆”一篇文章</a>中的一句话，说的是衡中人对于衡中的评价，衡中在近几年一直受到“关注”，同时每年的高考时段也成为了衡中的批斗大会召开时间，但是作为一名衡中人，对于网上的种种言论我都是报以“无力吐槽”的心态，因为国内的舆论环境就是这样的，人云亦云，不乏找存在感的无量群众。</p>\n<blockquote>\n<p>TL;DR</p>\n</blockquote>\n<p>经常逛大牛的博客，有时候就会看到上面这句话，充满好奇心的我就查了一下，其实是 “Too Long;Don’t Read” 的意思，在一些国外的网站用来告诉读者：下面的叙述太长了，你要是没耐心就别读了。而在国内呢，大多数学者都将其理解为“长话短说”的意思，所以和国外相反，一般这句话下面的文章都会言简意赅……</p>\n<blockquote>\n<p>Winter is coming!</p>\n</blockquote>\n<p>来自很黄很暴力的《冰与火之歌》，中文翻译为“凛冬将至”，具体可以查看知乎：<a href=\"https://www.zhihu.com/question/46335767\" target=\"_blank\" rel=\"noopener\">“winter is coming”这句话该怎么翻译？</a></p>\n<blockquote>\n<p>经不住流年似水，逃不过此间少年</p>\n</blockquote>\n<p>来自<a href=\"https://book.douban.com/review/4639373/\" target=\"_blank\" rel=\"noopener\">《此间的少年》</a>，寓意珍惜时间，让我想起了另外一句诗“有花堪折直须折，莫待无花空折枝”</p>\n<blockquote>\n<p>炫耀从来不是我写作的动机，好奇才是</p>\n</blockquote>\n<p>这是<a href=\"http://www.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">阮一峰</a>老师的一句话，其实写作就是这样的，尤其是技术类的文章，就算你阅读了很多资料，时间仍然是你最大的敌人，因为技术更新换代实在太快了，我相信每一位写技术博客的作者都是抱着这种心态去写作的，我更不例外，所以希望大家能够多多评论，如果发现有哪些地方写的不严谨或者不正确的，欢迎留言指出，我会认真改正的。</p>\n<blockquote>\n<p>好看的皮囊千篇一律，有趣的灵魂万里挑一</p>\n</blockquote>\n<p>这句话的具体出处不详，有人说是高晓松，有人说是王尔德，具体是谁说的已经不重要了，重要的是这句话已经成为许多人口中的情话，你学到了吗？</p>\n<blockquote>\n<p>愿你走出半生，归来仍是少年</p>\n</blockquote>\n<p>出自一位初中生的作文，引发了很多人的共鸣。</p>\n<blockquote>\n<p>生活不止眼前的苟且，还有诗和远方</p>\n</blockquote>\n<p>也许我们的教育还要再加一门课——“抗挫折”，不管现在过得怎样，不管过去如何迷茫，未来总是不确定的，所以抬起头，面向远方吧。</p>\n<blockquote>\n<p>命运以痛吻我，我愿报之以歌。</p>\n</blockquote>\n<p>这是模仿了泰戈尔诗集里面的一句话：<strong>世界以痛吻我，我要报之以歌</strong>。 原文的意思是：面对这个世界的苦难和人生的挫折，我们需要满怀希望，用积极乐观的心态去面对。</p>\n<p>英文版：<strong>Destiny with pain kiss me, I will come with songs</strong></p>\n<blockquote>\n<p>生而为人，请务必善良</p>\n</blockquote>\n<p>这句话初听上去有点“无病呻吟”的感觉，但是经历的多了，就会发现，善良是一件简单但奢侈的东西。<strong>你可以不善良，但是请不要去伤害</strong>。</p>\n<blockquote>\n<p>每一个你想抵达的地方，都有人和你一样想逃离。</p>\n</blockquote>\n<p>来自<a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjIyOTE4Nw==&amp;mid=2247487308&amp;idx=1&amp;sn=003e65d82753eb69af87fb68752fe8a1&amp;chksm=ea900be0dde782f6c2c51a8ecec96db0f01f64dc95981435822d85240cd522cefddd8af5e9a0&amp;mpshare=1&amp;scene=1&amp;srcid=0922xfopEPhMEnfWgCSQuqWP&amp;key=2d4f8815520d267175d4374196076806d930ad8f826e0cb219495de0a670baeda0f7dda353b1546aa67e910debfc48d6f10fcd4fbebd2c45e51bdd92e380c85dd5a68a754b88d9e1aba25a7d0c616f44&amp;ascene=0&amp;uin=MTMzNTc2NjIyMA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.5+build(16F73\" target=\"_blank\" rel=\"noopener\">杜蕾斯团队给京东做的新广告的文案</a>&amp;version=12020710&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=RyQZPMFy992DYlP1WXqhj%2FrCinnfljISztXgcD61wOwacxE1vMmUAufT5bFtUVHa)；我最喜欢的一句话是“知足常乐”，很多人都会因为羡慕（or 嫉妒 or 恨）别人而闷闷不乐，其实每个人都有专属自己的“小幸福”，知足才能常乐。</p>\n<blockquote>\n<p>卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭</p>\n</blockquote>\n<p>这句话是诗人北岛《回答》里面很著名的两句，有学者解读为：社会黑白不分，道德沦丧。这让我想到了电影《熔炉》里的一句话：<strong>我们要的不是改变世界，而是不让世界改变我们</strong>。（这个电影也很好看，是一部改变了韩国法律的电影）</p>\n<blockquote>\n<p>Stay hungry. Stay foolish.</p>\n</blockquote>\n<p>这句话最初是《Whole Earth Catalog》创办人斯图尔特·布兰特（Stewart Brand）说的；而后因为 2005 年乔布斯在斯坦福的演讲中引用过而出名，后来就开始被各方神圣引用；同时这句话的中文版本也有很多：</p>\n<ul>\n<li>保持饥饿。保持愚蠢。</li>\n<li>我傻我知道，我穷我努力。</li>\n<li><strong>求知若饥，虚心若愚。</strong></li>\n<li>求知。守拙。</li>\n<li>不知足。不卖弄。</li>\n<li>谦。虚。</li>\n<li>物有所不足，智有所不明。</li>\n<li>致虚极，守静笃。</li>\n<li>做个吃货，做个二货。</li>\n<li><strong>功成不息，坚守痴心。</strong></li>\n<li>守拙归园田。</li>\n<li>留在饥饿里。留在白痴里。</li>\n<li>保持渴望，固执愚见。</li>\n<li>朝三守四，二尽一来。</li>\n<li>保持饥渴觅成功，固守愚钝得精进。</li>\n</ul>\n<p>当然，如果你问我更倾向于哪种翻译，我想上面的加粗字体已经告诉了你答案~</p>\n<blockquote>\n<p>你说我是错的，那你最好证明你是对的 —— King of Pop</p>\n</blockquote>\n<p>这是 QQ 邮箱登录时看到的一句话，而 King of Pop 大家应该能猜出来了吧，说的就是迈克尔·杰克逊，这是 MJ 的一句歌词，原文是 “You say I’m wrong, but you’d better prove you’re right.”，而张小龙之所以选择这句话也是个蛮有意思的故事，大家看<a href=\"https://www.zhihu.com/question/29920558\" target=\"_blank\" rel=\"noopener\">知乎上关于这句话的讨论</a>就够了~</p>\n<blockquote>\n<p>在真正的开放社会里，人类没有 bug，只有 feature。</p>\n</blockquote>\n<p>最近关于同性恋是否属于“性变态”的话题上了热搜，其实在很早之前大家都认为同性恋是一种“疾病”，而到现在，大家都已经欣然接受了这一部分人群的存在，从一定程度上讲，这表明了社会的进步和真正的开放。</p>\n<blockquote>\n<p>待我代码编成，娶你为妻可好</p>\n</blockquote>\n<p>一个大牛说的一句话，为此还有个<a href=\"http://www.xuntayizhan.com/blog/ji-ke-ai-qing-zhi-er-shi-dai-wo-dai-ma-bian-cheng-qu-ni-wei-qi-ke-hao-wan/\" target=\"_blank\" rel=\"noopener\">我没看懂的小故事</a>。。</p>\n<blockquote>\n<p>佛为心，道为骨，儒为表，大度看世界； 技在手，能在身，思在脑，从容过生活。</p>\n</blockquote>\n<p>南怀瑾大师的一句话，用来指导在家的修行人的， 告诉他们如何在现代快速发展的经济社会中生活、修行。我等凡夫俗子是参悟不到其中的真谛了。。</p>\n<blockquote>\n<p>Talk is cheap, show me the code.</p>\n</blockquote>\n<p>翻译成中文就是：屁话少说，放码过来。——来自<a href=\"https://www.zhihu.com/question/23090743\" target=\"_blank\" rel=\"noopener\">知乎</a></p>\n<blockquote>\n<p>无人与我立黄昏，无人问我粥可温</p>\n</blockquote>\n<p>其实这是一句歌词，因七堇年的短文《浮生六记》而被众人误解，以为这一句出自沈复的《浮生六记》。原作者于 2015 年 5 月 30 日发表长微博解释。七堇年也发表了道歉微博。是陌緒（微博名）在 2012 年 6 月写的《寄芸》里的一句词。这首歌于 2012 年 8 月 27 日首发在<a href=\"http://5sing.kugou.com/fc/7245962.html\" target=\"_blank\" rel=\"noopener\">5sing</a>，署名为墨绪。<a href=\"https://www.zhihu.com/question/27056973\" target=\"_blank\" rel=\"noopener\">知乎</a>上有更多信息。</p>\n","raw":null,"categories":[{"name":"talk","path":"api/categories/talk.json"}],"tags":[{"name":"life","path":"api/tags/life.json"}]},{"title":"关于CSS Reset那些事","slug":"关于CSS Reset那些事","date":"2017-07-30T12:47:49.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/关于CSS Reset那些事.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"CSS-Reset\"><a href=\"#CSS-Reset\" class=\"headerlink\" title=\"CSS Reset\"></a>CSS Reset</h2><p>css reset，顾名思义，就是<strong>重置样式</strong>。那么为什么我们需要重置样式呢，这一切还要“归功于”前端领域的特点，就是跨平台、跨客户端；众所周知，现在所使用的主流浏览器对于一些标签的默认属性并没有做到统一，所以我们有时候会发现，某个页面在 chrome 浏览器上样式表现很正常，但是到了 firefox 上面却有着其他的样式表现（就更不用提IE了），这就是经常提到的“<strong>兼容性问题</strong>”，而 css reset 就是解决默认样式不兼容问题的办法之一</p>\n<h2 id=\"CSS-Reset发展历程\"><a href=\"#CSS-Reset发展历程\" class=\"headerlink\" title=\"CSS Reset发展历程\"></a>CSS Reset发展历程</h2><h3 id=\"第一份\"><a href=\"#第一份\" class=\"headerlink\" title=\"第一份\"></a>第一份</h3><p>查阅了一些资料，也看了一些大牛的博客，目前比较一致地认为最早的一份 CSS reset 来自<a href=\"http://tantek.com/log/2004/undohtml.css\" target=\"_blank\" rel=\"noopener\">Tantek 的 undohtml.css</a>，时间应该是 2004 年，很简单的代码（注释都比代码多），Tantek 根据自己的需要，对浏览器的默认样式进行了一些重置，同时从这一份 CSS reset 也可以窥探出“重置样式”需要考虑的标签有哪些。</p>\n<h3 id=\"YUI-团队\"><a href=\"#YUI-团队\" class=\"headerlink\" title=\"YUI 团队\"></a>YUI 团队</h3><p>业界领袖 YUI 团队在 Tantek 的基础上将 css reset 变得更加充实，当然代码的核心部分仍然是对样式进行重置，可以直接<a href=\"http://yui.yahooapis.com/3.18.1/build/cssreset-context/cssreset-context-min.css\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看，YUI 团队 2014 年给出的 css reset 代码（随着 Yahoo 光荣不再，估计这份 css reset 的版本也会停留在 3.18.1 了吧），从代码中可以看出我们如果想引用这套 css reset，还需要加一个 yui3-cssreset 类，或者修改其源码，将 .yui3-cssreset 全部删掉。YUI 不仅支持 css reset，还配套了 cssfonts.css 和 cssbase.css。<code>cssreset.css</code> 只负责清除默认样式,而 <code>cssfonts.css</code> 和 <code>cssbase.css</code> 则负责将一些元素的默认样式再重设回来</p>\n<h3 id=\"Eric-Meyer\"><a href=\"#Eric-Meyer\" class=\"headerlink\" title=\"Eric Meyer\"></a>Eric Meyer</h3><p>相比 YUI 团队的 css reset 方案，<a href=\"http://meyerweb.com/eric/tools/css/reset/index.html\" target=\"_blank\" rel=\"noopener\">Eric Meyer 的方案</a>就显得有些繁重了，而且这套代码最新版本是 2011 年公开的，考虑到年代久远，就不予评论了。</p>\n<h3 id=\"html5reset\"><a href=\"#html5reset\" class=\"headerlink\" title=\"html5reset\"></a>html5reset</h3><p>相比前面的这些方案，<a href=\"https://github.com/murtaugh/HTML5-Reset\" target=\"_blank\" rel=\"noopener\">这个团队</a>给出的方案就更显臃肿了，而且也不太出名，当然了，css reset 并不是用来全盘照搬的，找到自己需要的才是最聪明的办法</p>\n<h2 id=\"国产-CSS-reset\"><a href=\"#国产-CSS-reset\" class=\"headerlink\" title=\"国产 CSS reset\"></a>国产 CSS reset</h2><p>以上都是国外的大牛或团队给出的 css reset 方案，那么作为互联网行业发展最突飞猛进的中国，就没有人或团队做过 css reset 方面的尝试吗？肯定有啊（要不然我这一部分怎么写？）：</p>\n<h3 id=\"阿里-Kissy-框架\"><a href=\"#阿里-Kissy-框架\" class=\"headerlink\" title=\"阿里 Kissy 框架\"></a>阿里 Kissy 框架</h3><p>阿里在 2009 年就已经给出了自己的 css reset 方案，这应该是国内的第一份 css reset，是玉伯和另外一位前辈完成的，向他们致敬。但是由于距离现在已经有将近十年了，源码的链接已经失效，我将各种版本的 css reset 代码都上传到了我的 github，可以<a href=\"http://merrier.github.io/CSS-Reset/kissy/reset.css\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看国内第一份 css reset。</p>\n<h3 id=\"张鑫旭的方案\"><a href=\"#张鑫旭的方案\" class=\"headerlink\" title=\"张鑫旭的方案\"></a>张鑫旭的方案</h3><p>我不希望你看到这个标题的第一感觉是：<a href=\"http://www.zhangxinxu.com\" target=\"_blank\" rel=\"noopener\">张鑫旭</a>是谁。因为如果你连张鑫旭都不认识，前端界真是白混了！作为一位资深 css 研究学者，张鑫旭对于 css reset 也有自己独到的理解，下面就是他给出的方案：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>:<span class=\"number\">1.4</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#333</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>:arial;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">input</span>,<span class=\"selector-tag\">textarea</span>,<span class=\"selector-tag\">select</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">100%</span>;    </span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>:inherit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">h1</span>,<span class=\"selector-tag\">h2</span>,<span class=\"selector-tag\">h3</span>,<span class=\"selector-tag\">h4</span>,<span class=\"selector-tag\">h5</span>,<span class=\"selector-tag\">h6</span>,<span class=\"selector-tag\">p</span>,<span class=\"selector-tag\">ul</span>,<span class=\"selector-tag\">ol</span>,<span class=\"selector-tag\">form</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h4</span>,<span class=\"selector-tag\">h5</span>,<span class=\"selector-tag\">h6</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">1em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span>,<span class=\"selector-tag\">ol</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-left</span>:<span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">list-style-type</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/\\*image with no-border\\*/</span><br><span class=\"line\"><span class=\"selector-tag\">img</span>&#123;<span class=\"attribute\">border</span>:<span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，非常的简短，当然了，对于这份方案，张鑫旭在<a href=\"http://www.zhangxinxu.com/wordpress/2010/07/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BD%91%E7%AB%99css%E8%BF%9B%E8%A1%8C%E6%9E%B6%E6%9E%84%E7%9A%84/\" target=\"_blank\" rel=\"noopener\">他的文章</a>中也进行了解释</p>\n<h2 id=\"替代品-Normalize-css\"><a href=\"#替代品-Normalize-css\" class=\"headerlink\" title=\"替代品 Normalize.css\"></a>替代品 Normalize.css</h2><p>历史的车轮滚滚向前，时过境迁，中国的前端职位越发的火热，开发者们也变得更为专业，<code>CSS Reset</code> 泛滥使用逐渐淡出的前端的视野，被取而代之就是 <a href=\"https://github.com/necolas/normalize.css\" target=\"_blank\" rel=\"noopener\"><code>Normalize.css</code></a>，关于对 <code>CSS Reset</code> 与 <code>Normalize.css</code> 的区别？可以引用知乎上<a href=\"http://www.zhihu.com/question/20094066\" target=\"_blank\" rel=\"noopener\">张小核桃</a>的一个回答：</p>\n<blockquote>\n<p>CSS Reset 是革命党，CSS Reset 里最激进那一派提倡不管你小子有用没用，通通给我脱了那身衣服，凭什么你 body 出生就穿一圈 margin，凭什么你姓 h 的比别人吃得胖，凭什么你 ul 戴一胳膊珠子。于是 *{margin:0;} 等等运动，把人家全拍扁了。看似是众生平等了，实则是浪费了资源又占不到便宜，有求于人家的时候还得贱贱地给加回去，实在需要人家的默认样式了怎么办？人家锅都扔炉子里烧了，自己看着办吧。</p>\n</blockquote>\n<p>所以，normalize.css 的产生是有一定历史原因的（css reset 的滥用），normalize.css 是<a href=\"https://twitter.com/necolas\" target=\"_blank\" rel=\"noopener\">@necolas</a>和<a href=\"https://twitter.com/jon_neal\" target=\"_blank\" rel=\"noopener\">@jon_neal</a> 两位大牛花了几百个小时来研究不同浏览器的默认样式的差异而得出的结晶，感谢前辈们的贡献。 关于 normalize.css 的更多内容，就不在本篇文章里过多赘述了，因为它不是主角啊！有兴趣的童鞋可以点击下面的链接查看：</p>\n<ul>\n<li><a href=\"https://github.com/necolas/normalize.css/\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li><a href=\"http://nicolasgallagher.com/about-normalize-css/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></li>\n<li><a href=\"http://jerryzou.com/posts/aboutNormalizeCss/\" target=\"_blank\" rel=\"noopener\">官方介绍（中文）</a></li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最后引用张鑫旭文章中的一段话作为结束：</p>\n<blockquote>\n<p>武侠的最高境界是什么？ – 无招胜有招 设计的最高境界是什么？ – 减少设计 所以，最少的 CSS 代码，最少的渲染，最少的重置就是最好的CSS样式代码，这反应了您的 CSS 层次。说句不好听的话，CSS reset 是用来让那些 CSS 菜鸟，对 CSS 不太了解的人准备的。</p>\n</blockquote>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000003021766\" target=\"_blank\" rel=\"noopener\">关于CSS Reset 那些事（一）之 历史演变与Normalize.css</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2010/07/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BD%91%E7%AB%99css%E8%BF%9B%E8%A1%8C%E6%9E%B6%E6%9E%84%E7%9A%84/\" target=\"_blank\" rel=\"noopener\">我是如何对网站CSS进行架构的</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2010/04/css-reset%E7%9A%84%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86-%E9%81%BF%E5%85%8D%E6%A0%B7%E5%BC%8F%E9%87%8D%E7%BD%AE/\" target=\"_blank\" rel=\"noopener\">CSS reset的重新审视 – 避免样式重置</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2010/08/html5-css-reset/\" target=\"_blank\" rel=\"noopener\">HTML5 css reset</a></li>\n<li><a href=\"http://www.jianshu.com/p/69ba47248774\" target=\"_blank\" rel=\"noopener\">CSS:认识 css reset</a></li>\n</ul>\n","raw":null,"categories":[{"name":"summary","path":"api/categories/summary.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"性能优化","path":"api/tags/性能优化.json"}]},{"title":"JS 中的浅拷贝和深拷贝","slug":"JS中的浅拷贝和深拷贝","date":"2017-07-30T10:17:35.000Z","updated":"2019-01-27T10:07:12.320Z","comments":true,"path":"api/articles/JS中的浅拷贝和深拷贝.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"浅拷贝-VS-深拷贝\"><a href=\"#浅拷贝-VS-深拷贝\" class=\"headerlink\" title=\"浅拷贝 VS 深拷贝\"></a>浅拷贝 VS 深拷贝</h2><p>浅拷贝和深拷贝也成为<strong>浅复制</strong>和<strong>深复制</strong>，是在很多编程语言中经常用到的方法。另外，本文只会涉及到 js 中<strong>复杂数据类型</strong>的拷贝问题（Object, Array 等），不讨论基本数据类型（null, undefined, string, number 和 boolean），因为基本数据类型不存在引用值的情况。浅拷贝和深拷贝都可以实现在已有对象的基础上再生一份的作用，但是对象的实例是存储在堆内存中然后通过一个<strong>引用值</strong>去操作对象，由此拷贝的时候就存在两种情况了：<strong>拷贝引用和拷贝实例</strong>，这也是浅拷贝和深拷贝的区别所在：浅拷贝：只会将对象的各个属性进行依次复制，<strong>并不会进行递归复制</strong>，而JS中存储对象都是存地址的，所以浅拷贝会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址 深拷贝：不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法<strong>递归复制</strong>到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。 </p>\n<p>NOTE：如果对象比较大，层级也比较多，<strong>深拷贝会带来性能上的问题</strong>。在遇到需要采用深拷贝的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅拷贝更为常用。</p>\n<h2 id=\"浅拷贝的实现方式\"><a href=\"#浅拷贝的实现方式\" class=\"headerlink\" title=\"浅拷贝的实现方式\"></a>浅拷贝的实现方式</h2><p>从以上的对比可以总结出：浅拷贝就是简单的<strong>引用复制</strong>，有以下几种实现方式：</p>\n<h3 id=\"jQuery-extend-false-…\"><a href=\"#jQuery-extend-false-…\" class=\"headerlink\" title=\"jQuery.extend(false,…)\"></a>jQuery.extend(false,…)</h3><p>jQuery.extend 的第一个参数可以是布尔值，用来设置是否深度拷贝，设置为 false 或设置为空时就可以实现浅拷贝</p>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><p>ES6 中的 Object.assign(…) 方法可用来实现浅拷贝–它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到目标对象，最后返回目标对象。</p>\n<p>NOTE：这里<a href=\"https://stackoverflow.com/questions/38345937/object-assign-vs-extend\" target=\"_blank\" rel=\"noopener\">有一篇stackoverflow的文章</a>，是关于jQuery.extend()和Object.assign()区别的，当然你也可以直接点击<a href=\"https://jsfiddle.net/on9x55ow/2/\" target=\"_blank\" rel=\"noopener\">这里</a>通过实例比较两者区别</p>\n<h3 id=\"Underscore-的-clone\"><a href=\"#Underscore-的-clone\" class=\"headerlink\" title=\"Underscore 的 _.clone()\"></a>Underscore 的 _.clone()</h3><p>在 Underscore 中有这样一个方法：<code>_.clone()</code>，这个方法实际上是一种浅拷贝，所有嵌套的对象和数组都是直接复制引用，但是它比直接赋值来得“深”一些，因为它创建了一个新的对象，可以看下面例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: &#123; <span class=\"attr\">z</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = _.clone(x);</span><br><span class=\"line\"></span><br><span class=\"line\">y === x       <span class=\"comment\">// false</span></span><br><span class=\"line\">y.b === x.b   <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">x.b.z = <span class=\"number\">100</span>;</span><br><span class=\"line\">y.b.z         <span class=\"comment\">// 100</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-的-slice-和-concat\"><a href=\"#Array-的-slice-和-concat\" class=\"headerlink\" title=\"Array 的 slice 和 concat\"></a>Array 的 slice 和 concat</h3><p>Array 的 slice 和 concat 方法都会<strong>返回一个新的数组实例</strong>，但是这两个方法对于数组中的对象元素却没有执行深拷贝，而只是复制了引用。（和上面的 _.clone() 类似）</p>\n<h3 id=\"for…in…\"><a href=\"#for…in…\" class=\"headerlink\" title=\"for…in…\"></a>for…in…</h3><p>利用 for…in… 遍历对象就可以实现浅拷贝，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowCopy</span>(<span class=\"params\">p,c</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i;</span><br><span class=\"line\">    c = c||&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i <span class=\"keyword\">in</span> p)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.hasOwnProperty(i))&#123;</span><br><span class=\"line\">            c\\[i\\] = p\\[i\\];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"深拷贝的实现方式\"><a href=\"#深拷贝的实现方式\" class=\"headerlink\" title=\"深拷贝的实现方式\"></a>深拷贝的实现方式</h2><p>浅拷贝的实现方式如上所述，浅拷贝适合用在开发 jQuery 插件或者 redux 中返回 new state，而我们有时需要的是深拷贝，就是<strong>保证拷贝的对象与源对象完全隔离</strong>：</p>\n<h3 id=\"jQuery-extend-true-…\"><a href=\"#jQuery-extend-true-…\" class=\"headerlink\" title=\"jQuery.extend(true,…)\"></a>jQuery.extend(true,…)</h3><p>将 jQuery.extend 的第一个参数设置为 true 即可实现深度拷贝。但是缺点是<strong>无法深拷贝 JSON 对象以外的对象</strong></p>\n<p>NOTE：jQuery 中有一个叫做 $.clone() 的方法，可是它并不是用于一般的 JS 对象的拷贝，而是用于 DOM 对象的克隆，所以不要被它的名字骗到~</p>\n<h3 id=\"借助-JSON-全局对象\"><a href=\"#借助-JSON-全局对象\" class=\"headerlink\" title=\"借助 JSON 全局对象\"></a>借助 JSON 全局对象</h3><p>相比于使用插件，使用 JSON 全局对象的 <code>parse</code> 和 <code>stringify</code> 方法来实现深复制也算是一个简单讨巧的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> clone = jsonClone(&#123; <span class=\"attr\">a</span>:<span class=\"number\">1</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>然而这种方法<strong>有一些隐藏的坑</strong>：</p>\n<ul>\n<li>只能处理能够被json直接表示的数据结构：Number, String, Boolean, Array, 扁平对象；而对于正则表达式、Date 和 Function这种特殊的 Object 就无能为力了</li>\n<li>如果对象中存在循环引用的情况，这个方法也无法正确处理</li>\n</ul>\n<h3 id=\"lodash-的-clone-cloneDeep\"><a href=\"#lodash-的-clone-cloneDeep\" class=\"headerlink\" title=\"lodash 的 _.clone() / _.cloneDeep()\"></a>lodash 的 _.clone() / _.cloneDeep()</h3><p>在 lodash 中关于复制的方法有两个，分别是 <code>_.clone()</code> 和 <code>_.cloneDeep()</code>。其中 <code>_.clone(obj, true)</code> 等价于 <code>_.cloneDeep(obj)</code>。看了源码会发现，lodash 中与深拷贝相关的代码有上百行，而 jQuery 却只有 60 多行，这是为什么呢？原因是 lodash 花了大量的代码来实现 ES6 引入的大量新的标准对象。更厉害的是，lodash 针对<strong>存在环的对象</strong>的处理也是非常出色的。 所以，loadsh 在深拷贝上下了很多功夫，是一个很完美同时更拥抱未来的一个第三方库</p>\n<h2 id=\"各个深拷贝方法的比较\"><a href=\"#各个深拷贝方法的比较\" class=\"headerlink\" title=\"各个深拷贝方法的比较\"></a>各个深拷贝方法的比较</h2><p><a href=\"https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074\" target=\"_blank\" rel=\"noopener\">stackoverflow 上有一个提问</a>，讨论了 JS 中各个深拷贝方法的效率问题，然后有位大牛借助 jsben 对各个深拷贝方法进行了<a href=\"http://jsben.ch/bWfk9\" target=\"_blank\" rel=\"noopener\">实例测试</a>，强烈推荐大家看一下这个提问下的讨论以及实例测试的结果，相信看完后你对 JS 中的深拷贝会有更深刻的理解~</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/tracylin/p/5346314.html\" target=\"_blank\" rel=\"noopener\">也来谈一谈js的浅复制和深复制</a></li>\n<li><a href=\"https://www.zhihu.com/question/23031215\" target=\"_blank\" rel=\"noopener\">javascript中的深拷贝和浅拷贝？</a></li>\n<li><a href=\"http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/\" target=\"_blank\" rel=\"noopener\">深入剖析 JavaScript 的深复制</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]},{"title":"Mac下用Cron定时任务更新壁纸","slug":"Mac下用Cron定时任务更新壁纸","date":"2017-07-26T07:08:17.000Z","updated":"2019-01-27T10:07:12.320Z","comments":true,"path":"api/articles/Mac下用Cron定时任务更新壁纸.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这个技巧的原文来自<a href=\"https://www.macosxautomation.com/automator/apod/index.html\" target=\"_blank\" rel=\"noopener\">Set Desktop to NASA Astronomy Picture of the Day</a>，作者通过 Automator 脚本可以每天自动去 NASA（美国宇航局）下载“每日一图”，同时将其设置为桌面。是不是听起来很酷！当然了，我第一次看到的并不是上面那篇文章，而是另一位大神（harttle）的<a href=\"http://harttle.com/2015/11/20/crontab-desktop.html\" target=\"_blank\" rel=\"noopener\">用Cron定时任务更新壁纸</a>，harttle 并没有用 Automator 方式，而是通过 Cron 定时任务实现了这个功能。美中不足的是，harttle 是 Linux 系统，然后我就在自己的 Mac 上试了一下，下面就跟着我一起来实现一把吧！</p>\n<h2 id=\"下载壁纸的脚本\"><a href=\"#下载壁纸的脚本\" class=\"headerlink\" title=\"下载壁纸的脚本\"></a>下载壁纸的脚本</h2><p>首先，我们需要完成一个下载壁纸的脚本，在 Mac 环境下就是 shell 脚本了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/local/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载HTML到/tmp</span></span><br><span class=\"line\">base=<span class=\"string\">'http://apod.nasa.gov/apod/'</span></span><br><span class=\"line\">wget -O /tmp/nasa <span class=\"variable\">$&#123;base&#125;</span>astropix.html</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到其中的&lt;img&gt;标签的src参数</span></span><br><span class=\"line\">href=<span class=\"variable\">$&#123;base&#125;</span>\\`cat /tmp/nasa | grep -i <span class=\"string\">'&lt;img'</span> | awk -F <span class=\"string\">'\"'</span> <span class=\"string\">'&#123;print $2&#125;'</span>\\`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算src的文件后缀</span></span><br><span class=\"line\">ext=<span class=\"variable\">$&#123;href##*.&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算保存到的文件地址</span></span><br><span class=\"line\">file=/Users/\bYourMacName/Pictures/nasa/\\`date +<span class=\"string\">\"%Y-%m-%d\"</span>\\`.<span class=\"variable\">$ext</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载img</span></span><br><span class=\"line\">wget -O <span class=\"variable\">$file</span> <span class=\"variable\">$href</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不能完全复制粘贴上面的代码，需要注意将 <code>YourMacName</code> 换成你的真实文件夹名</li>\n<li>需要提前安装 wget，可以通过 brew install wget 安装</li>\n<li>需要将脚本保存到 /usr/local/bin 这个目录下，命名就随便了，可以取名为 nasa-pic-of-day.sh，运行一下，如果在 /Users/\bYourMacName/Pictures/nasa/ 下有一张图片那说明这一步已经成功了！</li>\n</ul>\n<h2 id=\"Cron-定时任务\"><a href=\"#Cron-定时任务\" class=\"headerlink\" title=\"Cron 定时任务\"></a>Cron 定时任务</h2><p>Cron 是 Unix 系统中用于周期执行任务的守护进程，被定时的任务由 crontab 文件提供。我们来写一个自己的 crontab 文件，保存为 ~/bin/daily.cron：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHELL=/usr/<span class=\"built_in\">local</span>/bin/bash</span><br><span class=\"line\">30 8 * * * /usr/<span class=\"built_in\">local</span>/bin/nasa-pic-of-day.sh &gt;&gt; /usr/<span class=\"built_in\">local</span>/var/frontend/cron 2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<p>其中 30 表示分钟，6 表示小时，后面的依次是日、月、星期。同时将输出重定向到 /var/harttle/cron（当然你需要确保这个目录存在）。2&gt;&amp;1 是将错误输出重定向至标准输出，这样我们的日志中将会同时包含标准输出和错误输出。 然后通过 crontab 命令载入我们的这个文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab /usr/<span class=\"built_in\">local</span>/bin/daily.cron</span><br></pre></td></tr></table></figure>\n<p>此后呢，我们的脚本就会在每天早上 8:30 执行。如果有问题我们可以查看日志文件 /usr/local/var/YourMacName/cron，这里有脚本的一切输出。</p>\n<h2 id=\"编辑-crontab\"><a href=\"#编辑-crontab\" class=\"headerlink\" title=\"编辑 crontab\"></a>编辑 crontab</h2><p>crontab 会把刚才载入的文件保存起来，以后我们可以通过 <code>crontab -e</code> 直接更改它（注意更改原文件是不起作用的）。在 Mac 上保存更改时会有错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab: temp file must be edited <span class=\"keyword\">in</span> place</span><br></pre></td></tr></table></figure>\n<p>可以在 ~/.vimrc 后面加一行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">autocmd filetype crontab setlocal nobackup nowritebackup</span><br></pre></td></tr></table></figure>\n<h2 id=\"Cron-运行环境\"><a href=\"#Cron-运行环境\" class=\"headerlink\" title=\"Cron 运行环境\"></a>Cron 运行环境</h2><p>Cron 运行脚本的环境和交互式 Shell 是不一样的，这一点需要注意。你的脚本可以在交互式 Shell 中正常运行，但 Cron 中可能会有错误。</p>\n<blockquote>\n<p>Cron always runs with a mostly empty environment. HOME, LOGNAME, and SHELL are set; and a very limited PATH.</p>\n</blockquote>\n<p>推荐的做法是在 Cron 运行的脚本中显式地声明那些环境变量：<code>source ~/.bashrc</code>，来手动设置需要的环境。比如在 Mac 上，你可能会需要这一项设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"tool","path":"api/categories/tool.json"}],"tags":[{"name":"Mac","path":"api/tags/Mac.json"}]},{"title":"读书笔记系列（8）——CSS Secrets","slug":"读书笔记系列（8）——CSS Secrets","date":"2017-07-06T10:21:45.000Z","updated":"2019-01-27T10:07:12.328Z","comments":true,"path":"api/articles/读书笔记系列（8）——CSS Secrets.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_248.png","content":"<p>这本书被誉为近十年来最出色的一本 CSS 相关书籍，作者是被誉为 “CSS一姐” 的 Lea Verou，是 W3C CSS 工作组特邀专家，而我看的是这本书的译本（翻译为 CSS 揭秘），作者叫张鹏，是百姓网的前端架构师；译者翻译的不错，同时还加入了自己的注解，如果对这本书有任何疑问，可以<a href=\"http://book.cssmagic.net\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看译者的注解。作者通过示例介绍了 CSS 的 47 个技巧，并将其归类至 7 大类中，由于这本书的绝大部分内容都是很值得学习的，所以关于这本书的读书笔记可能会比较长，强烈推荐你认真阅读一下这本书，是一本不可多得的 CSS 进阶教材。</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h3 id=\"currentColor\"><a href=\"#currentColor\" class=\"headerlink\" title=\"currentColor\"></a>currentColor</h3><p>这是一个特殊的颜色关键字，它是 CSS 中有史以来的第一个变量，举个例子，加入我们想让所有的水平分割线（所有 <code>&lt;hr&gt;</code> 元素）自动与文本的颜色一致，可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">hr</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: .<span class=\"number\">5em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: currentColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>currentColor 其实不仅仅可以用到 background 属性，还可以用在 border-color、outline-color、text-shadow 和 box-shadow 等等</p>\n<h3 id=\"避免不必要的媒体查询\"><a href=\"#避免不必要的媒体查询\" class=\"headerlink\" title=\"避免不必要的媒体查询\"></a>避免不必要的媒体查询</h3><ul>\n<li>使用百分比长度来取代固定长度，如果实在做不到这一点，也应该尝试使用与视口相关的单位（vw、vh、vmin  和vmax）</li>\n<li>当你需要在较大分辨率下得到固定宽度时，使用 max-width 而不是 width，因为它可以适应较小的分辨率，而无需使用媒体查询。</li>\n<li>不要忘记为替换元素(比如 img、object、video、iframe 等)设置一个 max-width，值为 100%。</li>\n<li>假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化，background-size: cover 这个属性都可以做到。但是，我们也要时刻牢记——带宽并不是无限的，因此在移动网页中通过 CSS 把一张大图缩小显示往往是不太明智的。</li>\n<li>当图片(或其他元素)以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局(即 Flexbox)或者 display: inline-block 加上常规的文本折行行为，都可以实现这一点。</li>\n<li>在使用多列文本时，指定 column-width(列宽)而不是指定 column-count(列数)，这样它就可以在较小的屏幕上自动显示为单列布局。</li>\n</ul>\n<h3 id=\"合理使用简写\"><a href=\"#合理使用简写\" class=\"headerlink\" title=\"合理使用简写\"></a>合理使用简写</h3><p>以下两行 CSS 代码并不是等价的：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">rebeccapurple</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-color</span>: <span class=\"selector-tag\">rebeccapurple</span>;</span><br></pre></td></tr></table></figure>\n<p>前者是简写，它可以确保你得到 rebeccapurple 纯色背景 但是如果你用的是展开式的单个属性（background-color），那这个元素的背景最终有可能会显示为一个粉色的渐变图案、一张猫的图片或其他任何东西，因为同时可能会有一条 background-image 声明在起作用。所以展开式属性并不会帮助你清空所有相关的其他属性，从而有可能会被其他属性所干扰。</p>\n<h3 id=\"预处理器不是完美无缺的\"><a href=\"#预处理器不是完美无缺的\" class=\"headerlink\" title=\"预处理器不是完美无缺的\"></a>预处理器不是完美无缺的</h3><ul>\n<li>CSS 的<strong>文件体积</strong>和<strong>复杂度</strong>可能会失控</li>\n<li><strong>调试难度</strong>会增加（但是 SourceMap 正是为了解决这个痛点而生的，它会告诉浏览器哪些编译生成的 CSS 代码对应哪些预处理器 CSS 代码，精确到行号）</li>\n<li>预处理器在开发过程中引入了一定程度的<strong>延时</strong></li>\n<li><strong>学习成本</strong>变高</li>\n<li>预处理器是由人类写出来的，就像所有由 人类写出来的大型程序一样，<strong>它们有它们自己的 bug</strong></li>\n</ul>\n<h3 id=\"预处理器中不可能做到的变量玩法\"><a href=\"#预处理器中不可能做到的变量玩法\" class=\"headerlink\" title=\"预处理器中不可能做到的变量玩法\"></a>预处理器中不可能做到的变量玩法</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> &#123; <span class=\"attribute\">--accent-color</span>: purple; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ol</span> &#123; <span class=\"attribute\">--accent-color</span>: rebeccapurple; &#125; </span><br><span class=\"line\"><span class=\"selector-tag\">li</span> &#123; <span class=\"attribute\">background</span>: <span class=\"built_in\">var</span>(--accent-color); &#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码的意图是：在有序列表中，列表项的背景色将是 rebeccapurple；但在无序列表中，列表项的背景色将是 purple</p>\n<h2 id=\"背景与边框\"><a href=\"#背景与边框\" class=\"headerlink\" title=\"背景与边框\"></a>背景与边框</h2><h3 id=\"半透明边框\"><a href=\"#半透明边框\" class=\"headerlink\" title=\"半透明边框\"></a>半透明边框</h3><p>假设我们想给一个容器设置一层白色背景和一道半透明白色边框，body 的背景会从它的半透明边框透上来。我们最开始的尝试可能是这样的:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border</span>: 10<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.5</span>); </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">white</span>;</span><br></pre></td></tr></table></figure>\n<p>但实际上，上面这段代码让 body 的背景从半透明白色边框处透了上来，这实际上得到的效果跟纯白实色的边框看起来完全一样。 所以我们可以通过 background-clip 属性来调整上述默认行为所带来的不便，这个属性的初始值是 border-box，意味着背景会被元素的 border box(边框的外沿框)裁切掉。如果不希望背景侵入边框所在的范围，我们要做的就是把它的值设为 padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border</span>: 10<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.5</span>); </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">white</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-clip</span>: <span class=\"selector-tag\">padding-box</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多重边框\"><a href=\"#多重边框\" class=\"headerlink\" title=\"多重边框\"></a>多重边框</h3><h4 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h4><p>box-shadow 还接受第四个参数（称作”扩张半径”），通过指定正值或负值，可以让投影面积加大或者减小。一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的“投影”其实就像一道实线边框。这并没有什么了不起的，因为你完全可以用 border 属性来生成完全一样的边框效果。不过 box-shadow 的好处在于，<strong>它支持逗号分隔语法，我们可以创建任意数量的投影</strong>，但是多重投影方案有一些注意事项： 投影不会影响布局，也不会受到 box-sizing 属性的影响。不过，你可以通过<strong>内边距或外边距</strong>(这取决于投影是内嵌和还是外扩的)来额外模拟出边框所需要占据的空间。 通过 box-shadow 创建出的假”边框’出现在元素的外圈，它们并不会响应鼠标事件，比如悬停或点击。可以通过给 box-shadow 加上 inset 关键字，来使投影绘制在元素的内圈，此时还需要额外的内边距来腾出足够的空隙</p>\n<h4 id=\"ouline\"><a href=\"#ouline\" class=\"headerlink\" title=\"ouline\"></a>ouline</h4><p>在某些情况下，你可能只需要两层边框，那就可以先设置一层常规边框，再加上 outline(描边)属性来产生外层的边框。这种方法的优点在于边框样式十分灵活（box-shadow 无法产生虚线边框），而且可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，但是同样有一些需要注意的地方：</p>\n<ul>\n<li>只适用于双层”边框”的场景，因为 outline 不接受逗号</li>\n<li>outline 产生的边框不一定会贴合 border-radius 产生的圆角</li>\n<li>对于 outline 的表现，各个浏览器可能会有所不同，最好在不同浏览器中完整地测试最终效果</li>\n</ul>\n<h3 id=\"灵活的背景定位\"><a href=\"#灵活的背景定位\" class=\"headerlink\" title=\"灵活的背景定位\"></a>灵活的背景定位</h3><h4 id=\"background-position\"><a href=\"#background-position\" class=\"headerlink\" title=\"background-position\"></a>background-position</h4><p>background-position 允许我们指定背景图片距离任意角的偏移量，只要我们在偏移量前面指定关键字：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">url</span>(<span class=\"selector-tag\">code-pirate</span><span class=\"selector-class\">.svg</span>) <span class=\"selector-tag\">no-repeat</span> <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: <span class=\"selector-tag\">right</span> 20<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">bottom</span> 10<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h4><p>背景图片的 background-position 属性是默认相对于 padding box 的左上角的，但是 background-origin 可以改变这种行为：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding</span>: 10<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">url</span>(\"<span class=\"selector-tag\">code-pirate</span><span class=\"selector-class\">.svg</span>\") <span class=\"selector-tag\">no-repeat</span> <span class=\"selector-id\">#58abottom</span> <span class=\"selector-tag\">right</span>; <span class=\"comment\">/* 或 100% 100% */</span> </span><br><span class=\"line\"><span class=\"selector-tag\">background-origin</span>: <span class=\"selector-tag\">content-box</span>;</span><br></pre></td></tr></table></figure>\n<p>此时，background-position 将以内容区的边缘作为基准，也就是此时图片距离边角的偏移量就跟内边距保持一致了</p>\n<h4 id=\"calc\"><a href=\"#calc\" class=\"headerlink\" title=\"calc\"></a>calc</h4><p>把背景图片定位到距离底边 10px 且距离右边 20px 的位置。如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个 100% - 20px 的水平偏移量，以及 100% - 10px 的垂直偏移量。calc() 函数可以完美地在 background-position 属性中使用：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">url</span>(\"<span class=\"selector-tag\">code-pirate</span><span class=\"selector-class\">.svg</span>\") <span class=\"selector-tag\">no-repeat</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>) <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 10<span class=\"selector-tag\">px</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"边框内圆角\"><a href=\"#边框内圆角\" class=\"headerlink\" title=\"边框内圆角\"></a>边框内圆角</h3><p>有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状，如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_248.png\" alt=\"\" width=\"400\"></div>\n\n<p>如果只需要达成简单地实色效果，我们可以只用一个元素：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">tan</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">border-radius</span>: <span class=\"selector-class\">.8em</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">padding</span>: 1<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 0 0 0 <span class=\"selector-class\">.6em</span> <span class=\"selector-id\">#655</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">outline</span>: <span class=\"selector-class\">.6em</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#655</span>;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码产生的视觉效果如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_249.png\" alt=\"\" width=\"\"></div>\n\n<p>我们受益于两个事实：<strong>描边并不会跟着元素的圆角走(因而显示出直角)，但 box-shadow 却是会的</strong>。因此，如果我们把这两者叠加到一起，box-shadow 会刚好填补描边和容器圆角之间的空隙，这两者的组合达成了我们想要的效果。</p>\n<h3 id=\"条纹背景\"><a href=\"#条纹背景\" class=\"headerlink\" title=\"条纹背景\"></a>条纹背景</h3><p>假如我们有一条基本的垂直现行渐变，颜色从 #fb3 过渡到 #58a：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 20%, <span class=\"selector-id\">#58a</span> 80%);</span><br></pre></td></tr></table></figure>\n<h4 id=\"水平条纹\"><a href=\"#水平条纹\" class=\"headerlink\" title=\"水平条纹\"></a>水平条纹</h4><p>现在容器顶部的 20% 区域被填充为 #fb3 实色，而底部 20% 区域被 填充为 #58a 实色。真正的渐变只出现在容器 60% 的高度区域。如果我们把两个色标重合在一起（改为 50% 和 50%）， 会发生什么?</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 50%, <span class=\"selector-id\">#58a</span> 50%);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_250.png\" alt=\"\" width=\"\"></div>\n\n<p>所以，本质上，我们通过垂直线性渐变创建了两条巨大的水平条纹 我们还可以通过 background-size 来调整其尺寸，然后由于背景在默认情况下是重复平铺的，整个容器其实已经被填满了水平条纹：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 50%, <span class=\"selector-id\">#58a</span> 50%); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_251.png\" alt=\"\" width=\"\"></div>\n\n<p>还有一条规范是：如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。这意味着，如果我们把第二个色标的位置值设置为 0，那它的位置就总是会被浏览器调整为前一个色标的位置值：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 30%, <span class=\"selector-id\">#58a</span> 0); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<p>如果要创建超过两种颜色的条纹，也是很容易的。举例来说，下面的代码可以生成三种颜色的水平条纹：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-id\">#fb3</span> 33<span class=\"selector-class\">.3</span>%,<span class=\"selector-id\">#58a</span> 0, <span class=\"selector-id\">#58a</span> 66<span class=\"selector-class\">.6</span>%, <span class=\"selector-tag\">yellowgreen</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 45<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"垂直条纹\"><a href=\"#垂直条纹\" class=\"headerlink\" title=\"垂直条纹\"></a>垂直条纹</h4><p>我们只需要在开头加上一个额外的参数来指定渐变的方向（但是我们还需要把 background-size 的值颠倒一下）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">to</span> <span class=\"selector-tag\">right</span>, <span class=\"comment\">/* 或 90deg */</span> <span class=\"selector-id\">#fb3</span> 50%, <span class=\"selector-id\">#58a</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 30<span class=\"selector-tag\">px</span> 100%;</span><br></pre></td></tr></table></figure>\n<h4 id=\"斜向条纹\"><a href=\"#斜向条纹\" class=\"headerlink\" title=\"斜向条纹\"></a>斜向条纹</h4><p>我们需要用单个贴片包包含四条条纹，而不是两条，只有这样才可能做到无缝拼接：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_252.png\" alt=\"\" width=\"\"></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>,<span class=\"selector-id\">#fb3</span> 25%, <span class=\"selector-id\">#58a</span> 0, <span class=\"selector-id\">#58a</span> 50%,<span class=\"selector-id\">#fb3</span> 0, <span class=\"selector-id\">#fb3</span> 75%, <span class=\"selector-id\">#58a</span> 0); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 30<span class=\"selector-tag\">px</span> 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<p>但是，如果我们想得到条纹宽度为 15px 的背景，则需要借助<strong>勾股定理</strong>进行计算，具体原理就不在赘述，看上面图应该能看出来</p>\n<h4 id=\"更好的斜向条纹\"><a href=\"#更好的斜向条纹\" class=\"headerlink\" title=\"更好的斜向条纹\"></a>更好的斜向条纹</h4><p>一个鲜为人知的真相是 linear-gradient() 和 radial-gradient() 还各有一个循环式的加强版：repeating-linear-gradient() 和 repeating-radial-gradient()。 它们的工作方式跟前两者类似，只有一点不同：<strong>色标是无限循环重复的，直到填满整个背景</strong>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">repeating-linear-gradient</span>(60<span class=\"selector-tag\">deg</span>,<span class=\"selector-id\">#fb3</span>, <span class=\"selector-id\">#fb3</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0, <span class=\"selector-id\">#58a</span> 30<span class=\"selector-tag\">px</span>);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_253.png\" alt=\"\" width=\"\"></div>\n\n<p>在这个方法中，不论条纹的角度如何，我们在创建双色条纹时都需要用到四个色标</p>\n<h4 id=\"灵活的同色系条纹\"><a href=\"#灵活的同色系条纹\" class=\"headerlink\" title=\"灵活的同色系条纹\"></a>灵活的同色系条纹</h4><p>如果我们想要的条纹图案并不是由差异极大的几种颜色组成的，而是属于同一色系，只是在明度方面有轻微差异的话，我们可以<strong>把最深的颜色指定为背景色，同时把半透明白色的条纹叠加在背景色之上来得到浅色条纹</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span>: <span class=\"selector-tag\">repeating-linear-gradient</span>(30<span class=\"selector-tag\">deg</span>,</span><br><span class=\"line\">                    <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.1</span>),</span><br><span class=\"line\">                    <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.1</span>) 15<span class=\"selector-tag\">px</span>,</span><br><span class=\"line\">                    <span class=\"selector-tag\">transparent</span> 0, <span class=\"selector-tag\">transparent</span> 30<span class=\"selector-tag\">px</span>);</span><br></pre></td></tr></table></figure>\n<p>我们现在只需要修改一个地方就可以改变所有颜色了。我们还得到了一个额外的好处，对于那些不支持 CSS 渐变的浏览器来说，这里的背景色还起到了回退的作用</p>\n<h3 id=\"复杂的背景图案\"><a href=\"#复杂的背景图案\" class=\"headerlink\" title=\"复杂的背景图案\"></a>复杂的背景图案</h3><h4 id=\"网格\"><a href=\"#网格\" class=\"headerlink\" title=\"网格\"></a>网格</h4><p>做法：<strong>把水平和垂直的条纹叠加起来</strong>；在某些情况下，我们希望网格中每个格子的大小可以调整，而网格线条的粗细同时保持固定。此时可以使用长度而不是百分比作为色标。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span><span class=\"selector-pseudo\">:linear-gradient(white</span> 1<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0),<span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">white</span> 1<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 30<span class=\"selector-tag\">px</span> 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"波点\"><a href=\"#波点\" class=\"headerlink\" title=\"波点\"></a>波点</h4><p>径向渐变能够创建的最简单的图案是圆点的阵列；我们可以生成两层圆点阵列图案，并把它们的背景定位错开，这样就可以得到真正的波点图案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background: #655;</span><br><span class=\"line\">background-image: radial-gradient(tan 30%, transparent 0),radial-gradient(tan 30%, transparent 0); </span><br><span class=\"line\">background-size: 30px 30px;</span><br><span class=\"line\">background-position: 0 0, 15px 15px;</span><br></pre></td></tr></table></figure>\n<h4 id=\"棋盘\"><a href=\"#棋盘\" class=\"headerlink\" title=\"棋盘\"></a>棋盘</h4><p>棋盘图案是可以通过平铺生成的，平铺成这个图案的典型贴片包含两种不同颜色的方块，且相互间隔，这里的窍门在于用两个直角三角形来拼合出我们想要的方块</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#eee</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#bbb</span> 25%, <span class=\"selector-tag\">transparent</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 75%, <span class=\"selector-id\">#bbb</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#bbb</span> 25%, <span class=\"selector-tag\">transparent</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 75%, <span class=\"selector-id\">#bbb</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 0 0, 15<span class=\"selector-tag\">px</span> 15<span class=\"selector-tag\">px</span>,15<span class=\"selector-tag\">px</span> 15<span class=\"selector-tag\">px</span>, 30<span class=\"selector-tag\">px</span> 30<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 30<span class=\"selector-tag\">px</span> 30<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CSS3图案库\"><a href=\"#CSS3图案库\" class=\"headerlink\" title=\"CSS3图案库\"></a>CSS3图案库</h4><p><a href=\"http://lea.verou.me/css3patterns/\" target=\"_blank\" rel=\"noopener\">lea.verou.me/css3patterns</a>，展示了 CSS 渐变早在 2011 年就能够实现的效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_254.png\" alt=\"\" width=\"\"></div>\n\n<h4 id=\"SVG图案库\"><a href=\"#SVG图案库\" class=\"headerlink\" title=\"SVG图案库\"></a>SVG图案库</h4><p><a href=\"http://philbit.com/svgpatterns\" target=\"_blank\" rel=\"noopener\">philbit.com/svgpatterns</a>，这个网站是 CSS 图案库的 SVG 版实现</p>\n<h4 id=\"Bennett-Feely-的图案库\"><a href=\"#Bennett-Feely-的图案库\" class=\"headerlink\" title=\"Bennett Feely 的图案库\"></a>Bennett Feely 的图案库</h4><p><a href=\"http://bennettfeely.com/gradients\" target=\"_blank\" rel=\"noopener\">http://bennettfeely.com/gradients</a>，采用混合模式生成的 CSS 图案库</p>\n<h3 id=\"伪随机背景\"><a href=\"#伪随机背景\" class=\"headerlink\" title=\"伪随机背景\"></a>伪随机背景</h3><p>重现大自然的随机性是一个挑战，因为 CSS 本身没有提供任何随机功能。</p>\n<p>为了更真实地模拟条纹的随机性，我们接下来可能会想到，把这组条纹从一个平面拆散为多个图层:一种颜色作为底色，另三种颜色作为条纹，然后再让条纹以不同的间隔进行重复平铺：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">hsl</span>(20, 40%, 90%); </span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#fb3</span> 10<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#ab4</span> 20<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0),</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-id\">#655</span> 20<span class=\"selector-tag\">px</span>, <span class=\"selector-tag\">transparent</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 80<span class=\"selector-tag\">px</span> 100%, 60<span class=\"selector-tag\">px</span> 100%, 40<span class=\"selector-tag\">px</span> 100%;</span><br></pre></td></tr></table></figure>\n<p>但是我们很容易发现：<strong>各层背景图像以不同间距重复数次后再次统一对齐，而贴片的尺寸实际上就是所有 background-size 的最小公倍数</strong>，而 40、60 和 80 的最小公倍数正是 240。 所以为了模拟随机，我们需要把贴片的尺寸最大化：<strong>为了让最小公倍数最大化，这些数字最好是“相对质数”。</strong>这个技巧被 Alex Walker 定名为“蝉原则”，他最先提出了通过质数来 增加随机真实性的想法。请注意这个方法不仅适用于背景，还可以用于其他 涉及有规律重复的情况：</p>\n<ul>\n<li>在照片图库中，为每幅图片应用细微的伪随机旋转效果时，可以使 用多个 :nth-child(a) 选择符，且让 a 是质数。</li>\n<li>如果要生成一个动画，而且想让它看起来不是按照明显的规律在 循环时，我们可以应用多个时长为质数的动画。</li>\n</ul>\n<h3 id=\"连续的图像边框\"><a href=\"#连续的图像边框\" class=\"headerlink\" title=\"连续的图像边框\"></a>连续的图像边框</h3><p>有时我们想把一幅图案或图片应用为边框，而不是背景，达到下面的展示效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_255.png\" alt=\"\" width=\"\"></div>\n\n<p>此时 border-image 是不可能做到的，因为它无法随着元素宽高和边框厚度的变化而变化。所以我们的思路是<strong>在石雕背景图片之上，再叠加一层纯白的实色背景</strong>。为了让下层的图片背景透过边框区域显示出来，我们需要给两层背景指定不同的 background-clip 值。最后一个要点在于，我们只能在多重背景的最底层设置背景色，因此需要用一道从白色过渡到白色的 CSS 渐变来模拟出纯白实色背景的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding</span>: 1<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border</span>: 1<span class=\"selector-tag\">em</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">white</span>, <span class=\"selector-tag\">white</span>),<span class=\"selector-tag\">url</span>(<span class=\"selector-tag\">stone-art</span><span class=\"selector-class\">.jpg</span>); </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: <span class=\"selector-tag\">cover</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-clip</span>: <span class=\"selector-tag\">padding-box</span>, <span class=\"selector-tag\">border-box</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-origin</span>: <span class=\"selector-tag\">border-box</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"老式信封样式的边框\"><a href=\"#老式信封样式的边框\" class=\"headerlink\" title=\"老式信封样式的边框\"></a><a href=\"http://play.csssecrets.io/vintage-envelope\" target=\"_blank\" rel=\"noopener\">老式信封样式的边框</a></h4><p>将上面的技巧用在渐变图案上：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding</span>: 1<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border</span>: 1<span class=\"selector-tag\">em</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">white</span>, <span class=\"selector-tag\">white</span>) <span class=\"selector-tag\">padding-box</span>,</span><br><span class=\"line\">            <span class=\"selector-tag\">repeating-linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>,</span><br><span class=\"line\">              <span class=\"selector-tag\">red</span> 0, <span class=\"selector-tag\">red</span> 12<span class=\"selector-class\">.5</span>%,</span><br><span class=\"line\">              <span class=\"selector-tag\">transparent</span> 0, <span class=\"selector-tag\">transparent</span> 25%,</span><br><span class=\"line\">              <span class=\"selector-id\">#58a</span> 0, <span class=\"selector-id\">#58a</span> 37<span class=\"selector-class\">.5</span>%,</span><br><span class=\"line\">              <span class=\"selector-tag\">transparent</span> 0, <span class=\"selector-tag\">transparent</span> 50%)</span><br><span class=\"line\">              0 / 5em 5em;</span><br></pre></td></tr></table></figure>\n<h4 id=\"蚂蚁行军边框\"><a href=\"#蚂蚁行军边框\" class=\"headerlink\" title=\"蚂蚁行军边框\"></a><a href=\"http://play.csssecrets.io/marching-ants\" target=\"_blank\" rel=\"noopener\">蚂蚁行军边框</a></h4><p>为了创建蚂蚁行军效果，我们将会用到“老式信封”技巧的一个变种。我们将把条纹转变为黑白两色，并把边框的宽度减少至 1px，然后再把 background-size 改为某个合适的值。最后，我们把 background-position 以动画的方式改变为 100%，就可以让它滚动起来了</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> ants &#123; <span class=\"selector-tag\">to</span> &#123; <span class=\"attribute\">background-position</span>: <span class=\"number\">100%</span> &#125; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.marching-ants</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent; <span class=\"attribute\">background</span>:</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(white, white) padding-box,</span><br><span class=\"line\">        <span class=\"built_in\">repeating-linear-gradient</span>(-45deg,</span><br><span class=\"line\">          black 0, black 25%, white 0, white 50%</span><br><span class=\"line\">        ) <span class=\"number\">0</span> / .<span class=\"number\">6em</span> .<span class=\"number\">6em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: ants <span class=\"number\">12s</span> linear infinite; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a><a href=\"http://play.csssecrets.io/footnote\" target=\"_blank\" rel=\"noopener\">脚注</a></h4><p>我们可以用 border-image 搭配渐变图案实现顶部边框被裁切的效果，就像一般的脚注那样，我们所需要的就是 border-image 属性再加上一条由渐变生成的垂直条纹，并把要裁切的长度在渐变中写好。边框线的粗细交给 border-width 来控制：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border-top</span>: <span class=\"selector-class\">.2em</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-image</span>: 100% 0 0 <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>,<span class=\"selector-tag\">currentColor</span> 4<span class=\"selector-tag\">em</span>,<span class=\"selector-tag\">transparent</span> 0);</span><br><span class=\"line\"><span class=\"selector-tag\">padding-top</span>: 1<span class=\"selector-tag\">em</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"形状\"><a href=\"#形状\" class=\"headerlink\" title=\"形状\"></a>形状</h2><h3 id=\"自适应的椭圆\"><a href=\"#自适应的椭圆\" class=\"headerlink\" title=\"自适应的椭圆\"></a>自适应的椭圆</h3><p>我们想要达到这样效果：<strong>如果宽高相等，就显示为一个圆；如果宽高不等，就显示为一个椭圆</strong> border-radius 可以单独指定水平和垂直半径，用一个斜杠（/）分隔这两个值即可；同时，它不仅可以接受长度值，还可以接受百分比值，这个百分比值会基于元素的尺寸进行解析。这意味着相同的百分比可能会计算出不同的水平和垂直半径，因此可以这样实现自适应椭圆：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border-radius</span>: 50%;</span><br></pre></td></tr></table></figure>\n<h3 id=\"半椭圆\"><a href=\"#半椭圆\" class=\"headerlink\" title=\"半椭圆\"></a>半椭圆</h3><div align=\"center\"><img src=\"/images/hexo_post_256.png\" alt=\"\" width=\"\"></div>\n\n<p>我们可以为四个角提供完全不同的水平和垂直半径，这意味着当 border-radius 的值为 10px / 5px 20px 时，其效果相当于 10px 10px 10px 10px / 5px 20px 5px 20px；所以我们很容易写出半椭圆的 CSS 代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50% / 100% 100% 0 0;</span><br></pre></td></tr></table></figure>\n<p>举一反三，沿纵轴劈开的半椭圆：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 100% 0 0 100% / 50%;</span><br></pre></td></tr></table></figure>\n<p>四分之一椭圆（其中一个角的水平和垂直半径值都需要是 100%，而其他三个角都不能设为圆角）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border-radius</span>: 100% 0 0 0;</span><br></pre></td></tr></table></figure>\n<p>但是很遗憾，<strong>border-radius 是无法生成八分之一椭圆，三分之一椭圆的</strong>！</p>\n<h3 id=\"平行四边形\"><a href=\"#平行四边形\" class=\"headerlink\" title=\"平行四边形\"></a>平行四边形</h3><p>我们可以通过 skew() 的变形属性来对某个矩形进行斜向拉伸，但是这回导致它的内容也发生了斜向变形。所以我们的思路是<strong>把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.button</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    /\\* 其他的文字颜色、内边距等样式...... */</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-class\">.button</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>; <span class=\"comment\">/* 用伪元素来生成一个矩形 */</span> </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: -<span class=\"number\">1</span>; <span class=\"comment\">/* 防止伪元素的背景遮住内容 */</span></span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#58a</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(45deg); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个技巧<strong>适用于其他任何变形样式</strong>，当我们想<strong>变形一个元素而不想变形它的内容</strong>时就很有用：</p>\n<ul>\n<li>可以用<a href=\"http://nicolasgallagher.com/multiple-backgrounds-and-borders-with-css2/\" target=\"_blank\" rel=\"noopener\">在IE下实现多重背景</a></li>\n<li>实现“边框内圆角”效果</li>\n<li>可以用来为某一层“背景”<a href=\"http://nicolasgallagher.com/css-background-image-hacks\" target=\"_blank\" rel=\"noopener\">单独设置类似opacity这样的属性</a></li>\n<li>模拟多层边框</li>\n</ul>\n<h3 id=\"菱形图片\"><a href=\"#菱形图片\" class=\"headerlink\" title=\"菱形图片\"></a><a href=\"http://play.csssecrets.io/diamond-clip\" target=\"_blank\" rel=\"noopener\">菱形图片</a></h3><p>主要思路是使用 clip-path 属性，它最大的缺陷在于其浏览器支持程度还很有限。但是，它可以平稳退化（只是没有裁切效果而已），因此它至少有资格成为我们的备选方案 我们将会使用 polygon()（多边形）函数来指定一个菱形。实际上，它允许我们用一系列（以逗号分隔的）坐标点来指定任意的多边形。我们甚至可以使用百分比值，它们会解析为元素自身的尺寸：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">clip-path</span>: <span class=\"selector-tag\">polygon</span>(50% 0, 100% 50%, 50% 100%, 0 50%);</span><br></pre></td></tr></table></figure>\n<p>clip-path 所能创造的奇迹还不止于此。这个属性甚至可以参与动画，只要我们的动画是在同一种形状函数(比如这里是 polygon())之间进行的，而且点的数量是相同的。因此，如果我们希望图片在鼠标悬停时平滑地扩展为完整的面积，只需要这样做：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">clip-path</span>: <span class=\"built_in\">polygon</span>(50% 0, 100% 50%, 50% 100%, 0 50%);</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: <span class=\"number\">1s</span> clip-path;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">img</span><span class=\"selector-pseudo\">:hover</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">clip-path</span>: <span class=\"built_in\">polygon</span>(0 0, 100% 0, 100% 100%,0 100%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MDN 关于 clip-path 的文档：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path</a></p>\n<h3 id=\"切角效果\"><a href=\"#切角效果\" class=\"headerlink\" title=\"切角效果\"></a>切角效果</h3><p>把角切掉不仅是为了省钱，它还是一种非常流行的设计风格，不论是在印刷媒介还是在网页设计中都是如此。</p>\n<h4 id=\"用渐变实现\"><a href=\"#用渐变实现\" class=\"headerlink\" title=\"用渐变实现\"></a>用渐变实现</h4><p>假设我们只需要一个角被切掉，以右下角为例，可以充分利用渐变的一大特性：渐变可以接受一个角度（比如 45deg）作为方向，而且色标的位置信息也可以是绝对的长度值，不受容器尺寸的影响；综上，我们需要一个线性渐变，把一个透明色标放在切角处，然后在相同位置设置另一个色标，并且把它的颜色设置为我们想要的背景色：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0);</span><br></pre></td></tr></table></figure>\n<p><strong>左下角和右下角都有切角效果</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">                <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">            <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">                <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 50% 100%; </span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">no-repeat</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>四个角都有切角效果</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(135<span class=\"selector-tag\">deg</span>,  <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">        <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">left</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-135deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">        <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">        <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0)</span><br><span class=\"line\">        <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 50% 50%;</span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">no-repeat</span>;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码的可维护性并不理想，使用<strong>预处理器的 mixin</strong> 可以帮助我们减少代码的重复度</p>\n<h4 id=\"弧形切角\"><a href=\"#弧形切角\" class=\"headerlink\" title=\"弧形切角\"></a>弧形切角</h4><p>很多人也把这种效果成为“内凹圆角”，因为它看起来就像是圆角的反向版本。唯一的区别在于，我们会用<strong>径向渐变</strong>来替代上述线性渐变：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_257.png\" alt=\"\" width=\"400\"></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">circle</span> <span class=\"selector-tag\">at</span> <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">left</span>,</span><br><span class=\"line\">             <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0) <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">left</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">circle</span> <span class=\"selector-tag\">at</span> <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">             <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0) <span class=\"selector-tag\">top</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">circle</span> <span class=\"selector-tag\">at</span> <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">             <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0) <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">right</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">circle</span> <span class=\"selector-tag\">at</span> <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>,</span><br><span class=\"line\">             <span class=\"selector-tag\">transparent</span> 15<span class=\"selector-tag\">px</span>, <span class=\"selector-id\">#58a</span> 0) <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 50% 50%; </span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">no-repeat</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"clip-path-实现切角\"><a href=\"#clip-path-实现切角\" class=\"headerlink\" title=\"clip-path 实现切角\"></a>clip-path 实现切角</h4><p>裁切路径最神奇的地方在于我们<strong>可以同时使用百分比数值（它会以元素自身的宽高作为基数度进行换算）和绝对长度值</strong>，从而提供巨大的灵活性。举个例子，如果用裁切路径将一个元素切出 20px 大小的斜面切角，代码如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">clip-path</span>: <span class=\"selector-tag\">polygon</span>(</span><br><span class=\"line\">    20<span class=\"selector-tag\">px</span> 0, <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>) 0, 100% 20<span class=\"selector-tag\">px</span>,</span><br><span class=\"line\">    100% <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>), <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>) 100%,</span><br><span class=\"line\">    20<span class=\"selector-tag\">px</span> 100%, 0 <span class=\"selector-tag\">calc</span>(100% <span class=\"selector-tag\">-</span> 20<span class=\"selector-tag\">px</span>), 0 20<span class=\"selector-tag\">px</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>但是它有一个很明显的缺点，就是<strong>当内边距不够宽时，它会裁切掉文本</strong>，因为它只能对元素做统一的裁切，并不能区分元素的各个部分</p>\n<h3 id=\"梯形标签页\"><a href=\"#梯形标签页\" class=\"headerlink\" title=\"梯形标签页\"></a><a href=\"http://play.csssecrets.io/trapezoid-tabs\" target=\"_blank\" rel=\"noopener\">梯形标签页</a></h3><p>一直以来，梯形都是众所周知难以用 CSS 生成的形状，网页开发者如果没有用精心设计的背景图片来实现梯形，那多半就是在用伪元素的边框来模拟梯形两侧的斜边，而我们的思路是通过 3D 变形，将矩形进行3D旋转，就可以创建一个梯形。但由于旋转之后，元素的尺寸会变小，同时会稍微下移，所以我们需要让其在3D空间旋转时固定底边（transform-origin），同时通过 scale() 方法改变它的尺寸：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scaleY</span>(1<span class=\"selector-class\">.3</span>) <span class=\"selector-tag\">perspective</span>(<span class=\"selector-class\">.5em</span>) <span class=\"selector-tag\">rotateX</span>(5<span class=\"selector-tag\">deg</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">transform-origin</span>: <span class=\"selector-tag\">bottom</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_258.png\" alt=\"\" width=\"\"></div>\n\n<p>同时，我们只需要把 transform-origin 改成 bottom left 或 bottom right，就可以立即得到左侧倾斜或右侧倾斜的标签页</p>\n<h3 id=\"简单的饼图\"><a href=\"#简单的饼图\" class=\"headerlink\" title=\"简单的饼图\"></a>简单的饼图</h3><p>我们可以通过渐变来将一个圆形的左右两半设置为不同的颜色，然后通过伪元素的旋转不同角度来实现不同角度的简单饼图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_259.png\" alt=\"\" width=\"\"></div>\n\n<p>由于已经找到了实现任意比率的方法，我们甚至可以用 CSS 动画来实现一个饼图从 0 变化到 100% 的动画，从而得到一个<a href=\"http://play.csssecrets.io/pie-animated\" target=\"_blank\" rel=\"noopener\">炫酷的进度指示器</a>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> spin &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123; <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(.5turn); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> bg &#123;</span><br><span class=\"line\">    50% &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#655</span>; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.pie</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">0</span> <span class=\"number\">100%</span> <span class=\"number\">100%</span> <span class=\"number\">0</span> / <span class=\"number\">50%</span>; </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: inherit; </span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: spin <span class=\"number\">3s</span> linear infinite, bg <span class=\"number\">6s</span> step-end infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们需要一个静态的任意比率的饼图，可以利用<strong>负的动画延时</strong>来直接跳至动画中的任意时间 点，并且定格在那里。举例来说，如果动画持续时间定为 6s，我们只需要把 animation-delay 设置为 -1.2s，就能显示出 20% 的比率。最终的效果：<a href=\"http://play.csssecrets.io/pie-static\" target=\"_blank\" rel=\"noopener\">play.csssecrets.io/pie-static</a> 我们还可以通过 SVG 实现简单的饼图，与伪元素相比，SVG 的方案具有不少优点：</p>\n<ul>\n<li>增加第三种颜色非常容易</li>\n<li>不需要特别担心打印，因为 SVG 元素本身被视为页面内容</li>\n<li>可以用内联样式指定颜色这意味着我们可以通过脚本控制颜色</li>\n</ul>\n<p>SVG 方案实现的效果：<a href=\"http://play.csssecrets.io/pie-svg\" target=\"_blank\" rel=\"noopener\">play.csssecrets.io/pie-svg</a></p>\n<h2 id=\"视觉效果\"><a href=\"#视觉效果\" class=\"headerlink\" title=\"视觉效果\"></a>视觉效果</h2><h3 id=\"单侧投影\"><a href=\"#单侧投影\" class=\"headerlink\" title=\"单侧投影\"></a><a href=\"http://play.csssecrets.io/shadow-one-side\" target=\"_blank\" rel=\"noopener\">单侧投影</a></h3><p>解决方案来自 box-shadow 鲜为人知的第四个长度参数，称作扩张半径。这个参数会根据你指定的值去扩大或 (当指定负值时)缩小投影的尺寸。举例来说，一个 -5px 的扩张半径会把投影的宽度和高度各减少 10px(即每边各  5px)。如果给投影应用一个正的垂直偏移量，我们就会在元素的底部看到一道投影，而元素的另外三侧是没有投影的：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 0 5<span class=\"selector-tag\">px</span> 4<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-4px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"邻边投影\"><a href=\"#邻边投影\" class=\"headerlink\" title=\"邻边投影\"></a><a href=\"http://play.csssecrets.io/shadow-2-sides\" target=\"_blank\" rel=\"noopener\">邻边投影</a></h4><p>把一个 black、6px 的投影设置到右侧和底部可以这样做：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 3<span class=\"selector-tag\">px</span> 3<span class=\"selector-tag\">px</span> 6<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-3px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双侧投影\"><a href=\"#双侧投影\" class=\"headerlink\" title=\"双侧投影\"></a><a href=\"http://play.csssecrets.io/shadow-opposite-sides\" target=\"_blank\" rel=\"noopener\">双侧投影</a></h4><p>唯一的办法是用两块投影（每边各一块）来达到目的：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 5<span class=\"selector-tag\">px</span> 0 5<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-5px</span> <span class=\"selector-tag\">black</span>, </span><br><span class=\"line\">            <span class=\"selector-tag\">-5px</span> 0 5<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-5px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不规则投影\"><a href=\"#不规则投影\" class=\"headerlink\" title=\"不规则投影\"></a>不规则投影</h3><p>当我们想给一个矩形或其他能用 border-radius 生成的形状加投影时，box-shadow 的表现都堪称完美。但是，当元素添加了一些伪元素或半透明的装饰之后，它就有些力不从心了，因为 border-radius 会无耻地忽视透明部分：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_260.png\" alt=\"\" width=\"\"></div>\n\n<p>我们的解决方案是利用 filter 的新属性来指定滤镜效果，比如上面的投影效果可以这样来写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">drop-shadow</span>(2<span class=\"selector-tag\">px</span> 2<span class=\"selector-tag\">px</span> 10<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.5</span>));</span><br></pre></td></tr></table></figure>\n<p>实现效果：<a href=\"http://play.csssecrets.io/drop-shadow\" target=\"_blank\" rel=\"noopener\">play.csssecrets.io/drop-shadow</a></p>\n<h3 id=\"染色效果\"><a href=\"#染色效果\" class=\"headerlink\" title=\"染色效果\"></a>染色效果</h3><p>首先可以去<a href=\"https://2014.cssconf.com/\" target=\"_blank\" rel=\"noopener\">CSSConf 官网</a>欣赏一下讲师照片的染色效果，当鼠标悬停或获得焦点时，照片将显示为全彩的样式</p>\n<h4 id=\"基于滤镜的方案\"><a href=\"#基于滤镜的方案\" class=\"headerlink\" title=\"基于滤镜的方案\"></a><a href=\"http://play.csssecrets.io/color-tint-filter\" target=\"_blank\" rel=\"noopener\">基于滤镜的方案</a></h4><p>filter 属性提供了多种关于色调调整的方法，下面的代码可以实现染色效果的过渡动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">5s</span> filter;</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">sepia</span>(1) <span class=\"built_in\">saturate</span>(4) <span class=\"built_in\">hue-rotate</span>(295deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">img</span><span class=\"selector-pseudo\">:hover</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">img</span><span class=\"selector-pseudo\">:focus</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: none; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基于混合模式的方案\"><a href=\"#基于混合模式的方案\" class=\"headerlink\" title=\"基于混合模式的方案\"></a><a href=\"http://play.csssecrets.io/color-tint\" target=\"_blank\" rel=\"noopener\">基于混合模式的方案</a></h4><p>使用 background-blend-mode 属性可以让每层背景跟它的下层背景进行混合：</p>\n<p>HTML 代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tinted-image\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">style</span>=<span class=\"string\">\"background-image:url(tiger.jpg)\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>CSS 代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tinted-image</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">640px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">440px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover; </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">hsl</span>(335, 100%, 50%); </span><br><span class=\"line\">    <span class=\"attribute\">background-blend-mode</span>: luminosity; </span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">5s</span> background-color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tinted-image</span><span class=\"selector-pseudo\">:hover</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"毛玻璃效果\"><a href=\"#毛玻璃效果\" class=\"headerlink\" title=\"毛玻璃效果\"></a><a href=\"http://play.csssecrets.io/frosted-glass\" target=\"_blank\" rel=\"noopener\">毛玻璃效果</a></h3><p>我们想要达到下面这种效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_261.png\" alt=\"\" width=\"\"></div>\n\n<p>我们的实现方案是利用伪元素实现模糊背景，但由于模糊效果在接近边缘处会逐渐消退，所以我们需要让伪元素相对其宿主元素的尺寸再向外扩大至少模糊半径的距离，然后再对宿主元素应用 overflow:hidden 来将多余的模糊区域裁切掉，最终代码如下所示：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>, <span class=\"selector-tag\">main</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"tiger.jpg\"</span>) <span class=\"number\">0</span> / cover fixed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">hsla</span>(0,0%,100%,.3); </span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(20px);</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: -<span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"折角效果\"><a href=\"#折角效果\" class=\"headerlink\" title=\"折角效果\"></a>折角效果</h3><h4 id=\"45°折角的解决方案\"><a href=\"#45°折角的解决方案\" class=\"headerlink\" title=\"45°折角的解决方案\"></a><a href=\"http://play.csssecrets.io/folded-corner\" target=\"_blank\" rel=\"noopener\">45°折角的解决方案</a></h4><p>我们先根据“切角效果”一节中的渐变方案实现一个右上角的斜面切角，然后增加另一层渐变来生成一个三角形并将其定位在右上角，从而实现翻折效果，需要注意的是<strong>这个渐变的两个色标需要在正中央重合</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#58a</span>; <span class=\"comment\">/* 回退样式 */</span> </span><br><span class=\"line\"><span class=\"selector-tag\">background</span>:</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">to</span> <span class=\"selector-tag\">left</span> <span class=\"selector-tag\">bottom</span>,</span><br><span class=\"line\">        <span class=\"selector-tag\">transparent</span> 50%, <span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.4</span>) 0)</span><br><span class=\"line\">        no-repeat 100% 0 / 2em 2em,</span><br><span class=\"line\">    <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-135deg</span>,</span><br><span class=\"line\">        <span class=\"selector-tag\">transparent</span> 1<span class=\"selector-class\">.5em</span>, <span class=\"selector-id\">#58a</span> 0);</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他角度的解决方案\"><a href=\"#其他角度的解决方案\" class=\"headerlink\" title=\"其他角度的解决方案\"></a><a href=\"http://play.csssecrets.io/folded-corner-realistic\" target=\"_blank\" rel=\"noopener\">其他角度的解决方案</a></h4><p>由于其他角度的切角需要旋转一定角度，所以我们需要借助伪元素来实现，同时还需要借助一些数学知识来计算角度和距离，具体实现过程比较复杂，大家可以看书中的解释或者直接看<a href=\"http://play.csssecrets.io/folded-corner-realistic\" target=\"_blank\" rel=\"noopener\">实现效果</a>，最终代码如下所示：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.note</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#58a</span>; <span class=\"comment\">/* 回退样式 */</span> </span><br><span class=\"line\"><span class=\"attribute\">background</span>:</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(-150deg,</span><br><span class=\"line\">            transparent 1.5em, #58a 0);</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: .<span class=\"number\">5em</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-class\">.note</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">linear-gradient</span>(to left bottom,</span><br><span class=\"line\">        transparent 50%, rgba(0,0,0,.2) <span class=\"number\">0</span>, <span class=\"built_in\">rgba</span>(0,0,0,.4))</span><br><span class=\"line\">        <span class=\"number\">100%</span> <span class=\"number\">0</span> no-repeat; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">1.73em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">3em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-1.3em) <span class=\"built_in\">rotate</span>(-30deg); </span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: bottom right; </span><br><span class=\"line\">    <span class=\"attribute\">border-bottom-left-radius</span>: inherit;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: -.<span class=\"number\">2em</span> .<span class=\"number\">2em</span> .<span class=\"number\">3em</span> -.<span class=\"number\">1em</span> <span class=\"built_in\">rgba</span>(0,0,0,.15);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字体排印\"><a href=\"#字体排印\" class=\"headerlink\" title=\"字体排印\"></a>字体排印</h2><h3 id=\"连字符断行\"><a href=\"#连字符断行\" class=\"headerlink\" title=\"连字符断行\"></a>连字符断行</h3><p>text-align:justify 可以实现两端对齐，但是对于英文字体来说，很容易出现“单词孤岛”现象，这样不仅看起来很糟糕，而且损伤了可读性。在打印媒介中，两端对齐总是和连字符断行相辅相成的，这样文本看起来就自然很多。 CSS 文本（第三版）引入了一个新的属性 hyphens：</p>\n<blockquote>\n<p>hyphens: none | manual | auto</p>\n</blockquote>\n<p>manual 是它的初始值，</p>\n<p>其行为正好对应了现有的工作方式：我们可以在任何时候手工插入软连字符，来实现断词折行的效果。很显然 hyphens: none; 会禁用这种行为；而最为神奇的是，只需这短短一行 CSS 就可以产生我们梦寐以求的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">hyphens</span>: <span class=\"selector-tag\">auto</span>;</span><br></pre></td></tr></table></figure>\n<p>为了确保它奏效，你需要在 HTML 标签的 lang 属性中指定合适的语言</p>\n<p>如果需要更细粒度地控制连字符的行为（比如在简短的引文中），你仍然可以通过一些软连字符（<code>&amp;shy;</code>）来辅助浏览器进行断词。这个 hyphens 属性会优先处理它们，然后再去计算其他可以断词的地方</p>\n<h3 id=\"插入换行\"><a href=\"#插入换行\" class=\"headerlink\" title=\"插入换行\"></a><a href=\"http://play.csssecrets.io/line-breaks\" target=\"_blank\" rel=\"noopener\">插入换行</a></h3><p>HTML代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dl</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>Name:<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>Lea Verou<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>Email:<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>lea@verou.me<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>Location:<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>Earth<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们想让 dt 和后面的 dd 在同一行，每个dt所在的内容都单独占一行。 有一个 Unicode 字符是专门代表换行符的:0x000A1。在 CSS 中， 这个字符可以写作 “\\000A”，或简化为 “\\A”。我们可以用它来作为 ::after 伪元素的内容，并将其添加到每个 <code>&lt;dd&gt;</code> 元素的尾部</p>\n<p>但是由于我们是在 HTML 代码中插入了换行符，所以这些换行符会和相邻的其他空白符进行合并，此时我们希望<strong>保留源代码中的这些空白符和换行，</strong>我们会用到 white-space:pre。然而如果你的结构代码在多个连续的 <code>&lt;dd&gt;</code> 之间包含了(未加注释的)空白符，那么逗号前面会有一个空格。有很多方法可以修复这个问题，但都不够完美。其中一种方法是利用<strong>负外边距</strong>。最终 CSS 代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dt</span>,<span class=\"selector-tag\">dd</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">dd</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">dd</span> + <span class=\"selector-tag\">dt</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">'\\\\A'</span>;</span><br><span class=\"line\">    <span class=\"attribute\">white-space</span>: pre; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">dd</span> + <span class=\"selector-tag\">dd</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">', '</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -.<span class=\"number\">25em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: normal; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文本行的斑马条纹\"><a href=\"#文本行的斑马条纹\" class=\"headerlink\" title=\"文本行的斑马条纹\"></a><a href=\"http://play.csssecrets.io/zebra-lines\" target=\"_blank\" rel=\"noopener\">文本行的斑马条纹</a></h3><p>我们可以通过 :nth-child() / :nth-of-type() 伪类来实现表格的“斑马条纹”：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">tr</span><span class=\"selector-pseudo\">:nth-child(even)</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(0,0,0,.2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，这种实现方式无法应用到文本行。我们可以<strong>在 CSS 中用渐变直接生成背景图像</strong>，而且可以用 em 单位来设定背景尺寸，这样背景就可以<strong>自动适应 font-size 的变化</strong>了。水平条纹背景的 background-size 需要设置为 line-height 的两倍，因为每个背景贴片需要覆盖两行代码。同时我们希望让背景自动跟着内边距的宽度走，所以就需要 background-origin 告诉浏览器在解析 background-position 时以 content box 的外沿作为基准：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding</span>: <span class=\"selector-class\">.5em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">line-height</span>: 1<span class=\"selector-class\">.5</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">beige</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: <span class=\"selector-tag\">auto</span> 3<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-origin</span>: <span class=\"selector-tag\">content-box</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-image</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.2</span>) 50%,</span><br><span class=\"line\">                                  <span class=\"selector-tag\">transparent</span> 0);</span><br></pre></td></tr></table></figure>\n<p>唯一可能破坏效果的情况可能就是在改变 line-height 时忘了相应地调整 background-size</p>\n<h3 id=\"调整tab的宽度\"><a href=\"#调整tab的宽度\" class=\"headerlink\" title=\"调整tab的宽度\"></a><a href=\"http://play.csssecrets.io/tab-size\" target=\"_blank\" rel=\"noopener\">调整tab的宽度</a></h3><p>我们通常使用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 元素来显示代码，但是<strong>浏览器会把 tab 的宽度显示为8个字符</strong>！ 而在 CSS 文本（第三版）中，一个新的 CSS 属性 tab-size 可以控制这个情况。这个属性接受一个数字(表示字符数)或者一个长度值(这个不那么实用)。我们通常希望把它设置为4(表示 4 个字符的宽度)或 2，后者是最近更为流行的缩进尺寸。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">pre</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">tab-size</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连字\"><a href=\"#连字\" class=\"headerlink\" title=\"连字\"></a><a href=\"http://play.csssecrets.io/ligatures\" target=\"_blank\" rel=\"noopener\">连字</a></h3><h4 id=\"什么是连字？（右侧为左侧连字写法）\"><a href=\"#什么是连字？（右侧为左侧连字写法）\" class=\"headerlink\" title=\"什么是连字？（右侧为左侧连字写法）\"></a>什么是连字？（右侧为左侧连字写法）</h4><p>i 的圆点往往会与 f 的升部发生冲突，导致两者都显示不清；为了缓解这个问题，字体设计师通常会在字体中包含一些额外的字形，称作连字。这些字形被设计为双字形或三字形的单一组合体，专门提供给排版软件使用，代为显示特定的字符组合：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_262.png\" alt=\"\" width=\"\"></div>\n\n<h4 id=\"支持连字解决方案\"><a href=\"#支持连字解决方案\" class=\"headerlink\" title=\"支持连字解决方案\"></a>支持连字解决方案</h4><p>在 CSS 字体（第三版）中，原有的 font- variant 被升级成了一个简写属性，由很多新的展开式属性组合而成。其中之一叫作 font-variant-ligatures，专门用来控制连字效果的开启和关闭。如果要启用所有可能的连字，需要同时指定这三个标识符:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">font-variant-ligatures</span>: <span class=\"selector-tag\">common-ligatures</span> </span><br><span class=\"line\">                        <span class=\"selector-tag\">discretionary-ligatures</span></span><br><span class=\"line\">                        <span class=\"selector-tag\">historical-ligatures</span>;</span><br></pre></td></tr></table></figure>\n<p>font-variant-ligatures 还接受 none 这个值，它会把所有的连字效果都关掉。千万不要使用 none，除非你绝对清楚自己是在做什么。如果要把 font-variant-ligatures 属性复位为初始值，应该使用 normal 而不是 none。</p>\n<h3 id=\"华丽的-amp-符号\"><a href=\"#华丽的-amp-符号\" class=\"headerlink\" title=\"华丽的 &amp; 符号\"></a><a href=\"http://play.csssecrets.io/ampersands\" target=\"_blank\" rel=\"noopener\">华丽的 &amp; 符号</a></h3><p>我们想要用另一种字体来单独美化某个特定字符（或是某个区间内的多个字符）： 首先，@font-face 规则中的 src 描述符是可以接受 local() 函数的，用于指定本地字体的名称：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">font-face</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: Ampersand;</span><br><span class=\"line\">    <span class=\"attribute\">src</span>: <span class=\"built_in\">local</span>(<span class=\"string\">'Baskerville'</span>),</span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'Goudy Old Style'</span>),</span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'Garamond'</span>),</span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'Palatino'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，整段文本会都被应用为我们指定的字体，所以需要一个描述符来声明我们想用这款字体来显示哪些字符，这个描述符叫做 unicode-range；它是基于 “Unicode 码位”的，所以需要知道你想指定的字符的十六进制码位，你可以在控制台打印下面JS代码获取：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"&amp;\"</span>.charCodeAt(<span class=\"number\">0</span>).toString(<span class=\"number\">16</span>); <span class=\"comment\">// 返回26</span></span><br></pre></td></tr></table></figure>\n<p>还需要在前面加上 U+ 作为前缀，所以最终声明方式为：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">unicode-range</span>: <span class=\"selector-tag\">U</span>+26;</span><br></pre></td></tr></table></figure>\n<p>如果你想指定一个字符区间，还是要加上 U+ 前缀，比如 U+400-4FF。实际上对于这个区间来说，你还可以使用通配符，以这样的方式来写：U+4??。同时指定多个字符或多个区间也是允许的，把它们用逗号隔开即可，比如 U+26, U+4??, U+2665-2670</p>\n<p>最后，为了指定某些字体的斜体版本，我们需要直接指定字体中我们想要的单个风格/字重所对应的 “PostScript 名称”：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">font-face</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: Ampersand;</span><br><span class=\"line\">    <span class=\"attribute\">src</span>: <span class=\"built_in\">local</span>(<span class=\"string\">'Baskerville-Italic'</span>),</span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'GoudyOldStyleT-Italic'</span>), </span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'Palatino-Italic'</span>), </span><br><span class=\"line\">         <span class=\"built_in\">local</span>(<span class=\"string\">'BookAntiqua-Italic'</span>);</span><br><span class=\"line\">    <span class=\"attribute\">unicode-range</span>: U+<span class=\"number\">26</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: Ampersand, Helvetica, sans-serif;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义下划线\"><a href=\"#自定义下划线\" class=\"headerlink\" title=\"自定义下划线\"></a>自定义下划线</h3><p>text-decoration:underline 实现的文本下划线不能够定制，同时<strong>在不同浏览器下的渲染效果大相径庭</strong>。所以为了得到更加定制化的下划线，我们可以通过 background-image 及其相关属性来实现（CSS 渐变）</p>\n<h4 id=\"实线下划线\"><a href=\"#实线下划线\" class=\"headerlink\" title=\"实线下划线\"></a>实线下划线</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">gray</span>, <span class=\"selector-tag\">gray</span>) <span class=\"selector-tag\">no-repeat</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 1<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 0 1<span class=\"selector-class\">.15em</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"防止下划线穿过文本的降部\"><a href=\"#防止下划线穿过文本的降部\" class=\"headerlink\" title=\"防止下划线穿过文本的降部\"></a>防止下划线穿过文本的降部</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">gray</span>, <span class=\"selector-tag\">gray</span>) <span class=\"selector-tag\">no-repeat</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 1<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 0 1<span class=\"selector-class\">.15em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: <span class=\"selector-class\">.05em</span> 0 <span class=\"selector-tag\">white</span>, <span class=\"selector-tag\">-</span><span class=\"selector-class\">.05em</span> 0 <span class=\"selector-tag\">white</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"虚线下划线\"><a href=\"#虚线下划线\" class=\"headerlink\" title=\"虚线下划线\"></a><a href=\"http://play.csssecrets.io/underlines\" target=\"_blank\" rel=\"noopener\">虚线下划线</a></h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(90<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">gray</span> 66%, <span class=\"selector-tag\">transparent</span> 0) <span class=\"selector-tag\">repeat-x</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: <span class=\"selector-class\">.2em</span> 2<span class=\"selector-tag\">px</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 0 1<span class=\"selector-tag\">em</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"波浪型的下划线（两层渐变）\"><a href=\"#波浪型的下划线（两层渐变）\" class=\"headerlink\" title=\"波浪型的下划线（两层渐变）\"></a><a href=\"http://play.csssecrets.io/wavy-underlines\" target=\"_blank\" rel=\"noopener\">波浪型的下划线（两层渐变）</a></h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">-45deg</span>, <span class=\"selector-tag\">transparent</span> 40%, <span class=\"selector-tag\">red</span> 0, <span class=\"selector-tag\">red</span> 60%, <span class=\"selector-tag\">transparent</span> 0) 0 1<span class=\"selector-tag\">em</span>,</span><br><span class=\"line\">\t    <span class=\"selector-tag\">linear-gradient</span>(45<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">transparent</span> 40%, <span class=\"selector-tag\">red</span> 0, <span class=\"selector-tag\">red</span> 60%, <span class=\"selector-tag\">transparent</span> 0) <span class=\"selector-class\">.1em</span> 1<span class=\"selector-tag\">em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">repeat-x</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: <span class=\"selector-class\">.2em</span> <span class=\"selector-class\">.1em</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: <span class=\"selector-class\">.05em</span> 0 <span class=\"selector-tag\">white</span>, <span class=\"selector-tag\">-</span><span class=\"selector-class\">.05em</span> 0 <span class=\"selector-tag\">white</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"现实中的文字效果\"><a href=\"#现实中的文字效果\" class=\"headerlink\" title=\"现实中的文字效果\"></a>现实中的文字效果</h3><h4 id=\"凸版印刷效果\"><a href=\"#凸版印刷效果\" class=\"headerlink\" title=\"凸版印刷效果\"></a><a href=\"http://play.csssecrets.io/letterpress\" target=\"_blank\" rel=\"noopener\">凸版印刷效果</a></h4><p>我们通过 text-shadow 使人产生物体从平面上凸起的错觉 <strong>当我们在浅色背景上使用深色文字时，在底部加上浅色投影通常效果最佳</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">hsl</span>(210, 13%, 60%);</span><br><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">hsl</span>(210, 13%, 30%);</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 1<span class=\"selector-tag\">px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">hsla</span>(0,0%,100%,<span class=\"selector-class\">.8</span>);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_263.png\" alt=\"\" width=\"\"></div>\n\n<p><strong>当我们在深色背景上使用浅色文字时，在底部加上深色投影通常效果最佳</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">hsl</span>(210, 13%, 40%); </span><br><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">hsl</span>(210, 13%, 75%); </span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 <span class=\"selector-tag\">-1px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_264.png\" alt=\"\" width=\"\"></div>\n\n<h4 id=\"空心字效果\"><a href=\"#空心字效果\" class=\"headerlink\" title=\"空心字效果\"></a><a href=\"http://play.csssecrets.io/stroked-text\" target=\"_blank\" rel=\"noopener\">空心字效果</a></h4><p>我们一般使用多个 text-shadow 来模拟文字描边：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">deeppink</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">white</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 1<span class=\"selector-tag\">px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, <span class=\"selector-tag\">-1px</span> <span class=\"selector-tag\">-1px</span> <span class=\"selector-tag\">black</span>,</span><br><span class=\"line\">             1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">-1px</span> <span class=\"selector-tag\">black</span>, <span class=\"selector-tag\">-1px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<p>但是，目前比较理想的方案是使用 SVG，HTML 代码可能是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"2em\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"1.2em\"</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#css\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span> <span class=\"attr\">id</span>=<span class=\"string\">\"css\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"1em\"</span>&gt;</span>CSS<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>CSS：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">500%</span>/<span class=\"number\">1</span> Rockwell, serif; </span><br><span class=\"line\">    <span class=\"attribute\">background</span>: deeppink;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> <span class=\"selector-tag\">text</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">fill</span>: currentColor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> <span class=\"selector-tag\">svg</span> &#123; <span class=\"attribute\">overflow</span>: visible &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> <span class=\"selector-tag\">use</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">stroke</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-width</span>: <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-linejoin</span>: round;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"文字外发光效果\"><a href=\"#文字外发光效果\" class=\"headerlink\" title=\"文字外发光效果\"></a><a href=\"http://play.csssecrets.io/glow\" target=\"_blank\" rel=\"noopener\">文字外发光效果</a></h4><p>文字外发光效果常用于凸显标题，或给链接添加鼠标悬停效果。它是最容易生成的文字美化效果之一。这种方法有一个最简单的版本:你只需要准备几层重叠的 text-shadow 即可，不需要考虑偏移量，颜色也只需跟文字保持一致：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-id\">#203</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-id\">#ffc</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 0 <span class=\"selector-class\">.1em</span>, 0 0 <span class=\"selector-class\">.3em</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">或者使用<span class=\"selector-tag\">CSS</span>滤镜：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#203</span>; </span><br><span class=\"line\">    <span class=\"attribute\">color</span>: white; </span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: <span class=\"number\">1s</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(.1em); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"文字凸起效果\"><a href=\"#文字凸起效果\" class=\"headerlink\" title=\"文字凸起效果\"></a><a href=\"http://play.csssecrets.io/extruded\" target=\"_blank\" rel=\"noopener\">文字凸起效果</a></h4><p>思路就是使用一长串累加的投影，不设模糊并以 1px 的跨度逐渐错开，使颜色逐渐变暗，然后在底部加一层强烈模糊的暗投影，从而模拟完整的立体效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background: #58a;</span><br><span class=\"line\">color: white;</span><br><span class=\"line\">text-shadow: 0 1px hsl(0,0%,85%),</span><br><span class=\"line\">             0 2px hsl(0,0%,80%), </span><br><span class=\"line\">             0 3px hsl(0,0%,75%), </span><br><span class=\"line\">             0 4px hsl(0,0%,70%), </span><br><span class=\"line\">             0 5px hsl(0,0%,65%), </span><br><span class=\"line\">             0 5px 10px black;</span><br></pre></td></tr></table></figure>\n<h4 id=\"模拟复古标志牌：\"><a href=\"#模拟复古标志牌：\" class=\"headerlink\" title=\"模拟复古标志牌：\"></a>模拟复古标志牌：</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">white</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">hsl</span>(0,50%,45%);</span><br><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 1<span class=\"selector-tag\">px</span> 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, 2<span class=\"selector-tag\">px</span> 2<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>,</span><br><span class=\"line\">             3<span class=\"selector-tag\">px</span> 3<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, 4<span class=\"selector-tag\">px</span> 4<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>,</span><br><span class=\"line\">             5<span class=\"selector-tag\">px</span> 5<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, 6<span class=\"selector-tag\">px</span> 6<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>,</span><br><span class=\"line\">             7<span class=\"selector-tag\">px</span> 7<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>, 8<span class=\"selector-tag\">px</span> 8<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">black</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_265.png\" alt=\"\" width=\"\"></div>\n\n<h3 id=\"环形文字\"><a href=\"#环形文字\" class=\"headerlink\" title=\"环形文字\"></a><a href=\"http://play.csssecrets.io/circular-text\" target=\"_blank\" rel=\"noopener\">环形文字</a></h3><p>目前我们没有很好的纯 CSS 方案实现环形问题，只能借助内联 SVG 来实现这种效果；</p>\n<p>在 SVG 中，让文本按照路径排列的基本方法就是用一个 <code>&lt;textPath&gt;</code> 元素来包裹住这段文本，再把它们装进一个 <code>&lt;text&gt;</code> 元素中。这个 <code>&lt;textPath&gt;</code> 元素还需要在它的 ID 属性中引用一个 <code>&lt;path&gt;</code> 元素，然后就可以用这个 <code>&lt;path&gt;</code> 元素来定义我们想要的路径</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"circular\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">viewBox</span>=<span class=\"string\">\"0 0 100 100\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 0,50 a 50,50 0 1,1 0,1 z\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"circle\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这个效果的实现比较复杂，所以直接点击上面标题链接查看吧。。</p>\n<h2 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h2><h3 id=\"选用合适的鼠标光标\"><a href=\"#选用合适的鼠标光标\" class=\"headerlink\" title=\"选用合适的鼠标光标\"></a>选用合适的鼠标光标</h3><p>在<a href=\"http://w3.org/TR/css3-ui/#cursor\" target=\"_blank\" rel=\"noopener\">CSS 基本UI 特性（第三版）</a>中，我们获得了一大批新的内建光标：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_266.png\" alt=\"\" width=\"\"></div>\n\n<h3 id=\"扩大可点击区域\"><a href=\"#扩大可点击区域\" class=\"headerlink\" title=\"扩大可点击区域\"></a><a href=\"http://play.csssecrets.io/hit-area\" target=\"_blank\" rel=\"noopener\">扩大可点击区域</a></h3><p><a href=\"http://simonwallner.at/ext/fitts/\" target=\"_blank\" rel=\"noopener\">Fitts法则</a>：人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数；所以将可点击区域（热区）向外扩张往往可以带来可用性的提升，我们还需要了解：<strong>伪元素同样可以代表其宿主元素来响应鼠标交互</strong></p>\n<p>所以，我们可以在按钮的上层覆盖一层透明的伪元素，并让伪元素在四个方向上都比宿主元素大出 10px：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">button</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    /\\* \\[其余样式\\] */ </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: -<span class=\"number\">10px</span>; <span class=\"attribute\">right</span>: -<span class=\"number\">10px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: -<span class=\"number\">10px</span>; <span class=\"attribute\">left</span>: -<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个基于伪元素的解决方案极为灵活，我们基本上可以把热区设置为任何想要的尺寸、位置或形状，甚至可以脱离元素原有的位置!</p>\n<h3 id=\"自定义复选框\"><a href=\"#自定义复选框\" class=\"headerlink\" title=\"自定义复选框\"></a>自定义复选框</h3><p>知识点：伪类选择符 :checked 和属性选择符 [checked] 之间的区别是<strong>后者是不会根据用户的交互行为进行更新的，因为用户的交互并不会影响到 HTML 标签上的属性</strong>。 下面是作者实现的效果：</p>\n<ul>\n<li><a href=\"http://play.csssecrets.io/checkboxes\" target=\"_blank\" rel=\"noopener\">自定义复选框</a></li>\n<li><a href=\"http://play.csssecrets.io/toggle-buttons\" target=\"_blank\" rel=\"noopener\">开关式按钮</a></li>\n</ul>\n<h3 id=\"通过阴影来弱化背景\"><a href=\"#通过阴影来弱化背景\" class=\"headerlink\" title=\"通过阴影来弱化背景\"></a>通过阴影来弱化背景</h3><p>很多时候，我们需要通过一层半透明的遮罩层来把后面的一切整体调暗，以便凸显某个特定的 UI 元素，引导用户关注</p>\n<h4 id=\"伪元素方案\"><a href=\"#伪元素方案\" class=\"headerlink\" title=\"伪元素方案\"></a>伪元素方案</h4><p>我们可以通过伪元素来添加：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.dimmed</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed; </span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(0,0,0,.8);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>伪元素方案的缺点：<strong>伪元素无法绑定独立的JavaScript事件处理函数；</strong>同时 ::before 伪元素有可能已经被占用；还需要一点 JavaScript 来给 <code>&lt;body&gt;</code> 添加 dimmed 这个类</p>\n<h4 id=\"box-shadow方案\"><a href=\"#box-shadow方案\" class=\"headerlink\" title=\"box-shadow方案\"></a><a href=\"http://play.csssecrets.io/dimming-box-shadow\" target=\"_blank\" rel=\"noopener\">box-shadow方案</a></h4><p>box-shadow 的扩张参数可以把元素的投影向各个方向延伸放大。具体做法就是生成一个巨大的投影，不偏移也不模糊，简单而拙劣地模拟出遮罩层的效果:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">box-shadow</span>: 0 0 0 50<span class=\"selector-tag\">vmax</span> <span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.8</span>);</span><br></pre></td></tr></table></figure>\n<p>但是它也存在两个非常严重的问题：当我们滚动页面时，遮罩层的边缘就露出来了；<strong>它只能在视觉上起到引导注意力的作用，却无法阻止鼠标交互</strong></p>\n<h4 id=\"backdrop-方案\"><a href=\"#backdrop-方案\" class=\"headerlink\" title=\"backdrop 方案\"></a><a href=\"http://play.csssecrets.io/native-modal\" target=\"_blank\" rel=\"noopener\">backdrop 方案</a></h4><p>\b如果你想引导用户关注元素就是一个模态的 <code>&lt;dialog&gt;</code> 元素，那么根据浏览器的默认样式，它会自带一个遮罩层。借助 ::backdrop 伪元素，这个原生的遮罩层也是可以设置样式的，比如可以把它变得更暗一些：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dialog</span><span class=\"selector-pseudo\">::backdrop</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(0, 0, 0, .8);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>唯一需要注意的地方在于，<strong>浏览器对它的支持还极为有限</strong></p>\n<h2 id=\"通过模糊来弱化背景\"><a href=\"#通过模糊来弱化背景\" class=\"headerlink\" title=\"通过模糊来弱化背景\"></a><a href=\"http://play.csssecrets.io/deemphasizing-blur\" target=\"_blank\" rel=\"noopener\">通过模糊来弱化背景</a></h2><p>我们需要一个额外的 HTML 元素来实现这个效果：需要把页面上除了关键元素之外的一切都包裹起来，这样就可以只对这个容器元素进行模糊处理了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\">    O HAI, I'm a dialog. Click on me to dismiss.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> 其他对话框都写在这里 <span class=\"attr\">--</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>接下来，每当弹出一个对话框，都需要给 <code>&lt;main&gt;</code> 元素增加一个类，以便对它应用模糊滤镜：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span><span class=\"selector-class\">.de-emphasized</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(5px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动提示\"><a href=\"#滚动提示\" class=\"headerlink\" title=\"滚动提示\"></a><a href=\"http://play.csssecrets.io/scrolling-hints\" target=\"_blank\" rel=\"noopener\">滚动提示</a></h3><p>我们需要实现的效果类似 Google Reader 中的一种用户体验模式：当侧边栏的容器还有更多内容时，一层淡淡的阴影会出现在容器的顶部和 / 或底部，用来提示侧边栏需要滚动才能看到完整的内容</p>\n<div align=\"center\"><img src=\"/images/hexo_post_267.png\" alt=\"\" width=\"\"></div>\n\n<p>我们可以用纯 CSS 实现这种效果，利用的就是 background-attachment 属性的一个关键字：local，但是<strong>我们需要两层背景</strong>：一层用来生成那条阴影，另一层基本上就是一个用来遮挡阴影的白色矩形，其作用类似于遮罩层。生成阴影的那层背景将具有默认的 background-attachment 值(scroll)，因为我们希望它总是保持在原位。我们把遮罩背景的 background-attachment 属性设置为 local，这样它就会在我们滚动到最顶部时盖住阴影，在向下滚动时跟着滚动，从而露出阴影。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">white</span> 30%, <span class=\"selector-tag\">transparent</span>), </span><br><span class=\"line\">            <span class=\"selector-tag\">radial-gradient</span>(<span class=\"selector-tag\">at</span> 50% 0, <span class=\"selector-tag\">rgba</span>(0,0,0,<span class=\"selector-class\">.2</span>),<span class=\"selector-tag\">transparent</span> 70%); </span><br><span class=\"line\"><span class=\"selector-tag\">background-repeat</span>: <span class=\"selector-tag\">no-repeat</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-size</span>: 100% 50<span class=\"selector-tag\">px</span>, 100% 15<span class=\"selector-tag\">px</span>; </span><br><span class=\"line\"><span class=\"selector-tag\">background-attachment</span>: <span class=\"selector-tag\">local</span>, <span class=\"selector-tag\">scroll</span>;</span><br></pre></td></tr></table></figure>\n<p>但是为了完整地实现这个效果，我们<strong>还需要再用两层渐变来实现底部的阴影和它配套的遮罩</strong>，具体实现可以点击上面的链接查看</p>\n<h3 id=\"交互式的图片对比控件\"><a href=\"#交互式的图片对比控件\" class=\"headerlink\" title=\"交互式的图片对比控件\"></a>交互式的图片对比控件</h3><p>有时，我们需要展示两张图片的外观差异，通常是“之前和之后”形式的对比</p>\n<h4 id=\"CSS-resize方案\"><a href=\"#CSS-resize方案\" class=\"headerlink\" title=\"CSS resize方案\"></a><a href=\"http://play.csssecrets.io/image-slider\" target=\"_blank\" rel=\"noopener\">CSS resize方案</a></h4><p>resize 属性可以让某个元素的大小变得可调整，我们的第一个念头可能是列出两个 <code>&lt;img&gt;</code> 元素。但是，直接对一个 <code>&lt;img&gt;</code> 元素应用 resize 看起来会很怪异，因为直接调整图片大小会导致其变形失真。如果用一个 <code>&lt;div&gt;</code> 作为它的容器，再对这个容器应用 resize 属性，那就合理多了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"image-slider\"</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"adamcatlace-before.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Before\"</span> /&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"adamcatlace-after.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"After\"</span> /&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>resize 起作用的前提条件是它的 overflow 属性不是 visible；</strong>同时我们可以通过伪元素改变调节手柄的样式；最后，我们可以对这两张图片应用 user-select: none，这样即使用户在没有点中调节手柄的情况下拖动鼠标，也不会误选图片：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.image-slider</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.image-slider</span> &gt; <span class=\"selector-tag\">div</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">resize</span>: horizontal; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.image-slider</span> &gt; <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">::before</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">12px</span>; <span class=\"attribute\">height</span>: <span class=\"number\">12px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">linear-gradient</span>(-45deg, white 50%, transparent 0); </span><br><span class=\"line\">    <span class=\"attribute\">background-clip</span>: content-box;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: ew-resize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.image-slider</span> <span class=\"selector-tag\">img</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">user-select</span>: none; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"范围输入控件方案\"><a href=\"#范围输入控件方案\" class=\"headerlink\" title=\"范围输入控件方案\"></a>范围输入控件方案</h4><p>上面的 CSS resize 方案有一些不足之处：</p>\n<ul>\n<li>对键盘来说不可访问</li>\n<li>调整上层图片的唯一方法就是拖动</li>\n<li>用户只能在右下角进行调整大小的操作</li>\n</ul>\n<p>我们可以将原生的滑块控件（HTML 范围输入控件）覆盖在图片上，用它来控制上层图片的伸缩，这样就可以解决上述三个问题，同时为了让范围输入控件在视觉上与整个控件更加统一，可以用混合模式和滤镜来实现，最终实现效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_268.png\" alt=\"\" width=\"\"></div>\n\n<h2 id=\"结构与布局\"><a href=\"#结构与布局\" class=\"headerlink\" title=\"结构与布局\"></a>结构与布局</h2><h3 id=\"自适应内部元素\"><a href=\"#自适应内部元素\" class=\"headerlink\" title=\"自适应内部元素\"></a><a href=\"http://play.csssecrets.io/intrinsic-sizing\" target=\"_blank\" rel=\"noopener\">自适应内部元素</a></h3><p>众所周知，如果不给元素指定一个具体的 height，它就会自动适应其内容的高度。假如我们希望 width 也具有类似的行为，该怎么做呢?</p>\n<p>CSS 内部与外部尺寸模型（第三版）为 width 和 height 属性定义了一些新的关键字，其中最有用的应该就是 min-content 了。这个关键字将解析为这个容器内部最大的不可断行元素的宽度(即最宽的单词、图片或具有固定宽度的盒元素)。这正是我们梦寐以求的！为了给那些旧版浏览器提供一个平稳的回退样式，我们需要在使用这个技巧的同时，提供一个固定的 max-width 值：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">figure</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: <span class=\"number\">300px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: min-content; </span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">figure</span> &gt; <span class=\"selector-tag\">img</span> &#123; <span class=\"attribute\">max-width</span>: inherit; &#125;</span><br></pre></td></tr></table></figure>\n<p>关于 width 和 height 的新关键字，还有 max-content，它的行为类似于我们在前面看到的 display: inline-block；而 fit-content 的行为与浮动元素是相同的(和 min-content 的效果通常一致，但也有例外)。</p>\n<h3 id=\"精确控制表格列宽\"><a href=\"#精确控制表格列宽\" class=\"headerlink\" title=\"精确控制表格列宽\"></a><a href=\"http://play.csssecrets.io/table-column-widths\" target=\"_blank\" rel=\"noopener\">精确控制表格列宽</a></h3><p>对于不固定的内容来说，表格的布局是很难预测的，这是因为<strong>列宽根据其内容进行调整</strong>，即使我们显式地指定了 width。解决方案来自于 CSS 2.1 中一个鲜为人知的属性，叫做 table-layout，它的默认值是 auto，其行为模式被称作自动表格布局算法，也就是我们最为熟悉的表格布局行为。不过，它还接受另外一个值 <strong>fixed</strong>，这个值的行为要明显可控一些，使用也很简单：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">table</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">table-layout</span>: fixed; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"根据兄弟元素的数量来设置样式\"><a href=\"#根据兄弟元素的数量来设置样式\" class=\"headerlink\" title=\"根据兄弟元素的数量来设置样式\"></a><a href=\"http://play.csssecrets.io/styling-sibling-count\" target=\"_blank\" rel=\"noopener\">根据兄弟元素的数量来设置样式</a></h3><p>在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。</p>\n<p>对于只有一个列表项的特殊场景来说，解决方案显然就是 :only-child：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:only-child</span> &#123;</span><br><span class=\"line\">    /\\* 只有一个列表项时的样式 */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，:only-child 等效于 :first-child:last-child，道理就是：如果第一项也是最后一项，那它就是唯一的那一项；而 :first-child:nth-last-child(4) 会匹配到一个正好有四个列表项的列表中的第一个列表项，所以下面的选择符就相当于<strong>在这个列表正好包含四个列表项时，命中它的每一项</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(4)</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(4)</span> ~ <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    /\\* 当列表正好包含四项时，命中所有列表项 */ </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用选择符的表达式，我们可以<strong>在列表项的总数是4或更多时选中所有列表项</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(n+4)</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(n+4)</span> ~ <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    /\\* 当列表至少包含四项时，命中所有列表项 */ </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理，-n+b 这种形式的表达式可以选中开头的 b 个元素。因此，我们可以<strong>在列表项的总数是 4 个或更少时选中所有列表项</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(-n+4)</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(-n+4)</span> ~ <span class=\"selector-tag\">li</span> &#123; </span><br><span class=\"line\">    /\\* 当列表最多包含四项时，命中所有列表项 */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，我们还可以把这两种技巧组合起来使用，不过代码也会变得更加复杂。假设我们希望<strong>在列表包含 2 ~ 6 个列表项时命中所有的列表项</strong>，可以这样写:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(n+2)</span><span class=\"selector-pseudo\">:nth-last-child(-n+6)</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span><span class=\"selector-pseudo\">:nth-last-child(n+2)</span><span class=\"selector-pseudo\">:nth-last-child(-n+6)</span> ~ <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    /\\* 当列表包含2~6项时，命中所有列表项 */ </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"满幅的背景，定宽的内容\"><a href=\"#满幅的背景，定宽的内容\" class=\"headerlink\" title=\"满幅的背景，定宽的内容\"></a><a href=\"http://play.csssecrets.io/fluid-fixed\" target=\"_blank\" rel=\"noopener\">满幅的背景，定宽的内容</a></h3><p>背景宽度满幅，内容宽度固定的设计手法在网页的页脚中经常看到：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_269.png\" alt=\"\" width=\"\"></div>\n\n<p>绝大多数的网页设计师/工程师都是用两层元素来实现的，那么能不能用一层元素实现呢？其实我们可以用 calc() 来实现内容的居中：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: <span class=\"number\">900px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">1em</span>;  <span class=\"comment\">/* 回退样式 */</span></span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span> <span class=\"built_in\">calc</span>(50% - 450px); </span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h3><blockquote>\n<p>44 年前我们就把人类送上月球了，但现在我们仍然无法在 CSS 中实现垂直居中 —— James Anderson</p>\n</blockquote>\n<h4 id=\"几种十分流行的技巧：\"><a href=\"#几种十分流行的技巧：\" class=\"headerlink\" title=\"几种十分流行的技巧：\"></a>几种十分流行的技巧：</h4><ul>\n<li>表格布局法</li>\n<li>行内块法</li>\n</ul>\n<p>Chris Coyier 写的<a href=\"http://css-tricks.com/centering-in-the-unknown\" target=\"_blank\" rel=\"noopener\">“不为人知的居中方法”</a>详细讲述了这两种技巧</p>\n<h4 id=\"基于绝对定位的解决方案\"><a href=\"#基于绝对定位的解决方案\" class=\"headerlink\" title=\"基于绝对定位的解决方案\"></a><a href=\"http://play.csssecrets.io/vertical-centering-abs\" target=\"_blank\" rel=\"noopener\">基于绝对定位的解决方案</a></h4><p>早期的垂直居中方法，它要求元素具有固定的宽度和高度：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">3em</span>; <span class=\"comment\">/* 6/2 = 3 */</span> </span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">9em</span>; <span class=\"comment\">/* 18/2 = 9 */</span> </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">18em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CSS 领域有一个很常见的现象，真正的解决方案往往来自于我们最意想不到的地方。当我们在 translate() 变形函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的，所以就解除了对固定尺寸的依赖：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-50%, -50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个方法有一些需要注意的地方：</p>\n<ul>\n<li>有时不能选用绝对定位</li>\n<li>如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视口裁切掉</li>\n<li>在某些浏览器中，这个方法可能会导致元素的显示有一些模糊</li>\n</ul>\n<h4 id=\"基于视口单位的解决方案\"><a href=\"#基于视口单位的解决方案\" class=\"headerlink\" title=\"基于视口单位的解决方案\"></a><a href=\"http://play.csssecrets.io/vertical-centering-vh\" target=\"_blank\" rel=\"noopener\">基于视口单位的解决方案</a></h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">18em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span> <span class=\"number\">1.5em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">50vh</span> auto <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基于-Flexbox-的解决方案\"><a href=\"#基于-Flexbox-的解决方案\" class=\"headerlink\" title=\"基于 Flexbox 的解决方案\"></a><a href=\"http://play.csssecrets.io/vertical-centering\" target=\"_blank\" rel=\"noopener\">基于 Flexbox 的解决方案</a></h4><p>这是毋庸置疑的最佳解决方案：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们使用 Flexbox 时，margin:auto 不仅在水平方向上将元素居中，垂直方向上也是如此</p>\n<h3 id=\"紧贴底部的页脚\"><a href=\"#紧贴底部的页脚\" class=\"headerlink\" title=\"紧贴底部的页脚\"></a>紧贴底部的页脚</h3><p>这是一个相当常见的问题：我们希望内容很长时，页脚在内容的尾部；而如果内容很短，页脚会在视口的底部。</p>\n<h4 id=\"一些解决方案（仍然有局限之处）：\"><a href=\"#一些解决方案（仍然有局限之处）：\" class=\"headerlink\" title=\"一些解决方案（仍然有局限之处）：\"></a>一些解决方案（仍然有局限之处）：</h4><ul>\n<li><a href=\"https://css-tricks.com/snippets/css/sticky-footer/\" target=\"_blank\" rel=\"noopener\">https://css-tricks.com/snippets/css/sticky-footer/</a></li>\n<li><a href=\"https://pixelsvsbytes.com/2011/09/sticky-css-footers-the-flexible-way/\" target=\"_blank\" rel=\"noopener\">https://pixelsvsbytes.com/2011/09/sticky-css-footers-the-flexible-way/</a></li>\n</ul>\n<h4 id=\"固定高度的解决方案\"><a href=\"#固定高度的解决方案\" class=\"headerlink\" title=\"固定高度的解决方案\"></a><a href=\"http://play.csssecrets.io/sticky-footer-fixed\" target=\"_blank\" rel=\"noopener\">固定高度的解决方案</a></h4><p>我们可以通过计算给内容指定最小高度，然后就可以将页脚“固定”到底部：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"built_in\">calc</span>(100vh - 7em); <span class=\"comment\">/* 7em为页脚高度 */</span> </span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Flexbox-的解决方案\"><a href=\"#Flexbox-的解决方案\" class=\"headerlink\" title=\"Flexbox 的解决方案\"></a><a href=\"http://play.csssecrets.io/sticky-footer\" target=\"_blank\" rel=\"noopener\">Flexbox 的解决方案</a></h4><p>我们需要对 <code>&lt;body&gt;</code> 元素设置 display:flex，然后将其 min-height 属性指定为 100vh，这样它就至少会占据整个视口的高度；此时我们所期望的是，页头和页脚的高度由其内部元素来决定，而内容区块的高度应该可以自动伸展并占满所有的可用空间。我们只要给 <code>&lt;main&gt;</code> 这个容器的 flex 属性指定一个大于 0 的值(比如 1 即可)，就可以实现这个效果了:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-flow</span>: column;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">100vh</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123; <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"过渡与动画\"><a href=\"#过渡与动画\" class=\"headerlink\" title=\"过渡与动画\"></a>过渡与动画</h2><h3 id=\"缓动效果\"><a href=\"#缓动效果\" class=\"headerlink\" title=\"缓动效果\"></a>缓动效果</h3><p>在现实世界中，物体从 A 点到 B 点的移动往往不是完全匀速的</p>\n<h4 id=\"弹跳动画\"><a href=\"#弹跳动画\" class=\"headerlink\" title=\"弹跳动画\"></a><a href=\"http://play.csssecrets.io/bounce\" target=\"_blank\" rel=\"noopener\">弹跳动画</a></h4><p>CSS 提供了一个 cubic-bezier() 函数，允许我们指定自定义的调速函数，借助该函数，我们可以近乎完美的实现回弹动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> bounce &#123; </span><br><span class=\"line\">    60%, 80%, <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(400px);</span><br><span class=\"line\">        <span class=\"attribute\">animation-timing-function</span>: ease; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    70% &#123; <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(300px); &#125;</span><br><span class=\"line\">    90% &#123; <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(360px); &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.ball</span> &#123;</span><br><span class=\"line\">    /\\* 外观样式 */</span><br><span class=\"line\">    <span class=\"selector-tag\">animation</span>: <span class=\"selector-tag\">bounce</span> 3<span class=\"selector-tag\">s</span> <span class=\"selector-tag\">cubic-bezier</span>(<span class=\"selector-class\">.1</span>,<span class=\"selector-class\">.25</span>,1,<span class=\"selector-class\">.25</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"弹性过渡\"><a href=\"#弹性过渡\" class=\"headerlink\" title=\"弹性过渡\"></a><a href=\"http://play.csssecrets.io/elastic\" target=\"_blank\" rel=\"noopener\">弹性过渡</a></h4><p>同样是 cubic-bezier() 函数的使用：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:focus)</span> + <span class=\"selector-class\">.callout</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0); </span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">25s</span> transform;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.callout</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: <span class=\"number\">1.4em</span> -.<span class=\"number\">4em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">5s</span> <span class=\"built_in\">cubic-bezier</span>(.25,.1,.3,1.5) transform;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"逐帧动画\"><a href=\"#逐帧动画\" class=\"headerlink\" title=\"逐帧动画\"></a><a href=\"http://play.csssecrets.io/frame-by-frame\" target=\"_blank\" rel=\"noopener\">逐帧动画</a></h4><p>在很多时候，我们需要一个很难（或不可能）只通过某些 CSS 属性的过渡来实现的动画。但由于 GIF 不具备透明的特性，所以下面的加载提示只能用CSS动画实现：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_270.png\" alt=\"\" width=\"\"></div>\n\n<p>而如何实现这种逐帧动画效果呢？秘诀就是 steps() 这个调速函数，steps() 函数会使整个动画在帧与帧之间硬切，所以只需把动画的代码修改为下面的形式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">animation</span>: <span class=\"selector-tag\">loader</span> 1<span class=\"selector-tag\">s</span> <span class=\"selector-tag\">infinite</span> <span class=\"selector-tag\">steps</span>(8);</span><br></pre></td></tr></table></figure>\n<h3 id=\"闪烁效果\"><a href=\"#闪烁效果\" class=\"headerlink\" title=\"闪烁效果\"></a><a href=\"http://play.csssecrets.io/blink\" target=\"_blank\" rel=\"noopener\">闪烁效果</a></h3><p>这里涉及到的知识点是 animation-direction 中的 alternate 属性，它的作用是反转第偶数个循环周期（包括调整函数）：</p>\n<blockquote>\n<p>animation-direction: normal | alternate | reverse | alternate-reverse</p>\n</blockquote>\n<div align=\"center\"><img src=\"/images/hexo_post_271.png\" alt=\"\" width=\"\"></div>\n\n<h3 id=\"打字动画\"><a href=\"#打字动画\" class=\"headerlink\" title=\"打字动画\"></a><a href=\"http://play.csssecrets.io/typing\" target=\"_blank\" rel=\"noopener\">打字动画</a></h3><p>CSS 值与单位规范引入了一个新单位，表示“0”字形的宽度，叫做 ch ；在等宽字体中，“0” 字形的宽度和其他所有字形的宽度是一样的，所以如果我们用 ch 单位来表达一段文本的宽度，那取值实际上就是字符的数量；最后，我们可以借助上面的闪烁动画的原理来实现文字后面闪烁的光标</p>\n<h3 id=\"状态平滑的动画\"><a href=\"#状态平滑的动画\" class=\"headerlink\" title=\"状态平滑的动画\"></a><a href=\"http://play.csssecrets.io/state-animations\" target=\"_blank\" rel=\"noopener\">状态平滑的动画</a></h3><p>我们需要根据用户的交互行为来暂停动画和继续之前的动画状态，从而避免生硬的跳回现象，而 animation-play-state 正是为这种暂停动画的需求专门设计的：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> panoramic &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123; <span class=\"attribute\">background-position</span>: <span class=\"number\">100%</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.panoramic</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>; <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"img/naxos-greece.jpg\"</span>); </span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: auto <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: panoramic <span class=\"number\">10s</span> linear infinite alternate; </span><br><span class=\"line\">    <span class=\"attribute\">animation-play-state</span>: paused;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.panoramic</span><span class=\"selector-pseudo\">:hover</span>, <span class=\"selector-class\">.panoramic</span><span class=\"selector-pseudo\">:focus</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">animation-play-state</span>: running;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"沿环形路径平移的动画\"><a href=\"#沿环形路径平移的动画\" class=\"headerlink\" title=\"沿环形路径平移的动画\"></a>沿环形路径平移的动画</h3><p>我们需要让一个元素沿着环形路径动起来，同时元素中的内容（图片、文字）不能发生旋转</p>\n<h4 id=\"需要两个元素的解决方案\"><a href=\"#需要两个元素的解决方案\" class=\"headerlink\" title=\"需要两个元素的解决方案\"></a><a href=\"http://play.csssecrets.io/circular-2elements\" target=\"_blank\" rel=\"noopener\">需要两个元素的解决方案</a></h4><p>我们让元素旋转，同时让其中的内容以相反的方向进行自转，从而可以抵消元素旋转的影响，由此可见，我们可以用 animation-direction 来实现这样的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> spin &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123; <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(1turn); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.avatar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: spin <span class=\"number\">3s</span> infinite linear; </span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: <span class=\"number\">50%</span> <span class=\"number\">150px</span>; <span class=\"comment\">/* 150px = 路径的半径 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.avatar</span> &gt; <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: inherit; </span><br><span class=\"line\">    <span class=\"attribute\">animation-direction</span>: reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"单个元素的解决方案\"><a href=\"#单个元素的解决方案\" class=\"headerlink\" title=\"单个元素的解决方案\"></a><a href=\"http://play.csssecrets.io/circular\" target=\"_blank\" rel=\"noopener\">单个元素的解决方案</a></h4><blockquote>\n<p>“transform-origin 只是一个语法糖而已。实际上你总是可以用 translate() 来代替它。” ——Aryeh Gregor</p>\n</blockquote>\n","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"CSS布局问题总结","slug":"CSS布局问题总结","date":"2017-07-04T10:17:27.000Z","updated":"2019-01-27T10:07:12.316Z","comments":true,"path":"api/articles/CSS布局问题总结.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_22.png","content":"<p>本文主要对 CSS 中常见的布局问题进行了总结，同时提供了解决方案和一些参考链接，涉及到三栏式布局（圣杯、双飞翼），居中布局等等；感兴趣的童鞋可以点击来源链接查看原文，因为本文是基于原文进行整理的，所以内容会比原文精简。</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><ul>\n<li><a href=\"http://zh.learnlayout.com/\" target=\"_blank\" rel=\"noopener\">学习CSS布局</a>（排版和配色比较舒服，简短不深入，适合入门）</li>\n<li><a href=\"http://www.barelyfitz.com/screencast/html-training/css/positioning/\" target=\"_blank\" rel=\"noopener\">10个文档学布局</a>（通过十个例子讲解布局，主要涉及相对布局，绝对布局和浮动）</li>\n</ul>\n<h2 id=\"三栏式布局\"><a href=\"#三栏式布局\" class=\"headerlink\" title=\"三栏式布局\"></a>三栏式布局</h2><p>涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_22.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>圣杯：父盒子包含三个子盒子（左，中，右）</p>\n<ul>\n<li>中间盒子的宽度设置为 <code>width: 100%;</code> 独占一行；</li>\n<li>使用负边距(均是 <code>margin-left</code>)把左右两边的盒子都拉上去和中间盒子同一行；<ul>\n<li><code>.left {margin-left:-100%;}</code> 把左边的盒子拉上去</li>\n<li><code>.right {margin-left：-右边盒子宽度px;}</code> 把右边的盒子拉上去</li>\n</ul>\n</li>\n<li>父盒子设置左右的 padding 来为左右盒子留位置；</li>\n<li>对左右盒子使用相对布局来占据 padding 的空白，避免中间盒子的内容被左右盒子覆盖；</li>\n</ul>\n<h4 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> 中间的<span class=\"attr\">div</span>必须写在最前面 <span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"middle\"</span>&gt;</span>中间内容区<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>左边栏<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span>右边栏<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/</span></span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">0</span> <span class=\"number\">200px</span> <span class=\"number\">0</span> <span class=\"number\">180px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.middle</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;<span class=\"comment\">/*左栏上去到第一行*/</span></span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">180px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>:-<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#0c9</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/</span></span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:-<span class=\"number\">180px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>:-<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#0c9</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/</span></span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:-<span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h3><p>双飞翼：父盒子包含三个子盒子（左，中，右），中间的子盒子里再加一个子盒子。</p>\n<ul>\n<li>中间盒子的宽度设置为 <code>width: 100%;</code> 独占一行；</li>\n<li>使用负边距(均是 <code>margin-left</code>)把左右两边的盒子都拉上去和中间盒子同一行；</li>\n<li>在中间盒子里面再添加一个 div，然后对这个 div 设置 <code>margin-left</code> 和 <code>margin-right</code>来为左右盒子留位置；</li>\n</ul>\n<h4 id=\"HTML结构-1\"><a href=\"#HTML结构-1\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> 中间的<span class=\"attr\">div</span>必须写在最前面 <span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"middle\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"middle-inner\"</span>&gt;</span>中间弹性区<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>左边栏<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span>右边栏<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"CSS-1\"><a href=\"#CSS-1\" class=\"headerlink\" title=\"CSS\"></a>CSS</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.middle</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.middle-inner</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">210px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgba</span>(33, 114, 214, 0.8);</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">500px</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgba</span>(255, 82, 0, 0.8);</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgba</span>(90, 243, 151, 0.8);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"圣杯和双飞翼异同\"><a href=\"#圣杯和双飞翼异同\" class=\"headerlink\" title=\"圣杯和双飞翼异同\"></a>圣杯和双飞翼异同</h3><p>圣杯布局和双飞翼布局解决的问题是一样的，都是两边定宽，中间自适应的三栏布局，<strong>中间栏要在放在文档流前面以优先渲染</strong>。</p>\n<ul>\n<li>两种方法基本思路都相同：三栏全部 float 浮动。首先让中间盒子 100% 宽度占满同一高度的空间，在左右两个盒子被挤出中间盒子所在区域时，使用 margin-left 的负值将左右两个盒子拉回与中间盒子同一高度的空间。接下来进行一些调整避免中间盒子的内容被左右盒子遮挡。</li>\n<li>主要区别在于 <strong>如何使中间盒子的内容不被左右盒子遮挡</strong>：<ul>\n<li>圣杯布局的方法：设置父盒子的 padding 值为左右盒子留出空位，再利用相对布局对左右盒子调整位置占据 padding 出来的空位；</li>\n<li>双飞翼布局的方法：在中间盒子里再增加一个子盒子，直接设置这个子盒子的 margin 值来让出空位，而不用再调整左右盒子。</li>\n</ul>\n</li>\n</ul>\n<p>简单说起来就是<strong>双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了，少设置几个属性</strong>。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"http://www.w3cplus.com/blog/104.html\" target=\"_blank\" rel=\"noopener\">CSS三栏布局——中间固定两边自适应宽度</a>：w3cplus 的文章，使用了双飞翼和浮动实现两侧定宽、中间自适应，也实现了两侧自适应、中间定宽</li>\n<li><a href=\"http://www.jianshu.com/p/f9bcddb0e8b4\" target=\"_blank\" rel=\"noopener\">简书 - 圣杯布局和双飞翼布局（前端面试必看）</a>：只讲了圣杯，不过特别详细</li>\n<li><a href=\"https://alistapart.com/article/holygrail\" target=\"_blank\" rel=\"noopener\">In Search of the Holy Grail</a>：圣杯布局的来源</li>\n<li><a href=\"http://ife.baidu.com/note/detail/id/1025\" target=\"_blank\" rel=\"noopener\">百度前端学院笔记 - 三栏式布局之双飞翼与圣杯</a>：百度前端学院学员的前端学习笔记</li>\n<li><a href=\"http://www.jianshu.com/p/549aaa5fabaa\" target=\"_blank\" rel=\"noopener\">简书 - margin为负值产生的影响和常见布局应用</a>：包括对自身的影响，对文档流的影响，以及一些在布局中的应用技巧(比如去除列表右边框，负边距+定位实现水平垂直居中，去除列表最后一个 li 元素的 border-bottom，多列等高)</li>\n</ul>\n<h2 id=\"居中布局\"><a href=\"#居中布局\" class=\"headerlink\" title=\"居中布局\"></a>居中布局</h2><p>强烈推荐<a href=\"https://css-tricks.com/centering-css-complete-guide/\" target=\"_blank\" rel=\"noopener\">Centering in CSS: A Complete Guide</a>这篇文章，非常全面的居中定位博客，包括各种情况下的水平居中，垂直居中和水平垂直居中方案。有展示示例及相应的 HTML 和 CSS 代码，这篇文章翻译总结如下：</p>\n<ul>\n<li>水平居中<ul>\n<li>对于行内元素(inline)：<code>text-align: center;</code></li>\n<li>对于块级元素(block)：设置宽度且 <code>marigin-left</code> 和 <code>margin-right</code> 是设成 auto</li>\n<li>对于多个块级元素：对父元素设置 <code>text-align: center;</code>，对子元素设置 <code>display: inline-block;</code>；或者使用 flex 布局</li>\n</ul>\n</li>\n<li>垂直居中<ul>\n<li>对于行内元素(inline)<ul>\n<li>单行：设置上下 pandding 相等；或者设置 <code>line-height</code> 和 <code>height</code> 相等</li>\n<li>多行：设置上下 pandding 相等；或者设置 <code>display: table-cell;</code> 和 <code>vertical-align: middle;</code>；或者使用 flex 布局；或者使用伪元素</li>\n</ul>\n</li>\n<li>对于块级元素(block)：下面前两种方案，父元素需使用相对布局<ul>\n<li>已知高度：子元素使用绝对布局 <code>top: 50%;</code>，再用负的 <code>margin-top</code> 把子元素往上拉一半的高度</li>\n<li>未知高度：子元素使用绝对布局 <code>position: absolute; top: 50%; transform: translateY(-50%);</code></li>\n<li>使用 Flexbox：选择方向，<code>justify-content: center;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>水平垂直居中<ul>\n<li>定高定宽：先用绝对布局 <code>top: 50%; left: 50%;</code>，再用和宽高的一半相等的负 margin 把子元素回拉</li>\n<li>高度和宽度未知：先用绝对布局 <code>top: 50%; left: 50%;</code>，再设置 <code>transform: translate(-50%, -50%);</code></li>\n<li>使用 Flexbox：<code>justify-content: center; align-items: center;</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><p><a href=\"https://segmentfault.com/a/1190000003931851\" target=\"_blank\" rel=\"noopener\">利用HTML和CSS实现常见的布局</a></p>\n","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"利用Github Pages搭建自己的个人博客","slug":"利用Github Pages搭建自己的个人博客","date":"2017-07-04T04:03:49.000Z","updated":"2019-01-27T10:07:12.324Z","comments":true,"path":"api/articles/利用Github Pages搭建自己的个人博客.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_242.png","content":"<p>这篇文章以我的亲身实验为基础，为大家讲解如何利用 Github Pages 搭建一个自己的个人博客，由于<a href=\"http://merrier.wang\">我的个人博客</a>已经拿 wordpress 搭建完成好久了，所以我就拿我 [github] (<a href=\"https://github.com/merrier/)中的另外一个项目作为试验，一步一步的截图引导大家将自己的\" target=\"_blank\" rel=\"noopener\">https://github.com/merrier/)中的另外一个项目作为试验，一步一步的截图引导大家将自己的</a> github 中的项目放到网上供其他人浏览，请注意，这都是免费的哦！不需要你购买域名和服务器，因为 github 帮你搞定了一切，最终实现的效果是下面这样的（可以看到，域名是 merrier.github.io，这是 github 为你提供的域名，\b该页面可以<a href=\"https://merrier.github.io/Magical-CSS/\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_242.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li>你需要有一个 github 账号</li>\n<li>如果想看到效果的话，你需要一个有 README.md / index.html 的项目</li>\n</ul>\n<h2 id=\"好戏开场\"><a href=\"#好戏开场\" class=\"headerlink\" title=\"好戏开场\"></a>好戏开场</h2><h3 id=\"gh-pages-分支\"><a href=\"#gh-pages-分支\" class=\"headerlink\" title=\"gh-pages 分支\"></a>gh-pages 分支</h3><p>基于上面的准备工作，我认为你现在应该在自己的 github 中有了一个用来向他人展示的项目，然后进入自己的项目，切换到 gh-pages 分支，没有的话创建一个就可以了：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_243.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"Theme选择\"><a href=\"#Theme选择\" class=\"headerlink\" title=\"Theme选择\"></a>Theme选择</h3><p>然后点击上面的 Settings 按钮，向下找到 Github Pages 模块：</p>\n<div align=\"center\"><img src=\"images/hexo_post_244.png\" alt=\"\" width=\"400\"></div>\n\n<p>然后在这里你可以选择一个主题（点击 Change theme 按钮，然后你就可以跳转到选择主题的页面），这些主题都是 github 给你免费提供的，我选择的是下面这款蓝色的主题，效果就是文章开头截图那样的：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_245.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"Done\"><a href=\"#Done\" class=\"headerlink\" title=\"Done\"></a>Done</h3><p>选择完主题之后再回到刚才有 Github Pages 的页面，github 会提示你现在可以通过某个URL访问你的页面了，此时你通过 github 提示的 URL 进行访问的话，显示的就是你项目根目录的 README.md / index.html 文件中的内容，这样就完成了！是不是很 easy！：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_246.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"现在已经不需要新建gh-pages分支了，任意分支都可以\"><a href=\"#现在已经不需要新建gh-pages分支了，任意分支都可以\" class=\"headerlink\" title=\"现在已经不需要新建gh-pages分支了，任意分支都可以\"></a>现在已经不需要新建gh-pages分支了，任意分支都可以</h3><ul>\n<li>在你选择完主题之后，github 会自动在你的项目根目录下创建一个 _config.yml 文件，内容大概是下面这个样子，合并代码时需要注意一下：</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">jekyll-theme-architect</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"在-Github-Pages-模块，你可以设置你自己的-custom-domain\"><a href=\"#在-Github-Pages-模块，你可以设置你自己的-custom-domain\" class=\"headerlink\" title=\"在 Github Pages 模块，你可以设置你自己的 custom domain\"></a>在 Github Pages 模块，你可以设置你自己的 custom domain</h3><p>比如设置成 <a href=\"http://www.example.com，此时别人就可以通过访问\" target=\"_blank\" rel=\"noopener\">www.example.com，此时别人就可以通过访问</a> <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 访问到你刚刚用 Github Pages 搭建的个人博客了</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><p><a href=\"http://www.pchou.info/ssgithubPage/2013-01-03-build-github-blog-page-01.html\" target=\"_blank\" rel=\"noopener\">一步步在GitHub上创建博客主页</a></p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[{"name":"Github","path":"api/tags/Github.json"}]}]}