{"total":120,"pageSize":10,"pageCount":12,"data":[{"title":"let和var到底有什么区别？","slug":"let和var到底有什么区别？","date":"2017-08-04T08:10:14.000Z","updated":"2019-05-05T03:15:41.357Z","comments":true,"path":"api/articles/let和var到底有什么区别？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>问题来自于stackoverflow：<a href=\"https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var-to-declare-a-variable\" target=\"_blank\" rel=\"noopener\">What’s the difference between using “let” and “var” to declare a variable?</a> 我们都知道 ES6 中引入了 let 声明，而 let 也一直被认为是声明“局部变量”，那么 let 和 var 到底有什么区别呢？</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>首先，从其定义本身，其区别之一是起作用的范围： var 起作用的范围是其最近的方法体，而 let 起作用的范围是其最近的包围块，所谓的“包围块”是有可能比方法体小的。但是<strong>如果都是全局作用域上声明的话，var 和 let 起作用的范围其实是一样的</strong> 除此之外，用 let 声明的变量在它们被声明之前是无法访问到的（有点类似于严格模式），举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'globalVar: '</span> + globalVar);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'globalLet: '</span> + globalLet);</span><br><span class=\"line\"><span class=\"keyword\">var</span> globalVar = <span class=\"string\">'globalVar'</span>;  <span class=\"comment\">//globalVar: undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> globalLet = <span class=\"string\">'globalLet'</span>;  <span class=\"comment\">//Uncaught ReferenceError: globalLet is not defined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"作为全局变量\"><a href=\"#作为全局变量\" class=\"headerlink\" title=\"作为全局变量\"></a>作为全局变量</h2><p>和 var 不同，用 let 声明的“全局变量”将不会作为属性赋给 window，简单的栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'go'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"string\">'able'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.me); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.i); <span class=\"comment\">// 'able'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在函数中声明\"><a href=\"#在函数中声明\" class=\"headerlink\" title=\"在函数中声明\"></a>在函数中声明</h2><p>当它们在函数体中声明时是一样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ingWithinEstablishedParameters</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> funclet = <span class=\"string\">'funclet'</span>; <span class=\"comment\">//作用域为函数体内部</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> funcvar = <span class=\"string\">'funcvar'</span>; <span class=\"comment\">//作用域为函数体内部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在循环体中声明\"><a href=\"#在循环体中声明\" class=\"headerlink\" title=\"在循环体中声明\"></a>在循环体中声明</h2><p>当我们在循环体中声明变量（例如 for）时，var 和 let 是有显著区别的：let 只在循环体内部可访问，而 var 在整个方法体中都可访问。还是个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allyIlliterate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//tuce在这里不可访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> tuce = <span class=\"number\">0</span>; tuce &lt; <span class=\"number\">5</span>; tuce++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//tuce只能在这里访问得到</span></span><br><span class=\"line\">        <span class=\"comment\">//所以每次循环之后tuce的值都会变</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//tuce在这里也不可访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">byE40</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//nish在这里可以访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">var</span> nish = <span class=\"number\">0</span>; nish &lt; <span class=\"number\">5</span>; nish++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//nish在整个方法体中都可以访问得到</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//nish在这里也可以访问</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明覆盖\"><a href=\"#声明覆盖\" class=\"headerlink\" title=\"声明覆盖\"></a>声明覆盖</h2><p>在严格模式下，var 允许你重新给一个变量赋值，但是 let 不允许：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'bar'</span>; <span class=\"comment\">// SyntaxError: Identifier 'me' has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"string\">'bar'</span>; <span class=\"comment\">// 没毛病，现在me就是bar了</span></span><br></pre></td></tr></table></figure>\n<p>虽然 let 和 var 在某些情况下是一样的行为表现，但还是推荐大家多使用 let，逐渐放弃 var 的使用。</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"ES6","path":"api/tags/ES6.json"}]},{"title":"在JS中如何清空一个数组？","slug":"在JS中如何清空一个数组？","date":"2017-08-04T07:30:29.000Z","updated":"2019-05-05T03:15:41.361Z","comments":true,"path":"api/articles/在JS中如何清空一个数组？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_277.png","content":"<p>问题来源于stackoverflow：<a href=\"https://stackoverflow.com/questions/1232040/how-do-i-empty-an-array-in-javascript\" target=\"_blank\" rel=\"noopener\">How do I empty an array in JavaScript?</a>。更多关于JS中数组的相关操作参见：<a href=\"/20170322/summary-of-array-method-in-js.html\">JS中数组方法总结</a> 比如我有如下数组：<code>A = [1, 2, 3, 4]</code>; 我如何清空它？</p>\n<h2 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A = [];\"></a>A = [];</h2><p>这个答案应该很好想到，因为很符合“从问题本身出发”的逻辑，既然我们想清空数组 A，那就清空喽~ 但是这个方法有一个弊端：如果你之前通过引用的方式 copy 了数组A，那么即使通过 <code>A = []</code> 将数组 A 清空了，你的引用变量也还是 A 原来的值，理论知识总是难理解，举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1;  <span class=\"comment\">//arr2是arr1的一个引用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2 === arr1)  <span class=\"comment\">//arr2和arr1共享内存地址</span></span><br><span class=\"line\">arr1 = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);  <span class=\"comment\">//['a', 'b', 'c', 'd', 'e', 'f']，此时arr2和arr1就互相不认识了</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"A-length-0\"><a href=\"#A-length-0\" class=\"headerlink\" title=\"A.length = 0\"></a>A.length = 0</h2><p>因为在 JS 中数组其实也是一个对象（所谓的“数组对象”），而每个数组都有一个 length 属性，这是一个可读写的属性，将其置为 0 之后就可以清空数组。同时它的引用变量也将被清空：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'f'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1;  <span class=\"comment\">// 我胡汉三又来引用了</span></span><br><span class=\"line\">arr1.length = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);  <span class=\"comment\">//[]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);  <span class=\"comment\">//[]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1 === arr2)  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"A-splice-0-A-length\"><a href=\"#A-splice-0-A-length\" class=\"headerlink\" title=\"A.splice(0, A.length)\"></a>A.splice(0, A.length)</h2><p>和上面的通过 length 清空类似，该方法也将同时清空数组 arr2。不同点在于，.splice() 方法将返回一个数组</p>\n<h2 id=\"while-和-pop\"><a href=\"#while-和-pop\" class=\"headerlink\" title=\"while 和 .pop()\"></a>while 和 .pop()</h2><p>这是一个比较“愚蠢”的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(A.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    A.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法同样会清空数组 arr2，但是也是效率最低的一种方法</p>\n<h2 id=\"while和-shift\"><a href=\"#while和-shift\" class=\"headerlink\" title=\"while和.shift()\"></a>while和.shift()</h2><p>一般“愚蠢”的方法不止一种。。：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(A.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    A.shift();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h2><p>可以<a href=\"http://jsben.ch/hyj65\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看这四种方法的性能测试结果，或者直接看下图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_277.png\" alt=\"\" width=\"500\"></div>\n\n<p>从图中可以很明显的看出来，<code>A.length = 0;</code> 这种方法是效率最高的，效率最低的是 pop 和 shift（不出所料啊。。）</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"数组","path":"api/tags/数组.json"}]},{"title":"jQuery事件：不要再(滥)用return false了","slug":"jQuery事件：不要再(滥)用return false了","date":"2017-08-03T10:25:21.000Z","updated":"2019-05-05T03:15:41.357Z","comments":true,"path":"api/articles/jQuery事件：不要再(滥)用return false了.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>无意中在 stackoverflow 上看到一个<a href=\"https://stackoverflow.com/questions/1357118/event-preventdefault-vs-return-false\" target=\"_blank\" rel=\"noopener\">关于jQuery中event.preventDefault()和return false的提问</a>，后来从评论中发现一篇<a href=\"https://web.archive.org/web/20160614140933/http://fuelyourcoding.com/jquery-events-stop-misusing-return-false/\" target=\"_blank\" rel=\"noopener\">关于这个问题的很不错的文章</a>，遂翻译了一下，希望能够帮助大家更好的理解 jQuery 中的 return false；当你刚开始学习 jQuery 中的事件时，也许你首先碰到的知识点就是“取消浏览器的默认行为”这一概念。比如，一个讲 click 的初级教程里可能会有如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a.toggle\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">\"#mydiv\"</span>).toggle();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 禁止浏览器访问'#'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面这个方法动态的控制 #mydiv 的显示与隐藏，然后取消了浏览器的默认行为——访问锚标签的 href，这是一个非常简单的例子，同时也让很多前端小白养成了使用 return false 取消浏览器默认行为的习惯。关于取消浏览器事件这一问题，我将从以下两个主题重点讲解：</p>\n<ul>\n<li>使用正确的方法：return false、preventDefault、stopPropagation 和 stopImmediatePropagation</li>\n<li>头部、底部或中间某个位置：我们应该在事件回调函数的哪个位置取消默认行为？</li>\n</ul>\n<h2 id=\"使用正确的方法\"><a href=\"#使用正确的方法\" class=\"headerlink\" title=\"使用正确的方法\"></a>使用正确的方法</h2><p>之所以 return false 被大量滥用，是因为它确实满足了我们的需求——超链接不再跳转，表单也不再提交等等，那么为什么我说好多人都误用了呢？</p>\n<h3 id=\"return-false-到底做了什么\"><a href=\"#return-false-到底做了什么\" class=\"headerlink\" title=\"return false 到底做了什么\"></a>return false 到底做了什么</h3><p>首先，大部分人都没有搞明白的是，jQuery 中的 return false 其实做了下面三件事：</p>\n<ol>\n<li><strong>event.preventDefault();</strong></li>\n<li><strong>event.stopPropagation();</strong></li>\n<li><strong>阻止剩下的代码执行，同时立即返回</strong></li>\n</ol>\n<p>“等一下”。你是不是很惊讶，大部分人用 return false 其实只是为了阻止默认行为，也就是上面的第一件事，另外两件其实根本不需要。上面3件事中，只有 event.preventDefault() 会取消默认行为。除非你真的打算阻止事件冒泡，否则使用 return false 将大大增加你的代码的脆弱性。让我们来看看现实应用中这种滥用是如何产生的： 我们有如下HTML代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"post\"</span>&gt;</span><br><span class=\"line\">    &lt;h2&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path/to/page\"</span>&gt;</span>My Page<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"content\"</span>&gt;</span><br><span class=\"line\">        Teaser text...</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>div&gt;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"post\"</span>&gt;</span><br><span class=\"line\">    &lt;h2&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path/to/other_page\"</span>&gt;</span>My Other Page<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"content\"</span>&gt;</span><br><span class=\"line\">        Teaser text...</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>现在我们想实现这样的功能：当用户点击标题链接时，跳转到相应的 div.content 上面，我们可能会写出这样的 jQuery 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$</span>) </span>&#123;</span><br><span class=\"line\">   $(<span class=\"string\">\"div.post h2 a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> a = $(<span class=\"keyword\">this</span>),</span><br><span class=\"line\">          href = a.attr(<span class=\"string\">'href'</span>), <span class=\"comment\">// \b获取href,</span></span><br><span class=\"line\">          content  = a.parent().next();</span><br><span class=\"line\">      content.load(href + <span class=\"string\">\" #content\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 取消链接跳转这种默认行为</span></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>目前，我们的页面一切正常。然后，我们又想要添加一个功能：当 div.post（或者它的子元素）被点击时，给当前被点击的 div.post 添加一个 “active” 类。所以，我们需要添加一个 click 事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> posts = $(<span class=\"string\">\"div.post\"</span>);</span><br><span class=\"line\">posts.click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    posts.removeClass(<span class=\"string\">\"active\"</span>);  <span class=\"comment\">// \b移除所有div.post的active类</span></span><br><span class=\"line\">    $(<span class=\"keyword\">this</span>).addClass(<span class=\"string\">\"active\"</span>);  <span class=\"comment\">// 给当前的div.post添加active类</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在测试一下，当我们点击标题链接的时候，它会起作用吗？不会！它不能起作用的原因是我们在点击事件中 return false 了。而 return false 实际上意味着执行了 event.preventDefault() 和 event.stopPropagation()。所以点击事件不会冒泡到 div.post 上，从而我们新添加的事件将不起作用。 当我们将正常绑定的事件和 live 以及 delegate 绑定的事件混用时，它也会出现问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).live(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的代码将不起作用</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"我们真正想要实现什么？\"><a href=\"#我们真正想要实现什么？\" class=\"headerlink\" title=\"我们真正想要实现什么？\"></a>我们真正想要实现什么？</h3><h4 id=\"preventDefault\"><a href=\"#preventDefault\" class=\"headerlink\" title=\"preventDefault()\"></a>preventDefault()</h4><p>在大多数场景下，当我们使用 return false 的时候，我们真正想要的其实是 e.preventDefault()。使用 preventDefault 的前提是你允许在你的函数中访问事件对象（在后面的例子中以 e 表示事件对象）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// e代表我们的事件对象</span></span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个方法就可以是实现取消默认行为，但是它不能阻止事件冒泡。但是，代码的功能越单一，它的可维护性就更强</p>\n<h4 id=\"stopPropagation\"><a href=\"#stopPropagation\" class=\"headerlink\" title=\"stopPropagation()\"></a>stopPropagation()</h4><p>有些时候我们只是想阻止事件冒泡，比如下面的栗子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"post\"</span>&gt;</span></span><br><span class=\"line\">    Normal text and then a <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path\"</span>&gt;</span>link<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> and then more text.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在，比如我们有一个非常“奇特”的需求：我们想让用户点击 div 中除了链接之外的任何地方都干一件事（可能是重定向到其他页面），然后还想让用户点击链接的时候可以正常跳转（从可用性的角度来看，这是一个非常糟糕的 idea。因为如果用户本意想点击链接却点到了其他地方，接下来发生的事情可能会让用户很吃惊，影响用户体验）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"div.post\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div.post a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在这里不要取消默认行为</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要阻止事件冒泡</span></span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，如果我们用 return false，那 div 的点击事件将永远不会触发，这样用户就不会被引导到正确的页面。</p>\n<h4 id=\"stopImmediatePropagation\"><a href=\"#stopImmediatePropagation\" class=\"headerlink\" title=\"stopImmediatePropagation()\"></a>stopImmediatePropagation()</h4><p>这个函数将阻止事件的进一步执行，即使是同一对象上绑定的不同事件。因为绑定到一个 dom 元素的所有事件都将按照它们被绑定的顺序执行。下面是一个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Do something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Do something else</span></span><br><span class=\"line\">   e.stopImmediatePropagation();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 这里将不会执行</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 这里也不会执行</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你认为这个例子看起来太假了，不得不说，是很假。然而，有时候这种情况确实会发生。当你构造更加复杂的代码时，代码结构会变得比较混乱，不同的组件和插件可能会给同一个 dom 元素添加事件。在这种情况下，正确的理解和使用 stopImmediatePropagation() 就显得尤为重要了。</p>\n<h4 id=\"return-false\"><a href=\"#return-false\" class=\"headerlink\" title=\"return false\"></a>return false</h4><p>只有当你同时需要 preventDefault() 和 stopPaopagation() 时，才需要使用 return false。与此同时，你的代码应该保证只有到回调函数的尾部才取消默认行为。我强烈反对您在为 jQuery 小白编写的实例中使用这个 return false。它会误导一些入门开发者，因为只有很清楚它的功能你才能正确的使用它。</p>\n<h2 id=\"头部，底部还是中间的某个地方？\"><a href=\"#头部，底部还是中间的某个地方？\" class=\"headerlink\" title=\"头部，底部还是中间的某个地方？\"></a>头部，底部还是中间的某个地方？</h2><p>之前，当你(滥)用 return false 时，它总是出现在函数的底部，或者至少在某个特定逻辑行的结尾处，因为它会组织后面的代码执行。但是我们有 e.preventDefault，所以我们有了更多选择。e.preventDefault 可以在函数执行过程中的任何时候调用。那么应该把它放在哪里呢？</p>\n<h3 id=\"在开发环境，它应该总是放在第一行\"><a href=\"#在开发环境，它应该总是放在第一行\" class=\"headerlink\" title=\"在开发环境，它应该总是放在第一行\"></a>在开发环境，它应该总是放在第一行</h3><p>对于一个表单，你想做的最后一件事往往是，你希望通过 ajax 的方式将表单提交到另一个网页，同时你尝试在回调函数中调试 JavaScript 产生的 bug</p>\n<h3 id=\"在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\"><a href=\"#在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\" class=\"headerlink\" title=\"在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\"></a>在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾</h3><p>如果你是在一个开发完的页面上添加功能，那么你的链接点击事件或者表单提交事件需要对于不支持 JS 的浏览器的服务器端的反馈。这里的好处在于，与不支持 JS 的浏览器无关，而是你的代码在那些浏览器中会抛出错误。下面有一个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.preventDefault(); <span class=\"comment\">// 取消默认行为</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 抛出一个错误，因为my是undefined</span></span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append(data.my.link);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 链接将不起作用</span></span><br><span class=\"line\">    <span class=\"comment\">// JS的执行将终端，用户将不知所措</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在，让我们看一下同样的问题出现在 preventDefault 放在末尾时候的表现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// \b抛出错误，因为my是undefined</span></span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append(data.my.link);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 这里将不会执行，此时你的网页将使用“href”</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    e.preventDefault(); <span class=\"comment\">// 取消默认行为</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个例子同样适用于表单提交事件，可以让你有适当的回退选择。所以，千万不要指望你的代码永远都会正确执行。计划好回退方案比盼望着不会报错要好得多！</p>\n<h3 id=\"在生产环境中，如果你的功能只与-JS-有关，请放在第一行\"><a href=\"#在生产环境中，如果你的功能只与-JS-有关，请放在第一行\" class=\"headerlink\" title=\"在生产环境中，如果你的功能只与 JS 有关，请放在第一行\"></a>在生产环境中，如果你的功能只与 JS 有关，请放在第一行</h3><p>它不一定是函数中的第一行，但是它应该在你的程序逻辑中的最开始位置。原因是这样的：如果功能的这一部分一开始是与 JS 相关的，那么回退就不是那么必要了。在这种情况下，回退只是会造成一个随机的“#”出现在 URL 中或者页面跳转的区别。很明显，我们需要做的事提供尽可能多的错误处理方案，从而确保用户不会觉得它们的努力是白费的。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我希望这篇文章在你对于取消事件进行选择时提供了足够多的信息。记住只有在你真正需要 return false 时采去使用它，同时确保在你的回调函数的正确位置取消了默认行为。程序员的目标就是让你的代码尽可能的灵活，所以不要再用 return false 了！</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"jQuery","path":"api/tags/jQuery.json"}]},{"title":"JS中的apply、call和bind","slug":"JS中的apply、call和bind","date":"2017-08-03T08:30:08.000Z","updated":"2019-05-05T03:15:41.357Z","comments":true,"path":"api/articles/JS中的apply、call和bind.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>关于 JS 中的 apply、call 和 bind，网上的相关文章实在是太多了，但是对于我这种比较重视基础的人来说，感觉大部分文章都讲不到点子上，不乏无脑复制粘贴之辈，所以我在参考了一些资料之后，决定用比较容易理解的方式来讲解，同时会用更多的实例来说明它们之间的区别。</p>\n<h2 id=\"为什么会有它们仨\"><a href=\"#为什么会有它们仨\" class=\"headerlink\" title=\"为什么会有它们仨\"></a>为什么会有它们仨</h2><p>首先，哲学中有一句话：</p>\n<blockquote>\n<p>存在即合理</p>\n</blockquote>\n<p>所以，JS 中为什么会有它们仨呢？让我们来一看一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cat</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cat.prototype=&#123;     </span><br><span class=\"line\">    food:<span class=\"string\">\"fish\"</span>,     </span><br><span class=\"line\">    say: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;          </span><br><span class=\"line\">    alert(<span class=\"string\">\"I love \"</span>+<span class=\"keyword\">this</span>.food);     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> blackCat = <span class=\"keyword\">new</span> cat;</span><br><span class=\"line\">blackCat.say();</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，也是我们经常会碰到的，就是我们定义了一个 cat 类，然后 blackCat 是 cat 类的一个实例， cat 类有一个 say 方法。那么问题来了，如果我们又有一个对象叫做 <code>whiteDog={food:&quot;bone&quot;}</code>，我们想让 whiteDog 也有 cat 类的 say 方法，那应该怎么办呢？所以这时候就体验出它们仨的作用了，我们可以通过下面的方式让 whiteDog 也有 say 方法：</p>\n<ul>\n<li>blackCat.say.call(whiteDog)</li>\n<li>blackCat.say.apply(whiteDog)</li>\n<li>blackCat.say.bind(whiteDog)()</li>\n</ul>\n<p>通过上面这个“猫与狗”的栗子，我们可以总结出 apply、call 和 bind 的共同点，就是它们都是为了改变函数体内部 this 的指向，也就是为了改变某个函数运行时的上下文（context）而存在的（JavaScript 的函数存在【定义时上下文】、【运行时上下文】和【上下文是可以改变的】这样的概念，具体参见简书-波同学的文章：<a href=\"http://www.jianshu.com/p/a6d37c77e8db\" target=\"_blank\" rel=\"noopener\">前端基础进阶（二）：执行上下文详细图解</a>）</p>\n<h2 id=\"bind-的独特性\"><a href=\"#bind-的独特性\" class=\"headerlink\" title=\"bind 的独特性\"></a>bind 的独特性</h2><p>通过上面的调用方式你可能发现了一些端倪，就是 bind 在调用之后还需要加一个“()”，这就是 call、apply 它们和 bind 的区别了：</p>\n<ul>\n<li>只传一个参数时，call 和 apply 都是对函数的直接调用</li>\n<li>而 bind 方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以</li>\n</ul>\n<p>也许你又有疑问了，一般我们的方法都会有参数的，如果有参数的话应该如何调用呢？我们再举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'asd'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">29</span> ,</span><br><span class=\"line\">  sayname: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i, j</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.name + <span class=\"string\">'是'</span> + <span class=\"keyword\">this</span>.age+i+j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 =&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'aaa'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">30</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.sayname.apply(obj2,\\[<span class=\"string\">'男'</span>,<span class=\"number\">180</span>\\]);</span><br><span class=\"line\">obj1.sayname.call(obj2,<span class=\"string\">'女'</span>,<span class=\"number\">167</span>);</span><br><span class=\"line\">obj1.sayname.bind(obj2,<span class=\"string\">'x'</span>,<span class=\"number\">150</span>)();</span><br><span class=\"line\">obj1.sayname.bind(obj2)(<span class=\"string\">'y'</span>,<span class=\"number\">110</span>);</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，我们可以直观的总结出如下几个知识点：</p>\n<ul>\n<li>call 后面的参数与 sayname 方法中是一一对应的</li>\n<li>apply 的第二个参数是一个数组，数组中的元素是和 sayname 方法中一一对应的（<strong>这其实就是和 call 最大的区别</strong>）</li>\n<li>bind 可以像 call 那样传参，但是由于 bind 返回的仍然是一个函数，还可以在调用的时候再进行传参</li>\n</ul>\n<h2 id=\"apply、call-的区别\"><a href=\"#apply、call-的区别\" class=\"headerlink\" title=\"apply、call 的区别\"></a>apply、call 的区别</h2><p>通过上面的栗子，我们可以看到，bind 和 apply、call 是有本质上的区别的，所以我们先讲 apply 和 call 这一对“近亲”。对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg1 + arg2);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过如下方式来调用：</p>\n<ul>\n<li>func.call(this, arg1, arg2);</li>\n<li>func.apply(this, [arg1, arg2]);</li>\n</ul>\n<p>其中 this 是你想指定的上下文，它可以是任何一个 JavaScript 对象，而不同点在于：call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 因此，如果你的参数明确知道数量的话，就用 call。而不确定的时候用 apply，然后把参数 push 进数组再传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数，所以也有人用一句话区分 apply 和 call：<code>foo.call(this, arg1, arg2, arg3) == foo.apply(this, arguments) == this.foo(arg1, arg2, arg3)</code></p>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><p>JS 中存在一种名为伪数组的对象结构，比较特别的是 arguments 对象，还有像调用 getElementsByTagName，document.childNodes 之类的，它们返回 NodeList 对象都属于<strong>伪数组（也有文章描述这类对象为“类数组对象”）</strong>，不能应用 Array 下的 push，pop 等方法。但是我们能够通过 Array.prototype.slice.call 将带有 length 属性的对象转换为真正的数组，这样 domNodes 就可以应用 Array 下的所有方法了。</p>\n<h2 id=\"一道面试题\"><a href=\"#一道面试题\" class=\"headerlink\" title=\"一道面试题\"></a>一道面试题</h2><p>可能你还是不太理解上面的“当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数”这句话，下面通过一道面试题，来更深入的理解 apply 和 call：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们定义一个log方法，让它可以代理console.log方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">msg</span>)　</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">1</span>);    <span class=\"comment\">//1</span></span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>上面定义的方法可以解决最基本的需求，但是有一个问题在于：当传入参数的个数是不确定的时候，上面的方法就失效了。这个时候，因为传入多少个参数是不确定的，所以使用 apply：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">log(<span class=\"number\">1</span>);    <span class=\"comment\">//1</span></span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">//1 2</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们又有一个需求，就是给每一个 log 信息添加一个 “(app)” 的前缀，比如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"string\">\"hello world\"</span>);    <span class=\"comment\">//(app)hello world</span></span><br></pre></td></tr></table></figure>\n<p>我们该如何实现呢？这个时候需要想到 arguments 参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法 unshift，像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  args.unshift(<span class=\"string\">'(app)'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"bind-详解\"><a href=\"#bind-详解\" class=\"headerlink\" title=\"bind 详解\"></a>bind 详解</h2><p>apply 和 call 就介绍完了，下面我们再介绍一下有些特殊的 bind。MDN 上对于 bind 的解释是：</p>\n<blockquote>\n<p>bind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n</blockquote>\n<p>我表示看完还是不懂，所以还是直接看实例来的痛快：在常见的单例模式中，通常我们会使用 _this, that, self 等保存 this，这样我们可以在改变了上下文之后继续引用到它。像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar : <span class=\"number\">1</span>,</span><br><span class=\"line\">    eventBind: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        $(<span class=\"string\">'.someClass'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(_this.bar);     <span class=\"comment\">//1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 Javascript 特有的机制，上下文环境在 eventBind: function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar : <span class=\"number\">1</span>,</span><br><span class=\"line\">    eventBind: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'.someClass'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.bar);      <span class=\"comment\">//1</span></span><br><span class=\"line\">        &#125;.bind(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码里，bind() 创建了一个函数，当这个 click 事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用 bind() 时传入的参数）。因此，这里我们传入想要的上下文 this (其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。</p>\n<h3 id=\"再来一个简单的栗子：\"><a href=\"#再来一个简单的栗子：\" class=\"headerlink\" title=\"再来一个简单的栗子：\"></a>再来一个简单的栗子：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo);</span><br><span class=\"line\">func(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。</p>\n<h3 id=\"连续-bind\"><a href=\"#连续-bind\" class=\"headerlink\" title=\"连续 bind()\"></a>连续 bind()</h3><p>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sed = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo).bind(sed);</span><br><span class=\"line\">func(); <span class=\"comment\">//?</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> fiv = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class=\"line\">func(); <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure>\n<p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在 Javascript 中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind(),故第二次以后的 bind 是无法生效的。</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h2><p>最近发现“总结一下”很好用，因为可以堂而皇之的给自己的文章增加很多篇幅，同时还可以显得高大上：</p>\n<ul>\n<li><strong>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</strong></li>\n<li><strong>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</strong></li>\n<li><strong>apply 、 call 、bind 三者都可以利用后续参数传参；</strong></li>\n<li><strong>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。</strong></li>\n</ul>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/coco1s/p/4833199.html\" target=\"_blank\" rel=\"noopener\">【优雅代码】深入浅出 妙用Javascript中apply、call、bind</a></li>\n<li><a href=\"http://www.jianshu.com/p/f17a7b5efc5d\" target=\"_blank\" rel=\"noopener\">javascript call apply bind this指向和区别</a></li>\n<li><a href=\"http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html\" target=\"_blank\" rel=\"noopener\">关于javascript中apply()和call()方法的区别</a></li>\n<li><a href=\"https://www.zhihu.com/question/20289071\" target=\"_blank\" rel=\"noopener\">如何理解和熟练运用js中的call及apply？</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply\" target=\"_blank\" rel=\"noopener\">What is the difference between call and apply?</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"}]},{"title":"理解JS中的内存分配","slug":"理解JS中的内存分配","date":"2017-08-03T02:06:42.000Z","updated":"2019-05-05T03:15:41.365Z","comments":true,"path":"api/articles/理解JS中的内存分配.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_113.jpeg","content":"<h2 id=\"原始值和引用值\"><a href=\"#原始值和引用值\" class=\"headerlink\" title=\"原始值和引用值\"></a>原始值和引用值</h2><p>在 ECMAScript 中，变量可以存放两种类型的值，即原始值和引用值；原始值：原始数据类型（简单类型）的值，即undefined、null、Number、String、Boolean 类型所表示的值；引用值：复合数据类型（对象类型）的值，即Object、Function、Array 以及自定义对象等</p>\n<h2 id=\"栈和堆\"><a href=\"#栈和堆\" class=\"headerlink\" title=\"栈和堆\"></a>栈和堆</h2><p>与原始值和引用值对应存在两种结构的内存，即栈和堆</p>\n<h3 id=\"栈和原始值\"><a href=\"#栈和原始值\" class=\"headerlink\" title=\"栈和原始值\"></a>栈和原始值</h3><p>栈是一种后进先出的数据结构，在 JS 中可以通过 Array（数组）来模拟栈的行为 原始值是存储在栈中的简单数据，也就是说，它们的值直接存储在变量访问的位置</p>\n<h3 id=\"堆和引用值\"><a href=\"#堆和引用值\" class=\"headerlink\" title=\"堆和引用值\"></a>堆和引用值</h3><p>堆是基于散列算法的数据结构，在 JS 中，引用值是存放在堆中的 引用值是存储在堆中的对象，也就是说，存储在变量处的值（即指向对象的变量，存储在栈中）是一个指针，指向存储在堆中的实际对象</p>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><p>通过上面的讲解，我们可以得到如下简单的结论：</p>\n<ul>\n<li><strong>简单类型都放在栈里</strong></li>\n<li><strong>对象类型都放在堆里，指向对象的指针放在栈里</strong></li>\n</ul>\n<p>假如我们有如下几个变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = &#123; <span class=\"attr\">m</span>: <span class=\"number\">20</span> &#125;  <span class=\"comment\">//地址假设为0x0012ff7c</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> e = &#123; <span class=\"attr\">m</span>: <span class=\"number\">20</span> &#125;  <span class=\"comment\">//重新开辟一段内存空间假设为0x0012ff8f</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e==d);  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>它们在实际存储时的内存空间占用是这样的：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_113.jpeg\" alt=\"\" width=\"600\"></div>\n\n<p>看到这里，你可能会问：为什么引用值要放在堆中，而原始值要放在栈中，不都是在内存中吗，为什么不放在一起呢？接下来，让我们来探索问题的答案！ 首先，请允许我再举个栗子:）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">id, name, age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bol = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = \\[<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"number\">100</span>,<span class=\"string\">\"笨蛋的座右铭\"</span>,<span class=\"number\">25</span>);</span><br></pre></td></tr></table></figure>\n<p>然后，我们来看一下分析图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_38.jpeg\" alt=\"\" width=\"400\"></div>\n\n<p>从上图我们可以看到，我们无法直接操纵堆中的数据，也就是说我们无法直接操纵对象，但我们可以通过栈中对对象的引用来操纵对象。</p>\n<h2 id=\"答案揭晓\"><a href=\"#答案揭晓\" class=\"headerlink\" title=\"答案揭晓\"></a>答案揭晓</h2><p>现在让我们来回答为什么引用值要放在堆中，而原始值要放在栈中的问题： 记住一句话：</p>\n<blockquote>\n<p>能量是守恒的，无非是时间换空间，空间换时间的问题</p>\n</blockquote>\n<p>堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008432611\" target=\"_blank\" rel=\"noopener\">从[]==![]为true来剖析JavaScript各种蛋疼的类型转换</a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html\" target=\"_blank\" rel=\"noopener\">理解js内存分配</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"数据结构","path":"api/tags/数据结构.json"},{"name":"内存","path":"api/tags/内存.json"}]},{"title":"JS中的==、===和Object.is","slug":"JS中的==、===和Object.is","date":"2017-08-02T12:07:47.000Z","updated":"2019-05-05T03:15:41.353Z","comments":true,"path":"api/articles/JS中的==、===和Object.is.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_51.png","content":"<p>在查阅了很多资料之后，我将在这篇文章对于 JS 中的 ==、===、Object.is 进行详细的讲解，所以这很有可能是一篇很长很长的“唠叨文”，但是我相信你一定可以从这篇文章中收货很多，所以抖擞精神，往下看吧！</p>\n<h2 id=\"比较操作\"><a href=\"#比较操作\" class=\"headerlink\" title=\"比较操作\"></a>比较操作</h2><p>首先，你需要知道 JavaScript 提供了三种不同的值比较操作：</p>\n<ul>\n<li>严格相等（’triple equals’或’identity’），即 “===”</li>\n<li>宽松相等（’double equals’），即 “==”</li>\n<li>Object.js（ECMAScript 2015/ES6 新特性）</li>\n</ul>\n<p>现在考虑表达式 x==y，当 x 和 y 的类型相同时，x==y 可以转化为 x===y，而对于后者是很简单的，因为不涉及到类型转换，只需要注意：</p>\n<ul>\n<li>+0 ==(=) -0  //true</li>\n<li>NaN ==(=) NaN  //false</li>\n</ul>\n<p>对于上面这两种，你可以理解为 JavaScript 设计的问题（其实还是那句老话，王八的屁股——规定！），所以只需要死记硬背就可以了，当然还有两个长得像的 Object 也不相等，表现在：</p>\n<ul>\n<li>[] ==(=) []  //false</li>\n<li>{} ==(=) {}  //false</li>\n</ul>\n<p>之所以两个长得像的对象和数组都不相等，是因为在JS中，数组和对象是复杂数据类型，所以其实比较的是引用值，所以任意两个长得像的对象都不相等，具体参见：<a href=\"/20170803/understanding-memory-allocation-in-js.html\">理解JS中的内存分配</a>。ES6 中新增了 Object.is() 方法，它和 “===” 是基本相同的，除了下面这两种情况：</p>\n<ul>\n<li>Object.is(+0, -0)  //false</li>\n<li>Object.is(NaN, NaN)  //true</li>\n</ul>\n<p>所以你可以理解为 Object.is() 其实是对 “===” 的修正。“===” 和 Object.is() 介绍完了，下面就着重介绍一下 “==”（因为 JS 中的 “==” 会将等号两边进行类型转换，所以情况比较复杂）</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h2><p>“==” 在比较前会将比较的值转换为相同类型，在转换后（等式的一边或两边都可能被转换），最终的比较方式就等同于全等操作符 “===”。同时请注意，“===” 满足交换律，但是 “==” 不满足交换律（比如![]和{}）。先来看一张吊炸天的图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_51.png\" alt=\"\" width=\"600\"></div>\n\n<p><strong>我们接下来的讲解都建立在这张图上面：</strong></p>\n<h3 id=\"有和无\"><a href=\"#有和无\" class=\"headerlink\" title=\"有和无\"></a>有和无</h3><p>从这张图我们可以明显的看出，它们被分成了两个阵营：</p>\n<ul>\n<li>String、Number、Boolean 和 Object（对应左侧）</li>\n<li>undefined 和 null（对应右侧）</li>\n</ul>\n<p>分组的依据是什么呢？就是左侧是一个存在的世界，右侧是一个空的世界。所以就有如下规则：</p>\n<ul>\n<li>左侧任意 == 右侧任意  // false</li>\n</ul>\n<p>也就是左右两个世界中的任意值做 “==” 比较的结果都是 false</p>\n<h3 id=\"空和空\"><a href=\"#空和空\" class=\"headerlink\" title=\"空和空\"></a>空和空</h3><p>JavaScript 中的 undefined 和 null 是另一个经常让我们崩溃的地方。通常它被认为是一个设计缺陷，这一点我们不去深究。不过我曾听说，JavaScript 的作者最初是这样想的：</p>\n<blockquote>\n<p>假如你打算把一个变量赋予对象类型的值，但是现在还没有赋值，那么你可以用 null 表示此时的状态(证据之一就是 typeof null 的结果是 ‘object’)；相反，假如你打算把一个变量赋予原始类型的值，但是现在还没有赋值，那么你可以用 undefined 表示此时的状态。</p>\n</blockquote>\n<p>不管这个传闻是否可信，它们两者做 == 比较的结果是 true 是很合理的。(见上图中右侧垂直线上标的 true，也就是 <code>undefined == null</code>)</p>\n<h3 id=\"P和N\"><a href=\"#P和N\" class=\"headerlink\" title=\"P和N\"></a>P和N</h3><p>依然是上面那张图，从图中可以看到两个符号：大写字母 N 和 P：N 表示 ToNumber 操作，即将操作数转为数字。它是规范中的抽象操作，但我们可以用 JS 中的 Number() 函数来等价替代；P 表示 ToPrimitive 操作，即将操作数转为原始类型的值。它也是规范中的抽象操作，同样也可以翻译成等价的 JS 代码，但是会比 ToNumber 复杂一些，所以我们后面会详细解释。  </p>\n<h4 id=\"ToPrimitive\"><a href=\"#ToPrimitive\" class=\"headerlink\" title=\"ToPrimitive\"></a>ToPrimitive</h4><p>我们先讲 ToPrimitive，因为 ToNumber 中会用到 ToPrimitive，下面是关于 ToPrimitive 的规范：</p>\n<blockquote>\n<p>ToPrimitive 运算符接受一个值和一个可选的期望类型作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原始类型，可以使用可选的期望类型来暗示那个类型。根据下表完成转换：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>null</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>String</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>返回该对象的默认值。对象的默认值由把期望类型传入作为hint参数调用对象的内部方法 <code>[[DefaultValue]]</code> 得到</td>\n</tr>\n</tbody>\n</table>\n<p>对于 Object 这种输入类型，上面的表格中的描述不够清楚，我查了一些资料，概括如下：MDN 上对于 ToPrimitive 的语法规范定位为：</p>\n<blockquote>\n<p>ToPrimitive(obj, preferredType)</p>\n</blockquote>\n<p><strong>在执行 ToPrimitive(obj, preferredType) 时如果第二个参数为空并且 obj 为 Date 的实例时，此时 preferredType 会被设置为 String，其他情况下 preferredType 都会被设置为 Number</strong>。如果 preferredType 为 Number，ToPrimitive 执行过程如下：</p>\n<ol>\n<li>如果 obj 为原始值，直接返回；</li>\n<li>否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</li>\n<li>否则调用 obj.toString()，如果执行结果是原始值，返回之；</li>\n<li>否则抛异常。</li>\n</ol>\n<p>如果 preferredType 为 String，将上面的第 2 步和第 3 步调换，即：</p>\n<ol>\n<li>如果 obj 为原始值，直接返回；</li>\n<li>否则调用 obj.toString()，如果执行结果是原始值，返回之；</li>\n<li>否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</li>\n<li>否则抛异常。</li>\n</ol>\n<p>接下来我们就开始介绍v alueOf() 和 toString() 以及原始值了：</p>\n<h3 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf()\"></a>valueOf()</h3><p>valueOf 方法返回对象的原始值，可能是字符串、数值或 bool 值等，看具体的对象。还是看具体的例子吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"obj\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.valueOf());<span class=\"comment\">//Object &#123;name: \"obj\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = \\[<span class=\"number\">1</span>\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.valueOf());<span class=\"comment\">//\\[1\\]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date.valueOf());<span class=\"comment\">//1456638436303</span></span><br><span class=\"line\"><span class=\"comment\">//如代码所示，三个不同的对象实例调用valueOf返回不同的数据</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>toString 方法用来返回对象的字符串表示</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString());<span class=\"comment\">//\\[object Object\\]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = \\[\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.toString());<span class=\"comment\">//\"\"，即空字符串</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date.toString());<span class=\"comment\">//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>\n<p>这个方法具体的运行机制是个比较复杂的过程，我之后会专门写一篇文章讲解这两个方法，可以尝试搜索一下。（当然，也可以自己在控制台敲一下，加深印象）</p>\n<h3 id=\"原始值（Primitive）\"><a href=\"#原始值（Primitive）\" class=\"headerlink\" title=\"原始值（Primitive）\"></a>原始值（Primitive）</h3><p>“原始值”这三个字虽然听上去很高大上，其实很容易理解，就是指 null、undefined、String、Boolean、Number 这五种基本数据类型之一。 花了这么大力气终于把 ToPrimitive 介绍完了，下面我们介绍一下 ToNumber：</p>\n<h3 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h3><p>ToNumber 运算符根据下表将其参数转换为数值类型的值：</p>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>null</td>\n<td>+0</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>如果参数是true，结果为1。如果参数是false，结果为+0</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>String</td>\n<td>下面会介绍</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>“应用下列步骤：1.设原始值为ToPrimitive(输入参数，暗示数值类型)；2.返回ToNumber(上面的原始值)”</td>\n</tr>\n</tbody>\n</table>\n<p>上面表格已经很清楚了，但是还有个 ToNumber(String 类型)没有介绍：</p>\n<h4 id=\"字符转数字\"><a href=\"#字符转数字\" class=\"headerlink\" title=\"字符转数字\"></a>字符转数字</h4><p>字符转数字的规则是这样的：把字符串两边的空白字符去掉，然后把两边的引号去掉，看它能否组成一个合法的数字。如果能，转化结果就是这个数字，否则结果就是 NaN。举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'123'</span>) <span class=\"comment\">//结果123</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'1.2e3'</span>) <span class=\"comment\">//结果1200</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'123abc'</span>) <span class=\"comment\">//结果NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'\\\\r\\\\n\\\\t123\\\\v\\\\f'</span>) <span class=\"comment\">//结果123</span></span><br></pre></td></tr></table></figure>\n<p>当然也有例外，比如空白字符串转换为数字的结果是 0。即：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">''</span>) <span class=\"comment\">// 结果+0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'\\\\r\\\\n\\\\t \\\\v\\\\f'</span>) <span class=\"comment\">// 结果+0</span></span><br></pre></td></tr></table></figure>\n<p>到目前为止，我们介绍完了 ToPrimitive 和 ToNumber，所以上面那张图的内容基本上就介绍完了。但是还有个运算符没有讲，就是 “!” 取非操作，下面就介绍一下这个看似简单的取非操作：</p>\n<h3 id=\"ToBoolean\"><a href=\"#ToBoolean\" class=\"headerlink\" title=\"ToBoolean\"></a>ToBoolean</h3><p>取非其实是执行了 ToBoolean 运算符之后再取反，ToBoolean 运算符根据下表将其参数转换为布尔值类型的值：</p>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>false</td>\n</tr>\n<tr>\n<td>null</td>\n<td>false</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>结果等于输入的参数</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>如果参数是+0，-0或NaN，结果为false；否则结果为true</td>\n</tr>\n<tr>\n<td>String</td>\n<td>如果参数时空字符串（长度为零），结果为false；否则为true</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"没图你说个\"><a href=\"#没图你说个\" class=\"headerlink\" title=\"没图你说个**\"></a>没图你说个**</h3><p>相等操作符 (==) 对于不同类型的值，进行的比较如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_276.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"万物皆数\"><a href=\"#万物皆数\" class=\"headerlink\" title=\"万物皆数\"></a>万物皆数</h2><p>我们再来看上面那张图，里面标有 N 或 P 的那几条连线是没有方向的。假如我们在这些线上表上箭头，使得连线从标有 N 或 P 的那一端指向另一端，那么就会得到：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_50.png\" alt=\"\" width=\"300\"></div>\n\n<p>聪明的你肯定发现了，在 == 运算过程中，所有类型的值都有一种向数字类型转化的趋势。毕竟有这样一句名言：</p>\n<blockquote>\n<p>万物皆数</p>\n</blockquote>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>前面废话一堆，还不如举个实例来的痛快：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] == ![]</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">首先你需要明确的是上面这段代码执行的顺序，这就涉及到运算符的优先级了：`</span>! &gt; ==<span class=\"string\">`。所以 ! 取反运算符的优先级会高于 ==，那让我们先来看等号右边的 “!\\[\\]”，根据上面的 ToBoolean，**\\[\\]是一个对象**，那么 ToBoolean(\\[\\]) 就是 true，!\\[\\] 就是 false 了 然后，我们根据上面那张图，等号左边的 \\[\\] 是 Object，等号右边的 !\\[\\] 是一个 Boolean 值，所以最终就成为了 ToPrimitive(\\[\\]) == ToNumber(false) 了；而 ToPrimitive 默认调用 toString 方法，于是 ToPrimitive(\\[\\]) 就是空字符串，而 ToNumber(false) 就是 0；那么最后就成为了 \"\" == 0，这种形态，此时是 String 和 Number 之间的比较，很明显就是 toNumber(\"\") == 0 的比较了，根据 ToNumber 的转换规则，toNumber(\"\")=0，于是 \\[\\] == !\\[\\] 最后成了 0 == 0 的问题，答案显而易见为 true。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 总结一下</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">最后，我们总结一下 == 运算的规则：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* undefined == null，结果是 true。且它俩与所有其他值比较的结果都是 false。</span></span><br><span class=\"line\"><span class=\"string\">* String == Boolean，需要两个操作数同时转为 Number。</span></span><br><span class=\"line\"><span class=\"string\">* String/Boolean == Number，需要 String/Boolean 转为 Number。</span></span><br><span class=\"line\"><span class=\"string\">* Object == Primitive，需要 Object 转为 Primitive(具体通过 valueOf 和 toString方法)。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">所以，其实只有 4 条规则！只要我们完全理解了这四条规则，以后再遇到 == 就不会头疼了！</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 一些经典题目</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">\\[\\]==\\[\\]  <span class=\"comment\">//false</span></span><br><span class=\"line\">&#123;&#125;==&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">\\[\\]==!\\[\\]  <span class=\"comment\">//true</span></span><br><span class=\"line\">&#123;&#125;==!&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">&#123;&#125;==!\\[\\]  <span class=\"comment\">//VM1896:1 Uncaught SyntaxError: Unexpected token ==</span></span><br><span class=\"line\">!\\[\\]==&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">\\[\\]==!&#123;&#125;  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span>==<span class=\"literal\">null</span>  <span class=\"comment\">//true</span></span><br><span class=\"line\">+<span class=\"number\">0</span> === <span class=\"number\">-0</span>  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>  <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> !== <span class=\"literal\">false</span>  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>更新自2017-8-4：根据<a href=\"https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric\" target=\"_blank\" rel=\"noopener\">stackoverflow上的一个讨论</a>，我发现还有如下规则：2e308 === Infinity，原因是<strong>2e308 &gt; Number.MAX_VALUE</strong>，所以其相当于是无穷大，负无穷大同理。</p>\n</blockquote>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness\" target=\"_blank\" rel=\"noopener\">JavaScript 中的相等性判断</a></li>\n<li><a href=\"http://dorey.github.io/JavaScript-Equality-Table/\" target=\"_blank\" rel=\"noopener\">JS比较表</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008432611\" target=\"_blank\" rel=\"noopener\">从[]==![]为true来剖析JavaScript各种蛋疼的类型转换</a></li>\n<li><a href=\"http://www.admin10000.com/document/9242.html\" target=\"_blank\" rel=\"noopener\">通过一张简单的图，让你彻底地、永久地搞懂JS的==运算</a></li>\n<li><a href=\"https://www.zhihu.com/question/31442029\" target=\"_blank\" rel=\"noopener\">Javascript 中 == 和 === 区别是什么？</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"运算符","path":"api/tags/运算符.json"}]},{"title":"函数声明VS函数表达式","slug":"函数声明VS函数表达式","date":"2017-08-02T07:16:07.000Z","updated":"2019-05-05T03:15:41.361Z","comments":true,"path":"api/articles/函数声明VS函数表达式.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>本篇文章译自某大牛的文章：<a href=\"https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/\" target=\"_blank\" rel=\"noopener\">Function Declarations vs. Function Expressions</a>，推荐英语不是很差的童鞋点击前面链接看原文。首先先做个小测验，下面四个例子的 alert 输出分别是什么？</p>\n<p><strong>例子一：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>例子二：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>例子三：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(foo());</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>例子四：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p>我就直接公布答案了：8，3，3 和 [Type Error:bar is not a function]。如果你没有完全答对或者直接翻到这里看答案，那你可以继续往下看了。</p>\n<h2 id=\"什么是函数声明-function-declaration\"><a href=\"#什么是函数声明-function-declaration\" class=\"headerlink\" title=\"什么是函数声明(function declaration)\"></a>什么是函数声明(function declaration)</h2><p>函数声明定义了一个命名的函数变量，而不需要变量赋值。函数声明是一种独特的结构，并且不能嵌套在非函数体中。我们可以将函数声明看做是变量声明的另一种形式，就像变量声明必须以 “var” 开头一样，函数声明必须以 “function” 关键字开头。下面就是一个很简单的函数声明实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ECMA 5(13.0) 中对于函数声明的定义：</p>\n<blockquote>\n<p>function_Identifier_ ( _FormalParameterList_opt ) { <em>FunctionBody</em> }</p>\n</blockquote>\n<p>需要注意的是，函数名在它本身的作用于以及它的父级作用域都是可见的（这是一个很不错的规则，因为不然的话在外面将无法访问到该函数）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">bar() <span class=\"comment\">//3</span></span><br><span class=\"line\">bar  <span class=\"comment\">//function</span></span><br><span class=\"line\">bar === <span class=\"built_in\">window</span>.bar  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是函数表达式-function-expression\"><a href=\"#什么是函数表达式-function-expression\" class=\"headerlink\" title=\"什么是函数表达式(function expression)\"></a>什么是函数表达式(function expression)</h2><p>函数表达式将一个函数定义为一个很长的表达式的一部分（通常是一个变量赋值表达式）。以“函数表达式”方式命名的函数可以是命名的也可以是匿名函数。<strong>函数表达式不能以 “function” 关键字开头</strong>（所以下面的第三个表达式需要用 “()” 包裹）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//匿名函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//命名函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//自调用函数表达式</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"hello!\"</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>和函数声明相反，<strong>函数表达式的函数名（如果有的话）在它的作用域之外是不可见的</strong></p>\n<h2 id=\"那函数语句-function-statement-又是什么呢？\"><a href=\"#那函数语句-function-statement-又是什么呢？\" class=\"headerlink\" title=\"那函数语句(function statement)又是什么呢？\"></a>那函数语句(function statement)又是什么呢？</h2><p>函数语句有时候只是函数声明的另一种叫法。然而，按照<a href=\"http://yura.thinkweb2.com/named-function-expressions/#function-statements\" target=\"_blank\" rel=\"noopener\">Kangax的说法</a>，Mozilla 认为函数语句是对于函数声明的扩展，它允许在任何允许使用语句的地方使用函数声明这种语法。但是，这是非行业标准，所以不推荐用于生产环境。</p>\n<h2 id=\"好像忘了上面四个例子\"><a href=\"#好像忘了上面四个例子\" class=\"headerlink\" title=\"好像忘了上面四个例子\"></a>好像忘了上面四个例子</h2><p>让我们回到文章开头那四个例子 首先，<strong>例子一是两个函数声明，所以这两个函数声明被“提升”了</strong></p>\n<h3 id=\"等一下，什么叫做被“提升”？\"><a href=\"#等一下，什么叫做被“提升”？\" class=\"headerlink\" title=\"等一下，什么叫做被“提升”？\"></a>等一下，什么叫做被“提升”？</h3><p>援引 <a href=\"http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting\" target=\"_blank\" rel=\"noopener\">Ben Cherry文章</a>中的一段话：</p>\n<blockquote>\n<p>Function declarations and function variables are always moved (‘hoisted’) to the top of their JavaScript scope by the JavaScript interpreter</p>\n</blockquote>\n<p>翻译一下就是：函数声明和函数变量总会被 Javascript 解释器移动（提升）到它们的 JavaScript 作用域的顶端（我希望你能够认认真真的理解一下上面这句话，如果还是不理解，没关系，继续向下看）;当函数声明被提升时，整个函数体都将随之提升。所以在解释器对例子一中的代码进行解析过后，它其实是这样的（建议回过头看一下例子一的代码，对比着看会更容易理解）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例子一实际执行时的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//\b第一次定义函数bar</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//第二次定义函数bar，将之前的定义覆盖</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//return调用结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar(); <span class=\"comment\">//8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>但是，我们一直以来的“常识”是return语句后面的代码是不会执行的啊？</strong></p>\n<p>这就涉及到“执行上下文”和“执行过程”的概念了，ECMA5 将“执行上下文”分为“词法环境”、“变量环境 ”和“绑定 this”，而“执行过程”是指最终的代码执行过程。当执行到声明语句的时候，此时的声明语句就会进入到“变量环境”，它们与语句（比如说 return 语句）是不同的，是不受所谓的“前面代码先执行，后面代码后执行”的约束的。 （“执行上下文”这一概念对于本篇文章来说是个重点，如果依然不理解的话，可以读一下<a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/13/2308101.html\" target=\"_blank\" rel=\"noopener\">汤姆大叔</a>和<a href=\"http://www.jianshu.com/p/a6d37c77e8db\" target=\"_blank\" rel=\"noopener\">简书-波同学</a>的文章加深理解）</p>\n<h3 id=\"那么，函数表达式也会提升吗\"><a href=\"#那么，函数表达式也会提升吗\" class=\"headerlink\" title=\"那么，函数表达式也会提升吗\"></a>那么，函数表达式也会提升吗</h3><p>这取决于表达式本身，让我们继续看以下例子二中的第一个表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>左边的 var bar 是一个变量声明。根据上面的规则，变量声明会被提升，但是赋值表达式却没有（和函数声明不同，函数声明会将整个函数体提升）。因此当 bar 这个变量被提升时，解释器会将 bar 初始化为 <code>undefined：var bar = undefined</code>。所以例子二中的代码实际上以下面的顺序执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例子二实际执行时的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//函数表达式的变量声明（被提升，同时被解释器赋初始值undefined）</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"comment\">//第一个函数表达式被执行</span></span><br><span class=\"line\">    bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//第一个函数表达式创建的函数被执行了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"comment\">//第二个函数表达式将不会执行（但是变量声明被提升了，就在上面）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo()); <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"目前你应该已经理解的差不多了，但是如果你在-Firebug-中运行例子三的代码会不符合预期，这又是为什么呢？\"><a href=\"#目前你应该已经理解的差不多了，但是如果你在-Firebug-中运行例子三的代码会不符合预期，这又是为什么呢？\" class=\"headerlink\" title=\"目前你应该已经理解的差不多了，但是如果你在 Firebug 中运行例子三的代码会不符合预期，这又是为什么呢？\"></a>目前你应该已经理解的差不多了，但是如果你在 Firebug 中运行例子三的代码会不符合预期，这又是为什么呢？</h3><p>你可以试着将例子三的代码保存在一个 HTML 文件中，然后用 firefox 浏览器打开，或者在 IE 8，Chrome 或者 Safari 的 console 中执行。你就会发现，Firebug 的 console 并没有像其他浏览器一样在全局作用域（其实并不是全局作用域，而是特殊的 “Firebug” 作用域。。可以试着在 firebug 的控制台中打印一下 “this == window” 你就明白了）中有函数体提升的表现 所以，抛开 firefox 的“灵异表现”不管，例子三和例子一其实是相同的道理，只不过是函数 foo 被提升了而已。</p>\n<h3 id=\"现在我们可以看一下例子四了\"><a href=\"#现在我们可以看一下例子四了\" class=\"headerlink\" title=\"现在我们可以看一下例子四了\"></a>现在我们可以看一下例子四了</h3><p>很明显，例子四是没有函数提升的，但是变量提升是存在的（而且是两个），那么此时 bar 的声明就会提升，但是它的值没有定义（undefined），所以最后相当于执行 undefined()。最后当然就会报错了：<code>bar is not a function</code>。</p>\n<h2 id=\"那还应该注意些什么呢？\"><a href=\"#那还应该注意些什么呢？\" class=\"headerlink\" title=\"那还应该注意些什么呢？\"></a>那还应该注意些什么呢？</h2><p>目前，你应该能完全理解上面的四个例子了。还需要注意的一点是，函数声明在非函数体（如 if）中是被明令禁止的。然而，所有的浏览器其实都允许这样做，并且更可怕的是，<strong>每个浏览器对这种不符合规定的语法的解释还不同！</strong>，举个栗子，下面的代码片断在 firefox 3.6 中会抛出一个错误，因为它将函数声明解析为函数语句（函数语句已经在上面介绍过了），所以 x is not defined。然而在 IE8，Chrome5 和 Safari5 中，函数 x 被正常 return 了（就像标准的函数声明一样）。当然，鉴于这篇文章的原文年代比较久远，具体的还是要自己在 dev tool 中运行一下才能得出结论（可以试着将 if 中的 true 替换为 false 再运行一下看看）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<h2 id=\"既然函数声明会造成混论，那它的好处在哪里？\"><a href=\"#既然函数声明会造成混论，那它的好处在哪里？\" class=\"headerlink\" title=\"既然函数声明会造成混论，那它的好处在哪里？\"></a>既然函数声明会造成混论，那它的好处在哪里？</h2><p>通过上面的讨论，你会发现函数声明是“宽松”的——如果你在某个函数声明之前就调用它，“函数提升”的机制将使函数得到正常调用而不会报错。但是这种“宽松”缺乏严谨性，同时从长远来看，禁止“声明前调用”将更有利于开发者的编程习惯的养成（就像所谓的“弱类型”）。毕竟，开发者需要养成以特定的顺序编写代码的习惯。</p>\n<h2 id=\"函数表达式的优势呢？\"><a href=\"#函数表达式的优势呢？\" class=\"headerlink\" title=\"函数表达式的优势呢？\"></a>函数表达式的优势呢？</h2><p>说出来你可能不信:）首先，函数声明的方式好像在模仿 Java 中的方法声明，然而 Java 的方法和 JS 中的函数是两码事啊（原文是：<strong>Java methods are very different animals</strong>）：在 JavaScript 中，函数是具有值的 living object，而 Java 中的方法只是元数据存储结构。下面的两段代码片断都定义了函数但是只有函数表达式表明我们在创建一个对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b&#125;;</span><br><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b&#125;;</span><br></pre></td></tr></table></figure>\n<p>其次，<strong>函数表达式的用途更多</strong>。一个函数声明只能解释为一段孤立的语句。它能做的仅仅是创建一个以当前作用域为父域的变量对象。与之相反，函数表达式是一种更复杂的结构。如果你想创建一个匿名函数或者将某个函数分配给一个原型对象亦或作为某个其他对象的属性的话，你就可以用函数表达式来实现。每当你使用高阶应用程序（比如 curry 或 compose）创建一个函数时，你其实都是在应用函数表达式。所以，<strong>函数表达式和函数编程其实是密不可分的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHello = alert.curry(<span class=\"string\">\"hello!\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数表达式有缺点吗？\"><a href=\"#函数表达式有缺点吗？\" class=\"headerlink\" title=\"函数表达式有缺点吗？\"></a>函数表达式有缺点吗？</h2><p>一般情况下，通过函数表达式方式创建的函数都是匿名的。比如下面这段代码创建的函数是匿名的，today 只是对于匿名函数的引用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;</span><br></pre></td></tr></table></figure>\n<p>那匿名不匿名关系大吗？大多数情况下是没有的，但是正如 <a href=\"http://fitzgeraldnick.com/weblog/\" target=\"_blank\" rel=\"noopener\">Nick Fitzgerald</a> 所说，使用匿名函数进行调试有可能会很痛苦。所以他建议使用命名函数表达式（NFEs）作为一种替代方案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">today</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，正如 Asen Bozhilov 所说（以及 <a href=\"http://yura.thinkweb2.com/named-function-expressions/#jscript-bugs\" target=\"_blank\" rel=\"noopener\">Kangax 的文章</a>），NFEs 在 IE9 以下的浏览器中无法正常运行（在我看来，这并不是个大问题）</p>\n<h2 id=\"MD终于到结尾了\"><a href=\"#MD终于到结尾了\" class=\"headerlink\" title=\"MD终于到结尾了\"></a>MD终于到结尾了</h2><p>在错误的位置进行函数声明会误导别人，而且很少有（如果有）这种情况，就是你不能通过函数表达式的方法创建函数而必须用函数声明。当然，如果你必须要用函数声明，请将它们放在作用域顶端，这样可以减小误导性。同时，我绝不会在 if 语句中进行函数声明（这是明令禁止的）。 说了这么多（译者注：确实很多，翻译了好几个小时），你可能依然觉得有时候还是宁愿用函数声明。这其实很正常，盲目的遵守某些规则是愚蠢的，而且有时候会导致自己的代码很“丑陋”。最重要的是，你理解了上面介绍的这些概念和知识点，从而能够让你做出明智的决定。我希望这篇文章在这个方面能够对你有所帮助。 欢迎评论，如果你觉得我哪里说得不对（或者翻译的不对:））以及还有哪里需要补充的，欢迎留言或者通过其他方式联系我。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"函数","path":"api/tags/函数.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"为什么随机字符串“chucknorris”会被识别为红色？","slug":"为什么随机字符串“chucknorris”会被识别为红色？","date":"2017-08-01T10:35:30.000Z","updated":"2019-05-05T03:15:41.357Z","comments":true,"path":"api/articles/为什么随机字符串“chucknorris”会被识别为红色？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_274.png","content":"<p>这个问题来源于 <a href=\"https://stackoverflow.com/questions/8318911/why-does-html-think-chucknorris-is-a-color\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>，就是有位学者无意中发现随机字符串会被 html 识别为特定的一些颜色，于是就在 stackoverflow 发起了讨论，这个问题也引起了我的兴趣，虽然是一个比较偏的知识点，但是了解一下还是没坏处的。</p>\n<h2 id=\"题目解释\"><a href=\"#题目解释\" class=\"headerlink\" title=\"题目解释\"></a>题目解释</h2><p>从下图我们可以看到，“chucknorris” 是一个随机的字符串，但是 body 却被渲染成了红色，是不是很有趣？</p>\n<div align=\"center\"><img src=\"/images/hexo_post_274.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先你需要知道 css 中的颜色值是十六进制的（比如最通常的白色：”#FFFFFF”，黑色：”#000000”），所以对于随机的字符串来说，其中有可能会包含不属于十六进制字母的那些字母（比如 h、u、k 等等），那么就会有如下的规则对“随机字符串颜色”进行替换（以随机字符串 “chucknorris” 为例）：</p>\n<h3 id=\"首先，用’0’替换所有的非十六进制字母\"><a href=\"#首先，用’0’替换所有的非十六进制字母\" class=\"headerlink\" title=\"首先，用’0’替换所有的非十六进制字母\"></a>首先，用’0’替换所有的非十六进制字母</h3><p>chucknorris -&gt; c00c0000000  </p>\n<h3 id=\"然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加-‘0’，比如上面的-“c00c0000000”-就只有-11-个字母，需要在尾部添加一个-‘0’）\"><a href=\"#然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加-‘0’，比如上面的-“c00c0000000”-就只有-11-个字母，需要在尾部添加一个-‘0’）\" class=\"headerlink\" title=\"然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加 ‘0’，比如上面的 “c00c0000000” 就只有 11 个字母，需要在尾部添加一个 ‘0’）\"></a>然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加 ‘0’，比如上面的 “c00c0000000” 就只有 11 个字母，需要在尾部添加一个 ‘0’）</h3><p>c00c 0000 0000  </p>\n<h3 id=\"最后，对于每一组内的字符串，只取前两位字母作为最终的-“R”、“G”、“B”-的值\"><a href=\"#最后，对于每一组内的字符串，只取前两位字母作为最终的-“R”、“G”、“B”-的值\" class=\"headerlink\" title=\"最后，对于每一组内的字符串，只取前两位字母作为最终的 “R”、“G”、“B” 的值\"></a>最后，对于每一组内的字符串，只取前两位字母作为最终的 “R”、“G”、“B” 的值</h3><p>c00c 0000 0000 -&gt; RGB(c0, 00, 00)</p>\n<p>所以，最终的结果是 #c00000/rgb(192,0,0),就是最开始那张图显示的深红色。</p>\n<h2 id=\"还没完\"><a href=\"#还没完\" class=\"headerlink\" title=\"还没完\"></a>还没完</h2><p>所以这个问题的答案就是一个歇后语：王八的屁股——规定！当然了，对于那种不足六个字母的颜色值来说，就会有额外的处理规则了：#aaa -&gt; #aaaaaa、#aaa3 -&gt; #aaa300、#aaa35 -&gt; #aaa350，有一个“很有想法”的哥们专门为这个转换做了一个网页，可以<a href=\"http://randomstringtocsscolor.com/\" target=\"_blank\" rel=\"noopener\">点击这里</a>试玩一下，输入任意的字符串可以看到背景颜色的变化，同时可以看到最终的颜色值</p>\n<div align=\"center\"><img src=\"/images/hexo_post_275.png\" alt=\"\" width=\"500\"></div>","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"CSS","path":"api/tags/CSS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"}]},{"title":"JS中判断字符串中是否含有一个子串","slug":"JS中判断字符串中是否含有一个子串","date":"2017-08-01T07:33:27.000Z","updated":"2019-05-05T03:15:41.353Z","comments":true,"path":"api/articles/JS中判断字符串中是否含有一个子串.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_273.png","content":"<p>题目我就不过多解释了，这篇文章是对 <a href=\"https://stackoverflow.com/questions/1789945/how-to-check-whether-a-string-contains-a-substring-in-javascript\" target=\"_blank\" rel=\"noopener\">stackoverflow 上一个问题</a>的总结，如果英文不是特别差的话，推荐大家点击上面链接看大家对这个问题的详细讨论</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">string.indexOf(substring) !== <span class=\"number\">-1</span>;</span><br></pre></td></tr></table></figure>\n<p>String 的原型方法，返回一个字符串在另一个字符串中的位置，如果没有找到的话就返回 -1；也是大家经常用的方案</p>\n<h3 id=\"ES6-的-includes\"><a href=\"#ES6-的-includes\" class=\"headerlink\" title=\"ES6 的 includes\"></a>ES6 的 includes</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">string.includes(substring);</span><br></pre></td></tr></table></figure>\n<p>ES6 中新增的 String 原型方法（其实 Array 原型也有 includes 方法），可以<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看文档</p>\n<h3 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search\"></a>search</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;</span><br><span class=\"line\">string.search(expr);</span><br></pre></td></tr></table></figure>\n<p>String.prototype.search() 执行正则表达式和 String 对象之间的一个搜索匹配，所以参数需要是正则表达式，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看中文文档</p>\n<h3 id=\"lodash-的-includes\"><a href=\"#lodash-的-includes\" class=\"headerlink\" title=\"lodash 的 includes\"></a>lodash 的 includes</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">_.includes(string, substring);</span><br></pre></td></tr></table></figure>\n<p>lodash 是一个前端库，其提供了一些更加拥抱未来的方法，其中就有 _.includes(str,substr)</p>\n<h3 id=\"RegExp-和-test\"><a href=\"#RegExp-和-test\" class=\"headerlink\" title=\"RegExp 和 test\"></a>RegExp 和 test</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;  <span class=\"comment\">// no quotes here</span></span><br><span class=\"line\">expr.test(string);</span><br></pre></td></tr></table></figure>\n<p>“正则表达式是万能的”，RegExp.prototype.test(str)</p>\n<h3 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;</span><br><span class=\"line\">string.match(expr);</span><br></pre></td></tr></table></figure>\n<p>和上面的 test 正好相反，match 方式是 String 的原型方法，String.prototype.match(expr)</p>\n<h2 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h2><p>既然有这么多方法都可以实现，那么哪一种才是“性能最优”的方法呢？早就有前辈替我们做了测试，可以<a href=\"http://jsben.ch/#/RVYk7\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看测试结果，或者直接看下面这张图片：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_273.png\" alt=\"\" width=\"500\"></div>\n\n<p>不出所料，果然原生方法 indexOf() 是最快的，所以我们以后就还尽量用 indexOf() 吧！</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"}]},{"title":"总有那么一句话……","slug":"总有那么一句话……","date":"2017-08-01T03:34:27.000Z","updated":"2019-05-05T03:15:41.361Z","comments":true,"path":"api/articles/总有那么一句话…….json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_272.png","content":"<p>曾经有记者问朴灵：如果不做程序员，你最想做什么职业？朴灵是这样回答的：“如果不做程序员，我可能想做一个写作者。或者是教师。觉得骨子里有种将好东西分享出去的冲动。”其实在这一点上，我和朴灵是类似的，虽然高考语文只考了 108 分，但是我如果没有踏进互联网大门的话，可能会将更多的时间用在写作分享上。所以，这篇文章就是我用来和大家分享我想到、听到、看到的那些“一句话真言”，或哲理、或深刻、或讽刺、或扎心。你可以在闲暇时来看一下这篇文章，因为这篇文章会持续更新……</p>\n<blockquote>\n<p>叩首问路，码梦为生</p>\n</blockquote>\n<p>细心的同学可能发现了，我的个人博客的 title 就是这句话，这句话出自朴灵，后来被很多“文艺型码农”引用：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_272.png\" alt=\"\" width=\"500\"></div>\n\n<blockquote>\n<p>钱总要挣，家总要成，奔走红尘，莫忘曾经是书生</p>\n</blockquote>\n<p>这句话是一副对联的下联，原对联是“<strong>史亦尝考，文亦尝校，答辩近了，犹思几度改论稿；家总要成，钱总要挣，奔走红尘，莫忘曾经是书生。</strong>”出自<a href=\"http://www.thepaper.cn/newsDetail_forward_1422430\" target=\"_blank\" rel=\"noopener\">复旦大学教授陈正宏</a>，提醒我们在众多红尘琐事之外不要丢了书生本色。</p>\n<blockquote>\n<p>来了不后悔，走了不想再来</p>\n</blockquote>\n<p>这是微信公众号<a href=\"http://mp.weixin.qq.com/s/OcTtk9FWKrdRhDioGjtMYA\" target=\"_blank\" rel=\"noopener\">“十一姐的涂鸦馆”一篇文章</a>中的一句话，说的是衡中人对于衡中的评价，衡中在近几年一直受到“关注”，同时每年的高考时段也成为了衡中的批斗大会召开时间，但是作为一名衡中人，对于网上的种种言论我都是报以“无力吐槽”的心态，因为国内的舆论环境就是这样的，人云亦云，不乏找存在感的无量群众。</p>\n<blockquote>\n<p>TL;DR</p>\n</blockquote>\n<p>经常逛大牛的博客，有时候就会看到上面这句话，充满好奇心的我就查了一下，其实是 “Too Long;Don’t Read” 的意思，在一些国外的网站用来告诉读者：下面的叙述太长了，你要是没耐心就别读了。而在国内呢，大多数学者都将其理解为“长话短说”的意思，所以和国外相反，一般这句话下面的文章都会言简意赅……</p>\n<blockquote>\n<p>Winter is coming!</p>\n</blockquote>\n<p>来自很黄很暴力的《冰与火之歌》，中文翻译为“凛冬将至”，具体可以查看知乎：<a href=\"https://www.zhihu.com/question/46335767\" target=\"_blank\" rel=\"noopener\">“winter is coming”这句话该怎么翻译？</a></p>\n<blockquote>\n<p>经不住流年似水，逃不过此间少年</p>\n</blockquote>\n<p>来自<a href=\"https://book.douban.com/review/4639373/\" target=\"_blank\" rel=\"noopener\">《此间的少年》</a>，寓意珍惜时间，让我想起了另外一句诗“有花堪折直须折，莫待无花空折枝”</p>\n<blockquote>\n<p>炫耀从来不是我写作的动机，好奇才是</p>\n</blockquote>\n<p>这是<a href=\"http://www.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">阮一峰</a>老师的一句话，其实写作就是这样的，尤其是技术类的文章，就算你阅读了很多资料，时间仍然是你最大的敌人，因为技术更新换代实在太快了，我相信每一位写技术博客的作者都是抱着这种心态去写作的，我更不例外，所以希望大家能够多多评论，如果发现有哪些地方写的不严谨或者不正确的，欢迎留言指出，我会认真改正的。</p>\n<blockquote>\n<p>好看的皮囊千篇一律，有趣的灵魂万里挑一</p>\n</blockquote>\n<p>这句话的具体出处不详，有人说是高晓松，有人说是王尔德，具体是谁说的已经不重要了，重要的是这句话已经成为许多人口中的情话，你学到了吗？</p>\n<blockquote>\n<p>愿你走出半生，归来仍是少年</p>\n</blockquote>\n<p>出自一位初中生的作文，引发了很多人的共鸣。</p>\n<blockquote>\n<p>生活不止眼前的苟且，还有诗和远方</p>\n</blockquote>\n<p>也许我们的教育还要再加一门课——“抗挫折”，不管现在过得怎样，不管过去如何迷茫，未来总是不确定的，所以抬起头，面向远方吧。</p>\n<blockquote>\n<p>命运以痛吻我，我愿报之以歌。</p>\n</blockquote>\n<p>这是模仿了泰戈尔诗集里面的一句话：<strong>世界以痛吻我，我要报之以歌</strong>。 原文的意思是：面对这个世界的苦难和人生的挫折，我们需要满怀希望，用积极乐观的心态去面对。</p>\n<p>英文版：<strong>Destiny with pain kiss me, I will come with songs</strong></p>\n<blockquote>\n<p>生而为人，请务必善良</p>\n</blockquote>\n<p>这句话初听上去有点“无病呻吟”的感觉，但是经历的多了，就会发现，善良是一件简单但奢侈的东西。<strong>你可以不善良，但是请不要去伤害</strong>。</p>\n<blockquote>\n<p>每一个你想抵达的地方，都有人和你一样想逃离。</p>\n</blockquote>\n<p>来自<a href=\"https://mp.weixin.qq.com/s/CqoOcWM_Dg3vS_wAp7ILpw\" target=\"_blank\" rel=\"noopener\">杜蕾斯团队给京东做的新广告的文案</a>；我最喜欢的一句话是“知足常乐”，很多人都会因为羡慕（or 嫉妒 or 恨）别人而闷闷不乐，其实每个人都有专属自己的“小幸福”，知足才能常乐。</p>\n<blockquote>\n<p>卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭</p>\n</blockquote>\n<p>这句话是诗人北岛《回答》里面很著名的两句，有学者解读为：社会黑白不分，道德沦丧。这让我想到了电影《熔炉》里的一句话：<strong>我们要的不是改变世界，而是不让世界改变我们</strong>。（这个电影也很好看，是一部改变了韩国法律的电影）</p>\n<blockquote>\n<p>Stay hungry. Stay foolish.</p>\n</blockquote>\n<p>这句话最初是《Whole Earth Catalog》创办人斯图尔特·布兰特（Stewart Brand）说的；而后因为 2005 年乔布斯在斯坦福的演讲中引用过而出名，后来就开始被各方神圣引用；同时这句话的中文版本也有很多：</p>\n<ul>\n<li>保持饥饿。保持愚蠢。</li>\n<li>我傻我知道，我穷我努力。</li>\n<li><strong>求知若饥，虚心若愚。</strong></li>\n<li>求知。守拙。</li>\n<li>不知足。不卖弄。</li>\n<li>谦。虚。</li>\n<li>物有所不足，智有所不明。</li>\n<li>致虚极，守静笃。</li>\n<li>做个吃货，做个二货。</li>\n<li><strong>功成不息，坚守痴心。</strong></li>\n<li>守拙归园田。</li>\n<li>留在饥饿里。留在白痴里。</li>\n<li>保持渴望，固执愚见。</li>\n<li>朝三守四，二尽一来。</li>\n<li>保持饥渴觅成功，固守愚钝得精进。</li>\n</ul>\n<p>当然，如果你问我更倾向于哪种翻译，我想上面的加粗字体已经告诉了你答案~</p>\n<blockquote>\n<p>你说我是错的，那你最好证明你是对的 —— King of Pop</p>\n</blockquote>\n<p>这是 QQ 邮箱登录时看到的一句话，而 King of Pop 大家应该能猜出来了吧，说的就是迈克尔·杰克逊，这是 MJ 的一句歌词，原文是 “You say I’m wrong, but you’d better prove you’re right.”，而张小龙之所以选择这句话也是个蛮有意思的故事，大家看<a href=\"https://www.zhihu.com/question/29920558\" target=\"_blank\" rel=\"noopener\">知乎上关于这句话的讨论</a>就够了~</p>\n<blockquote>\n<p>在真正的开放社会里，人类没有 bug，只有 feature。</p>\n</blockquote>\n<p>最近关于同性恋是否属于“性变态”的话题上了热搜，其实在很早之前大家都认为同性恋是一种“疾病”，而到现在，大家都已经欣然接受了这一部分人群的存在，从一定程度上讲，这表明了社会的进步和真正的开放。</p>\n<blockquote>\n<p>待我代码编成，娶你为妻可好</p>\n</blockquote>\n<p>一个大牛说的一句话，为此还有个<a href=\"http://www.xuntayizhan.com/blog/ji-ke-ai-qing-zhi-er-shi-dai-wo-dai-ma-bian-cheng-qu-ni-wei-qi-ke-hao-wan/\" target=\"_blank\" rel=\"noopener\">我没看懂的小故事</a>。。</p>\n<blockquote>\n<p>佛为心，道为骨，儒为表，大度看世界； 技在手，能在身，思在脑，从容过生活。</p>\n</blockquote>\n<p>南怀瑾大师的一句话，用来指导在家的修行人的， 告诉他们如何在现代快速发展的经济社会中生活、修行。我等凡夫俗子是参悟不到其中的真谛了。。</p>\n<blockquote>\n<p>Talk is cheap, show me the code.</p>\n</blockquote>\n<p>翻译成中文就是：屁话少说，放码过来。——来自<a href=\"https://www.zhihu.com/question/23090743\" target=\"_blank\" rel=\"noopener\">知乎</a></p>\n<blockquote>\n<p>无人与我立黄昏，无人问我粥可温</p>\n</blockquote>\n<p>其实这是一句歌词，因七堇年的短文《浮生六记》而被众人误解，以为这一句出自沈复的《浮生六记》。原作者于 2015 年 5 月 30 日发表长微博解释。七堇年也发表了道歉微博。是陌緒（微博名）在 2012 年 6 月写的《寄芸》里的一句词。这首歌于 2012 年 8 月 27 日首发在<a href=\"http://5sing.kugou.com/fc/7245962.html\" target=\"_blank\" rel=\"noopener\">5sing</a>，署名为墨绪。<a href=\"https://www.zhihu.com/question/27056973\" target=\"_blank\" rel=\"noopener\">知乎</a>上有更多信息。</p>\n<blockquote>\n<p>one more thing</p>\n</blockquote>\n<p><code>One more thing</code> 是苹果前 CEO 史蒂夫·乔布斯的经典名言。史蒂夫·乔布斯在临近发布会结尾时酷酷地说一句“One More Thing”（还有件事儿），然后带来最大的惊喜。<a href=\"https://baike.baidu.com/item/One%20more%20thing/18462213\" target=\"_blank\" rel=\"noopener\">百度百科</a>上面有 <code>one more thing</code> 汇总，<a href=\"https://www.bilibili.com/video/av11880208/\" target=\"_blank\" rel=\"noopener\">哔哩哔哩</a>上面有视频版的汇总。</p>\n<blockquote>\n<p>向内认知，向外行走。</p>\n</blockquote>\n<p>出处不祥，具体含义见知乎：<a href=\"https://www.zhihu.com/question/273828010\" target=\"_blank\" rel=\"noopener\">向内认知，向外行走的意思是什么？</a></p>\n<blockquote>\n<p>但行好事，莫问前程</p>\n</blockquote>\n<p>但行好事，莫问前程的意思是自身要多做义举，做好当下，出自明代的《增广贤文》：但行好事，莫问前程。河狭水激，人急计生。明知山有虎，偏向虎山行。知乎有对这句话的讨论：<a href=\"https://www.zhihu.com/question/20979297\" target=\"_blank\" rel=\"noopener\">《但行好事，莫问前程，如何理解？》</a></p>\n<blockquote>\n<p>面试造航母，工作拧螺丝</p>\n</blockquote>\n<p>面试的时候问各种刁钻问题，结果真工作了就是各种复制粘贴+Google搜索。。道出了多少程序员的心声</p>\n<blockquote>\n<p>高度不够看到的都是问题，格局太小纠结的都是鸡毛蒜皮</p>\n</blockquote>\n<div align=\"center\"><img src=\"/images/hexo_post_347.jpeg\" alt=\"\" width=\"500\"></div>\n\n<p>比较鸡汤的一句话，但是不无道理</p>\n","raw":null,"categories":[{"name":"talk","path":"api/categories/talk.json"}],"tags":[{"name":"life","path":"api/tags/life.json"}]}]}