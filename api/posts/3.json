{"total":118,"pageSize":10,"pageCount":12,"data":[{"title":"机器学习概念入门","slug":"机器学习概念入门","date":"2017-11-02T14:23:08.000Z","updated":"2019-02-04T13:27:44.357Z","comments":true,"path":"api/articles/机器学习概念入门.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_287.png","content":"<p>最近在做毕设，需要用到一些机器学习的内容（不要问我为什么，做前端根本没办法毕业！），这篇文章是我看 bilibili 上<a href=\"https://www.bilibili.com/video/av12556478/\" target=\"_blank\" rel=\"noopener\">莫烦系列教程-Tensorflow教程</a>时候做的笔记，都是一些机器学习入门概念，如果你和我一样都是入门选手，我相信这些概念能够帮助到你~</p>\n<h2 id=\"什么是机器学习\"><a href=\"#什么是机器学习\" class=\"headerlink\" title=\"什么是机器学习\"></a>什么是机器学习</h2><p>机器学习是一帮计算机科学家想让计算机像人一样思考，所研发出来的计算机理论</p>\n<h2 id=\"机器学习分类\"><a href=\"#机器学习分类\" class=\"headerlink\" title=\"机器学习分类\"></a>机器学习分类</h2><h3 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h3><p>有数据和标签</p>\n<h3 id=\"非监督学习\"><a href=\"#非监督学习\" class=\"headerlink\" title=\"非监督学习\"></a>非监督学习</h3><p>只有数据，没有标签</p>\n<h3 id=\"半监督学习\"><a href=\"#半监督学习\" class=\"headerlink\" title=\"半监督学习\"></a>半监督学习</h3><p>结合了监督学习和非监督学习</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>从经验中总结提升</p>\n<h3 id=\"遗传算法\"><a href=\"#遗传算法\" class=\"headerlink\" title=\"遗传算法\"></a>遗传算法</h3><p>和强化学习类似，有着适者生存，不适者淘汰准则</p>\n<h2 id=\"什么是神经网络\"><a href=\"#什么是神经网络\" class=\"headerlink\" title=\"什么是神经网络\"></a>什么是神经网络</h2><p>神经网络是一种数学模型，是存在于计算机的神经系统，由大量的神经元相连接并进行计算，在外界信息的基础上，改变内部的结构，常用来对输入和输出间复杂的关系进行建模。</p>\n<p>神经网络由大量的节点和之间的联系构成，负责传递信息和加工信息，神经元也可以通过训练而被强化。</p>\n<h2 id=\"怎么检验神经网络\"><a href=\"#怎么检验神经网络\" class=\"headerlink\" title=\"怎么检验神经网络\"></a>怎么检验神经网络</h2><p>为了检验、评价神经网络，并努力改善这些问题，我们常会把收集到的数据分为<strong>训练数据</strong>和<strong>测试数据</strong>，一般用于训练的数据可以是全部数据的百分之 70，剩下的百分之 30 可以用来测试学习结果。接着，对于神经网络的评价，基本上基于这百分之 30 的测试结果。</p>\n<ul>\n<li>评价机器学习可以从误差这个值开始，随着训练时间的变长，优秀的神经网络能够预测到更精准的答案，预测的误差也会越小；</li>\n<li>除了误差曲线，我们也可以看它的精确度曲线，最好的精度是趋向于百分之百的精度；</li>\n<li>对于回归问题，我们可以采用 R2 score 作为评分标准；</li>\n<li>还有 F1 score 用来测量不均衡数据的精度。</li>\n</ul>\n<h2 id=\"什么叫过拟合\"><a href=\"#什么叫过拟合\" class=\"headerlink\" title=\"什么叫过拟合\"></a>什么叫过拟合</h2><p>如下图，训练时的误差比测试误差小，神经网络虽然学习到了知识，但是对于训练数据太过依赖，所以测试数据产生的误差会产生波谷，后面会变大。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_287.png\" alt=\"\" width=\"400\"></div>\n\n<p>在机器学习中，解决过拟合的方法也有很多，比如 <strong>L1，L2正规化</strong>和 <strong>Dropout方法</strong></p>\n<h2 id=\"什么是交叉验证\"><a href=\"#什么是交叉验证\" class=\"headerlink\" title=\"什么是交叉验证\"></a>什么是交叉验证</h2><p>交叉验证不仅可以用于神经网络的调参，还可以用于其他机器学习方法的调参，同样是选择你想观看的误差值或者精确度，不过横坐标不再是学习时间，而是你要测试的某一参数，比如说神经网络的层数。。</p>\n<h2 id=\"为什么要特征标准化\"><a href=\"#为什么要特征标准化\" class=\"headerlink\" title=\"为什么要特征标准化\"></a>为什么要特征标准化</h2><p>我们在机器学习训练之前, 先对数据预先处理一下, 取值跨度大的特征数据, 我们浓缩一下, 跨度小的括展一下, 使得他们的跨度尽量统一，这样可以<strong>提升学习效率</strong> 通常用于 特征标准化的途径有两种, 一种叫做 min max normalization, 他会将所有特征数据按比例缩放到 0-1 的这个取值区间. 有时也可以是 -1 到 1 的区间. 还有一种叫做 standard deviation normalization, 他会将所有特征数据缩放成平均值为 0, 方差为 1. 使用这些标准化手段. 我们不仅可以快速推进机器学习的学习速度, 还可以<strong>避免机器学习学得特扭曲</strong>.</p>\n<h2 id=\"区分好用的特征\"><a href=\"#区分好用的特征\" class=\"headerlink\" title=\"区分好用的特征\"></a>区分好用的特征</h2><p>在选择特征的时候,我们得要时刻回想起这三点.：</p>\n<ol>\n<li>避免无意义的信息</li>\n<li>避免重复性的信息</li>\n<li>避免复杂的信息</li>\n</ol>\n<p>这就是我们这次机器学习简介中所聊到的如何区分好用的特征</p>\n<h2 id=\"为什么需要激励函数\"><a href=\"#为什么需要激励函数\" class=\"headerlink\" title=\"为什么需要激励函数\"></a>为什么需要激励函数</h2><p>因为现实中的问题往往不是线性的，所以需要一个激励函数<strong>来扭曲原来的线性结果</strong> 你甚至可以创造自己的激励函数来处理自己的问题, 不过要确保的是这些激励函数必须是可以微分的, 因为在 backpropagation 误差反向传递的时候, 只有这些可微分的激励函数才能把误差传递回去. 在少量层结构中, 我们可以尝试很多种不同的激励函数. 在卷积神经网络 Convolutional neural networks 的卷积层中, 推荐的激励函数是 relu. 在循环神经网络中 recurrent neural networks, 推荐的是 tanh 或者是 relu</p>\n<h2 id=\"如何加速神经网络训练\"><a href=\"#如何加速神经网络训练\" class=\"headerlink\" title=\"如何加速神经网络训练\"></a>如何加速神经网络训练</h2><p>越复杂的神经网络，越多的数据，我们需要在训练神经网络的过程上花费的时间也就越多；原因很简单，就是因为计算量太大了。可是往往有时候为了解决复杂的问题, 复杂的结构和大数据又是不能避免的, 所以我们需要寻找一些方法, 让神经网络聪明起来, 快起来. 包括以下几种模式:</p>\n<ul>\n<li>Stochastic Gradient Descent (SGD)</li>\n<li>Momentum</li>\n<li>AdaGrad</li>\n<li>RMSProp</li>\n<li>Adam</li>\n</ul>\n<p>关于这几种方法的具体原理，可以<a href=\"https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-06-speed-up-learning/\" target=\"_blank\" rel=\"noopener\">点击这里</a>观看莫烦的讲解</p>\n<h2 id=\"如何处理不均衡数据\"><a href=\"#如何处理不均衡数据\" class=\"headerlink\" title=\"如何处理不均衡数据\"></a>如何处理不均衡数据</h2><p>不均衡的数据预测起来很简单. 永远都猜多的那一方面准没错. 没错, 机器也懂这个小伎俩. 所以机器学到最后, 学乖了, 每次都预测多数派. 解决的方法有几种, 我们来谈谈.</p>\n<h3 id=\"方法一：想办法获取更多数据\"><a href=\"#方法一：想办法获取更多数据\" class=\"headerlink\" title=\"方法一：想办法获取更多数据\"></a>方法一：想办法获取更多数据</h3><h3 id=\"方法二：更换评判方式\"><a href=\"#方法二：更换评判方式\" class=\"headerlink\" title=\"方法二：更换评判方式\"></a>方法二：更换评判方式</h3><p>通常, 我们会用到准确率 accuracy, 或者误差 cost 来判断机器学习的成果. 可是这些评判方法在不均衡数据面前, 高的准确率和低的误差变得没那么重要. 所以我们得换一种方式评判. 通过 confusion matrix 来计算 precision 和 recall, 然后通过 precision 和 recall 再计算f1 score.这种方式能成功地区分不均衡数据, 给出更好的评判分数.</p>\n<h3 id=\"方法三：重组数据\"><a href=\"#方法三：重组数据\" class=\"headerlink\" title=\"方法三：重组数据\"></a>方法三：重组数据</h3><p>这是最简单粗暴的方法之一，重新组合不均衡数据，使之均衡。有两种方式：</p>\n<ol>\n<li>复制或者合成少数部分的样本, 使之和多数部分差不多数量</li>\n<li>砍掉一些多数部分, 使两者数量差不多</li>\n</ol>\n<h3 id=\"方法四：使用其他机器学习方法\"><a href=\"#方法四：使用其他机器学习方法\" class=\"headerlink\" title=\"方法四：使用其他机器学习方法\"></a>方法四：使用其他机器学习方法</h3><p>如果使用的机器学习方法像神经网络等, 在面对不均衡数据时, 通常是束手无策. 不过有些机器学习方法, 像决策树, decision trees 就不会受到不均很数据的影响.</p>\n<h3 id=\"方法五：修改算法\"><a href=\"#方法五：修改算法\" class=\"headerlink\" title=\"方法五：修改算法\"></a>方法五：修改算法</h3><p>最后一种方法是让自己变得有创造力, 尝试修改算法. 如果你用的是 Sigmoid 的激励函数, activation function, 他会有一个<strong>预测门槛</strong>, 一般如果输出结果落在门槛的这一段,预测结果为梨, 如果落在这一段, 预测结果为苹果, 不过因为现在的梨是多数派, 我们得<strong>调整一下门槛的位置，</strong>使得门槛偏向苹果这边, 只有很自信的时候, 模型才会预测这是苹果. 让机器学习,学习到更好的效果.</p>\n<h2 id=\"什么是批标准化\"><a href=\"#什么是批标准化\" class=\"headerlink\" title=\"什么是批标准化\"></a>什么是批标准化</h2><p>和普通的数据标准化类似, 是将分散的数据统一的一种做法, 也是优化神经网络的一种方法. Batch normalization 的 batch 是批数据, <strong>把数据分成小批小批进行 stochastic gradient descent. 而且在每批数据进行前向传递 forward propagation 的时候, 对每一层都进行 normalization 的处理</strong> Batch normalization 也可以被看做一个层面. 在一层层的添加神经网络的时候, 我们先有数据 X, 再添加全连接层, 全连接层的计算结果会经过 激励函数 成为下一层的输入, 接着重复之前的操作. Batch Normalization (BN) 就被添加在每一个全连接和激励函数之间。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/e112012a4b2d\" target=\"_blank\" rel=\"noopener\">一文学会用 Tensorflow 搭建神经网络</a></li>\n</ul>\n","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"机器学习","path":"api/tags/机器学习.json"}]},{"title":"我为什么要写个人博客","slug":"我为什么要写个人博客","date":"2017-10-17T07:51:33.000Z","updated":"2019-02-04T13:27:44.357Z","comments":true,"path":"api/articles/我为什么要写个人博客.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>之前看到了一篇文章：<a href=\"http://www.cnblogs.com/zery/p/3343893.html\" target=\"_blank\" rel=\"noopener\">做为技术人员为什么要写博客</a>，作者写的很真诚，也说出了很多技术人员的心声，然后，我后来又看到了一篇文章：<a href=\"http://blog.jobbole.com/18251/\" target=\"_blank\" rel=\"noopener\">为什么有些技术人员不写博客？</a>，这篇文章篇幅较短，虽然看题目好像是一篇介绍“不写博客”的，但是看完之后才发现，其实作者还是推荐大家写博客。。作为众多拥有个人博客的技术人员之一，我也斗胆谈一下我为什么要写个人博客？</p>\n<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>其实我从小学开始就喜欢收藏和总结，记得小学的时候流行那种或圆形或方形的卡片，我就收藏了很多；然后初中之后就收藏烟盒（这个习惯到目前还有）；后来到大学之后，和计算机打交道比较多，就将一些好用的软件和工具记录下来；研究生期间开始做前端，看到写的好的技术类文章就保存到有道云笔记里，虽然有些可能一直放在里面后来再也没看过。。 所以，其实总结和个人习惯是密切关联的，这也是我写博客的初衷。</p>\n<h2 id=\"导火线\"><a href=\"#导火线\" class=\"headerlink\" title=\"导火线\"></a>导火线</h2><p>虽然写博客的想法很早之前就有，但是就像上面那两篇文章里说的，那时候觉得自己水平有限，就算写出来恐怕也是哗众取宠，无人问津罢了，同时也不知道是去某个平台写还是自己搭建一个网站，这件事情就暂时搁置了；后来到研二的时候，需要找实习了，而前端知识繁杂，找实习之前脑子里还一头雾水，就打算趁着这个机会把当初那个小愿望实现了吧。。 淫僧就是如此的奇妙，找实习就成为了我写博客的导火线。</p>\n<h2 id=\"wordpress？\"><a href=\"#wordpress？\" class=\"headerlink\" title=\"wordpress？\"></a>wordpress？</h2><p>其实，目前有很多现成的博客平台，我在写博客之前也了解了一些，而最终没有选择大平台的原因是：</p>\n<ul>\n<li><strong>被动</strong>：虽然有很多博客平台，但是也有一些平台都已经死气沉沉半死不活了，所以不能确保现在你选择的某个平台能否一直活下去，如果突然某一天，你选择的某个平台停止维护了而又没办法导出数据的话，那简直就是“叫天天不应，叫地地不灵”了</li>\n<li><strong>不安全</strong>：虽然我们现在已经身处一个“没有隐私”的世界，但是这种意识还是要有的，而如果选择平台的话，你发的文章都会存储在别人的数据库中，同时你的一些行为也会被记录下来，不得不说，这确实是不安全的</li>\n<li><strong>缺乏灵活性</strong>：其实我是喜欢定制化的东西的，而平台的话会受到许许多多的制约，比如你想添加某个插件或者改变网站的背景颜色，估计是做不到的</li>\n</ul>\n<p>所以基于以上原因，我最终选择自己搭建博客，而选择 wordpress 的原因很简单，毕竟 wordpress 在业界已经拥有统治地位了，值得信赖。</p>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h2><p>前面可能对你的作用不是很大，那么下面我就说一下在个人博客这件事情上我的建议，如果能够对你所有帮助是再好不过的了：</p>\n<ol>\n<li><strong>通过平台搭建或者个人搭建各有利弊，一定要考虑清楚</strong>；上面我已经介绍了平台搭建的弊端，而个人搭建的话相对来说会更麻烦，需要你对服务器、域名等知识也有所了解，会有一定的学习成本，同时日常的维护也会比现成平台繁琐</li>\n<li><strong>写博客贵在坚持</strong>；如果你写过技术类博客的话，你肯定会有所感触：写一篇文章往往需要几个小时甚至几天的时间，你需要阅读大量相关资料，同时还有可能需要写domo、敲代码，这无疑会占用你大量的业余时间，在写博客之前要有心理准备</li>\n<li><strong>心态放平稳</strong>；对于每一个博客作者而言，如果自己写的东西受到更多人关注那肯定是一件好事，而其实大部分人写的文章是很少有人看到的，这种现象的造成会有很多原因，有个人的原因（文章质量、SEO等），也有外界的原因（墙、技术迭代很快）；但是“事在人为”，一定要放平心态，即使现在访问量/阅读量很少，相信坚持下去你肯定会收货很多读者</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>说了这么多，总结成一句话就是： <strong>有些事情你现在不去做，可能以后都不会有机会了！</strong></p>\n","raw":null,"categories":[{"name":"talk","path":"api/categories/talk.json"}],"tags":[{"name":"life","path":"api/tags/life.json"}]},{"title":"杂谈系列","slug":"杂谈系列","date":"2017-10-17T06:02:51.000Z","updated":"2019-02-04T13:27:44.357Z","comments":true,"path":"api/articles/杂谈系列.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这个系列的文章大多数都是我的所想所感，大部分和技术关联不大，或感概或吐槽或叙述，反正就是想到什么就会写点什么，毕竟博客的意义就在于此嘛。。当然，因为平时喜欢看一些东西，发现了一些不错的文章/视频，参见<a href=\"/20170807/good-article-recommendation.html\">他山之石，可以攻玉，好文章推荐</a>和<a href=\"/20171007/recommend-some-videos.html\">推荐一些视频</a>。以下文章按照发布时间倒叙排列：</p>\n<ul>\n<li><a href=\"/20190101/goodbye-2018.html\">再见，2018</a></li>\n<li><a href=\"/20180922/cat-strategy.html\">铲屎官，这里有一份属于你的空投</a></li>\n<li><a href=\"/20171231/goodbye-2017.html\">再见，2017</a></li>\n<li><a href=\"/20171017/why-i-write-blog.html\">我为什么要写个人博客</a></li>\n<li><a href=\"/20170906/beautiful-poetry.html\">不想当诗人的程序员不是好工程师</a></li>\n<li><a href=\"/20170820/it-nouns.html\">身在IT界，不能不知道这些名词</a></li>\n<li><a href=\"/20170801/there-is-always-a-sentence.html\">总有那么一句话……</a></li>\n<li><a href=\"/20170403/to-just-touched-the-front-end.html\">写给刚接触前端的你</a></li>\n</ul>\n","raw":null,"categories":[{"name":"series","path":"api/categories/series.json"}],"tags":[{"name":"life","path":"api/tags/life.json"}]},{"title":"读书笔记系列（9）——你不知道的JavaScript（上卷）","slug":"读书笔记系列（9）——你不知道的JavaScript（上卷）","date":"2017-10-10T11:42:12.000Z","updated":"2019-02-04T13:27:44.361Z","comments":true,"path":"api/articles/读书笔记系列（9）——你不知道的JavaScript（上卷）.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这本书在 github 上很火，而中文译本迟迟没有发行，最近出了中卷，我很早之前就听说了该大作，然而一直没有时间拜读，现在实习告一段落了，终于可以静下心来品味经典了。</p>\n<h2 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h2><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p>\n<h3 id=\"分词-词法分析\"><a href=\"#分词-词法分析\" class=\"headerlink\" title=\"分词/词法分析\"></a>分词/词法分析</h3><p>将字符串分解成有意义的代码块，这些代码块被称为词法单元（token），例如：<code>var a = 2;</code>，会被分解为下面这些词法单元：var、a、=、2、；</p>\n<h3 id=\"解析-语法分析\"><a href=\"#解析-语法分析\" class=\"headerlink\" title=\"解析/语法分析\"></a>解析/语法分析</h3><p>将语法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，被称为“抽象语法树”（AST）。<code>var a = 2;</code> 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier (它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。</p>\n<h3 id=\"代码生成\"><a href=\"#代码生成\" class=\"headerlink\" title=\"代码生成\"></a>代码生成</h3><p>将 AST 转换为可执行代码。简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。 然而，比起那些编译过程只有三个步骤的语言的编译器，<strong>JavaScript 引擎要复杂得多</strong>。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。</p>\n<p>对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内。</p>\n<h3 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h3><p>首先介绍将要参与到对程序 <code>var a = 2;</code> 进行处理的过程中的演员们。</p>\n<h4 id=\"引擎\"><a href=\"#引擎\" class=\"headerlink\" title=\"引擎\"></a>引擎</h4><p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p>\n<h4 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h4><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>\n<h3 id=\"变量的赋值操作\"><a href=\"#变量的赋值操作\" class=\"headerlink\" title=\"变量的赋值操作\"></a>变量的赋值操作</h3><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。（我们在面试时会经常遇到变量为undefined的问题，其实就是这个道理）</p>\n<h4 id=\"编译器有话说\"><a href=\"#编译器有话说\" class=\"headerlink\" title=\"编译器有话说\"></a>编译器有话说</h4><p>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。</p>\n<p>讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</p>\n<h4 id=\"引擎和作用域的对话\"><a href=\"#引擎和作用域的对话\" class=\"headerlink\" title=\"引擎和作用域的对话\"></a>引擎和作用域的对话</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123; <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">2</span> );</span><br></pre></td></tr></table></figure>\n<p>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。</p>\n<blockquote>\n<p>引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?<br>作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎:哥们太够意思了!好吧，我来执行一下 foo。<br>引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?<br>作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。<br>引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。<br>引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?<br>作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。<br>引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。<br>引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。<br>作用域:放心吧，这个变量没有变动过，拿走，不谢。 引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。 ……</p>\n</blockquote>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 <code>var a = 2</code> 这样的声明会被分解成两个独立的步骤:</p>\n<ol>\n<li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>\n<li>接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li>\n</ol>\n<p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，但是如果对结果的操作是非法或不合理的，会抛出 TypeError 异常，或者直接抛出 ReferenceError 异常(严格模式下)。</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><h3 id=\"变量查找\"><a href=\"#变量查找\" class=\"headerlink\" title=\"变量查找\"></a>变量查找</h3><p>全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。 window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。</p>\n<p><strong>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</strong></p>\n<h3 id=\"欺骗词法\"><a href=\"#欺骗词法\" class=\"headerlink\" title=\"欺骗词法\"></a>欺骗词法</h3><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”(也可以说欺骗)词法作用域呢? JavaScript 中有两种机制来实现这个目的。</p>\n<ol>\n<li>eval</li>\n<li>with</li>\n</ol>\n<p>欺骗词法作用域会导致性能下降。</p>\n<h4 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h4><p>在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p>\n<p>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>; </span><br><span class=\"line\">    <span class=\"built_in\">eval</span>( str ); </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// ReferenceError: a is not defined </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">foo( <span class=\"string\">\"var a = 2\"</span> );</span><br></pre></td></tr></table></figure>\n<p>JavaScript 中还有其他一些功能效果和 <code>eval(..)</code> 很 相 似。setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们! new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。</p>\n<h4 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h4><p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。with 的副作用通过一个简单的例子就可以看到：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">2</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; </span><br><span class=\"line\">    b: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo( o1 );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( o1.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo( o2 );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( o2.a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2——不好，a 被泄漏到全局作用域上了!</span></span><br></pre></td></tr></table></figure>\n<p>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此<strong>这个对象的属性也会被处理为定义在这个作用域中的词法标识符</strong>。</p>\n<p>结合上面的例子，o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a=2 执行时，<strong>自动创建了一个全局变量</strong>(因为是非严格模式)。</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p>\n<h2 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h2><h3 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h3><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。</p>\n<h3 id=\"全局命名空间\"><a href=\"#全局命名空间\" class=\"headerlink\" title=\"全局命名空间\"></a>全局命名空间</h3><p>某些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyReallyCoolLibrary = &#123; </span><br><span class=\"line\">    awesome: <span class=\"string\">\"stuff\"</span>, </span><br><span class=\"line\">    doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    doAnotherThing: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"匿名和具名\"><a href=\"#匿名和具名\" class=\"headerlink\" title=\"匿名和具名\"></a>匿名和具名</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I waited 1 second!\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</p>\n<h3 id=\"然而，匿名函数也有几个缺点：\"><a href=\"#然而，匿名函数也有几个缺点：\" class=\"headerlink\" title=\"然而，匿名函数也有几个缺点：\"></a>然而，匿名函数也有几个缺点：</h3><ol>\n<li>匿名函数在栈追踪中不会显示出有意义的函数名，使得<strong>调试很困难</strong>。</li>\n<li>如果没有函数名，当函数需要引用自身时只能使用已经过期的<strong>arguments.callee</strong>引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li>\n<li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。<strong>一个描述性的名称可以让代码不言自明</strong>。</li>\n</ol>\n<p>综合考虑而言，始终给函数表达式命名是一个最佳实践（下面的例子叫做行内函数表达式）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeoutHandler</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// &lt;-- 快看，我有名字了! </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"I waited 1 second!\"</span> );</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<h3 id=\"立即执行函数表达式\"><a href=\"#立即执行函数表达式\" class=\"headerlink\" title=\"立即执行函数表达式\"></a>立即执行函数表达式</h3><p>立即执行函数表达式（IIFE）有两种形式：</p>\n<ol>\n<li>(function foo(){ .. })()</li>\n<li>(function foo(){ .. }())</li>\n</ol>\n<p>这两种形式在功能上是一致的，<strong>选择哪个全凭个人喜好</strong>。</p>\n<h3 id=\"IIFE的用途\"><a href=\"#IIFE的用途\" class=\"headerlink\" title=\"IIFE的用途\"></a>IIFE的用途</h3><h4 id=\"把它们当做函数调用并传递参数进去：\"><a href=\"#把它们当做函数调用并传递参数进去：\" class=\"headerlink\" title=\"把它们当做函数调用并传递参数进去：\"></a>把它们当做函数调用并传递参数进去：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)( <span class=\"built_in\">window</span> );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"解决-undefined-标识符的默认值被错误覆盖导致的异常-虽然不常见\"><a href=\"#解决-undefined-标识符的默认值被错误覆盖导致的异常-虽然不常见\" class=\"headerlink\" title=\"解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)\"></a>解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)</h4><p>将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 给其他代码挖了一个大坑!绝对不要这样做! </span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> undefined </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"string\">\"Undefined is safe here!\"</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\"><a href=\"#倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\" class=\"headerlink\" title=\"倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\"></a>倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>) </span>&#123; </span><br><span class=\"line\">    def( <span class=\"built_in\">window</span> );</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。</p>\n<h3 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h3><p>块作用域的例子：</p>\n<h4 id=\"with-1\"><a href=\"#with-1\" class=\"headerlink\" title=\"with\"></a>with</h4><p>with就是块作用域的一个例子（形式），用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效</p>\n<h4 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try/catch\"></a>try/catch</h4><p>try/catch 是 ES3 的规范，而很少有人注意到，<strong>catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效</strong></p>\n<blockquote>\n<p>尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境(除了老 版本的 IE 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。</p>\n</blockquote>\n<h4 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h4><p>ES6 引入的 let 关键字可以将变量绑定到所在的任意作用域中(通常是{ .. }内部)。换句话说，let 为其声明的变量隐式地了所在的块作用域。 但是，let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError! </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h4><p>ES6 还引入了 const，同样可以用来创建块作用域变量，但是其值是固定的</p>\n<h3 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h3><h4 id=\"先有鸡还是先有蛋\"><a href=\"#先有鸡还是先有蛋\" class=\"headerlink\" title=\"先有鸡还是先有蛋\"></a>先有鸡还是先有蛋</h4><p>首先，抛出两个例子，也是很经典的JS的“坑”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>关于这一奇怪现象，可以用一句话概括：<strong>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理</strong> 当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个——声明:var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。 换句话说，<strong>先有蛋（声明）后又鸡（赋值）</strong>；所以上面的两个例子会以如下形式进行处理： 例子一：（第一部分是编译，第二部分是执行）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">a = <span class=\"number\">2</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>例子二：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 不是 ReferenceError, 而是 TypeError!</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域(在这里是全局作用域)，因此foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式，那么就会赋值)。<strong>foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常</strong>。</p>\n<p>从上面的例子，我们还可以得出：<strong>函数声明会被提升，但是函数表达式不会被提升</strong></p>\n<h3 id=\"函数优先\"><a href=\"#函数优先\" class=\"headerlink\" title=\"函数优先\"></a>函数优先</h3><p>函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。考虑下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子会被引擎理解为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>从这两段代码我们可以得出两个结论：</p>\n<ol>\n<li>var foo 尽管出现在 function foo()…的声明之前，但它是重复的声明(因此<strong>被忽略</strong>了)，因为函数声明会被提升到普通变量之前。</li>\n<li>尽管重复的 var 声明会被忽略掉，但<strong>出现在后面的函数声明还是可以覆盖前面的</strong>。</li>\n</ol>\n<h2 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h2><h3 id=\"老生常谈，闭包是什么\"><a href=\"#老生常谈，闭包是什么\" class=\"headerlink\" title=\"老生常谈，闭包是什么\"></a>老生常谈，闭包是什么</h3><p>划重点：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 这一部分之前已经讲了很多次了，感觉这本书也没有很多新意，所以想了解闭包的童鞋可以参见我的另一篇文章：<a href=\"/20170405/closure-in-js.html\">前端面试系列（10）——JS中的闭包</a></p>\n<h3 id=\"不太显性的闭包\"><a href=\"#不太显性的闭包\" class=\"headerlink\" title=\"不太显性的闭包\"></a>不太显性的闭包</h3><p>其实，你已经写过的代码中一定到处都是闭包的身影。</p>\n<h4 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait(<span class=\"string\">\"Hello, closure!\"</span>);</span><br></pre></td></tr></table></figure>\n<p>将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域 的闭包，因此还保有对变量 message 的引用。wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，<strong>timer 函数依然保有 wait(..) 作用域的闭包</strong>。</p>\n<h4 id=\"jQuery-或其他-JS-框架\"><a href=\"#jQuery-或其他-JS-框架\" class=\"headerlink\" title=\"jQuery 或其他 JS 框架\"></a>jQuery 或其他 JS 框架</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setupBot</span>(<span class=\"params\">name, selector</span>) </span>&#123;</span><br><span class=\"line\">    $( selector ).click( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">activator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"string\">\"Activating: \"</span> + name ); </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setupBot( <span class=\"string\">\"Closure Bot 1\"</span>, <span class=\"string\">\"#bot_1\"</span> );</span><br><span class=\"line\">setupBot( <span class=\"string\">\"Closure Bot 2\"</span>, <span class=\"string\">\"#bot_2\"</span> );</span><br></pre></td></tr></table></figure>\n<p>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包!</p>\n<h4 id=\"IIFE\"><a href=\"#IIFE\" class=\"headerlink\" title=\"IIFE\"></a>IIFE</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么?因为函数(示例代码中的 IIFE)并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行(而外部作用域，也就是全局作用域也持有 a)。a 是通过普通的词法作用域查找而非闭包被发现的。 尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。</p>\n<h3 id=\"块作用域和闭包\"><a href=\"#块作用域和闭包\" class=\"headerlink\" title=\"块作用域和闭包\"></a>块作用域和闭包</h3><p>一道很经典的面试题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码在运行时会以每秒一次的频率输出五次 6，具体原因就不再赘述了。。而如果我们想让他连续输出1 2 3 4 5应该怎么办呢？有两种方法:</p>\n<h4 id=\"利用闭包\"><a href=\"#利用闭包\" class=\"headerlink\" title=\"利用闭包\"></a>利用闭包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">        &#125;, j*<span class=\"number\">1000</span> ); </span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"闭包-块作用域\"><a href=\"#闭包-块作用域\" class=\"headerlink\" title=\"闭包+块作用域\"></a>闭包+块作用域</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><h4 id=\"模块有两个主要特征：\"><a href=\"#模块有两个主要特征：\" class=\"headerlink\" title=\"模块有两个主要特征：\"></a>模块有两个主要特征：</h4><ol>\n<li>为创建内部作用域而调用了一个包装函数;</li>\n<li>包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>\n</ol>\n<p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览器或引擎有一个默认的“模块加载器”(可以被重载，但这远超出了我们的讨论范围)可以在导入模块时异步地加载模块文件。 模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。</p>\n<h4 id=\"动态作用域与词法作用域\"><a href=\"#动态作用域与词法作用域\" class=\"headerlink\" title=\"动态作用域与词法作用域\"></a>动态作用域与词法作用域</h4><p>下面一段代码很有意思：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2(不是3!)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    foo(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara=<span class=\"number\">2</span>;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>如果 JS 是动态作用域，上面将会输出 3，因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。 需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>\n<h2 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h2><h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>有两种常见的对于this的解释，但是它们都是错误的：</p>\n<h4 id=\"指向自身\"><a href=\"#指向自身\" class=\"headerlink\" title=\"指向自身\"></a>指向自身</h4><p>人们很容易把 this 理解成指向函数自身，然而如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符(变量)来引用它。 思考一下下面这两个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.count = <span class=\"number\">4</span>; <span class=\"comment\">// foo 指向它自身</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匿名(没有名字的)函数无法指向自身</span></span><br><span class=\"line\">&#125;,<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p>第一个函数被称为具名函数，在它内部可以使用 foo 来引用自身。 但是在第二个例子中，传入 setTimeout(..) 的回调函数没有名称标识符(这种函数被称为匿名函数)，因此无法从函数内部引用自身。</p>\n<h4 id=\"它的作用域\"><a href=\"#它的作用域\" class=\"headerlink\" title=\"它的作用域\"></a>它的作用域</h4><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。 <strong>每当你想要把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</strong></p>\n<h3 id=\"this到底是什么\"><a href=\"#this到底是什么\" class=\"headerlink\" title=\"this到底是什么\"></a>this到底是什么</h3><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</strong> 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>\n<h2 id=\"this全面解析\"><a href=\"#this全面解析\" class=\"headerlink\" title=\"this全面解析\"></a>this全面解析</h2><h3 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h3><p>在理解 this 的绑定过程之前，首先要理解调用位置：<strong>调用位置就是函数在代码中被调用的位置(而不是声明的位置)</strong>；然而做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。 下面通过一个例子来看看到底什么是调用栈和调用位置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是:baz</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置是全局作用域</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"baz\"</span> );</span><br><span class=\"line\">    bar(); <span class=\"comment\">// &lt;-- bar 的调用位置 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是 baz -&gt; bar</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置在 baz 中</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\">    foo(); <span class=\"comment\">// &lt;-- foo 的调用位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置在 bar 中</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">baz(); <span class=\"comment\">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p>\n<h4 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>this.a 被解析成了全局变量 a。为什么?因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此<strong>this会绑定到 undefined</strong> 这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是<strong>只有foo()运行在非strict mode下时，默认绑定才能绑定到全局对象；严格模式下与foo() 的调用位置无关：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>;</span><br><span class=\"line\">    foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>调用位置会使用 obj 上下文来引用函数</strong>，因此你可以说<strong>函数foo被调用时 obj 对象“拥有”或者“包含”它</strong>。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">42</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    obj2: obj2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj1.obj2.foo(); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h4><p>可以使用函数的 call(..) 和 apply(..) 方法。这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现在其他的参数上，但是现在我们不用考虑这些。 <strong>硬绑定</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.call( obj );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">setTimeout( bar, <span class=\"number\">100</span> ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 硬绑定的 bar 不可能再修改它的 this</span></span><br><span class=\"line\">bar.call( <span class=\"built_in\">window</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>无论我们如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype. bind，它的用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">3</span>);<span class=\"comment\">//23</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p>\n<h4 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h4><p>JS 中 new 的机制和面向类的语言完全不同：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>\n<ol>\n<li>创建(或者说构造)一个全新的对象。</li>\n<li>这个新对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>一个简单的例子来解释 new 绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar.a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。</strong></p>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><p>（原书中通过很多例子得到了上面四种绑定方式的优先级，这里就不再赘述了。。） 我们可以按照下面的顺序来进行判断：</p>\n<ol>\n<li>函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。 var bar = new foo()</li>\n<li>函数是否通过 call、apply(显式绑定)或者硬绑定调用?如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2)</li>\n<li>函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo()</li>\n<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo()</li>\n</ol>\n<p>然而，凡事总有例外。</p>\n<h4 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a>绑定例外</h4><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用的可能是默认绑定规则。</p>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara=<span class=\"number\">2</span>;</span><br><span class=\"line\">foo.call( <span class=\"literal\">null</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>一般，如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择。 然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。 划重点：<strong>Object.create(null)和{}很像，但是并不会创建Object.prototype 这个委托，所以它比 {}“更空”</strong></p>\n<h4 id=\"间接引用\"><a href=\"#间接引用\" class=\"headerlink\" title=\"间接引用\"></a>间接引用</h4><p>你有可能(有意或者无意地)创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。而间接引用最容易在赋值时发生：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>:<span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>:<span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此<strong>调用位置是 foo() 而不是 p.foo() 或者 o.foo()</strong>。根据我们之前说过的，这里会应用默认绑定。</p>\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><p>硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。 下面是一种被称为软绑定的方法，有时间的话可以研究一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Function</span>.prototype.softBind) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.softBind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 捕获所有 curried 参数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = \\[\\].slice.call( <span class=\"built_in\">arguments</span>, <span class=\"number\">1</span> );</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(</span><br><span class=\"line\">                (!<span class=\"keyword\">this</span> || <span class=\"keyword\">this</span> === (<span class=\"built_in\">window</span> || global)) ?</span><br><span class=\"line\">                    obj : <span class=\"keyword\">this</span></span><br><span class=\"line\">                curried.concat.apply( curried, <span class=\"built_in\">arguments</span> )</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = <span class=\"built_in\">Object</span>.create( fn.prototype );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this语法\"><a href=\"#this语法\" class=\"headerlink\" title=\"this语法\"></a>this语法</h3><p>ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定义的。<strong>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//this 继承自 foo()</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2, 不是3!</span></span><br></pre></td></tr></table></figure>\n<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不 行!)</p>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>对象可以通过两种形式定义:声明(文字)形式和构造形式。</p>\n<h4 id=\"文字形式（对象字面量）\"><a href=\"#文字形式（对象字面量）\" class=\"headerlink\" title=\"文字形式（对象字面量）\"></a>文字形式（对象字面量）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    key: value</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"构造形式\"><a href=\"#构造形式\" class=\"headerlink\" title=\"构造形式\"></a>构造形式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">myObj.key = value;</span><br></pre></td></tr></table></figure>\n<p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键值对，但是在构造形式中你必须逐个添加属性。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>在 JavaScrip t中一共有六种主要类型（语言类型）：</p>\n<ul>\n<li>string</li>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>object</li>\n</ul>\n<p>简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。 null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 “object”。实际上，<strong>null 本身是基本类型</strong>。</p>\n<blockquote>\n<p>原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。</p>\n</blockquote>\n<h3 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h3><p>JavaScript 中还有一些对象子类型，通常被称为内置对象。</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n</ul>\n<h3 id=\"自动转换\"><a href=\"#自动转换\" class=\"headerlink\" title=\"自动转换\"></a>自动转换</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strPrimitive = <span class=\"string\">\"I am a string\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( strPrimitive.length ); <span class=\"comment\">// 13</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( strPrimitive.charAt( <span class=\"number\">3</span> ) ); <span class=\"comment\">// \"m\"</span></span><br></pre></td></tr></table></figure>\n<p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为<strong>引擎自动把字面量转换成 String 对象</strong>，所以可以访问属性和方法。同样的事也会发生在数值字面量上 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式（只能通过 new Date() 创建一个 Date 对象）。</p>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"a\"</span>\\]; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>.a 语法通常被称为“<strong>属性访问</strong>”，[“a”] 语法通常被称为“<strong>键访问</strong>”。这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject\\[<span class=\"literal\">true</span>\\] = <span class=\"string\">\"foo\"</span>;</span><br><span class=\"line\">myObject\\[<span class=\"number\">3</span>\\] = <span class=\"string\">\"bar\"</span>;</span><br><span class=\"line\">myObject\\[myObject\\] = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"true\"</span>\\]; <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"3\"</span>\\]; <span class=\"comment\">// \"bar\"</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"\\[object Object\\]\"</span>\\]; <span class=\"comment\">// \"baz\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = \\[ <span class=\"string\">\"foo\"</span>, <span class=\"number\">42</span>, <span class=\"string\">\"bar\"</span> \\];</span><br><span class=\"line\">myArray.baz = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\">myArray.length; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myArray.baz; <span class=\"comment\">// \"baz\"</span></span><br></pre></td></tr></table></figure>\n<p>可以看到虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，<strong>数组的 length 值并未发生变化</strong>。但是，如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标(因此会修改数组的内容而不是添加一个属性)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = \\[ <span class=\"string\">\"foo\"</span>, <span class=\"number\">42</span>, <span class=\"string\">\"bar\"</span> \\];</span><br><span class=\"line\">myArray\\[<span class=\"string\">\"4\"</span>\\] = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\">myArray.length; <span class=\"comment\">// 5</span></span><br><span class=\"line\">myArray\\[<span class=\"number\">4</span>\\]; <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\">myArray\\[<span class=\"number\">3</span>\\]; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h3><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"a\"</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"number\">2</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h3><p>有时候你会希望属性或者对象是不可改变(无论有意还是无意)的，在 ES5 中可以通过很多种方法来实现：</p>\n<h4 id=\"对象常量\"><a href=\"#对象常量\" class=\"headerlink\" title=\"对象常量\"></a>对象常量</h4><p>结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性(不可修改、重定义或者删除):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"FAVORITE_NUMBER\"</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"number\">42</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"禁止扩展\"><a href=\"#禁止扩展\" class=\"headerlink\" title=\"禁止扩展\"></a>禁止扩展</h4><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions( myObject );</span><br><span class=\"line\">myObject.b = <span class=\"number\">3</span>;</span><br><span class=\"line\">myObject.b; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"密封\"><a href=\"#密封\" class=\"headerlink\" title=\"密封\"></a>密封</h4><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable: false。 所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。</p>\n<h4 id=\"冻结\"><a href=\"#冻结\" class=\"headerlink\" title=\"冻结\"></a>冻结</h4><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable: false，这样就无法修改它们的值。 <strong>这个方法是你可以应用在对象上的级别最高的不可变性</strong>，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。</p>\n<h4 id=\"数组上不要用for-in循环\"><a href=\"#数组上不要用for-in循环\" class=\"headerlink\" title=\"数组上不要用for..in循环\"></a>数组上不要用for..in循环</h4><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><h4 id=\"ES5中增加了一些数组的辅助迭代器：\"><a href=\"#ES5中增加了一些数组的辅助迭代器：\" class=\"headerlink\" title=\"ES5中增加了一些数组的辅助迭代器：\"></a>ES5中增加了一些数组的辅助迭代器：</h4><ol>\n<li>forEach(..)：遍历数组中的所有值并忽略回调函数的返回值</li>\n<li>every(..)：会一直运行直到回调函数返回 false</li>\n<li>some(..)：会一直运行直到回调函数返回 true</li>\n</ol>\n<h2 id=\"混合对象“类”\"><a href=\"#混合对象“类”\" class=\"headerlink\" title=\"混合对象“类”\"></a>混合对象“类”</h2><h3 id=\"类的机制\"><a href=\"#类的机制\" class=\"headerlink\" title=\"类的机制\"></a>类的机制</h3><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息(状态)。 类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。</p>\n<h4 id=\"JS中的类\"><a href=\"#JS中的类\" class=\"headerlink\" title=\"JS中的类\"></a>JS中的类</h4><p>在传统的面向类的语言中 super 有一个功能，就是<strong>从子类的构造函数中通过 super 可以直接调用父类的构造函数</strong>。通常来说这没什么问题，因为对于真正的类来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——<strong>实际上“类”是属于构造函数的</strong>(类似 Foo.prototype… 这样的类型引用)。由于<strong>JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中</strong>，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用</p>\n<blockquote>\n<p>注: 其实这一部分还蛮重要的，而原文也通过比较大量的篇幅对JS中的“类”进行了介绍，只不过我感觉没有什么与众不同之处就略过了，对这一部分还不太熟悉的童鞋可以自己研究一下。。</p>\n</blockquote>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"Prototype\"><a href=\"#Prototype\" class=\"headerlink\" title=\"[[Prototype]]\"></a>[[Prototype]]</h3><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。 而[[Prototype]]的作用是：对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个关联到 anotherObject 的对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到(并且是 enumerable)的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链(无论属性是否可枚举)</p>\n<h3 id=\"Object-prototype\"><a href=\"#Object-prototype\" class=\"headerlink\" title=\"Object.prototype\"></a>Object.prototype</h3><p><strong>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype</strong>。由于所有的“普通”(内置，不是特定主机的扩展)对象都“源于”(或者说把 [[Prototype]] 链的顶端设置为)这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。</p>\n<h3 id=\"属性屏蔽\"><a href=\"#属性屏蔽\" class=\"headerlink\" title=\"属性屏蔽\"></a>属性屏蔽</h3><p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为<strong>myObject.foo 总是会选择原型链中最底层的 foo 属性</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a++; <span class=\"comment\">// 隐式屏蔽!</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>尽管 myObject.a++ 看起来应该(通过委托)查找并增加 anotherObject.a 属性，但是别忘了<strong>++操作相当于myObject.a = myObject.a + 1</strong>。因此++操作首先会通过[[Prototype]]查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐!</p>\n<h3 id=\"“类”\"><a href=\"#“类”\" class=\"headerlink\" title=\"“类”\"></a>“类”</h3><h4 id=\"“类”函数\"><a href=\"#“类”函数\" class=\"headerlink\" title=\"“类”函数\"></a>“类”函数</h4><p>所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype; <span class=\"comment\">// &#123; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这个对象通常被称为 Foo 的原型，然而，如果是我的话就 会叫它“之前被称为 Foo 的原型的那个对象”。好吧我是开玩笑的，你觉得“<strong>被贴上‘Foo 点 prototype’标签的对象</strong>”这个名字怎么样？最直接的解释就是，这个对象是在调用new Foo()时创建的，最后会被(有点武断地)关联到这个“Foo 点 prototype”对象上。</p>\n<h4 id=\"继承与原型\"><a href=\"#继承与原型\" class=\"headerlink\" title=\"继承与原型\"></a>继承与原型</h4><p>继承意味着复制操作，JavaScript(默认)并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。委托(参见第 6 章)这个术语可以更加准确地描述 JavaScript 中对象的关联机制。</p>\n<h4 id=\"构造函数还是调用\"><a href=\"#构造函数还是调用\" class=\"headerlink\" title=\"构造函数还是调用\"></a>构造函数还是调用</h4><p>在JS中，<strong>new 会劫持所有普通函数并用构造对象的形式来调用它</strong>。换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是<strong>当且仅当使用 new 时，函数调用会变成“构造函数调用”</strong>。</p>\n<h4 id=\"constructor-并不表示被构造\"><a href=\"#constructor-并不表示被构造\" class=\"headerlink\" title=\"constructor 并不表示被构造\"></a>constructor 并不表示被构造</h4><p>function Foo() { /<em> .. </em>/ }<br>Foo.prototype = { /<em> .. </em>/ }; // 创建一个新原型对象<br>var a1 = new Foo();<br>a1.constructor === Foo; // false! a1.constructor === Object; // true!</p>\n<p>a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性(不过<strong>默认的 Foo.prototype 对象有这个属性</strong>!)，所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。 a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。</p>\n<h4 id=\"（原型）继承\"><a href=\"#（原型）继承\" class=\"headerlink\" title=\"（原型）继承\"></a>（原型）继承</h4><h3 id=\"Object-setPrototypeOf-…\"><a href=\"#Object-setPrototypeOf-…\" class=\"headerlink\" title=\"Object.setPrototypeOf(…)\"></a>Object.setPrototypeOf(…)</h3><p>ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6 之前需要抛弃默认的 Bar.prototype</span></span><br><span class=\"line\">Bar.ptototype = <span class=\"built_in\">Object</span>.create( Foo.prototype );</span><br><span class=\"line\"><span class=\"comment\">// ES6 开始可以直接修改现有的 Bar.prototype </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象关联\"><a href=\"#对象关联\" class=\"headerlink\" title=\"对象关联\"></a>对象关联</h3><p>[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。 这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p>\n<h2 id=\"行为委托\"><a href=\"#行为委托\" class=\"headerlink\" title=\"行为委托\"></a>行为委托</h2><p>委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Task = &#123;</span><br><span class=\"line\">    setID: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ID</span>) </span>&#123; <span class=\"keyword\">this</span>.id = ID; &#125;,</span><br><span class=\"line\">    outputID: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.id ); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 让XYZ委托Task</span></span><br><span class=\"line\">XYZ = <span class=\"built_in\">Object</span>.create( Task );</span><br><span class=\"line\"></span><br><span class=\"line\">XYZ.prepareTask = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ID,Label</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setID( ID );</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.label = Label;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">XYZ.outputTaskDetails = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.outputID();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.label );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ABC = Object.create( Task );</span></span><br><span class=\"line\"><span class=\"comment\">// ABC ... = ...</span></span><br></pre></td></tr></table></figure>\n<p>在上面这段代码中，Task 和 XYZ 并不是类（或者函数），它们是对象。<strong>XYZ 通过 Object. create(..) 创建，它的 [[Prototype]] 委托了 Task 对象</strong></p>\n<h3 id=\"互相委托（禁止）\"><a href=\"#互相委托（禁止）\" class=\"headerlink\" title=\"互相委托（禁止）\"></a>互相委托（禁止）</h3><p>你无法在两个或两个以上互相(双向)委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。如果你引用了一个两边都不存在的属性或者方法，那就会在 [[Prototype]] 链上产生一个<strong>无限递归的循环</strong>。 所以互相委托是被禁止的。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>JavaScript 规范并不会控制浏览器中开发者工具对于特定值或者结构的表示方式，所以浏览器和工具的解析结果并不一定相同。下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a1 = <span class=\"keyword\">new</span> Foo(); </span><br><span class=\"line\">a1; <span class=\"comment\">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>这段代码在chrome中会输出：Foo {}；而在Firefox中会得到Object {}</strong></p>\n<p>Chrome 实际上想说的是“<strong>{} 是一个空对象，由名为 Foo 的函数构造</strong>”。Firefox 想说的是“<strong>{} 是一个空对象，由 Object 构造</strong>”。之所以有这种细微的差别，是因为 <strong>Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性</strong>，但是其他浏览器并不会跟踪这些额外的信息。</p>\n<p>然而，这个行为被认定是 Chrome 的一个 bug，当你读到此书时，它可能已经被修复了。所以你看到的可能是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1; <span class=\"comment\">// Object &#123;&#125;。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h3><p>相比“类”的构造方式，<strong>对象关联可以更好地支持关注分离（separation of concerns）原则</strong>，创建和初始化并不需要合并为一个步骤。 对象关联除了能让代码看起来更简洁(并且更具扩展性)外还可以通过行为委托模式简化代码结构。</p>\n<h3 id=\"更好的语法\"><a href=\"#更好的语法\" class=\"headerlink\" title=\"更好的语法\"></a>更好的语法</h3><p>在 ES6 中，你可以使用对象的字面形式(这样就可以使用简洁方法定义)来改写之前繁琐的属性赋值语法(比如 AuthController 的定义)，然后用 Object.setPrototypeOf(..) 来修改它的 [[Prototype]]:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用更好的对象字面形式语法和简洁方法 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> AuthController = &#123;</span><br><span class=\"line\">    errors: \\[\\],</span><br><span class=\"line\">    checkAuth() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    server(url, data) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在把 AuthController 关联到 LoginController</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( AuthController, LoginController );</span><br></pre></td></tr></table></figure>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。</p>\n<p>在 js 中，instanceof 语法会产生语义困惑而且非常不直观。如果你想检查对象 a1 和某个对象的关系，那必须使用另一个引用该对象的函数才行——你不能直接判断两个对象是否关联。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* .. */</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* .. */</span> &#125;</span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create( Foo.prototype ); <span class=\"comment\">// 让Foo和Bar互相关联</span></span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype <span class=\"keyword\">instanceof</span> Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\">Bar <span class=\"keyword\">instanceof</span> Foo; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>然而，又回到上面的那个问题，<strong>如果通过对象关联的方式构造对象，内省的方法将更加简洁并且清晰</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Foo = &#123; <span class=\"comment\">/* .. */</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Bar = <span class=\"built_in\">Object</span>.create( Foo ); <span class=\"comment\">// 让Foo和Bar互相关联</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"built_in\">Object</span>.create( Bar ); <span class=\"comment\">// 让b1关联到Foo和Bar</span></span><br><span class=\"line\"></span><br><span class=\"line\">Foo.isPrototypeOf( Bar ); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf( Bar ) === Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Foo.isPrototypeOf( b1 ); <span class=\"comment\">// true </span></span><br><span class=\"line\">Bar.isPrototypeOf( b1 ); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf( b1 ) === Bar; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"ES6中的Class\"><a href=\"#ES6中的Class\" class=\"headerlink\" title=\"ES6中的Class\"></a>ES6中的Class</h3><p>除了语法更好看之外，ES6 还解决了什么问题？</p>\n<ol>\n<li>（基本上）不再引用杂乱的 .prototype 了；</li>\n<li>不再需要通过 Object.create(..) 来替换 .prototype 对象，也不需要设置 .__proto__ 或者 Object.setPrototypeOf(..)；</li>\n<li>可以通过 super(..) 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法；</li>\n<li>class 字面语法不能声明属性(只能声明方法)。看起来这是一种限制，但是它会排除掉许多不好的情况，可以帮助你避免犯错；</li>\n<li>可以通过 extends 很自然地扩展对象(子)类型，甚至是内置的对象(子)类型，比如 Array 或 RegExp。</li>\n</ol>\n<p>然而，class 语法并没有解决所有的问题，你可能会认为 ES6 的 class 语法是向 JavaScript 中引入了一种新的“类”机制，其实不是这样。class 基本上只是现有 [[Prototype]](委托!)机制的一种语法糖。 也就是说，class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你 (有意或无意)修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为<strong>它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托。</strong> 除此之外，class 还有以下问题：</p>\n<ol>\n<li><strong>class 语法无法定义类成员属性（只能定义方法）；</strong></li>\n<li>class 语法仍然面临<strong>意外屏蔽</strong>的问题；</li>\n<li>super 并不是动态绑定this的，它会在声明时“静态”绑定。（可以通过 toMethod(…) 手动修改 super 绑定）</li>\n</ol>\n<p>综上，class 最大的问题在于，像传统的类一样)它的语法有时会让你认为，定义了一个 class 后，它就变成了一个(未来会被实例化的)东西的静态定义。<strong>你会彻底忽略 C 是一个对象，是一个具体的可以直接交互的东西。</strong></p>\n<p>ES6 的 class 想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让 JavaScript 更加难以理解。</p>\n","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"推荐一些视频","slug":"推荐一些视频","date":"2017-10-07T14:10:49.000Z","updated":"2019-02-04T13:27:44.357Z","comments":true,"path":"api/articles/推荐一些视频.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_285.png","content":"<p>平时很喜欢看一些东西，当然不局限于前端，而相比文字而言，更喜欢看视频，尤其是有了“弹幕”这个神奇的东东之后，在这里就推荐一些我看过的有趣的视频，有些是技术类的，也有些是搞笑片段或纪录片，闲暇之余仅供娱乐。</p>\n<h2 id=\"技术类\"><a href=\"#技术类\" class=\"headerlink\" title=\"技术类\"></a>技术类</h2><h3 id=\"Javascript作者接受采访视频\"><a href=\"#Javascript作者接受采访视频\" class=\"headerlink\" title=\"Javascript作者接受采访视频\"></a><a href=\"https://www.youtube.com/watch?v=IPxQ9kEaF8c\" target=\"_blank\" rel=\"noopener\">Javascript作者接受采访视频</a></h3><p>从<a href=\"https://www.zhihu.com/question/31415286\" target=\"_blank\" rel=\"noopener\">知乎</a>上看到的，之前就听说过JS是一位大神用 10 天时间赶出来的。。虽然目前看来JS存在很多问题和很多坑，但是10天写出一门风靡全球的语言也是一件很伟大的事情了。。</p>\n<h3 id=\"浏览器的背后（续）\"><a href=\"#浏览器的背后（续）\" class=\"headerlink\" title=\"浏览器的背后（续）\"></a><a href=\"http://v.youku.com/v_show/id_XMjMzMzU2NDc2.html\" target=\"_blank\" rel=\"noopener\">浏览器的背后（续）</a></h3><p>浏览器其实有很多可以探讨的东西，同时也是笔试面试时的常客，这个视频来自优酷，虽然有个“续”字，但是我并没有找到前面的视频啊我勒个擦？！</p>\n<h3 id=\"动画设计的12原则\"><a href=\"#动画设计的12原则\" class=\"headerlink\" title=\"动画设计的12原则\"></a><a href=\"https://www.youtube.com/watch?v=GcryIdriSe4\" target=\"_blank\" rel=\"noopener\">动画设计的12原则</a></h3><p>在看文章-<a href=\"https://www.w3cplus.com/animation/crafting-easing-curves-for-user-interfaces.html\" target=\"_blank\" rel=\"noopener\">给用户界面添加缓和效果(Easing Curves)</a>时发现的一个视频，其实设计动画的初衷是为了对用户更“亲切”，所以动画设计的原则就是要满足现实世界中的物理学规则，而该视频就是对该原则的总结，视频来自Youtube，所以需要fq，文字版的<a href=\"https://www.w3cplus.com/css3/animation-principles-for-the-web.html\" target=\"_blank\" rel=\"noopener\">在这里</a>，除此之外你能在 Codepen 找到它们<a href=\"http://codepen.io/collection/AxKOdY/\" target=\"_blank\" rel=\"noopener\">全部的开源 HTML 和 CSS 代码</a>。</p>\n<h3 id=\"Maxoden的演讲视频\"><a href=\"#Maxoden的演讲视频\" class=\"headerlink\" title=\"Maxoden的演讲视频\"></a><a href=\"https://www.youtube.com/watch?v=8gM3xMObEz4\" target=\"_blank\" rel=\"noopener\">Maxoden的演讲视频</a></h3><p>Maxoden 是<a href=\"https://github.com/maxogden/voxel-engine\" target=\"_blank\" rel=\"noopener\">Voxel.js</a>（一个在浏览器里运行的 Minecraft 框架）的作者，而他也借此做了一个 Minecraft 风格的展示他自己项目的页面，是一个很有探索精神的前端工程师。</p>\n<h3 id=\"What-the-heck-is-the-event-loop-anyway\"><a href=\"#What-the-heck-is-the-event-loop-anyway\" class=\"headerlink\" title=\"What the heck is the event loop anyway\"></a><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\" target=\"_blank\" rel=\"noopener\">What the heck is the event loop anyway</a></h3><p>Philip Roberts 的演讲视频:，主题为《什么是 JavaScript 中的事件循环》，收到了广泛好评，对 event loop 仍然存在疑问的童鞋可以花半小时看一下，当然，如果你更喜欢文字版的，可以移步掘金上的<a href=\"https://juejin.im/post/5ae083166fb9a07ab9792896\" target=\"_blank\" rel=\"noopener\">这篇演讲译文</a></p>\n<h3 id=\"像素的一生Life-of-a-Pixel-Steve-Kobes\"><a href=\"#像素的一生Life-of-a-Pixel-Steve-Kobes\" class=\"headerlink\" title=\"像素的一生Life of a Pixel - Steve Kobes\"></a><a href=\"https://www.youtube.com/watch?reload=9&amp;v=NCUDntd-3ao\" target=\"_blank\" rel=\"noopener\">像素的一生Life of a Pixel - Steve Kobes</a></h3><p>Youtube 上关于像素的演讲，从微博上看到的，也有很多同事反馈讲的不错，关键是还有中英文双语字幕，这对于我这种英文水平不是很高的人说来说不能再贴心。</p>\n<h3 id=\"Getting-Started-with-Redux\"><a href=\"#Getting-Started-with-Redux\" class=\"headerlink\" title=\"Getting Started with Redux\"></a><a href=\"https://search.bilibili.com/all?keyword=Getting%20Started%20with%20Redux\" target=\"_blank\" rel=\"noopener\">Getting Started with Redux</a></h3><p>Redux 作者出的入门教学视频，不过非常贴心的配了字幕。</p>\n<h2 id=\"剧集类\"><a href=\"#剧集类\" class=\"headerlink\" title=\"剧集类\"></a>剧集类</h2><h3 id=\"《国家宝藏》系列\"><a href=\"#《国家宝藏》系列\" class=\"headerlink\" title=\"《国家宝藏》系列\"></a><a href=\"https://search.bilibili.com/all?keyword=%E5%9B%BD%E5%AE%B6%E5%AE%9D%E8%97%8F&amp;page=1&amp;order=totalrank\" target=\"_blank\" rel=\"noopener\">《国家宝藏》系列</a></h3><p>央视：你爸爸还是你爸爸。节目集结了以故宫博物院为首的<strong>九大博物馆</strong>，每个博物馆选出三件文物组内 battle，每件文物都有一位明星守护人来讲述这件文物前世今生的故事。总之吧，你要是不跪着看完请来打我……</p>\n<h3 id=\"地下交通站\"><a href=\"#地下交通站\" class=\"headerlink\" title=\"地下交通站\"></a><a href=\"https://www.bilibili.com/bangumi/play/ss20999/\" target=\"_blank\" rel=\"noopener\">地下交通站</a></h3><p>这是一部拿鬼子和汉奸做包袱的国产情景喜剧，<a href=\"https://movie.douban.com/subject/2133474/\" target=\"_blank\" rel=\"noopener\">豆瓣</a>评分 9.0，包袱无处不在，堪称国产神作，不过笑点低的就算了吧，别再笑岔过去- -</p>\n<h2 id=\"演讲类\"><a href=\"#演讲类\" class=\"headerlink\" title=\"演讲类\"></a>演讲类</h2><h3 id=\"玉伯在2017SEE-Conf大会上的演讲视频\"><a href=\"#玉伯在2017SEE-Conf大会上的演讲视频\" class=\"headerlink\" title=\"玉伯在2017SEE Conf大会上的演讲视频\"></a><a href=\"https://mp.weixin.qq.com/s/08A6OF3G-UnH3vm0vCZoGg\" target=\"_blank\" rel=\"noopener\">玉伯在2017SEE Conf大会上的演讲视频</a></h3><p>玉伯在首届蚂蚁体验科技 SEE Conf 大会上分享的总结，不管是前端还是设计师都值得一看。</p>\n<h3 id=\"故宫“看门人”带您探访紫禁城\"><a href=\"#故宫“看门人”带您探访紫禁城\" class=\"headerlink\" title=\"故宫“看门人”带您探访紫禁城\"></a><a href=\"http://m.bilibili.com/video/av6737337.html\" target=\"_blank\" rel=\"noopener\">故宫“看门人”带您探访紫禁城</a></h3><p>故宫博物院院长讲述故宫博物院概况，未开放区的故事，和故宫中的趣事。别的不说，院长的 ppt 做的很棒，同时讲解风趣幽默，还调侃了一下国家领导人，怪不得后面好多人站着听完。。</p>\n<h3 id=\"How-GitHub-Uses-GitHub-to-Build-GitHub\"><a href=\"#How-GitHub-Uses-GitHub-to-Build-GitHub\" class=\"headerlink\" title=\"How GitHub Uses GitHub to Build GitHub\"></a><a href=\"https://zachholman.com/talk/how-github-uses-github-to-build-github/\" target=\"_blank\" rel=\"noopener\">How GitHub Uses GitHub to Build GitHub</a></h3><p>题目看似一个绕口令，其实就是一个绕口令，这个视频为我们讲述了 github 团队是如何利用 github 搭建 github 这个站点的，不过该网站需要翻墙，也不知道当你观看的时候视频是否存在，一切随缘吧~</p>\n<h3 id=\"Git-and-GitHub-Secrets\"><a href=\"#Git-and-GitHub-Secrets\" class=\"headerlink\" title=\"Git and GitHub Secrets\"></a><a href=\"https://zachholman.com/talk/git-github-secrets/\" target=\"_blank\" rel=\"noopener\">Git and GitHub Secrets</a></h3><p>github 是当今最流行的版本控制工具了（没有之一），而 git 和 github 的功能非常强大，我们平常用到的都是一些最基本的功能，所以有一些隐藏功能是大多数人都不知道的，而这个视频就是 git 创始人之一Zach Hloman 的一篇演讲，可以让你了解到 git 和 github 的秘密机关。</p>\n<h3 id=\"缅怀经典！乔布斯2007年iPhone发布会全程-中文字幕\"><a href=\"#缅怀经典！乔布斯2007年iPhone发布会全程-中文字幕\" class=\"headerlink\" title=\"缅怀经典！乔布斯2007年iPhone发布会全程 中文字幕\"></a><a href=\"http://www.iqiyi.com/w_19rqw2asd9.html\" target=\"_blank\" rel=\"noopener\">缅怀经典！乔布斯2007年iPhone发布会全程 中文字幕</a></h3><p>乔布斯已经离开我们有一段时间了，但是他的传奇仍在继续，Apple 作为全球第二大互联网科技公司，其对世界的影响是有目共睹的，在 2018 年的今天，就让我们一起穿越回 2007 年，那一年是属于乔布斯的，是属于 iPhone的！</p>\n<h3 id=\"周其仁号称14亿人都应该看的关于以色列的演讲视频\"><a href=\"#周其仁号称14亿人都应该看的关于以色列的演讲视频\" class=\"headerlink\" title=\"周其仁号称14亿人都应该看的关于以色列的演讲视频\"></a><a href=\"https://mp.weixin.qq.com/s/JGB_BQXZ86L-ywDcAMtJRQ\" target=\"_blank\" rel=\"noopener\">周其仁号称14亿人都应该看的关于以色列的演讲视频</a></h3><p>北大国家发展研究院教授在联想之星 WILL 大会上发表的演讲，虽然主题是经济，但是值得所有人看一下。</p>\n<h3 id=\"官方完整视频！张小龙在微信公开课的4小时\"><a href=\"#官方完整视频！张小龙在微信公开课的4小时\" class=\"headerlink\" title=\"官方完整视频！张小龙在微信公开课的4小时\"></a><a href=\"https://mp.weixin.qq.com/s/CZZ7JSz-r1UexVY2xpJvZA\" target=\"_blank\" rel=\"noopener\">官方完整视频！张小龙在微信公开课的4小时</a></h3><p>“微信之父”张小龙在 2019微信公开课上的演讲，值得每一位产品经理观看研习，文字版：<a href=\"https://mp.weixin.qq.com/s/FgKpY62OceBAPpz5MklS_g\" target=\"_blank\" rel=\"noopener\">官方最完整版：张小龙微信公开课超时演讲，总结微信8年</a></p>\n<h3 id=\"推荐8个设计师必看的TED演讲\"><a href=\"#推荐8个设计师必看的TED演讲\" class=\"headerlink\" title=\"推荐8个设计师必看的TED演讲\"></a><a href=\"https://mp.weixin.qq.com/s/oEcZRIt4NOhWev2KRLJL6w\" target=\"_blank\" rel=\"noopener\">推荐8个设计师必看的TED演讲</a></h3><p>公众号【壹念视觉】给众道友推荐的 8 个网上口碑很好的 TED 设计演讲，这些已在网上流传已久，与其躺着刷抖音不如去看看这些，换换口味~</p>\n<h2 id=\"广告类\"><a href=\"#广告类\" class=\"headerlink\" title=\"广告类\"></a>广告类</h2><h3 id=\"年度走心广告：总有人偷偷爱着你\"><a href=\"#年度走心广告：总有人偷偷爱着你\" class=\"headerlink\" title=\"年度走心广告：总有人偷偷爱着你\"></a><a href=\"https://mp.weixin.qq.com/s/IIqjd-sFrPgcY6Tizc8_TA\" target=\"_blank\" rel=\"noopener\">年度走心广告：总有人偷偷爱着你</a></h3><p>这是 999感冒灵推出的感恩节短片，广告片选取真人事件改编，以一段网络问答为线，串联 5 个反转故事。看完后你会觉得：这个世界没有想象中的那么好，但似乎……也没那么糟，总有人偷偷爱着你。</p>\n<h3 id=\"近年最喜欢的-Apple-广告片\"><a href=\"#近年最喜欢的-Apple-广告片\" class=\"headerlink\" title=\"近年最喜欢的 Apple 广告片\"></a><a href=\"https://www.jianshu.com/p/e01c5bc2757d\" target=\"_blank\" rel=\"noopener\">近年最喜欢的 Apple 广告片</a></h3><p>来自简书-<a href=\"https://www.jianshu.com/u/ba6d563caa3a\" target=\"_blank\" rel=\"noopener\">刘英滕</a>的推荐，Apple 的广告往往不会单纯的宣传其产品，更注重的是传达一种理念，表达一种对设计和交互的思考，同时关注人情和应用场景。</p>\n<h3 id=\"两秒钟，你究竟错过了什么？——美国抵制分心驾驶公益广告\"><a href=\"#两秒钟，你究竟错过了什么？——美国抵制分心驾驶公益广告\" class=\"headerlink\" title=\"两秒钟，你究竟错过了什么？——美国抵制分心驾驶公益广告\"></a><a href=\"https://new.qq.com/omn/20171224/20171224A02ZLA.html\" target=\"_blank\" rel=\"noopener\">两秒钟，你究竟错过了什么？——美国抵制分心驾驶公益广告</a></h3><p>手机给我们传递了最新消息，有时无意中也为我们“推送”了安全隐患。开车时，即便是两秒钟的分神，也会使车辆碰撞的概率翻倍。<strong>专心驾驶</strong>，才是最不容错过的事！</p>\n<h3 id=\"啥是佩奇\"><a href=\"#啥是佩奇\" class=\"headerlink\" title=\"啥是佩奇\"></a><a href=\"https://www.zhihu.com/question/309457864/answer/576303849\" target=\"_blank\" rel=\"noopener\">啥是佩奇</a></h3><p>每到春节前后就有很多以亲情为主题的广告和宣传片，这部《啥是佩奇》虽然也带着推广的目的，但是它有一个不太一样的地方，就是<strong>没有把要推广的产品作为核心的”亲情解决方案”</strong>。</p>\n<blockquote>\n<p>亲情本身才是亲情的解决方案，这可能就是这部片子最值得欣赏的地方。</p>\n</blockquote>\n<h3 id=\"简单才是王道\"><a href=\"#简单才是王道\" class=\"headerlink\" title=\"简单才是王道\"></a><a href=\"https://www.bilibili.com/video/av31248682/\" target=\"_blank\" rel=\"noopener\">简单才是王道</a></h3><p>挪威创意广告《简单才是王道》，装逼开场苦逼结尾。搞笑之余阐述了对于人工智能的担忧和思考</p>\n<h3 id=\"杜蕾斯惨败，这才是2018年度最扎心广告\"><a href=\"#杜蕾斯惨败，这才是2018年度最扎心广告\" class=\"headerlink\" title=\"杜蕾斯惨败，这才是2018年度最扎心广告!\"></a><a href=\"https://mp.weixin.qq.com/s/E716DWBg0TuCZlAy8l8VOA\" target=\"_blank\" rel=\"noopener\">杜蕾斯惨败，这才是2018年度最扎心广告!</a></h3><blockquote>\n<p>如果生命到此为止<br>你是不是没有任何遗憾？</p>\n</blockquote>\n<h3 id=\"王者荣耀暖心公益片：过年这局，好好打\"><a href=\"#王者荣耀暖心公益片：过年这局，好好打\" class=\"headerlink\" title=\"王者荣耀暖心公益片：过年这局，好好打\"></a><a href=\"https://www.digitaling.com/projects/54473.html\" target=\"_blank\" rel=\"noopener\">王者荣耀暖心公益片：过年这局，好好打</a></h3><p>玩游戏无法逃离生活，游戏是生活的影子。游戏本身并无意义，是生活赋予了它一定意义。</p>\n<h2 id=\"纪录片类\"><a href=\"#纪录片类\" class=\"headerlink\" title=\"纪录片类\"></a>纪录片类</h2><h3 id=\"超级大工程\"><a href=\"#超级大工程\" class=\"headerlink\" title=\"超级大工程\"></a><a href=\"https://www.bilibili.com/video/av18659657/\" target=\"_blank\" rel=\"noopener\">超级大工程</a></h3><p>许多人类的想法建立起来似乎是不可能的。这是进步的一个不可避免的方面：事情越来越大。这是大坝，高速公路，桥梁和建筑已经改变了城市甚至国家的故事。这个系列的视频探索了百年来最大，最重，最高的建筑工程，并且看到了 10 年甚至 100 年前的超大型建筑</p>\n<h3 id=\"Google搜索：“How”\"><a href=\"#Google搜索：“How”\" class=\"headerlink\" title=\"Google搜索：“How”\"></a><a href=\"https://mp.weixin.qq.com/s/D5N50mE2ylkWf30zEuWu6Q\" target=\"_blank\" rel=\"noopener\">Google搜索：“How”</a></h3><p>Google 刚刚发布了 2017 年搜索关键词报告，这一年，我们在 Google 搜索栏，键入最多的一个单词是：<strong>“How”。</strong>为此 Google 做了一支名为“How”的视频。这家全球最大的搜索引擎公司，每天悄无声息的出现在我们生活里。 <strong>那个两寸长的搜索框，记录着 2017 年里人们的好奇、困惑、恐惧、沮丧、无助，但更多的是希望和善良。</strong></p>\n<h3 id=\"最动人的年度视频：3分钟回望2017\"><a href=\"#最动人的年度视频：3分钟回望2017\" class=\"headerlink\" title=\"最动人的年度视频：3分钟回望2017\"></a><a href=\"http://video.sina.com.cn/p/mobile/doc/2017-12-21/171367657863.html\" target=\"_blank\" rel=\"noopener\">最动人的年度视频：3分钟回望2017</a></h3><p>2017 即将结束，新浪带我们回首了这一年发生的种种，有国家的荣耀时刻，也有英雄的陨落</p>\n<h3 id=\"知乎发布-2017-大事记：关于世界，关于中国，关于你\"><a href=\"#知乎发布-2017-大事记：关于世界，关于中国，关于你\" class=\"headerlink\" title=\"知乎发布 2017 大事记：关于世界，关于中国，关于你\"></a><a href=\"https://zhuanlan.zhihu.com/p/32168125\" target=\"_blank\" rel=\"noopener\">知乎发布 2017 大事记：关于世界，关于中国，关于你</a></h3><p>知乎也发布了 2017 总结视频。。</p>\n<h3 id=\"因为热爱，才对世界饱含希望\"><a href=\"#因为热爱，才对世界饱含希望\" class=\"headerlink\" title=\"因为热爱，才对世界饱含希望\"></a><a href=\"https://bbs.hupu.com/24792317.html\" target=\"_blank\" rel=\"noopener\">因为热爱，才对世界饱含希望</a></h3><p>知乎发布 2018 年度回顾视频，收录了今年知乎热搜词背后的重大事件：金庸逝世、MH370调查组解散、创造101、杜嘉班纳辱华、IG夺冠等，2018年不够完美，我们经历苦痛，承受告别，但因为热爱，我们才好奇，才拥有光芒，才对世界饱含希望！片尾那句“除了这一生，我们又没有其他时间”，真的让人泪目！</p>\n<h3 id=\"Life-in-A-Day\"><a href=\"#Life-in-A-Day\" class=\"headerlink\" title=\"Life in A Day\"></a><a href=\"https://www.youtube.com/watch?v=JaFVr_cJJIY\" target=\"_blank\" rel=\"noopener\">Life in A Day</a></h3><p>这部 Youtube 筹划的纪录片，记录着全世界 2010 年 7 月 24 日这天，世界各角落的可能性。影片由全世界的 Youtube 使用者拍摄，上传至 Youtube，并由导演 Kevin MacDonald 和 Ridley Scott 剪辑成九十分钟影片，影片没有各种花哨的技术手法，为的是让你看到世界上最真实的人生百态。</p>\n<h3 id=\"北邮60年-校庆官方宣传片《世界因你而改变》\"><a href=\"#北邮60年-校庆官方宣传片《世界因你而改变》\" class=\"headerlink\" title=\"北邮60年 | 校庆官方宣传片《世界因你而改变》\"></a><a href=\"https://mp.weixin.qq.com/s/WCsWBkx0VM8YHPpCCmsaqg\" target=\"_blank\" rel=\"noopener\">北邮60年 | 校庆官方宣传片《世界因你而改变》</a></h3><p>这部六十周年校庆官方宣传片思路新颖，通过纪录15级毕业生张浩用镜头重新审视母校，让大家了解到北邮的过去和今天。同时还包含很多校友采访及珍贵的老资料，让人们感受到北邮所肩负的“传邮万里、国脉所系”的历史使命和“大众创业、万众创新”的时代责任。</p>\n<h3 id=\"工作细胞\"><a href=\"#工作细胞\" class=\"headerlink\" title=\"工作细胞\"></a><a href=\"https://movie.douban.com/subject/28514091/\" target=\"_blank\" rel=\"noopener\">工作细胞</a></h3><p>豆瓣评分 9.2 分的岛国神作，<strong>无论是否喜欢看动漫，都很难不被《工作细胞》精准秒杀。</strong>网易云音乐《工作细胞》主题曲的评论区里，有人这样说：</p>\n<blockquote>\n<p>请记住，如果哪天不高兴或者是有很不好的想法，请记住这个身体里有37兆细胞还在为你辛勤工作着，他们一直在努力，请你也不要放弃</p>\n</blockquote>\n<p>这里有一篇介绍，可以提前看一下：<a href=\"https://mp.weixin.qq.com/s/DSWZsfKyeLd1OAs8EzyDSg\" target=\"_blank\" rel=\"noopener\">《岛国9.2高分神作！揭露身体的秘密，看完再也不忍心作践自己….》</a></p>\n<h3 id=\"林下生命\"><a href=\"#林下生命\" class=\"headerlink\" title=\"林下生命\"></a><a href=\"https://www.bilibili.com/bangumi/media/md20364/\" target=\"_blank\" rel=\"noopener\">林下生命</a></h3><blockquote>\n<p>看看怪异、可怕、美丽得令人吃惊的无脊椎动物的世界吧！和大卫·爱登堡一起，去开创性地探索一个我们从未见过、却一直围绕在我们周围的壮观的微观宇宙吧！它们不仅仅包括臭虫和昆虫，还有奇异的蝉、萤火虫、结网的蜘蛛和荧光色的蜻蜓——更不用说其它令人难以置信的生命形式和它们惊人的秘密行为了。幸亏有了照明、光学和计算机动作控制技术的革新，这个动荡不安、超级有组织的世界终于以其非凡居民的视角被揭开了面纱。这些动物可能极其微小，但它们的生活的确是宏伟壮观的……</p>\n</blockquote>\n<h3 id=\"珠峰清道夫\"><a href=\"#珠峰清道夫\" class=\"headerlink\" title=\"珠峰清道夫\"></a><a href=\"http://www.dlili.tv/gresource/3691\" target=\"_blank\" rel=\"noopener\">珠峰清道夫</a></h3><p>豆瓣评分<strong>9.0</strong>，这部纪录片讲述的是夏尔巴人从世界屋脊往下背尸体的故事！每年珠峰都会迎来7万至10万的旅客。而这里没有公共厕所，也没有集中排泄体内废物的场所，随地大小便的后果就是，留下12吨的屎和数不清的生活垃圾。珠峰上的清道夫们，他们用自己的双手，还珠峰一片雪白；</p>\n<blockquote>\n<p>用自己的生命，还人间一片净土。</p>\n</blockquote>\n<p>他们是平凡人，却做着不平凡的事情。珠峰清道夫们，在用生命告诉我们。请不要去玷污珠峰的神圣保护它比征服它更有意义！</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"【敖厂长】史上最垃圾游戏判明\"><a href=\"#【敖厂长】史上最垃圾游戏判明\" class=\"headerlink\" title=\"【敖厂长】史上最垃圾游戏判明!\"></a><a href=\"http://www.bilibili.com/video/av12719263/\" target=\"_blank\" rel=\"noopener\">【敖厂长】史上最垃圾游戏判明!</a></h3><p>被誉为“镇站之宝”的 Bilibili 视频，虽然完整的看下来之后只有佩服二字可言（因为从头到尾也没看懂说的是个啥），但是佩服就足够了，上一张伪封面图感受一下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_285.png\" alt=\"\"></div>\n\n<h3 id=\"2017-最火歌曲，YouTube-第一个浏览量达到-30-亿的MV\"><a href=\"#2017-最火歌曲，YouTube-第一个浏览量达到-30-亿的MV\" class=\"headerlink\" title=\"2017 最火歌曲，YouTube 第一个浏览量达到 30 亿的MV\"></a><a href=\"https://www.ixigua.com/a6454878191382168078/#mid=52142827529\" target=\"_blank\" rel=\"noopener\">2017 最火歌曲，YouTube 第一个浏览量达到 30 亿的MV</a></h3><p>RT，这首《despacito》是一首西语歌，发行于 2017 年 1 月 13 日，发行之后就收获了很多奖项：YouTube 网站上播放量最多、YouTube 上第一个浏览量达到30亿次的视频、YouTube 上最快达到 20 亿次浏览量的视频；当然，由于贾斯汀比伯的加入，让《despacito》更火了。其中这个剪辑视频的最后，当人们听到贾斯汀比伯的西语时的表情是一个亮点。。</p>\n<h3 id=\"3-分钟带你认识一夜爆火的“引力波”，目前最清楚明了的科普短片\"><a href=\"#3-分钟带你认识一夜爆火的“引力波”，目前最清楚明了的科普短片\" class=\"headerlink\" title=\"3 分钟带你认识一夜爆火的“引力波”，目前最清楚明了的科普短片\"></a><a href=\"https://mp.weixin.qq.com/s/DVbIbSpi3GDizTMIOvixIQ\" target=\"_blank\" rel=\"noopener\">3 分钟带你认识一夜爆火的“引力波”，目前最清楚明了的科普短片</a></h3><p>题目说明了一切。。</p>\n<h3 id=\"这样的旅行记录太酷了吧，像科幻大片\"><a href=\"#这样的旅行记录太酷了吧，像科幻大片\" class=\"headerlink\" title=\"这样的旅行记录太酷了吧，像科幻大片\"></a><a href=\"https://mp.weixin.qq.com/s/sG-mEth_NjYowsnviI00ZQ\" target=\"_blank\" rel=\"noopener\">这样的旅行记录太酷了吧，像科幻大片</a></h3><p>旅行记录做的非常酷</p>\n<h3 id=\"有什么特别治愈的音乐、视频或图片\"><a href=\"#有什么特别治愈的音乐、视频或图片\" class=\"headerlink\" title=\"有什么特别治愈的音乐、视频或图片?\"></a><a href=\"https://www.zhihu.com/question/303612486\" target=\"_blank\" rel=\"noopener\">有什么特别治愈的音乐、视频或图片?</a></h3><p>来自知乎的一则问答。</p>\n","raw":null,"categories":[{"name":"summary","path":"api/categories/summary.json"}],"tags":[{"name":"推荐","path":"api/tags/推荐.json"}]},{"title":"Merrier说还可以这样玩儿？！","slug":"Merrier说还可以这样玩儿？！","date":"2017-09-23T06:32:34.000Z","updated":"2019-02-04T13:27:44.349Z","comments":true,"path":"api/articles/Merrier说还可以这样玩儿？！.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_214.png","content":"<p>不知不觉，Merrier说 已经上线近半年了；前不久添加了 CNZZ 的统计代码，虽然 UV、PV 不是很多，但是发现老访客的比例还是比较高的，下面我介绍一个技巧——“<strong>把喜欢的网站添加到主屏幕，方便以后访问</strong>”，这样以后再想访问我的博客就会变得很简单了（当然，也可以用在其他喜欢的网站）</p>\n<h2 id=\"第一步，打开浏览器，访问Merrier说主页（http-merrier-wang）\"><a href=\"#第一步，打开浏览器，访问Merrier说主页（http-merrier-wang）\" class=\"headerlink\" title=\"第一步，打开浏览器，访问Merrier说主页（http://merrier.wang）\"></a>第一步，打开浏览器，访问Merrier说主页（<a href=\"http://merrier.wang\">http://merrier.wang</a>）</h2><p>我的手机是iOS的，目前发现<strong>只有safari</strong>才行</p>\n<h2 id=\"第二步，点击浏览器下方的“发送”按钮\"><a href=\"#第二步，点击浏览器下方的“发送”按钮\" class=\"headerlink\" title=\"第二步，点击浏览器下方的“发送”按钮\"></a>第二步，点击浏览器下方的“发送”按钮</h2><p>如下图红框处：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_214.png\" alt=\"\" width=\"300\"></div>\n\n<h2 id=\"第三步，找到“添加到主屏幕”按钮\"><a href=\"#第三步，找到“添加到主屏幕”按钮\" class=\"headerlink\" title=\"第三步，找到“添加到主屏幕”按钮\"></a>第三步，找到“添加到主屏幕”按钮</h2><p>如下图红框处，在靠下方位置（不要在意那个“宇宙第一美男”。。）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_215.png\" alt=\"\" width=\"300\"></div>\n\n<h2 id=\"最后一步，点击“添加”按钮即可\"><a href=\"#最后一步，点击“添加”按钮即可\" class=\"headerlink\" title=\"最后一步，点击“添加”按钮即可\"></a>最后一步，点击“添加”按钮即可</h2><p>由于wordpress本身就做了这方面的工作，所以当我们在上一步点击“添加到主屏幕”时，就会看到下面已经配置好的内容：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_216.png\" alt=\"\" width=\"300\"></div>\n\n<p>从上面的截图中可以看出，“添加到主屏幕”的结果是：一个图标将会添加到您的主屏幕，以便您快速访问此网站。</p>\n<h2 id=\"最终结果\"><a href=\"#最终结果\" class=\"headerlink\" title=\"最终结果\"></a>最终结果</h2><p>添加到主屏幕之后，我们就可以看到主屏幕上多了一个“很怪”的图标。。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_120.png\" alt=\"\" width=\"300\"></div>\n\n<p>以后直接点击 Merrier说 图标就可以访问我的博客啦~~！！</p>\n<h2 id=\"关于安卓\"><a href=\"#关于安卓\" class=\"headerlink\" title=\"关于安卓\"></a>关于安卓</h2><p>iOS 可以按照上面的步骤添加图标至主屏幕，安卓的话因为身边没有安卓手机，所以暂时不太了解有没有类似功能。。（据说安卓的 UC 浏览器中有类似的按钮？）</p>\n","raw":null,"categories":[{"name":"mobile","path":"api/categories/mobile.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"Merrier说","path":"api/tags/Merrier说.json"}]},{"title":"不想当诗人的程序员不是好工程师","slug":"不想当诗人的程序员不是好工程师","date":"2017-09-06T14:40:12.000Z","updated":"2019-02-04T13:27:44.353Z","comments":true,"path":"api/articles/不想当诗人的程序员不是好工程师.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>RT，作为一名程序员，如果会几首诗，那你就不是一名普通的程序员，而是一名</p>\n<p><strong>会几首诗的程序员</strong></p>\n<h2 id=\"一封情书（中文更惊艳）\"><a href=\"#一封情书（中文更惊艳）\" class=\"headerlink\" title=\"一封情书（中文更惊艳）\"></a>一封情书（中文更惊艳）</h2><blockquote>\n<p>I love three things in this world.<br>Sun, Moon and You.<br>Sun for morning,<br>Moon for night,<br>and You forever.</p>\n</blockquote>\n<p>中文版：</p>\n<blockquote>\n<p>浮世三千，吾爱有三。<br>日、月与卿。<br>日为朝，<br>月为暮，<br>卿为朝朝暮暮。</p>\n</blockquote>\n<p>另一个版本：</p>\n<blockquote>\n<p>浮世三千，挚爱有三。<br>喷薄朝阳，皓婉皎月；<br>不及汝尔，沧海桑田。</p>\n</blockquote>\n<h2 id=\"如果有来生\"><a href=\"#如果有来生\" class=\"headerlink\" title=\"如果有来生\"></a>如果有来生</h2><blockquote>\n<p>如果有来生，<br>要做一棵树，<br>站成永恒，没有悲欢的姿势。<br>一半在土里安详，一半在风里飞扬，<br>一半洒落阴凉，一半沐浴阳光，<br>非常沉默非常骄傲， 从不依靠从不寻找。</p>\n</blockquote>\n<h2 id=\"毛不易《消愁》\"><a href=\"#毛不易《消愁》\" class=\"headerlink\" title=\"毛不易《消愁》\"></a>毛不易《消愁》</h2><blockquote>\n<p>一杯敬朝阳，一杯敬月光；<br>一杯敬故乡，一杯敬远方；<br>一杯敬明天，一杯敬过往；<br>一杯敬自由，一杯敬死亡。</p>\n</blockquote>\n<h2 id=\"木心《从前慢》\"><a href=\"#木心《从前慢》\" class=\"headerlink\" title=\"木心《从前慢》\"></a>木心《从前慢》</h2><blockquote>\n<p>从前车马很慢，<br>书信很远，<br>一生只够爱一个人。</p>\n</blockquote>\n<h2 id=\"黑别人可不是好孩子\"><a href=\"#黑别人可不是好孩子\" class=\"headerlink\" title=\"黑别人可不是好孩子\"></a><a href=\"http://mp.weixin.qq.com/s/Qz17OFqQ_bcrqhG82d-q9A\" target=\"_blank\" rel=\"noopener\">黑别人可不是好孩子</a></h2><blockquote>\n<p>从一而终薛之谦<br>百年贤妻翟欣欣<br>下周回国贾跃亭<br>真爱无敌邓文迪<br>遵纪守法郎咸平<br>西门官人王宝强</p>\n</blockquote>\n<h2 id=\"来自网易云音乐《起风了（Cover-高橋優）》评论\"><a href=\"#来自网易云音乐《起风了（Cover-高橋優）》评论\" class=\"headerlink\" title=\"来自网易云音乐《起风了（Cover 高橋優）》评论\"></a>来自<a href=\"http://music.163.com/#/song?id=461525011\" target=\"_blank\" rel=\"noopener\">网易云音乐《起风了（Cover 高橋優）》</a>评论</h2><blockquote>\n<p>我是个俗气至顶的人，见山是山，见海是海，见花便是花。<br>唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。<br>你无需开口，我和天地万物便通通奔向你。<br>曾经我自诩半个诗人，见山是深情伟岸，见海是热情澎湃，见花见草信他们皆有故事，云海江潮，虫鸣鸟啼都暗藏情愫。<br>唯独见了你，山川沉默，海面静谧，云海不再翻涌，江潮不再澎湃，花鸟鱼虫被光与尘凝固，世界万籁俱寂，只剩下你。</p>\n</blockquote>\n<h2 id=\"梁启超《少年中国说》\"><a href=\"#梁启超《少年中国说》\" class=\"headerlink\" title=\"梁启超《少年中国说》\"></a>梁启超《少年中国说》</h2><blockquote>\n<p>故今日之责任，不在他人，而全在我少年。<br>少年智则国智，少年富则国富；<br>少年强则国强，少年独立则国独立；<br>少年自由则国自由；少年进步则国进步；<br>少年胜于欧洲，则国胜于欧洲；<br>少年雄于地球，则国雄于地球。<br>红日初升，其道大光。<br>河出伏流，一泻汪洋。<br>潜龙腾渊，鳞爪飞扬。<br>乳虎啸谷，百兽震惶。<br>鹰隼试翼，风尘翕张。<br>奇花初胎，矞矞皇皇。<br>干将发硎，有作其芒。<br>天戴其苍，地履其黄。<br>纵有千古，横有八荒。<br>前途似海，来日方长。<br>美哉我少年中国，与天不老！<br>壮哉我中国少年，与国无疆！</p>\n</blockquote>\n<h2 id=\"《侠客行》\"><a href=\"#《侠客行》\" class=\"headerlink\" title=\"《侠客行》\"></a>《侠客行》</h2><blockquote>\n<p>十步杀一人，<br>千里不留行。<br>事了拂衣去，<br>深藏身与名。</p>\n</blockquote>\n<h2 id=\"《横渠四句》\"><a href=\"#《横渠四句》\" class=\"headerlink\" title=\"《横渠四句》\"></a>《横渠四句》</h2><blockquote>\n<p>为天地立心，<br>为生民立命，<br>为往圣继绝学，<br>为万世开太平</p>\n</blockquote>\n<h2 id=\"《寻李白》\"><a href=\"#《寻李白》\" class=\"headerlink\" title=\"《寻李白》\"></a>《寻李白》</h2><blockquote>\n<p>酒入豪肠，七分酿成了月光<br>余下的三分啸成剑气<br>绣口一吐，就半个盛唐</p>\n</blockquote>\n<h2 id=\"龙应台《目送》\"><a href=\"#龙应台《目送》\" class=\"headerlink\" title=\"龙应台《目送》\"></a>龙应台《目送》</h2><blockquote>\n<p>很多时候不是我们去看父母的背影<br>而是承受他们追逐的目光，<br>承受他们不舍的，<br>不放心的，满眼的目送。<br>最后才渐渐明白，<br>这个世界上，再也没有任何人，<br>可以像父母一样，爱我如生命。</p>\n</blockquote>\n<h2 id=\"互联网\"><a href=\"#互联网\" class=\"headerlink\" title=\"互联网\"></a>互联网</h2><blockquote>\n<p>产品有三宝，弹窗，浮层加引导；<br>设计有三宝，透明，阴影加圆角；<br>运营有三宝，短信，推送加红包；<br>程序员有一宝，这个做不了。</p>\n</blockquote>\n<h2 id=\"卧春（我蠢）\"><a href=\"#卧春（我蠢）\" class=\"headerlink\" title=\"卧春（我蠢）\"></a>卧春（我蠢）</h2><blockquote>\n<p>暗梅幽闻花，（俺没有文化，）<br>卧枝伤恨底。（我智商很低。）<br>遥闻卧似水，（要问我是谁，）<br>易透达春绿。（一头大蠢驴。）<br>岸似绿，（俺是驴，）<br>岸似透绿，（俺是头驴，）<br>岸似透黛绿。 （俺是头呆驴。）</p>\n</blockquote>\n<h2 id=\"武汉大学第二届情书大赛冠军作品\"><a href=\"#武汉大学第二届情书大赛冠军作品\" class=\"headerlink\" title=\"武汉大学第二届情书大赛冠军作品\"></a>武汉大学第二届情书大赛冠军作品</h2><blockquote>\n<p>螃蟹在剥我的壳<br>笔记本在写我<br>满天的我落在枫叶上雪花上<br>而你在想我</p>\n</blockquote>\n<p>你读懂了吗？</p>\n<h2 id=\"就像是爱情\"><a href=\"#就像是爱情\" class=\"headerlink\" title=\"就像是爱情\"></a>就像是爱情</h2><p>在任何东西后面加上“就像是爱情”，就会变得巨有哲理巨像写诗：</p>\n<blockquote>\n<p>WINDOWS的更新<br>总在最不该来的时候开始<br>就像是爱情</p>\n</blockquote>\n<blockquote>\n<p>外卖送到五百米<br>又拐去八百米<br>现在距离我有一千米<br>就像是爱情</p>\n</blockquote>\n<blockquote>\n<p>装修队的师傅说<br>过年来不了<br>年后也不行<br>他也不知道什么时候来<br>就像是爱情</p>\n</blockquote>\n","raw":null,"categories":[{"name":"talk","path":"api/categories/talk.json"}],"tags":[{"name":"life","path":"api/tags/life.json"}]},{"title":"Mac下的效率工具autojump","slug":"Mac下的效率工具autojump","date":"2017-08-30T13:09:31.000Z","updated":"2019-02-04T13:27:44.349Z","comments":true,"path":"api/articles/Mac下的效率工具autojump.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>首先，这篇文章的封面图是我随便找的，好像是一个游戏的名字。。但是就连 <a href=\"https://github.com/wting/autojump\" target=\"_blank\" rel=\"noopener\">autojump的github</a> 上面都没有一张图片，所以我也很无奈啊~</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>autojump 是干什么的呢？从它的名字能看出来，它的功能类似“<strong>自动跳转</strong>”，比如我们之前曾经访问过一个目录：<code>/Users/frontend/repos/mineProject</code>，现在我们通过简单的一条指令：autojump mine 就可以跳转到这个目录（注意：我们在任意位置都可以跳），autojump 它自己是这么描述的：</p>\n<blockquote>\n<p>autojump is a faster way to navigate your filesystem. It works by maintaining a database of the directories you use the most from the command line.</p>\n</blockquote>\n<p>autojump 就是通过记录你在 history 中的行为把你访问过的文件夹路径都 cache 下来，然后当你输入指令时再读取 cache 文件(<strong>/Users/frontend/Library/autojump/autojump.txt</strong>)，它还有一个快捷方式：<code>j mine</code>，总而言之，这个小工具可以让你游荡于文件夹之间不费吹灰之力！</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"首先，安装-homebrew\"><a href=\"#首先，安装-homebrew\" class=\"headerlink\" title=\"首先，安装 homebrew\"></a>首先，安装 homebrew</h3><p>homebrew 是 mac 上的一个软件包管理器，可以通过如下方式进行安装（粘贴至终端即可）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure>\n<p>更多关于 homebrew 的介绍可以查看<a href=\"https://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">它的官网</a></p>\n<h3 id=\"然后，安装-zsh\"><a href=\"#然后，安装-zsh\" class=\"headerlink\" title=\"然后，安装 zsh\"></a>然后，安装 zsh</h3><p>给大家讲个笑话：</p>\n<blockquote>\n<p>Zsh 全称为 Z Shell，因为 Z 是最后一个字母，因此大家称之为——终极 Shell。</p>\n</blockquote>\n<p>我们可以通过 brew 安装 zsh：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install zsh</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-autojump\"><a href=\"#安装-autojump\" class=\"headerlink\" title=\"安装 autojump\"></a>安装 autojump</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install autojump</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-zshrc\"><a href=\"#配置-zshrc\" class=\"headerlink\" title=\"配置 .zshrc\"></a>配置 .zshrc</h3><p>在 <code>~/.zshrc</code> 中编辑以下内容：<code>plugins=(autojump)</code>，当然，如果你有其他 zsh 插件比如 git，直接在后面添加即可：<code>plugins=(git autojump)</code>。然后继续在 .zshrc 文件中添加如下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\[ -s $(brew --prefix)/etc/profile.d/autojump.sh \\]\\] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure>\n<p>还剩最后一步，使刚才的更改生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>Enjoy coding:)</p>\n<h2 id=\"其他可能错误\"><a href=\"#其他可能错误\" class=\"headerlink\" title=\"其他可能错误\"></a>其他可能错误</h2><h3 id=\"zshrc-3-command-not-found-M\"><a href=\"#zshrc-3-command-not-found-M\" class=\"headerlink\" title=\".zshrc:3: command not found: ^M\"></a>.zshrc:3: command not found: ^M</h3><blockquote>\n<p>The temporary solution to that is changing your core.autocrlf git config setting to use input, given that you are on OSX. See <a href=\"https://github.com/robbyrussell/oh-my-zsh/issues/4402#issuecomment-143976458\" target=\"_blank\" rel=\"noopener\">#4402 (comment)</a>.</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$ZSH</span> </span><br><span class=\"line\">git config core.autocrlf input </span><br><span class=\"line\">git rm --cached -r . </span><br><span class=\"line\">git reset --hard</span><br></pre></td></tr></table></figure>\n<h3 id=\"PATH-set-to-RVM-ruby-but-GEM-HOME-and-or-GEM-PATH-not-set\"><a href=\"#PATH-set-to-RVM-ruby-but-GEM-HOME-and-or-GEM-PATH-not-set\" class=\"headerlink\" title=\"PATH set to RVM ruby but GEM_HOME and/or GEM_PATH not set\"></a>PATH set to RVM ruby but GEM_HOME and/or GEM_PATH not set</h3><blockquote>\n<p><a href=\"https://github.com/rvm/rvm/issues/3212\" target=\"_blank\" rel=\"noopener\">PATH set to RVM ruby but GEM_HOME and/or GEM_PATH not set</a> Add RVM set at <code>~/.zshrc</code>:</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">\"<span class=\"variable\">$PATH</span>:<span class=\"variable\">$HOME</span>/.rvm/bin\"</span> <span class=\"comment\"># Add RVM to PATH for scripting</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.barretlee.com/blog/2015/03/30/autojump-in-mac/\" target=\"_blank\" rel=\"noopener\">Mac下的效率工具autojump</a></li>\n<li><a href=\"http://www.jianshu.com/p/5ced5876cba4\" target=\"_blank\" rel=\"noopener\">mac终端快速启动Sublime/WebStrom/VS Code/Atom等编辑器</a></li>\n<li><a href=\"http://www.jianshu.com/p/0d265d9f914b\" target=\"_blank\" rel=\"noopener\">MacOS X 安装 oh-my-zsh autojump</a></li>\n</ul>\n","raw":null,"categories":[{"name":"tool","path":"api/categories/tool.json"}],"tags":[{"name":"mac","path":"api/tags/mac.json"},{"name":"autojump","path":"api/tags/autojump.json"}]},{"title":"网罗天下好教程","slug":"网罗天下好教程","date":"2017-08-27T07:56:15.000Z","updated":"2019-02-04T13:27:44.357Z","comments":true,"path":"api/articles/网罗天下好教程.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>总结了一下我看过的好的教程，多数为系列文章，鉴于如今信息鱼龙混杂，这篇文章可以省去很多找好教程的时间。</p>\n<h2 id=\"入门级\"><a href=\"#入门级\" class=\"headerlink\" title=\"入门级\"></a>入门级</h2><h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><h4 id=\"手把手教你使用Hexo-Github-Pages搭建个人独立博客\"><a href=\"#手把手教你使用Hexo-Github-Pages搭建个人独立博客\" class=\"headerlink\" title=\"手把手教你使用Hexo + Github Pages搭建个人独立博客\"></a><a href=\"https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/\" target=\"_blank\" rel=\"noopener\">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></h4><p>很完整很详细的 Hexo 搭建个人博客教程</p>\n<h4 id=\"从0到1搭建和部署个人博客\"><a href=\"#从0到1搭建和部署个人博客\" class=\"headerlink\" title=\"从0到1搭建和部署个人博客\"></a><a href=\"https://juejin.im/post/5ae170e1f265da0b7527d0dc\" target=\"_blank\" rel=\"noopener\">从0到1搭建和部署个人博客</a></h4><p>此教程会教你从 0 到 1 搭建一个完整的博客，包括前端展示页、后台管理系统、后端接口及接口文档、服务端部署整个完整流程。技术栈是 vue+express+mongodb</p>\n<h4 id=\"Hexo-主题开发指南\"><a href=\"#Hexo-主题开发指南\" class=\"headerlink\" title=\"Hexo 主题开发指南\"></a><a href=\"http://chensd.com/2016-06/hexo-theme-guide.html\" target=\"_blank\" rel=\"noopener\">Hexo 主题开发指南</a></h4><p>该文章包含的内容如下：</p>\n<ul>\n<li>主题的基本结构</li>\n<li>常见问题</li>\n<li>常用页面的实现</li>\n<li>基本工具</li>\n</ul>\n<h3 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h3><h4 id=\"CSS布局说——可能是最全的\"><a href=\"#CSS布局说——可能是最全的\" class=\"headerlink\" title=\"CSS布局说——可能是最全的\"></a><a href=\"https://segmentfault.com/a/1190000011358507\" target=\"_blank\" rel=\"noopener\">CSS布局说——可能是最全的</a></h4><p>其实很多时候，我们都会在布局上花费很多时间，尤其是遇到一个比较“严格”的设计师的时候，而 css 虽然语法简单（css 有语法？），但是真正用起来会有很多学问，而布局这种问题是老生常谈的问题了，这篇来自 SegmentFault的文章对 css 中的布局的相关知识进行了总结，满满的干货。</p>\n<h4 id=\"CSS-中重要的层叠概念\"><a href=\"#CSS-中重要的层叠概念\" class=\"headerlink\" title=\"CSS 中重要的层叠概念\"></a><a href=\"https://juejin.im/post/5ba4efe36fb9a05cf52ac192\" target=\"_blank\" rel=\"noopener\">CSS 中重要的层叠概念</a></h4><p>作者参考了很多关于层叠概念的文章，对这一经常迷糊的概念进行了全面总结，讲解的非常清晰全面，是我看过的讲层叠概念最好的文章，十分值得一看！</p>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><h4 id=\"JavaScript-标准参考教程（alpha）\"><a href=\"#JavaScript-标准参考教程（alpha）\" class=\"headerlink\" title=\"JavaScript 标准参考教程（alpha）\"></a><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程（alpha）</a></h4><p>阮一峰的 JS 教程，内容很多，而且讲解的很详细，很透彻，是一篇不错的 JS 入门教程。</p>\n<h4 id=\"如何定义一个高逼格的原生JS插件\"><a href=\"#如何定义一个高逼格的原生JS插件\" class=\"headerlink\" title=\"如何定义一个高逼格的原生JS插件\"></a><a href=\"https://juejin.im/entry/5ae033d86fb9a07ac76e7bcc\" target=\"_blank\" rel=\"noopener\">如何定义一个高逼格的原生JS插件</a></h4><p>作者通过很多实例介绍了如何定义自己的 JS 插件，包含了很多方面和技巧</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><h4 id=\"七天学会node-js\"><a href=\"#七天学会node-js\" class=\"headerlink\" title=\"七天学会node.js\"></a><a href=\"http://nqdeng.github.io/7-days-nodejs/\" target=\"_blank\" rel=\"noopener\">七天学会node.js</a></h4><p>这是一篇比较详细的 node.js 入门教程，但是我确实没有七天就学会。。</p>\n<h4 id=\"node-js之fs模块\"><a href=\"#node-js之fs模块\" class=\"headerlink\" title=\"node.js之fs模块\"></a><a href=\"https://www.jianshu.com/p/5683c8a93511\" target=\"_blank\" rel=\"noopener\">node.js之fs模块</a></h4><p>fs 模块是 node.js 中一个很重要的模块，其提供了文件相关操作，包括打开、读取、写入和追加等等操作</p>\n<h4 id=\"Express-4-入门中文手册\"><a href=\"#Express-4-入门中文手册\" class=\"headerlink\" title=\"Express 4 入门中文手册\"></a><a href=\"https://www.zybuluo.com/bajian/note/444152\" target=\"_blank\" rel=\"noopener\">Express 4 入门中文手册</a></h4><p>最近在做 node  相关的项目，express 之前接触过，但是基本上一点印象都没有留下。。然后 express 的英文文档从布局和样式上就给人一种不想看的感觉，同时我的英语水平也很差，所以就在网上找了很久的中文文档，最终追根溯源找到了上面这篇，无法评价好坏，因为有就不错了嘛~</p>\n<h4 id=\"Redux中文文档\"><a href=\"#Redux中文文档\" class=\"headerlink\" title=\"Redux中文文档\"></a><a href=\"http://cn.redux.js.org/\" target=\"_blank\" rel=\"noopener\">Redux中文文档</a></h4><p>在线 gitbook，有很多实例，是一个很不过的 redux 入门文档（我就是通过看这个文档入门的~）</p>\n<h4 id=\"Redux从设计到源码\"><a href=\"#Redux从设计到源码\" class=\"headerlink\" title=\"Redux从设计到源码\"></a><a href=\"https://tech.meituan.com/redux-design-code.html\" target=\"_blank\" rel=\"noopener\">Redux从设计到源码</a></h4><p>这也是一篇 Redux 入门教程，虽然比不上上面的教程，但是这篇文章里面的某些图片画的还是相当不错的，可以当做补充资料</p>\n<h4 id=\"react-starter-kit-入门（翻译）\"><a href=\"#react-starter-kit-入门（翻译）\" class=\"headerlink\" title=\"react-starter-kit 入门（翻译）\"></a><a href=\"http://www.jianshu.com/p/6c522c9a20cb\" target=\"_blank\" rel=\"noopener\">react-starter-kit 入门（翻译）</a></h4><p>starter-kit 的教程实在太少了，只找到了这一篇中文的，就先凑合看吧，具体写的好不好可以先睹为快，因为篇幅比较短，而且 starter-kit 本来就是一个脚手架，还是需要了解其他技术栈才能真正看懂</p>\n<h4 id=\"React-Router官方教程\"><a href=\"#React-Router官方教程\" class=\"headerlink\" title=\"React Router官方教程\"></a><a href=\"https://github.com/reactjs/react-router-tutorial\" target=\"_blank\" rel=\"noopener\">React Router官方教程</a></h4><p>官方给出的 react-router 入门文档，通过14个实例一步步进行讲解，由浅入深，由易到难，只需要一个多小时就可以跟着文档写完 14 个实例，同时在写的过程中还可以学习到 express 和 webpack 的相关知识。</p>\n<h4 id=\"Redux作者出的教学视频\"><a href=\"#Redux作者出的教学视频\" class=\"headerlink\" title=\"Redux作者出的教学视频\"></a><a href=\"https://egghead.io/instructors/dan-abramov\" target=\"_blank\" rel=\"noopener\">Redux作者出的教学视频</a></h4><p>Redux 作者自己在 egghead.io 上面上传了教学视频，墙裂推荐，不过全程英文讲解，可能会有点费劲- -：</p>\n<ul>\n<li>基础篇：<a href=\"https://egghead.io/courses/getting-started-with-redux\" target=\"_blank\" rel=\"noopener\">Getting Started with Redux</a></li>\n<li>进阶篇：<a href=\"https://egghead.io/courses/building-react-applications-with-idiomatic-redux\" target=\"_blank\" rel=\"noopener\">Building React Applications with Idiomatic Redux</a></li>\n</ul>\n<h4 id=\"从零开始学-ReactJS（ReactJS-101）\"><a href=\"#从零开始学-ReactJS（ReactJS-101）\" class=\"headerlink\" title=\"从零开始学 ReactJS（ReactJS 101）\"></a><a href=\"https://github.com/carlleton/reactjs101/tree/zh-CN\" target=\"_blank\" rel=\"noopener\">从零开始学 ReactJS（ReactJS 101）</a></h4><p>从零开始学 ReactJS（ReactJS 101）是一本希望让初学者一看就懂的 ReactJS 中文入门教学书，由浅入深学习 ReactJS 生态系 (Flux, Redux, React Router, ImmutableJS, React Native, Relay/GraphQL etc.)。</p>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><h4 id=\"入门Webpack，看这篇就够了\"><a href=\"#入门Webpack，看这篇就够了\" class=\"headerlink\" title=\"入门Webpack，看这篇就够了\"></a><a href=\"http://www.jianshu.com/p/42e11515c10f#\" target=\"_blank\" rel=\"noopener\">入门Webpack，看这篇就够了</a></h4><p>进度条说明了一切，作者通过对比 gulp 和 webpack，详细的介绍了 webpack 的优缺点，同时还介绍了一些其他工具的用法，虽然篇幅较长，但是大部分都是代码，可以跟着作者自己敲一遍，相信敲完之后的你可以自信的说 webpack 我终(hai)于(shi)会(bu)了(hui)</p>\n<h4 id=\"webpack-2-打包实战\"><a href=\"#webpack-2-打包实战\" class=\"headerlink\" title=\"webpack 2 打包实战\"></a><a href=\"https://github.com/fenivana/webpack-in-action/\" target=\"_blank\" rel=\"noopener\">webpack 2 打包实战</a></h4><p>这是一篇对于 webpack 2 的讲解，作者通过追根溯源向我们阐述了为什么需要 webpack，作为历史的产物， webpack 具备哪些优势，文章篇幅较长，不过弥补了 webpack 官方文档写的很差的缺陷，是一篇比较不错的 webpack 入门文档</p>\n<h4 id=\"令人困惑的webpack之entry\"><a href=\"#令人困惑的webpack之entry\" class=\"headerlink\" title=\"令人困惑的webpack之entry\"></a><a href=\"https://segmentfault.com/a/1190000008288240\" target=\"_blank\" rel=\"noopener\">令人困惑的webpack之entry</a></h4><p>鉴于 webpack 的文档实在太差，而 webpack 本身又比较复杂，各种 loader，各种 plugin，各种配置，所以刚接触 webpack 的童鞋会感到很头疼，而 entry 作为 webpack 中最基础的配置，可以作为入门 webpack 的关键点，这篇文章非常详细的介绍了 entry 配置项的作用以及参数含义</p>\n<h4 id=\"用grunt搭建自动化的web前端开发环境-完整教程\"><a href=\"#用grunt搭建自动化的web前端开发环境-完整教程\" class=\"headerlink\" title=\"用grunt搭建自动化的web前端开发环境-完整教程\"></a><a href=\"http://developer.51cto.com/art/201506/479127.htm\" target=\"_blank\" rel=\"noopener\">用grunt搭建自动化的web前端开发环境-完整教程</a></h4><p>jQuery 在使用 grunt，bootstrap 在使用 grunt，百度 UEditor 在使用 grunt，你没有理由不学、不用！</p>\n<h4 id=\"Sublime-Text-2-性感无比的代码编辑器！程序员必备神器！\"><a href=\"#Sublime-Text-2-性感无比的代码编辑器！程序员必备神器！\" class=\"headerlink\" title=\"Sublime Text 2 - 性感无比的代码编辑器！程序员必备神器！\"></a><a href=\"http://www.iplaysoft.com/sublimetext.html\" target=\"_blank\" rel=\"noopener\">Sublime Text 2 - 性感无比的代码编辑器！程序员必备神器！</a></h4><p>这是一篇比较全的 sublime 介绍文章，作者介绍了很多 sublime 的特性和优点，同时还推荐了一些插件和使用技巧。</p>\n<h4 id=\"浅入浅出webpack\"><a href=\"#浅入浅出webpack\" class=\"headerlink\" title=\"浅入浅出webpack\"></a><a href=\"https://juejin.im/post/5afa9cd0f265da0b981b9af9\" target=\"_blank\" rel=\"noopener\">浅入浅出webpack</a></h4><p>webpack 作为一个非常流行的构建工具，其文档和使用一直为人所诟病，而当我真正的自己对 webpack 进行了了解和实战之后，发现其实 webpack 并不是那么难理解，而很多童鞋其实是因为 webpack 的功能太强大而对其产生了畏惧，这篇文章对这部分童鞋来说是一篇很好的教程，从基本使用的角度对 webpack 进行了介绍和讲解，除此之外还介绍一些高阶应用，如 TreeShaking、构建 PWA 应用等</p>\n<h4 id=\"iOS开发工具——网络封包分析工具Charles\"><a href=\"#iOS开发工具——网络封包分析工具Charles\" class=\"headerlink\" title=\"iOS开发工具——网络封包分析工具Charles\"></a><a href=\"http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles\" target=\"_blank\" rel=\"noopener\">iOS开发工具——网络封包分析工具Charles</a></h4><p><a href=\"http://www.charlesproxy.com/\" target=\"_blank\" rel=\"noopener\">Charles</a> 是在 Mac 下常用的截取网络封包的工具。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。作者在该教程中介绍了安装 Charles、安装SSL证书、将Charles设置成系统代理、过滤网络请求、截取 iPhone 上的网络封包、截取 SSL 信息、模拟慢速网络、修改网络请求内容等内容。</p>\n<h4 id=\"webpack-教程资源收集\"><a href=\"#webpack-教程资源收集\" class=\"headerlink\" title=\"webpack 教程资源收集\"></a><a href=\"https://github.com/kraaas/webpack-tutorial-collection\" target=\"_blank\" rel=\"noopener\">webpack 教程资源收集</a></h4><p>作者收集总结了关于 webpack 的各种教程，大概共有 50 篇文章。</p>\n<h4 id=\"运营小白带你5分钟入门谷歌分析-GA\"><a href=\"#运营小白带你5分钟入门谷歌分析-GA\" class=\"headerlink\" title=\"运营小白带你5分钟入门谷歌分析(GA)\"></a><a href=\"https://mp.weixin.qq.com/s/oJv0cOl71VfUW_Q2RUzChA\" target=\"_blank\" rel=\"noopener\">运营小白带你5分钟入门谷歌分析(GA)</a></h4><p>主要通过截图的方式简单介绍了如何使用 GA 进行数据分析，以及 GA 都有哪些功能。</p>\n<h4 id=\"全网最贴心的webpack4系列中文教程和配套代码\"><a href=\"#全网最贴心的webpack4系列中文教程和配套代码\" class=\"headerlink\" title=\"全网最贴心的webpack4系列中文教程和配套代码\"></a><a href=\"https://github.com/dongyuanxin/webpack-demos\" target=\"_blank\" rel=\"noopener\">全网最贴心的webpack4系列中文教程和配套代码</a></h4><p>作者花费了 3 个多月整理了这份教程，一共分成 16 节，每节都有讲解，并且准备了配套代码。</p>\n<h3 id=\"理论\"><a href=\"#理论\" class=\"headerlink\" title=\"理论\"></a>理论</h3><h4 id=\"同构-Isomorphic-web-是什么鬼？\"><a href=\"#同构-Isomorphic-web-是什么鬼？\" class=\"headerlink\" title=\"同构(Isomorphic) web 是什么鬼？\"></a><a href=\"http://www.jianshu.com/p/5ce23647e7e3\" target=\"_blank\" rel=\"noopener\">同构(Isomorphic) web 是什么鬼？</a></h4><p>同构这个概念最近比较火，相比 SPA，同构会有其独特的优势，作者用非常简短的语言介绍了同构产生的背景和如何将自己的网站改造为同构 web。</p>\n<h4 id=\"再不懂区块链，你就OUT了！\"><a href=\"#再不懂区块链，你就OUT了！\" class=\"headerlink\" title=\"再不懂区块链，你就OUT了！\"></a><a href=\"http://jingyan.baidu.com/zt/qukuailian/index.html\" target=\"_blank\" rel=\"noopener\">再不懂区块链，你就OUT了！</a></h4><p>区块链从 15 年到 17 年，但是你却任对区块链一知半解，百度经验联合火币网打造讲解区块链的系列小动画《区块链100问》 ，将抽象的区块链概念转化为100集轻松易懂的 1 分钟小动画，每集学懂一个知识点~</p>\n<h4 id=\"快乐的Linux命名行\"><a href=\"#快乐的Linux命名行\" class=\"headerlink\" title=\"快乐的Linux命名行\"></a><a href=\"http://billie66.github.io/TLCL/book/\" target=\"_blank\" rel=\"noopener\">快乐的Linux命名行</a></h4><p><a href=\"http://linuxcommand.org/\" target=\"_blank\" rel=\"noopener\">The Linux Command Line</a> 的中文版，一个文科生说他看完这个都会 Linux 了</p>\n<h4 id=\"HTTPS-的故事\"><a href=\"#HTTPS-的故事\" class=\"headerlink\" title=\"HTTPS 的故事\"></a><a href=\"https://juejin.im/post/5b10aa22e51d4506c5568f1d\" target=\"_blank\" rel=\"noopener\">HTTPS 的故事</a></h4><p>作者缘于在 Twitter 上看到的 <a href=\"https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fmedium.freecodecamp.org%2Fhttps-explained-with-carrier-pigeons-7029d2193351\" target=\"_blank\" rel=\"noopener\">HTTPS explained with carrier pigeons</a>，原作者用很简单的故事就把 HTTP / HTTPS 的传输过程讲解的很清楚。 借原文的意思，该作者重新写了这个故事，加上了一些配图和补充，很形象的解释了为什么要有https以及如何实现。</p>\n<h4 id=\"JS-函数式编程指南\"><a href=\"#JS-函数式编程指南\" class=\"headerlink\" title=\"JS 函数式编程指南\"></a><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/\" target=\"_blank\" rel=\"noopener\">JS 函数式编程指南</a></h4><p>这是<em><a href=\"https://github.com/DrBoolean/mostly-adequate-guide\" target=\"_blank\" rel=\"noopener\">mostly-adequate-guide</a></em>的中文版，可以说是最好的\b函数式编程书籍，作者还非常有心的提供了 EPUB 和 MOBI 格式的下载。</p>\n<h4 id=\"Bash-脚本-set-命令教程\"><a href=\"#Bash-脚本-set-命令教程\" class=\"headerlink\" title=\"Bash 脚本 set 命令教程\"></a><a href=\"http://www.ruanyifeng.com/blog/2017/11/bash-set.html\" target=\"_blank\" rel=\"noopener\">Bash 脚本 set 命令教程</a></h4><p>阮一峰老师写的教程，也是一些大牛推荐的 set 命令教程，文章短小精悍，基本上把 set 命令相关的所有知识都涵盖了。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"npm-scripts-使用指南\"><a href=\"#npm-scripts-使用指南\" class=\"headerlink\" title=\"npm scripts 使用指南\"></a><a href=\"http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html\" target=\"_blank\" rel=\"noopener\">npm scripts 使用指南</a></h4><p>阮一峰讲解的 npm script 入门知识，关于 npm script 首推这篇文章</p>\n<h4 id=\"Linux大棚版Thrift入门教程\"><a href=\"#Linux大棚版Thrift入门教程\" class=\"headerlink\" title=\"Linux大棚版Thrift入门教程\"></a><a href=\"http://roclinux.cn/?p=3316\" target=\"_blank\" rel=\"noopener\">Linux大棚版Thrift入门教程</a></h4><p>thrift 作为一种 RPC 框架，其诞生以来就受到了广泛关注，虽然 RPC 框架有很多种，但是 thrift 还是有其独特优势的，这篇入门教程篇幅较长，作者介绍了 thrift 的基础概念，同时通过实例介绍了如何应用 thrift，比其他教程要详细很多。</p>\n<h4 id=\"Shell脚本编程30分钟入门\"><a href=\"#Shell脚本编程30分钟入门\" class=\"headerlink\" title=\"Shell脚本编程30分钟入门\"></a><a href=\"https://github.com/qinjx/30min_guides/blob/master/shell.md\" target=\"_blank\" rel=\"noopener\">Shell脚本编程30分钟入门</a></h4><p>前端工程师和 shell 打交道会比较少，但是知道一些往往会节省自己很多时间，比如定时备份、定时提交修改神马的，这篇文章虽然看上去有点“标题党”的意思，但是作者介绍的还算详细，同时作者还有一些其他类型的“30 分钟教程”，也可以看一看（作者是多么喜欢30分钟这个时间段啊。。）</p>\n<h4 id=\"Docker-入门\"><a href=\"#Docker-入门\" class=\"headerlink\" title=\"Docker 入门\"></a><a href=\"http://www.jianshu.com/p/d4f24f8012fd\" target=\"_blank\" rel=\"noopener\">Docker 入门</a></h4><p>Docker 是一个非常有趣的项目。它最大的作用就是隔绝了操作系统环境，类似于虚拟机，但是相对于虚拟机，他又拥有绝对的高效率、和通用性。相信看完这篇文章之后，你会对docker有一个直观的认识= =</p>\n<h4 id=\"图说设计模式\"><a href=\"#图说设计模式\" class=\"headerlink\" title=\"图说设计模式\"></a><a href=\"\bhttp://design-patterns.readthedocs.io/zh_CN/latest/index.html\">图说设计模式</a></h4><p>通过画图的方式理解设计模式，以一种轻松的姿势理解高深的学问。</p>\n<h4 id=\"Go-指南\"><a href=\"#Go-指南\" class=\"headerlink\" title=\"Go 指南\"></a><a href=\"https://tour.go-zh.org/list\" target=\"_blank\" rel=\"noopener\">Go 指南</a></h4><p>该指南介绍了 Go 的大部分重要特性，同时有一些练习进行巩固。</p>\n<h4 id=\"centos-6-7安装最新版-git\"><a href=\"#centos-6-7安装最新版-git\" class=\"headerlink\" title=\"centos 6.7安装最新版 git\"></a><a href=\"https://segmentfault.com/a/1190000007134786\" target=\"_blank\" rel=\"noopener\">centos 6.7安装最新版 git</a></h4><p>阿里云上的 ECS 很多人都会选择 CentOS 系统，而作为前端，可能需要安装 nvm，但是 CentOS 6.7 默认安装的 git 版本是比较低的 1.7.1 版本，所以需要重新安装最新版 git，这篇教程讲的很详细，我按照他的步骤很顺利的就安装成功了。</p>\n<h4 id=\"Jenkins-nginx-搭建前端构建环境\"><a href=\"#Jenkins-nginx-搭建前端构建环境\" class=\"headerlink\" title=\"Jenkins+nginx 搭建前端构建环境\"></a><a href=\"https://juejin.im/post/5b371678f265da599f68dfa2\" target=\"_blank\" rel=\"noopener\">Jenkins+nginx 搭建前端构建环境</a></h4><p>废话很少，直接上代码的方式我很喜欢，Jenkins 解决了很令人头疼的构建问题，所以如果想成为一名称职的前端工程师，这是一篇值得参考和手巧的教程，赶快跟着作者的手速敲起来吧！</p>\n<h4 id=\"技术胖-155-集前端视频教程\"><a href=\"#技术胖-155-集前端视频教程\" class=\"headerlink\" title=\"技术胖 155 集前端视频教程\"></a><a href=\"https://juejin.im/post/5a5bc8c36fb9a01ca26774eb\" target=\"_blank\" rel=\"noopener\">技术胖 155 集前端视频教程</a></h4><p>技术胖在 2017 年录制的 155 集视频教程，可以免费观看，其中包括 Vue2.x、Vue-cli、Vue-router、vuex、Vue实战、weex、ES6、React基础、React全家桶、Koa2.x、Fabric.js 和 CocosCreater 实战教程等。</p>\n<h2 id=\"进阶级\"><a href=\"#进阶级\" class=\"headerlink\" title=\"进阶级\"></a>进阶级</h2><h4 id=\"深入理解JSON\"><a href=\"#深入理解JSON\" class=\"headerlink\" title=\"深入理解JSON\"></a><a href=\"https://mp.weixin.qq.com/s/CQKFfecqy3_EgW0jLfEMIQ\" target=\"_blank\" rel=\"noopener\">深入理解JSON</a></h4><p>作者将 JSON 和 JS 中的 JSON 都梳理了一遍，也对里面的细节和注意点进行了一次遍历，从中我们能够知道 JSON 是一种语法上衍生于JS语言的一种轻量级的数据交换格式，也会明白 JSON 相对于一般的JS数据结构（尤其是对象）的差别；除此之外，作者更进一步地仔细讨论了 JS 中关于 JSON 处理的 3 个函数和细节。</p>\n<h4 id=\"通用-CSS-笔记、建议与指导\"><a href=\"#通用-CSS-笔记、建议与指导\" class=\"headerlink\" title=\"通用 CSS 笔记、建议与指导\"></a><a href=\"https://github.com/chadluo/CSS-Guidelines/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">通用 CSS 笔记、建议与指导</a></h4><p>作者总结了 CSS 的相关规范，但是建议下面腾讯 AlloyTeam 总结的那篇。。</p>\n<h4 id=\"前端规范总结-AlloyTeam\"><a href=\"#前端规范总结-AlloyTeam\" class=\"headerlink\" title=\"前端规范总结-AlloyTeam\"></a><a href=\"http://alloyteam.github.io/CodeGuide/\" target=\"_blank\" rel=\"noopener\">前端规范总结-AlloyTeam</a></h4><p>腾讯 AlloyTeam 通过分析 github 代码库总结出来的工程师代码书写习惯，内容很全很详细，值得一看！</p>\n<h4 id=\"CSS进阶系列\"><a href=\"#CSS进阶系列\" class=\"headerlink\" title=\"CSS进阶系列\"></a><a href=\"http://www.cnblogs.com/coco1s/category/833837.html\" target=\"_blank\" rel=\"noopener\">CSS进阶系列</a></h4><p>通过作者的 github，可以看出来这是一位腾讯的大牛，作者通过 CSS 实现了很多复杂的效果，其中有些例子是《CSS揭秘》这本书里面的，这本书也是我之前强烈推荐大家看的一本 CSS 进阶书籍。</p>\n<h4 id=\"简书-前端基础进阶系列\"><a href=\"#简书-前端基础进阶系列\" class=\"headerlink\" title=\"简书-前端基础进阶系列\"></a><a href=\"http://www.jianshu.com/p/cd3fee40ef59\" target=\"_blank\" rel=\"noopener\">简书-前端基础进阶系列</a></h4><p>作者叫“波同学”，我之前是从来没有听说过作者大名的，但是读过作者这一系列的文章之后对作者的前端能力很是钦佩，同时作者的讲解能力也很强，将一些别人讲的晦涩难懂的原理讲的很透彻，十分推荐大家认真阅读一下作者这一系列的文章，我相信你看完之后你的前端水平会有很大的提升</p>\n<blockquote>\n<p>更新于2017-01-26：波同学将自己在简书上的文章都迁移到了<a href=\"https://yangbo5207.github.io/wutongluo/\" target=\"_blank\" rel=\"noopener\">自己的Gitbook</a>上</p>\n</blockquote>\n<h4 id=\"深入理解-JavaScript-系列\"><a href=\"#深入理解-JavaScript-系列\" class=\"headerlink\" title=\"深入理解 JavaScript 系列\"></a><a href=\"http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html\" target=\"_blank\" rel=\"noopener\">深入理解 JavaScript 系列</a></h4><p>汤姆大叔写的文章，文章内容实在是多。。而且感觉难度有点大，推荐大家先看一下上面简书的前端基础进阶系列，再来看汤姆大叔这一系列的文章，可能理解起来会更容易一些。</p>\n<h4 id=\"webshell-原理\"><a href=\"#webshell-原理\" class=\"headerlink\" title=\"webshell 原理\"></a><a href=\"http://www.jianshu.com/p/02aac12e459f\" target=\"_blank\" rel=\"noopener\">webshell 原理</a></h4><p>webshell，顾名思义：web 指的是在 web 服务器上，而 shell 是用脚本语言编写的脚本程序，webshell 就是就是 web 的一个管理工具，可以对 web 服务器进行操作的权限，也叫 webadmin。接触过集群的童鞋对这个概念肯定不会感到陌生，虽然一般人不会接触到 webshell，但是多了解一些总是没错的~</p>\n<h4 id=\"全自动科学上网方案分享\"><a href=\"#全自动科学上网方案分享\" class=\"headerlink\" title=\"全自动科学上网方案分享\"></a><a href=\"https://github.com/bestswifter/blog/commit/b68a7bbc413874c3883a66b6b065413f0f351156\" title=\"[Add] 全自动科学上网方案分享\" target=\"_blank\" rel=\"noopener\">全自动科学上网方案分享</a></h4><p>有些童鞋并不了解如何通过 VPS 实现科学上网，这篇文章介绍了如何利用 VPS 进行代理配置，以及实现自动切换，讲解的很详细。</p>\n","raw":null,"categories":[{"name":"summary","path":"api/categories/summary.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"教程","path":"api/tags/教程.json"}]},{"title":"iOS中采用AMP规范时的scroll和position:fixed带来的bug","slug":"iOS中采用AMP规范时的scroll和position:fixed带来的bug","date":"2017-08-26T12:23:20.000Z","updated":"2019-02-04T13:27:44.349Z","comments":true,"path":"api/articles/iOS中采用AMP规范时的scroll和position:fixed带来的bug.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>本文翻译自一位前辈的两篇文章，原文链接：</p>\n<ul>\n<li><a href=\"https://medium.com/@dvoytenko/amp-ios-scrolling-and-position-fixed-b854a5a0d451\" target=\"_blank\" rel=\"noopener\">AMP, iOS, Scrolling and Position Fixed</a></li>\n<li><a href=\"https://hackernoon.com/amp-ios-scrolling-and-position-fixed-redo-the-wrapper-approach-8874f0ee7876\" target=\"_blank\" rel=\"noopener\">AMP, iOS, Scrolling and Position Fixed Redo — the wrapper approach</a></li>\n</ul>\n<p>首先，你需要先了解一下 AMP，<a href=\"https://imququ.com/post/amp-project.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们对于 AMP 的目标是确保 document 文档在不同环境中都是可嵌入的，无论是单独查看还是在 webview 中或者在 iframe 中——总体而言，它在不同环境中的功能和行为表现都应该尽可能相同。我们将从一个简单的栗子开始，在这个栗子中，一个 AMP 文档通过 iframe 被嵌入了一个 web app。这听起来很正常，但是很实在的说，iframes 在最近已经很少有人用了。闲话少说，html 结构是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>I’m a Web App and I show AMP documents<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    iframe &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">      top: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">      left: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">      right: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">      bottom: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">iframe</span> … <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">scrolling</span>=<span class=\"string\">\"yes\"</span></span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.ampproject.org/c/pub1.com/doc1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面这段代码通常来说在移动设备上表现良好。然后我们有了一个新的想法，我们尝试将 iframe 调整到整个 document 的高度，同时使用 static 定位，从而将滚动委托给上一层的 window。然而，出于一些原因，我们放弃了这种方法：</p>\n<ul>\n<li>当视口高度等于文档高度时，在嵌入的AMP文档中设置<code>“position: fixed”</code>是不会起作用的</li>\n<li>计算文档高度容易出错，而且有延迟</li>\n</ul>\n<p>当然，我们最终没有很好的解决方案。主要是，设置了<code>“scrolling=yes”</code>的 iframe 会丢失一些移动设备的特性，比如滚动时隐藏地址栏。然而，我们仍然觉得这已经是一个很好的折衷方案了。除此之外，一些浏览器已经开始尝试将这些特性扩展到非 body 滚动的情况中。我们就这样美滋滋，直到我们遇到了 iOS。。</p>\n<h3 id=\"问题1：iOS-不支持-iframe-的-“scrollable-yes”\"><a href=\"#问题1：iOS-不支持-iframe-的-“scrollable-yes”\" class=\"headerlink\" title=\"问题1：iOS 不支持 iframe 的 “scrollable=yes”\"></a>问题1：iOS 不支持 iframe 的 <code>“scrollable=yes”</code></h3><p>Bug：<a href=\"https://bugs.webkit.org/show_bug.cgi?id=149264\" target=\"_blank\" rel=\"noopener\">https://bugs.webkit.org/show_bug.cgi?id=149264</a> 简单的说：<strong>ios中不能有可以滚动的iframe</strong>。然而，我们找到了解决这个 bug 的方法。参考这里<a href=\"https://github.com/ampproject/amphtml/blob/de7a14d/src/service/viewport-impl.js#L754\" target=\"_blank\" rel=\"noopener\">ViewportBindingNaturalIosEmbed_</a>。简短而言，我们让 document 中真正的<code>&lt;body&gt;</code>元素滚动。这样的话，即使 iframe 自身不滚动，它里面的内容也会滚动。 我们按照上面方案修改后的 AMP 文档如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">AMP</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">style</span>=<span class=\"string\">\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      overflow-y: auto;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      -webkit-overflow-scrolling: touch;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">    \"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们以为自己很牛逼，然而。。</p>\n<h3 id=\"问题2：现在-scrollTop，scrollLeft，scrollHeight，scrollWidth-不管用了\"><a href=\"#问题2：现在-scrollTop，scrollLeft，scrollHeight，scrollWidth-不管用了\" class=\"headerlink\" title=\"问题2：现在 scrollTop，scrollLeft，scrollHeight，scrollWidth 不管用了\"></a>问题2：现在 scrollTop，scrollLeft，scrollHeight，scrollWidth 不管用了</h3><p>Bug：<a href=\"https://bugs.webkit.org/show_bug.cgi?id=106133\" target=\"_blank\" rel=\"noopener\">https://bugs.webkit.org/show_bug.cgi?id=106133</a> 这是 webkit 中长期存在的一个 bug。scrollTop 和其他类似属性被分配给了 <code>“document.body”</code>，但是却委托给了<code>“document.documentElement”</code>。最终，当 “scrollingElement” 是文档里的大部分元素的时候，这个问题会被解决。同时，令人惊喜的是，这个 bug 不会对我们在问题1中提出的解决方案造成冲突。然而，<code>“scrollTop”</code> 将会一直是 0，从而导致其他连带属性也会受到影响，比如 <code>“window.pageYOffset”</code> 解决方案是添加一个滚动的元素到文档顶部。它的 <code>“getBoundingClientRect().top”</code> 就可以用来重新计算文档的滚动位置。 具体如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">AMP</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      overflow-y: auto;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      -webkit-overflow-scrolling: touch;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">    \"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"scroll-pos\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        width: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        height: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        visibility: hidden;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      \"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们的 JS 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getScrollTop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 要对scrollPos.top取负值的原因是滚动位置在计算时，</span></span><br><span class=\"line\">  <span class=\"comment\">// 我们的scrollPos元素会向上滚动，在视口范围外,</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时它的top值是负的</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> -scrollPos.getBoundingClientRect().top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，这个解决方案显得很蠢，但是它确实奏效了。类似的方法可用于“scrollLeft”，“scrollHeight” 以及剩余属性。 然而，我们又有了新的发现。。</p>\n<h3 id=\"问题3：“postion-fixed”-的元素在-“overflow-auto”-容器中会有很多-bug\"><a href=\"#问题3：“postion-fixed”-的元素在-“overflow-auto”-容器中会有很多-bug\" class=\"headerlink\" title=\"问题3：“postion: fixed” 的元素在 “overflow: auto” 容器中会有很多 bug\"></a>问题3：“postion: fixed” 的元素在 “overflow: auto” 容器中会有很多 bug</h3><p>Bug：<a href=\"https://bugs.webkit.org/show_bug.cgi?id=154399\" target=\"_blank\" rel=\"noopener\">https://bugs.webkit.org/show_bug.cgi?id=154399</a> 如果一个 “position: fixed” 元素在一个 “overflow: auto” 的容器中，它的表现会让你很失望：滚动的时候，“position: fixed” 元素会跳远和闪现。它看起来像是稍微滚动一点然而又跳回到正确的位置。这个效果很差，可以通过这个<a href=\"https://drive.google.com/file/d/0B_v8thsbiGyDMXZMZkRFZGFRbjA/view?usp=sharing\" target=\"_blank\" rel=\"noopener\">视频演示</a>看到这个 bug。 要哭了。我们通过各种 hack 解决了各种 bug，最后还是有一个 bug，我们如何解决这个？这里有一个很疯狂的 idea 貌似好使。我们可以添加一个虚拟元素到 “document.documentElement”（不是 “body”，所以它其实是 “body” 的兄弟元素）。我们把它叫做“<strong>固定层</strong>”。他将占据整个视口。我们将使用CSS来找到所有的可能是 “fixed” 的元素（希望不会有太多。。），如果在某些时候它们是确定 “fixed” 的，我们就通过正确的 “z-index” 属性将它们移动到“固定层” 你可能看晕了，直接上代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">AMP</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-id\">#fixed-element</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      position: fixed;</span></span><br><span class=\"line\"><span class=\"undefined\">      right: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">      top: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      overflow-y: auto;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      -webkit-overflow-scrolling: touch;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">    \"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"fixed-element\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"fixed-layer\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      width: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      height: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      pointer-events: none;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">    \"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们找到一个确实 “fixed” 的元素的时候，我们将它移动到“固定层”，像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"fixed-layer\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      pointer-events: none;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">    \"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"fixed-element\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">style</span>=<span class=\"string\">\"pointer-events: initial; z-index: 11;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>因此，我们可以根据某元素是否 “fixed” 来将它在 “\bbody” 中的原始位置和“固定层”之间移动。 这个方法就无懈可击了吗？很明显没有：</p>\n<ul>\n<li>\b这代码看都看不懂！</li>\n<li>计算 “z-index” 会相当痛苦</li>\n<li>我们将失去一些 CSS 祖先选择器</li>\n</ul>\n<p>但是它确实是有效的，可以看一下<a href=\"http://github.com/ampproject/amphtml/pull/2128\" target=\"_blank\" rel=\"noopener\">这条PR</a>。还有别的 idea 吗？ 准确来说是有的，下面是作者第二篇文章的译文：</p>\n<h2 id=\"回顾一下\"><a href=\"#回顾一下\" class=\"headerlink\" title=\"回顾一下\"></a>回顾一下</h2><p>简单回顾一下，AMP 文档经常在一个滚动的 iframe 中进行展示。它的 html 结构看起来像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>I'm a Web App and I show AMP documents<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">      iframe &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">        top: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">        left: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">        right: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">        bottom: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">iframe</span> … <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">scrolling</span>=<span class=\"string\">\"yes\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.ampproject.org/c/pub1.com/doc1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在大部分浏览器中，上面这段代码表现很正常。但是在 ios 中会有很多异常表现，我们尝试了很多方法，包括通过内容调整 iframe 大小和滚动主文档。但是他们都有一些性能问题，具体可以参见上面的问题描述。 根本而言，ios 的 safari 浏览器不支持滚动的 iframe。换句话说，<code>“scrolling=yes”</code> 这个属性被直接忽略了。<a href=\"http://jsbin.com/gugika/edit?html,css,output\" target=\"_blank\" rel=\"noopener\">看这个例子</a>。这个 bug 由来已久，可以<a href=\"https://bugs.webkit.org/show_bug.cgi?id=149264\" target=\"_blank\" rel=\"noopener\">在这里</a>发现。 我们在<a href=\"https://github.com/ampproject/amphtml/blob/de7a14d/src/service/viewport-impl.js#L754\" target=\"_blank\" rel=\"noopener\">之前提到的一篇文章</a>中发现了一个很原始的方案。简而言之，我们让真正的 “body” 元素滚动。于是，即使 iframe 它自身不滚动，iframe 中的内容也会滚动，AMP 文档如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">AMP</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        overflow-y: auto;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        -webkit-overflow-scrolling: touch;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      \"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> <span class=\"attr\">document</span> <span class=\"attr\">content</span> <span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在我们 iframe 可以滚动了！这个 AMP 中的解决方案我们用了一年。然而，随着时间的流逝，我们发现了一系列的问题，这些问题在上一篇文章中已经详细介绍过了，这里再简单罗列一下： 给“ body” 添加 “position: absolute” 属性是作者不想看到的，会影响原始布局。另外一个副作用是我们不没办法在 “body” 元素上设置 margin body 的 scrollTop，scrollLeft，scrollHeight 和 scrollWidth 将不起作用。这个 bug 通过上面介绍的注入虚拟 dom 元素可以解决。 “position: fixed” 在 “-webkit-overflow-scrolling: touch” 容器中会有各种 bug 抵消 header 和 footer 需要给 body 设置边框，这个代价很昂贵，因为它缩小了滚动区域，同时可能会打破现有布局。而隐藏头部又会造成 UI 视觉的隔断和滚动的间断 那我们如何解决这个问题呢，我们的主角就要登场了。。</p>\n<h3 id=\"新的解决方案——wrapper-元素\"><a href=\"#新的解决方案——wrapper-元素\" class=\"headerlink\" title=\"新的解决方案——wrapper 元素\"></a>新的解决方案——wrapper 元素</h3><p>这个方案已开源，可以<a href=\"https://github.com/ampproject/amphtml/blob/2d73ac0d9c451dee4c89ac1fa73329b69edca5a4/src/service/viewport-impl.js#L1404\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看源代码</p>\n<h3 id=\"DOM-结构\"><a href=\"#DOM-结构\" class=\"headerlink\" title=\"DOM 结构\"></a>DOM 结构</h3><p>通俗来讲，wrapper 元素和滚动的 “body” 元素是类似的。iframe 在 ios 的 safari 浏览器中依然无法滚动，所以我们需要让 iframe 中的内容滚动。因为让<code>&lt;body&gt;</code>滚动会有一系列问题，所以我们可以创建一个滚动的 wrapper，然后将它放在<code>&lt;html&gt;</code>和<code>&lt;body&gt;</code>中间。换句话说，我们将<code>&lt;body&gt;</code>元素包装在一个可滚动的容器中。 现在的 dom 结构类似这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">AMP</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">i-amp-html-wrapper</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        display: block;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        overflow-y: auto;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        -webkit-overflow-scrolling: touch;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      \"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position: relative;\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> <span class=\"attr\">document</span> <span class=\"attr\">content</span> <span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">i-amp-html-wrapper</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>毫无疑问，这看起来很怪，但是它确实解决了原来的问题——它让 iframe 在 ios 的 safari 浏览器中可以滚动。此外，它也解决了上面描述的许多问题：</p>\n<ul>\n<li>对于<code>&lt;body&gt;</code>元素没有任何强制要求：它仍然拥有原来的“position”属性，同时也可以拥有默认的“overflow: visible”属性。AMP 允许 dom 中的大多数 css 样式，这样可以减少对代码原作者样式的干扰</li>\n<li>可滚动的 wrapper 元素可以用来获取 scrollTop，scrollLeft，scrollHeight 和 scrollWidth 属性，于是之前介绍过的虚拟元素将不再需要</li>\n<li>不再需要给<code>&lt;body&gt;</code>设置边界来抵消 header 和 footer 了——只需要给 wrapper 元素添加 padding 就足够了</li>\n</ul>\n<p>然而，“position: fixed” 的问题仍然存在，我们稍后再谈。</p>\n<h3 id=\"两个-lt-html-gt-元素\"><a href=\"#两个-lt-html-gt-元素\" class=\"headerlink\" title=\"两个&lt;html&gt;元素\"></a>两个<code>&lt;html&gt;</code>元素</h3><p>我们采用了 wrapper 方案，然后很快就碰到了一个小问题。很多人喜欢 html&gt;body 选择器，而我们在 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 中间插入了 i-amp-html-wrapper 元素。为了解决这个问题，我们将 i-amp-html-wrapper 作为另外一个 <code>&lt;html&gt;</code> 元素，最终的 dom 结构长这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">AMP</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">id</span>=<span class=\"string\">\"i-amp-html-wrapper\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        display: block;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        overflow-y: auto;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        -webkit-overflow-scrolling: touch;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      \"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position: relative;\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> <span class=\"attr\">document</span> <span class=\"attr\">content</span> <span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>加倍奇怪，加倍好玩。总而言之现在 html&gt;body 选择器将正常起作用</p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>AMP runtime 会在启动时尽可能早的创建 wrapper 元素。而现有的 <code>&lt;body&gt;</code> 元素会作为子元素放到新建 wrapper 里面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create wrapper.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> wrapper = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'html'</span>);</span><br><span class=\"line\">wrapper.id = <span class=\"string\">'i-amp-html-wrapper'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Setup classes and styles.</span></span><br><span class=\"line\">wrapper.className = <span class=\"built_in\">document</span>.documentElement.className;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.documentElement.className = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.documentElement.style = <span class=\"string\">'...'</span>;</span><br><span class=\"line\">wrapper.style = <span class=\"string\">'...'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Attach wrapper straight inside the document root.</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.documentElement.appendChild(wrapper);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reparent the body.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> body = <span class=\"built_in\">document</span>.body;</span><br><span class=\"line\">wrapper.appendChild(body);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">document</span>, <span class=\"string\">'body'</span>, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> body,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，不过有一个细节——将 body 移到 wrapper 里面会将 document.body 重置为 null，因此我们需要将 document.body 重写回初始的 <code>&lt;body&gt;</code> 元素，可以通过 Object.defineProperty 来实现</p>\n<h4 id=\"position-fixed问题\"><a href=\"#position-fixed问题\" class=\"headerlink\" title=\"position: fixed问题\"></a>position: fixed问题</h4><p>尽管 wrapper 方案能够解决大部分问题，但是 position: fixed 的问题仍然存在 这个问题在上面那篇文章已经详细介绍过了，有关 ios 的 safari 浏览器 bug 可以<a href=\"https://bugs.webkit.org/show_bug.cgi?id=154399\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看 简而言之，一个 position: fixed 元素在一个 -webkit-overflow-scrolling: touch 容器中滚动时会出现跳跃和闪现的问题。它看起来像是稍微滚动一点然而又跳回到正确的位置。可以通过这个<a href=\"https://drive.google.com/file/d/0B_v8thsbiGyDMXZMZkRFZGFRbjA/view?usp=sharing\" target=\"_blank\" rel=\"noopener\">视频演示</a>看到这个 bug。 在我们之前的解决方案中，我们将有 position: fixed 属性的元素放到了 <code>&lt;body&gt;</code> 外面，同时放到了一个虚拟“固定层”元素内部，这个“固定层”元素放在了 -webkit-overflow-scrolling: touch 容器外面 最终的 dom 结构：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">AMP</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">id</span>=<span class=\"string\">\"i-amp-html-wrapper\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        display: block;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        overflow-y: auto;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        -webkit-overflow-scrolling: touch;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      \"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position: relative;\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> <span class=\"attr\">document</span> <span class=\"attr\">content</span> <span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">id</span>=<span class=\"string\">\"i-amp-fixed-layer\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">style</span>=<span class=\"string\">\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        position: absolute;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        top: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        left: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        right: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        bottom: 0;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        pointer-events: none;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      \"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">!\\-\\-</span> <span class=\"attr\">fixed</span> <span class=\"attr\">elements</span> <span class=\"attr\">reparented</span> <span class=\"attr\">here</span> <span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>于是，<strong>我们最终获得了两个<code>&lt;html&gt;</code>元素和两个<code>&lt;body&gt;</code>元素</strong>。看起来很疯狂，但是它确实解决了两个问题： iframe 不滚动和 position:fixed 元素闪现问题 很明显，我们将取得更好的效果如果存在已久的 ios safari 问题被修复。。</p>\n","raw":null,"categories":[{"name":"mobile","path":"api/categories/mobile.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"AMP","path":"api/tags/AMP.json"},{"name":"fixed","path":"api/tags/fixed.json"},{"name":"ios","path":"api/tags/ios.json"}]}]}