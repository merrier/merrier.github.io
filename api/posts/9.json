{"total":121,"pageSize":10,"pageCount":13,"data":[{"title":"CSS深入理解之padding","slug":"CSS深入理解之padding","date":"2017-04-20T12:30:24.000Z","updated":"2019-07-04T08:09:14.545Z","comments":true,"path":"api/articles/CSS深入理解之padding.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_60.png","content":"<h2 id=\"1-padding-和元素尺寸的关系\"><a href=\"#1-padding-和元素尺寸的关系\" class=\"headerlink\" title=\"1. padding 和元素尺寸的关系\"></a>1. padding 和元素尺寸的关系</h2><h3 id=\"对于-block-水平元素\"><a href=\"#对于-block-水平元素\" class=\"headerlink\" title=\"对于 block 水平元素\"></a>对于 block 水平元素</h3><ul>\n<li>padding 太大时，一定会影响尺寸</li>\n<li>width 非 auto，padding 影响尺寸</li>\n<li>width 为 auto 或 box-sizing 为 border-box，同时 padding 值没有过大，此时不会影响尺寸</li>\n</ul>\n<h3 id=\"对于-inline-水平元素\"><a href=\"#对于-inline-水平元素\" class=\"headerlink\" title=\"对于 inline 水平元素\"></a>对于 inline 水平元素</h3><p>水平 padding 影响尺寸，垂直 padding 不影响尺寸，<strong>但是会影响背景色(占据空间)</strong></p>\n<div align=\"center\"><img src=\"/images/hexo_post_60.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"inline-元素-padding-特性应用-gt-gt-高度可控的分割线\"><a href=\"#inline-元素-padding-特性应用-gt-gt-高度可控的分割线\" class=\"headerlink\" title=\"inline 元素 padding 特性应用 &gt;&gt; 高度可控的分割线\"></a>inline 元素 padding 特性应用 &gt;&gt; 高度可控的分割线</h3><ol>\n<li>直接使用字符：注册 | 退出登录</li>\n<li>inline-block 控制：注册丨退出登录</li>\n<li>使用 inline 和 padding：注册丨退出登录</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注册<span class=\"tag\">&lt;<span class=\"name\">sapn</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>退出登录</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">span</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">16px</span> <span class=\"number\">6px</span> <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">2px</span> solid;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-padding-负值\"><a href=\"#2-padding-负值\" class=\"headerlink\" title=\"2. padding 负值\"></a>2. padding 负值</h2><p>padding 不支持任何形式的负值</p>\n<h2 id=\"3-padding-百分比值\"><a href=\"#3-padding-百分比值\" class=\"headerlink\" title=\"3. padding 百分比值\"></a>3. padding 百分比值</h2><p>padding 百分比均是相对于宽度计算的，所以可以用来实现一个正方形（<strong>padding: 50%</strong>）</p>\n<h3 id=\"inline-元素的-padding-百分比值\"><a href=\"#inline-元素的-padding-百分比值\" class=\"headerlink\" title=\"inline 元素的 padding 百分比值\"></a>inline 元素的 padding 百分比值</h3><ul>\n<li>同样相对于宽度计算</li>\n<li>默认的高度宽度细节有差异</li>\n<li>padding 会断行</li>\n</ul>\n<p>因为文字的换行导致表现诡异，当 padding 变小以至于文字不会换行时就会正常表现</p>\n<div align=\"center\"><img src=\"/images/hexo_post_61.png\" alt=\"\" width=\"400\"></div>\n\n<p>空 inline 元素 + padding 高度也不等(高度大于宽度)，此时如果设置 font-size: 0 就可以正常表现了</p>\n<p>原因：inline 元素的垂直 padding 会让”幽灵空白节点”显现，也就是规范中的 “strut” 出现</p>\n<h2 id=\"4-标签元素的内置-padding\"><a href=\"#4-标签元素的内置-padding\" class=\"headerlink\" title=\"4. 标签元素的内置 padding\"></a>4. 标签元素的内置 padding</h2><h3 id=\"ol-ul-列表\"><a href=\"#ol-ul-列表\" class=\"headerlink\" title=\"ol / ul 列表\"></a>ol / ul 列表</h3><ul>\n<li>ol / li 元素内置 padding-left，但是单位是 px 不是 em；</li>\n<li>例如 Chrome 浏览器下是 40px；</li>\n<li>如果字号很小，间距就会很开；</li>\n<li>如果字号很大，序号会爬到容器外面；</li>\n</ul>\n<h3 id=\"表单元素\"><a href=\"#表单元素\" class=\"headerlink\" title=\"表单元素\"></a>表单元素</h3><ul>\n<li>所有浏览器 input / textarea 输入框内置 padding</li>\n<li>所有浏览器 button 按钮内置 padding</li>\n<li>部分浏览器 select 下拉内置 padding，如 FireFox、IE8+ 可以设置 padding</li>\n<li>所有浏览器 radio / checkbox 单复选框无内置 padding</li>\n<li>button 按钮元素的 padding 最难控制</li>\n</ul>\n<h3 id=\"button按钮\"><a href=\"#button按钮\" class=\"headerlink\" title=\"button按钮\"></a>button按钮</h3><h4 id=\"Chrome-浏览器\"><a href=\"#Chrome-浏览器\" class=\"headerlink\" title=\"Chrome 浏览器\"></a>Chrome 浏览器</h4><p>可以完美设置 padding</p>\n<h4 id=\"FireFox-浏览器\"><a href=\"#FireFox-浏览器\" class=\"headerlink\" title=\"FireFox 浏览器\"></a>FireFox 浏览器</h4><p>设置 padding: 0 左右依然有 padding，只能通过：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">::-moz-focus-inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"IE-浏览器\"><a href=\"#IE-浏览器\" class=\"headerlink\" title=\"IE 浏览器\"></a>IE 浏览器</h4><p>IE7 文字越多，左右 padding 逐渐变大，解决方案：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: visible;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-padding-与高度计算的不兼容\"><a href=\"#4-padding-与高度计算的不兼容\" class=\"headerlink\" title=\"4.padding 与高度计算的不兼容\"></a>4.padding 与高度计算的不兼容</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>IE7: 45px</li>\n<li>IE8+: 40px</li>\n<li>FireFox: 42px</li>\n<li>Chrome: 40px</li>\n</ul>\n<p>button 按钮会有以上的各种 bug，所以建议是<strong>通过 label 按钮模拟按钮</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"btn\"</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">label</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-padding-与图形绘制\"><a href=\"#5-padding-与图形绘制\" class=\"headerlink\" title=\"5. padding 与图形绘制\"></a>5. padding 与图形绘制</h2><h3 id=\"三道杠\"><a href=\"#三道杠\" class=\"headerlink\" title=\"三道杠\"></a>三道杠</h3><p>第一道杠用 border-top，第二道杠用 background-color，第三道杠用 border-bottom，中间空白用padding：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_72.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"白眼效果\"><a href=\"#白眼效果\" class=\"headerlink\" title=\"白眼效果\"></a>白眼效果</h3><p>中间大的圆用 background-color，最外面的环用 border，中间空白用 padding</p>\n<div align=\"center\"><img src=\"/images/hexo_post_52.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"6-padding-与布局\"><a href=\"#6-padding-与布局\" class=\"headerlink\" title=\"6. padding 与布局\"></a>6. padding 与布局</h2><h3 id=\"使用百分比单位构建固定比例布局结构\"><a href=\"#使用百分比单位构建固定比例布局结构\" class=\"headerlink\" title=\"使用百分比单位构建固定比例布局结构\"></a>使用百分比单位构建固定比例布局结构</h3><p>移动端 1:1 头图布局</p>\n<div align=\"center\"><img src=\"/images/hexo_post_75.png\" alt=\"\" width=\"200\"></div>\n\n<h3 id=\"配合-margin-等高布局\"><a href=\"#配合-margin-等高布局\" class=\"headerlink\" title=\"配合 margin 等高布局\"></a>配合 margin 等高布局</h3><div align=\"center\"><img src=\"/images/hexo_post_71.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"两栏自适应布局\"><a href=\"#两栏自适应布局\" class=\"headerlink\" title=\"两栏自适应布局\"></a>两栏自适应布局</h3><h4 id=\"padding-在容器上\"><a href=\"#padding-在容器上\" class=\"headerlink\" title=\"padding 在容器上\"></a>padding 在容器上</h4><div align=\"center\"><img src=\"/images/hexo_post_125.png\" alt=\"\" width=\"500\"></div>\n\n<h4 id=\"padding-在子元素上\"><a href=\"#padding-在子元素上\" class=\"headerlink\" title=\"padding 在子元素上\"></a>padding 在子元素上</h4><div align=\"center\"><img src=\"/images/hexo_post_126.png\" alt=\"\" width=\"500\"></div>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"一些常用邮箱的IMAP&SMTP&POP3地址","slug":"一些常用邮箱的IMAP&SMTP&POP3地址","date":"2017-04-20T02:05:49.000Z","updated":"2019-07-04T08:09:14.549Z","comments":true,"path":"api/articles/一些常用邮箱的IMAP&SMTP&POP3地址.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>我们在客户端设置邮箱或者使用 PHPMailer 发送邮件的时候，我们都会去查找这些邮箱的 IMAP / SMTP / POP3 地址，这里列出了一些常用邮箱的这些地址，方便自己和大家以后设置邮箱时候使用。</p>\n<h2 id=\"Gmail\"><a href=\"#Gmail\" class=\"headerlink\" title=\"Gmail\"></a>Gmail</h2><p>Gmail 的 IMAP / SMTP / POP3 协议默认都是开启，它的详细地址如下：</p>\n<table>\n<thead>\n<tr>\n<th>服务器名称</th>\n<th>服务器地址</th>\n<th>SSL协议端口</th>\n<th>非SSL协议端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IMAP</td>\n<td>imap.gmail.com</td>\n<td>993</td>\n<td>/</td>\n</tr>\n<tr>\n<td>SMTP</td>\n<td>smtp.gmail.com</td>\n<td>465</td>\n<td>/</td>\n</tr>\n<tr>\n<td>POP3</td>\n<td>pop.gmail.com</td>\n<td>995</td>\n<td>/</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"QQ邮箱\"><a href=\"#QQ邮箱\" class=\"headerlink\" title=\"QQ邮箱\"></a>QQ邮箱</h2><p>QQ邮箱的 IMAP / SMTP / POP3 协议默认是不开启的，你需要登陆到 QQ邮箱，然后到“设置” &gt; “账户” 将其开启。</p>\n<table>\n<thead>\n<tr>\n<th>服务器名称</th>\n<th>服务器地址</th>\n<th>SSL协议端口</th>\n<th>非SSL协议端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IMAP</td>\n<td>imap.qq.com</td>\n<td>993</td>\n<td>143</td>\n</tr>\n<tr>\n<td>SMTP</td>\n<td>smtp.qq.com</td>\n<td>465或587</td>\n<td>25</td>\n</tr>\n<tr>\n<td>POP3</td>\n<td>pop.qq.com</td>\n<td>995</td>\n<td>110</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"163-邮箱\"><a href=\"#163-邮箱\" class=\"headerlink\" title=\"163 邮箱\"></a>163 邮箱</h2><table>\n<thead>\n<tr>\n<th>服务器名称</th>\n<th>服务器地址</th>\n<th>SSL协议端口</th>\n<th>非SSL协议端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IMAP</td>\n<td>imap.163.com</td>\n<td>993</td>\n<td>143</td>\n</tr>\n<tr>\n<td>SMTP</td>\n<td>smtp.163.com</td>\n<td>465或994</td>\n<td>25</td>\n</tr>\n<tr>\n<td>POP3</td>\n<td>pop.163.com</td>\n<td>995</td>\n<td>110</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"阿里云邮箱\"><a href=\"#阿里云邮箱\" class=\"headerlink\" title=\"阿里云邮箱\"></a>阿里云邮箱</h2><table>\n<thead>\n<tr>\n<th>服务器名称</th>\n<th>服务器地址</th>\n<th>SSL协议端口</th>\n<th>非SSL协议端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>POP3</td>\n<td>pop3.aliyun.com</td>\n<td>110</td>\n<td>995</td>\n</tr>\n<tr>\n<td>SMTP</td>\n<td>smtp.aliyun.com</td>\n<td>25</td>\n<td>465</td>\n</tr>\n<tr>\n<td>IMAP</td>\n<td>imap.aliyun.com</td>\n<td>143</td>\n<td>993</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"139邮箱\"><a href=\"#139邮箱\" class=\"headerlink\" title=\"139邮箱\"></a>139邮箱</h2><table>\n<thead>\n<tr>\n<th>服务器名称</th>\n<th>服务器地址</th>\n<th>SSL协议端口</th>\n<th>非SSL协议端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IMAP</td>\n<td>imap.10086.cn</td>\n<td>143</td>\n<td>/</td>\n</tr>\n<tr>\n<td>POP3</td>\n<td>pop.10086.cn</td>\n<td>110</td>\n<td>995</td>\n</tr>\n<tr>\n<td>SMTP</td>\n<td>smtp.10086.cn</td>\n<td>25</td>\n<td>465</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"sina邮箱\"><a href=\"#sina邮箱\" class=\"headerlink\" title=\"sina邮箱\"></a>sina邮箱</h2><table>\n<thead>\n<tr>\n<th>服务器名称</th>\n<th>服务器地址</th>\n<th>SSL协议端口</th>\n<th>非SSL协议端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IMAP</td>\n<td>imap.sina.com</td>\n<td>143</td>\n<td>993</td>\n</tr>\n<tr>\n<td>SMTP</td>\n<td>smtp.sina.com</td>\n<td>25</td>\n<td>/</td>\n</tr>\n<tr>\n<td>POP3</td>\n<td>pop.sina.com</td>\n<td>110</td>\n<td>/</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://www.cnblogs.com/shangdawei/p/4305989.html\" target=\"_blank\" rel=\"noopener\">常用邮箱的 IMAP/POP3/SMTP 设置</a></li>\n</ul>\n","raw":null,"categories":[{"name":"summary","path":"api/categories/summary.json"}],"tags":[{"name":"SMTP","path":"api/tags/SMTP.json"},{"name":"邮箱地址","path":"api/tags/邮箱地址.json"}]},{"title":"一篇绝对能看懂的Git入门教程","slug":"一篇绝对能看懂的Git入门教程","date":"2017-04-17T13:35:16.000Z","updated":"2019-07-04T08:09:14.549Z","comments":true,"path":"api/articles/一篇绝对能看懂的Git入门教程.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_237.png","content":"<p>不管你是从事什么方面的程序猿，只要你属于这个神秘组织，就必须要对 SVN 或 Git 这种版本控制系统有所了解；和大部分人一样，当初项目负责人告诉我需要学 Git 的时候，只说了这样一句话：“网上很多教程，自己看着学吧”，当然，这句话直到今天我也无力反驳，因为对于一个新鲜的程序猿来说，只需要懂一些 Git 的基本指令就可以了，一些高端指令可能永远都用不到，所以，我就查阅了一些 Git 的教程和手册，整理出这篇对于新手很友好的 Git 入门教程</p>\n<h2 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h2><p>很多 Git 教程都把这一部分的讲解放到很靠后的位置，所以我当初学习的时候并没有把这一部分放在心上；但是现在我觉得，这一部分才是最需要明白的，因为这一部分是非常“真实”的，对于一个之前从来没接触过命令行或一直在 windows 上打游戏、看直播的程序猿来说，这一部分也是最容易理解的</p>\n<p><strong>工作区</strong>：通俗易懂的来说就是你电脑里面的能看到的目录，比如 learngit 的目录。<br><strong>版本库</strong>：工作区有一个隐藏的目录 .git，这是 Git 的版本库。版本库中存了很多东西，其中最重要的就是stage(index)的 <strong>暂存区</strong>。 下面这张图非常清晰的表明了这三者的关系，我就不多说了：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_237.png\" alt=\"\" width=\"400\"></div>\n\n<p><strong>请牢牢记住这三\b个概念，因为下面会经常用到</strong></p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><h3 id=\"生成-ssh\"><a href=\"#生成-ssh\" class=\"headerlink\" title=\"生成 ssh\"></a>生成 ssh</h3><p>通过下面的指令可以生成 id_rsa 和 id_rsa.pub 两个文件，不同操作系统这两个文件所在位置不同，id_rsa.pub 里面的所有内容就是你的公钥，直接复制到 GitHub 的 Add SSH key 页面就可以愉快的进行玩耍了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t ras -C <span class=\"string\">\"email@xxx\"</span></span><br></pre></td></tr></table></figure>\n<p>ssh 是一种协议，而 Git 目前支持<a href=\"http://www.cnblogs.com/lzxianren/p/git2.html\" target=\"_blank\" rel=\"noopener\">4种协议</a>——ssh协议，http/s协议，git 协议，本地协议，ssh 协议配置简单，权限管理也比较全面，更重要的是无需密码和 linux 内置（git 是 linus 写的软件，linus 是 linux的作者，所以你懂得），至于 ssh 究竟怎么做的就不在本文介绍了，可以去阮一峰的博客中查找相关资料</p>\n<h3 id=\"设置用户名\"><a href=\"#设置用户名\" class=\"headerlink\" title=\"设置用户名\"></a>设置用户名</h3><p>和现实世界类似，你想和别人进行数据通信，首先得让别人知道你是谁，你的联系方式吧，而和现实世界不同的是，这里的联系方式只能填写邮箱，填写微信或者 QQ 号是木有用的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">\"cc\"</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"cc@xx\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化当前目录的项目\"><a href=\"#初始化当前目录的项目\" class=\"headerlink\" title=\"初始化当前目录的项目\"></a>初始化当前目录的项目</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p>还记得上面我们提到的三个概念吗，这里的初始化就是为了在本地目录中添加本地版本库，然后才可以后续的 git 操作。比如初始化之前你的目录是这样的（当前目录为空是因为我是在一个空文件夹的基础上进行初始化的，而实际情况是这里面会有你的项目文件）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_189.png\" alt=\"\" width=\"700\"></div>\n\n<p>而执行初始化操作之后：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_190.png\" alt=\"\" width=\"700\"></div>\n\n<p>从上图可以看到，当前目录中多了 .git 文件夹，这个文件夹就是你的本地的版本库了，里面存储着很多东西，其中包括暂存区；通过短短的一行命令，初始化操作就已经完成了，同时 Git 也为我们创建了第一个分支 master，和一个指向 master 的指针 HEAD，接下来就是一些常用的命令</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><h3 id=\"查看工作区状态\"><a href=\"#查看工作区状态\" class=\"headerlink\" title=\"查看工作区状态\"></a>查看工作区状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<p>这是一条需要经常使用的命令，因为有时候工作区的改变可能会是“隐性”的，比如你的编辑器自己添加的文件或者其他类型的隐藏文件，而经常查看状态也是检验某些 git 命令是否执行的方法。通过执行这一命令，我们在终端中可能会看到：</p>\n<div align=\"center\"><img src=\"/images/QQ20170417-153116@2x.png\" alt=\"\" width=\"700\"></div>\n\n<p>从终端的第四行我们可以看到，当我们查看状态时，Git 告诉我们当前分支为 master；第八行的意思是我们没有什么可以 commit 的，说明我们在当前目录下并没有进行修改，所以我们需要进行修改之后再进行后续操作：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_192.png\" alt=\"\" width=\"700\"></div>\n\n<p>从上图我们可以看到，我在当前目录中新添加了一个文件 octocat.txt，然后我们再通过 <code>git status</code> 查看一下当前工作区的状态：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_193.png\" alt=\"\" width=\"700\"></div>\n\n<p>这次好像和上次不一样了，Git 告诉我们有一个文件 untracked files 叫做 octocat.txt，同时还提醒你通过 <code>git add &lt;file&gt;...</code> 进行提交，那这里就稍微提一下 git status 时可能看到的当前工作区的文件的状态</p>\n<ul>\n<li>staged：已经添加到暂存区，等待提交的文件</li>\n<li>unstaged：已经发生了改变，但是还没有提交</li>\n<li>untracked：Git 都不知道还有这个文件，所以说明这是一个新添加的文件（就像上面的 octocat.txt）</li>\n<li>deleted：已经从本地删除的文件</li>\n</ul>\n<h3 id=\"提交工作区修改到暂存区\"><a href=\"#提交工作区修改到暂存区\" class=\"headerlink\" title=\"提交工作区修改到暂存区\"></a>提交工作区修改到暂存区</h3><ul>\n<li>git add .  // 将工作区所有修改添加到暂存区</li>\n<li>git add filename // 将指定文件添加到暂存区</li>\n</ul>\n<p>还是一开始我们提到的那三个概念，我们在本地进行了修改（新建、修改、删除），但是此时还只是我们自己知道发生了哪些改变，Git 根本都不知道（本地的 Git 都不知道，更别提远程），所以需要进行提交；那么你可能有疑问了，为什么提交到暂存区？直接提交给远程不就完了吗？这里就是 Git 设计的巧妙之处，通过暂存区可以防止你的错误提交（事实证明，这一点很重要）。经过 git add 后，我们再通过 git status 查看一下状态：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_194.png\" alt=\"\" width=\"700\"></div>\n\n<p>Git 告诉我们它看到了一个新的文件 octocat.txt，并且 to be committed，那么你可能会问了，假如我当前的目录里有好多文件都需要 add 怎么办，难道一次次执行命令吗？当然不需要，从上面的代码块中可以看到，我们可以通过 <code>git add .</code> 提交所有修改，但是<strong>不推荐这种操作</strong>，因为有可能会将一些不想提交的隐藏文件也提交到暂存区了；假如我们当前目录下有很多 .txt 文件等待提交：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_195.png\" alt=\"\" width=\"700\"></div>\n\n<p>我们可以使用 “*.txt” 匹配到所有的 txt 文件，然后就可以将它们全部提交了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add <span class=\"string\">'*.txt'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"将暂存区修改添加到本地仓库\"><a href=\"#将暂存区修改添加到本地仓库\" class=\"headerlink\" title=\"将暂存区修改添加到本地仓库\"></a>将暂存区修改添加到本地仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">'备注信息'</span></span><br></pre></td></tr></table></figure>\n<p>经过多次的 git add，此时的暂存区有好多本地的修改，通过上面的 commit 可以将所有的暂存区的修改添加到本地仓库，所以你可以简单理解为：需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>\n<h3 id=\"push-到远程\"><a href=\"#push-到远程\" class=\"headerlink\" title=\"push 到远程\"></a>push 到远程</h3><p>经过上面的一顿折腾，仍然只有本地的 “Git” 知道了我们都做了些什么，如果想让远程仓库也知道，我们需要先和远程仓库建立联系：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/try-git/try_git.git</span><br></pre></td></tr></table></figure>\n<p>在这里遇到一个问题：每次 push 都要输入用户名和密码，原因是我们是通过 https 方式进行 push，解决方法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin      // 移除</span><br><span class=\"line\">git remote add origin git@github.com:try-git/test.git       // 添加</span><br></pre></td></tr></table></figure>\n<p>此后就不用再输入用户名和密码了，同时我们和远程建立联系以后就不用再 git remote add 了，这就好比你去别人家串门，第一次可能需要你需要查一下地图，第二次的话就直接去找他就行了。接下来就是 push 到远程了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>第一次 push 是需要加 -u 参数的，这个参数是告诉远程我是谁（<a href=\"https://www.zhihu.com/question/20019419\" target=\"_blank\" rel=\"noopener\">git push的-u参数具体含义</a>），还是刚才串门的例子，第一次去别人家串门肯定需要表明身份的，第二次就不再需要了，因为已经知道你是谁了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h3 id=\"从远程-pull\"><a href=\"#从远程-pull\" class=\"headerlink\" title=\"从远程 pull\"></a>从远程 pull</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<p>如果别人提交了他们的修改到远程仓库，我们需要从远程 pull 修改到我们的本地，从而保证大家的进度保持同步，比如别人提交了一个 yellow_octocat.txt 文件到远程，我们 git pull 之后：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_197.png\" alt=\"\" width=\"700\"></div>\n\n<p>Git 告诉我们，你 pull 成功了，新增加了一个文件叫做 yellow_octocat.txt，此时我们的当前目录就多了一个 yellow_octocat.txt（.git 也就是本地版本库也知道了这个文件）</p>\n<div align=\"center\"><img src=\"/images/hexo_post_198.png\" alt=\"\" width=\"700\"></div>\n\n<h3 id=\"查看修改的内容\"><a href=\"#查看修改的内容\" class=\"headerlink\" title=\"查看修改的内容\"></a>查看修改的内容</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n<p>有可能别人和我对同一文件进行了修改，所以在 pull 之后需要查看一下都发生了哪些修改:</p>\n<div align=\"center\"><img src=\"/images/hexo_post_199.png\" alt=\"\" width=\"700\"></div>\n\n<p>其实，git diff 的用法不仅只有这一种，还可以查看暂存区的修改都有哪些：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --staged</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h3><h4 id=\"丢弃工作区的修改\"><a href=\"#丢弃工作区的修改\" class=\"headerlink\" title=\"丢弃工作区的修改\"></a>丢弃工作区的修改</h4><p>假如我们对之前的一个文件 readme.txt 进行了修改，但是现在我发现对这个文件进行的修改都是错的（经常会发生），此时我不想要我对这个文件的修改了，就可以执行下面的命令，然后 readme.txt 就可以回退到我修改之前的样子</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout readme.txt</span><br></pre></td></tr></table></figure>\n<h4 id=\"丢弃暂存区的修改\"><a href=\"#丢弃暂存区的修改\" class=\"headerlink\" title=\"丢弃暂存区的修改\"></a>丢弃暂存区的修改</h4><p>和刚才不一样的是，我已经将我的修改提交到暂存区了（也就是说已经执行了 git add readme.txt 命令），此时我想把这个文件的修改从暂存区放回到工作区，就需要执行下面的命令，然后此时的暂存区就不再有 readme.txt 的修改，就像没 git add 过</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支相关\"><a href=\"#分支相关\" class=\"headerlink\" title=\"分支相关\"></a>分支相关</h2><p>除了 Git，其他版本控制系统如 SVN 中也有分支管理，但是 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。但是截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即<code>master</code> 分支。<code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<strong><code>HEAD</code> 指向的就是当前分支</strong>。每次提交，<code>master</code> 分支都会向前移动一步，这样，随着你不断提交，<code>master</code> 分支的线也越来越长。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_1.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch clean_up</span><br></pre></td></tr></table></figure>\n<p>此时我们在本地创建了一个分支叫做 clean_up，对于 Git 来说，相当于新建了一个指针叫 clean_up，指向和 master 相同的提交，但是此时的 HEAD 仍然指向 master，因为此时我们只是新建了一个分支，并没有切换到 clean_up 分支</p>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout clean_up</span><br></pre></td></tr></table></figure>\n<p>我们新创建了 clean_up 分支后，可以通过上面的命令将本地的分支切换到 clean_up，此时的 HEAD 就会指向 clean_up</p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p>为了后面的分支命令展示，我们通过下面的命令将 .txt 文件（注意此时所在的分支仍然是 clean_up）删除</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm <span class=\"string\">'*.txt'</span></span><br></pre></td></tr></table></figure>\n<p>然后，我们将删除这些文件的修改进行提交（add + commit），此时本地的 clean_up 分支就没有这些 .txt 文件了：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_200.png\" alt=\"\" width=\"700\"></div>\n\n<p>此时我们再切换到 master 分支（git checkout master）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_201.png\" alt=\"\" width=\"700\"></div>\n\n<p>通过上面两张图片，我们可以清晰的看到分支的作用，其实相当于两个平行世界（branch），而你所扮演的就是上帝的角色，想让哪个世界继续进行，就 checkout 哪个分支就可以了。此时如果我们想让\b clean_up 分支上做出的改变合并到 master 分支该怎么办呢？</p>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge clean_up</span><br></pre></td></tr></table></figure>\n<p>上面这段命令执行的前提是你当前的分支是 master，而通过 git merge 某分支可以将某分支的改变合并到当前分支：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_202.png\" alt=\"\" width=\"700\"></div>\n\n<p>我们通过上面的结果可以看到此时的 master 分支已经没有了 .txt 文件</p>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d clean_up</span><br></pre></td></tr></table></figure>\n<p>既然我们已经把 clean_up 分支的改变合并到了 master 分支，所以此时我们就不再需要 clean_up 分支了，通过上面的命令可以将该分支删除</p>\n<h2 id=\"版本相关\"><a href=\"#版本相关\" class=\"headerlink\" title=\"版本相关\"></a>版本相关</h2><p>较为复杂的分支命令的介绍就告一段落了，下面介绍一下和版本相关的一些常用命令</p>\n<h3 id=\"查看提交的历史记录\"><a href=\"#查看提交的历史记录\" class=\"headerlink\" title=\"查看提交的历史记录\"></a>查看提交的历史记录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<p>我们可以通过 git log 查看提交的历史记录（每一次 commit 都是一次记录）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_196.png\" alt=\"\" width=\"700\"></div>\n\n<p>从上面的图片可以看到，我们有两次 commit 记录，他们的 id 是很长的黄色字符串，这个 id 和每次提交是一一对应的，同时也对应着相应的版本，而除了 commit id，我们还可以看到提交的作者、日期以及备注信息（这里就体现出了备注信息是多么的重要）</p>\n<h3 id=\"回退版本\"><a href=\"#回退版本\" class=\"headerlink\" title=\"回退版本\"></a>回退版本</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n<p>通过上面的命令，我们可以回退到上个版本，<code>HEAD</code> 为当前版本，<code>HEAD^</code> 为上一个版本，<code>HEAD^^</code> 为上上个版本，如果有 100 个版本 <code>HEAD~100</code>。当然，我们也可以通过上面提到的 commit id 来回到过去的某个版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard commit_id</span><br></pre></td></tr></table></figure>\n<p>是不是更感觉自己像是一个上帝了，在 Git 中，你可以随意控制平行世界的发展，需要做的只是输出一行命令而已</p>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><p>上面就是一些我们最常用的 Git 命令，但是 Git 的强大之处远不止这些，下面就简单介绍几种我们可能会用到的命令：</p>\n<h3 id=\"建立本地分支与远程分支的追踪关系\"><a href=\"#建立本地分支与远程分支的追踪关系\" class=\"headerlink\" title=\"建立本地分支与远程分支的追踪关系\"></a>建立本地分支与远程分支的追踪关系</h3><p>当在本地新建分支的时候，可能远程并没有这个分支，所以你需要建立追踪关系，这样你 push 的时候才不会 push 到别的分支上去</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --<span class=\"built_in\">set</span>-upstream-to=&lt;remote&gt;/branchName  // 建立本地分支与远程分支的追踪关系</span><br><span class=\"line\">git branch --track branchName [remote branch]   // 新建一个分支，并与远程建立追踪关系</span><br></pre></td></tr></table></figure>\n<h3 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h3><p>这是 Git 的又一神奇命令，它可以让你将任何一次 commit 的修改合并到当前分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick commitId  // 将与 commitId 对应的提交合进当前分支</span><br></pre></td></tr></table></figure>\n<h3 id=\"bug-分支\"><a href=\"#bug-分支\" class=\"headerlink\" title=\"bug 分支\"></a>bug 分支</h3><p>当我们修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除分支；但是如果我们的手头工作没有完成呢，就需要暂时放弃当前没有提交的修改，然后去修复bug，修复完之后再回来恢复原样继续做刚才的工作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash     // 暂时放弃未提交的修改</span><br><span class=\"line\">git stash pop    // 恢复</span><br></pre></td></tr></table></figure>\n<h2 id=\"实践步骤\"><a href=\"#实践步骤\" class=\"headerlink\" title=\"实践步骤\"></a>实践步骤</h2><table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>git操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>克隆代码</td>\n<td>git clone远端代码</td>\n</tr>\n<tr>\n<td>创建分支</td>\n<td>git checkout -b branch_name</td>\n</tr>\n<tr>\n<td>在分支中开发</td>\n<td>无</td>\n</tr>\n<tr>\n<td>review代码</td>\n<td>无</td>\n</tr>\n<tr>\n<td>第一轮测试</td>\n<td>无</td>\n</tr>\n<tr>\n<td>添加代码至分支</td>\n<td>git add somefile</td>\n</tr>\n<tr>\n<td>提交代码至分支</td>\n<td>“git commit -m “”本次提交注释”””</td>\n</tr>\n<tr>\n<td>切换至主分支</td>\n<td>git checkout master</td>\n</tr>\n<tr>\n<td>获取远端最新代码</td>\n<td>git pull origin master</td>\n</tr>\n<tr>\n<td>合并分支至master分支</td>\n<td>git merge branch_name</td>\n</tr>\n<tr>\n<td>解决合并时产生的冲突</td>\n<td></td>\n</tr>\n<tr>\n<td>第二轮测试</td>\n<td>无</td>\n</tr>\n<tr>\n<td>获取远端最新代码</td>\n<td>git pull origin master</td>\n</tr>\n<tr>\n<td>推送至master分支</td>\n<td>git push origin master</td>\n</tr>\n<tr>\n<td>若无问题，删除本地分支</td>\n<td>git branch -d branch_name</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">图解Git</a></li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">廖雪峰-Git教程</a></li>\n<li><a href=\"https://try.github.io/levels/1/challenges/1\" target=\"_blank\" rel=\"noopener\">在线练习git命令</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2\" target=\"_blank\" rel=\"noopener\">Pro Git</a></li>\n<li><a href=\"http://www.jianshu.com/p/50892fac6cbc\" target=\"_blank\" rel=\"noopener\">实用Git Workflow</a></li>\n<li><a href=\"http://gitbook.liuhui998.com/index.html\" target=\"_blank\" rel=\"noopener\">Git Community Book 中文版</a></li>\n</ul>\n<h2 id=\"另外一些关于-Git-Github-入门的文章\"><a href=\"#另外一些关于-Git-Github-入门的文章\" class=\"headerlink\" title=\"另外一些关于 Git / Github 入门的文章\"></a>另外一些关于 Git / Github 入门的文章</h2><ul>\n<li><a href=\"http://blog.jobbole.com/111187/\" target=\"_blank\" rel=\"noopener\">大白话解释 Git 和 GitHub</a></li>\n<li><a href=\"http://rogerdudler.github.io/git-guide/\" target=\"_blank\" rel=\"noopener\">git - the simple guide</a></li>\n<li><a href=\"https://www.pluralsight.com/blog/software-development/github-tutorial\" target=\"_blank\" rel=\"noopener\">GitHub: the beginner’s guide</a></li>\n</ul>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[{"name":"git","path":"api/tags/git.json"},{"name":"教程","path":"api/tags/教程.json"}]},{"title":"前端面试系列（12）——前端性能优化","slug":"前端面试系列（12）——前端性能优化","date":"2017-04-16T14:20:57.000Z","updated":"2019-07-04T08:09:14.553Z","comments":true,"path":"api/articles/前端面试系列（12）——前端性能优化.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>近几年的前端发展异常火爆，各种框架各种技术层出不穷，而所有的前端框架面临着同一个问题：怎样才能缩短首屏时间，让用户以最快的速度看到页面最想展现的内容；所以，前端性能优化这一问题成为所有前端开发人员需要考虑的需求。下面我将从 html、css、js 等方面介绍前端性能优化的一些方式，考虑到篇幅原因，只会以列表的形式进行简单概括，具体做法可以自行查阅，在这里强烈推荐<a href=\"https://developer.yahoo.com/performance/rules.html\" target=\"_blank\" rel=\"noopener\">雅虎军规</a>，Yahoo Rules 是对于前端性能优化的全面总结，有时间一定要看一看</p>\n<h2 id=\"HTML-的优化\"><a href=\"#HTML-的优化\" class=\"headerlink\" title=\"HTML 的优化\"></a>HTML 的优化</h2><h3 id=\"使用相对-URL\"><a href=\"#使用相对-URL\" class=\"headerlink\" title=\"使用相对 URL\"></a>使用相对 URL</h3><p>某些 href、src 属性如果与当前页面处于同一域名下，则使用相对 URL 能够节省至少一个域名的长度。</p>\n<h3 id=\"删除-HTTP-或者-HTTPS\"><a href=\"#删除-HTTP-或者-HTTPS\" class=\"headerlink\" title=\"删除 HTTP 或者 HTTPS\"></a>删除 HTTP 或者 HTTPS</h3><p>绝对 URL 都以 HTTP 或 HTTPS 等协议头开始，如果能确定 URL 的协议与当前页面 URL 的协议是一致的，或者说该 URL 在多种协议下均是可用的，则可以考虑删除这个协议头。</p>\n<h3 id=\"删除注释\"><a href=\"#删除注释\" class=\"headerlink\" title=\"删除注释\"></a>删除注释</h3><p>考虑不必要的 IE 条件注释和 CDATA 注释及自定义注释。</p>\n<h3 id=\"压缩空白符\"><a href=\"#压缩空白符\" class=\"headerlink\" title=\"压缩空白符\"></a>压缩空白符</h3><p>对于多数标签，可以通过删除多余的空白符来减少 HTML 体积，但是对于 pre 等是例外。</p>\n<h3 id=\"压缩-inline-css-amp-Javascript\"><a href=\"#压缩-inline-css-amp-Javascript\" class=\"headerlink\" title=\"压缩 inline css &amp; Javascript\"></a>压缩 inline css &amp; Javascript</h3><p>不管 inline 还是 external，都需要压缩，这是减小体积的最直接的方式。</p>\n<h3 id=\"CSS-amp-Javascript-尽量外链\"><a href=\"#CSS-amp-Javascript-尽量外链\" class=\"headerlink\" title=\"CSS &amp; Javascript 尽量外链\"></a>CSS &amp; Javascript 尽量外链</h3><p>不仅可以减少体积，还能够充分利用浏览器的缓存机制。</p>\n<h3 id=\"删除元素默认属性\"><a href=\"#删除元素默认属性\" class=\"headerlink\" title=\"删除元素默认属性\"></a>删除元素默认属性</h3><p>在 HTML 规范中，很多 HTML 元素的属性是有默认值的，对于这些默认值可以抹去不写。</p>\n<h3 id=\"避免使用-Iframe\"><a href=\"#避免使用-Iframe\" class=\"headerlink\" title=\"避免使用 Iframe\"></a>避免使用 Iframe</h3><p>创建 iframe 元素的开销要比创建其他类型的 DOM 元素高 1~2 个数量级</p>\n<h3 id=\"避免空链接属性\"><a href=\"#避免空链接属性\" class=\"headerlink\" title=\"避免空链接属性\"></a>避免空链接属性</h3><p>可以看做是上面“删除元素默认属性”的特例，即使图片的地址为空，浏览器依旧会以默认的规则去请求空地址</p>\n<h3 id=\"避免节点深层级嵌套\"><a href=\"#避免节点深层级嵌套\" class=\"headerlink\" title=\"避免节点深层级嵌套\"></a>避免节点深层级嵌套</h3><p>由于浏览器构建 DOM 文档的机制，深层级嵌套的节点在初始化构建时往往需要更多的内存占用，并且在遍历节点时也会更慢些</p>\n<h3 id=\"避免-Table-布局\"><a href=\"#避免-Table-布局\" class=\"headerlink\" title=\"避免 Table 布局\"></a>避免 Table 布局</h3><p>构建 table 的开销也很大</p>\n<h3 id=\"显示指定文档字符集\"><a href=\"#显示指定文档字符集\" class=\"headerlink\" title=\"显示指定文档字符集\"></a>显示指定文档字符集</h3><p>如果浏览器不能获知页面的编码字符集，一般都会在执行脚本和渲染页面前，把字节流缓存，然后再搜索可进行解析的字符集，或以默认的字符集来解析页面代码，这会导致消耗不必要的时间。为了避免浏览器把时间花费在搜寻合适的字符集来进行解码，所以最好在文档中总是显式的指定页面字符集。</p>\n<h2 id=\"CSS-的优化\"><a href=\"#CSS-的优化\" class=\"headerlink\" title=\"CSS 的优化\"></a>CSS 的优化</h2><h3 id=\"把-CSS-放到代码页上端\"><a href=\"#把-CSS-放到代码页上端\" class=\"headerlink\" title=\"把 CSS 放到代码页上端\"></a>把 CSS 放到代码页上端</h3><p>加快渲染</p>\n<h3 id=\"避免-CSS-表达式\"><a href=\"#避免-CSS-表达式\" class=\"headerlink\" title=\"避免 CSS 表达式\"></a>避免 CSS 表达式</h3><p>表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给 CSS 表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到 10000 次以上的计算量。</p>\n<h3 id=\"使用-lt-link-gt-而不是-import\"><a href=\"#使用-lt-link-gt-而不是-import\" class=\"headerlink\" title=\"使用 &lt;link&gt; 而不是 @import\"></a>使用 <code>&lt;link&gt;</code> 而不是 <code>@import</code></h3><p>在外部的 CSS 文件中使用 @import 会使得页面在加载时增加额外的延迟。虽然规则允许在样式中调用 @import 来导入其它的 CSS，但浏览器不能并行下载样式，就会导致页面增添了额外的往返耗时。比如，第一个 CSS 文件 first.css 包含了以下内容：@import url(“second.css”)。那么浏览器就必须先把 first.css 下载、解析和执行后，才发现及处理第二个文件 second.css。</p>\n<h3 id=\"避免通配选择器\"><a href=\"#避免通配选择器\" class=\"headerlink\" title=\"避免通配选择器\"></a>避免通配选择器</h3><p>CSS 选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免需要消耗更多匹配时间的选择器。比如这种反例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.selected</span> * &#123;<span class=\"attribute\">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 <strong>CSS 选择器从右到左匹配的机制</strong>，浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 selected 的元素，直到文档的根节点，因此其匹配开销是非常大的，通常比开销最小的 ID 选择器高出 1~3 个数量级，所以应避免使用关键选择器是通配选择器的规则。</p>\n<h3 id=\"避免单规则的属性选择器\"><a href=\"#避免单规则的属性选择器\" class=\"headerlink\" title=\"避免单规则的属性选择器\"></a>避免单规则的属性选择器</h3><p>属性选择器根据元素的属性是否存在或其属性值进行匹配，如下例规则会把 herf 属性值等于 ”#index” 的链接元素设置为红色：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.selected</span> <span class=\"selector-attr\">[href=”#index”]</span> &#123;<span class=\"attribute\">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>\n<p>但其匹配开销是非常大的，浏览器先匹配所有的元素，检查其是否有 href 属性并且 herf 属性值等于 ”#index”， 然后分别向上逐级匹配 class 为 selected 的元素，直到文档的根节点。所以应避免使用关键选择器是单规则属性选择器的规则。</p>\n<h3 id=\"避免类正则的属性选择器\"><a href=\"#避免类正则的属性选择器\" class=\"headerlink\" title=\"避免类正则的属性选择器\"></a>避免类正则的属性选择器</h3><p>CSS3 添加了复杂的属性选择器，可以通过类正则表达式的方式对元素的属性值进行匹配。当然这些类型的选择器定是会影响性能的，正则表达式匹配会比基于类别的匹配会慢很多。大部分情况下我们应尽量避免使用 *=， |=， ^=， $=，和 ~= 语法的属性选择器。</p>\n<h2 id=\"JavaScript-的优化\"><a href=\"#JavaScript-的优化\" class=\"headerlink\" title=\"JavaScript 的优化\"></a>JavaScript 的优化</h2><h3 id=\"脚本放到-HTML-代码页底部\"><a href=\"#脚本放到-HTML-代码页底部\" class=\"headerlink\" title=\"脚本放到 HTML 代码页底部\"></a>脚本放到 HTML 代码页底部</h3><p>加快渲染，当然如果你的 js 会影响 dom 建立，那放在哪都是一样的了</p>\n<h3 id=\"移除重复脚本\"><a href=\"#移除重复脚本\" class=\"headerlink\" title=\"移除重复脚本\"></a>移除重复脚本</h3><p>封装方法是一个前端开发人员最基本的技能</p>\n<h3 id=\"减少-DOM-访问\"><a href=\"#减少-DOM-访问\" class=\"headerlink\" title=\"减少 DOM 访问\"></a>减少 DOM 访问</h3><p>使用 JavaScript 访问 DOM 元素是比较慢的，因此为了提升性能，应该做到：</p>\n<ul>\n<li>缓存已经查询过的元素；</li>\n<li>线下更新完节点之后再将它们添加到文档树中；</li>\n<li>避免使用 JavaScript 来修改页面布局；</li>\n</ul>\n<h3 id=\"使用事件代理\"><a href=\"#使用事件代理\" class=\"headerlink\" title=\"使用事件代理\"></a>使用事件代理</h3><p>有时候我们会感觉到页面反应迟钝，这是因为 DOM 树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用事件代理是一种好方法了。如果你在一个 div 中有 10 个按钮，你只需要在 div 上附加一次事件句柄就可以了，而不用去为每一个按钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。</p>\n<h3 id=\"缓存选择器查询结果\"><a href=\"#缓存选择器查询结果\" class=\"headerlink\" title=\"缓存选择器查询结果\"></a>缓存选择器查询结果</h3><p>选择器查询是开销很大的方法。所以，使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。 不要使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery(<span class=\"string\">'#top'</span>).find(<span class=\"string\">'p.classA'</span>);</span><br><span class=\"line\">jQuery(<span class=\"string\">'#top'</span>).find(<span class=\"string\">'p.classB'</span>);</span><br></pre></td></tr></table></figure>\n<p>而是使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cached = jQuery(<span class=\"string\">'#top'</span>);</span><br><span class=\"line\">cached.find(<span class=\"string\">'p.classA'</span>);</span><br><span class=\"line\">cached.find(<span class=\"string\">'p.classB'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用微类库\"><a href=\"#使用微类库\" class=\"headerlink\" title=\"使用微类库\"></a>使用微类库</h3><p>通常开发者都会使用 JavaScript 类库，如 jQuery、Mootools、YUI、Dojo 等，但是开发者往往只是使用 JavaScript 类库中的部分功能。为了更大的提升性能，应尽量避免使用这类大而全的类库，而是按需使用微类库来辅助开发。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li>[Absolute HTML Compressor](<a href=\"http://www.alentum.com/ahc/\" target=\"_blank\" rel=\"noopener\">http://www.alentum.com/ahc/</a> “Absolute HTML Compressor”）：HTML 的优化工具，压缩效果比较理想</li>\n<li><a href=\"https://book.douban.com/subject/3686503/\" target=\"_blank\" rel=\"noopener\">Even Faster Web Sites</a>：关于前端优化的书，本人没看过，但是豆瓣评分 8.6 的它应该还不错吧</li>\n</ul>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/news/2010/05/baidu-html-optimize\" target=\"_blank\" rel=\"noopener\">不应忽视的HTML优化</a> </li>\n<li><a href=\"https://developer.yahoo.com/performance/rules.html\" target=\"_blank\" rel=\"noopener\">Yahoo Rules</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000007677580\" target=\"_blank\" rel=\"noopener\">前端性能优化黄金法则</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002418920\" target=\"_blank\" rel=\"noopener\">网站性能优化工具大全</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008829958\" target=\"_blank\" rel=\"noopener\">WEB前端性能优化常见方法</a></li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"性能优化","path":"api/tags/性能优化.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"JS中的一些小技巧，精妙且实用","slug":"JS中的一些小技巧，精妙且实用","date":"2017-04-13T01:33:29.000Z","updated":"2019-07-04T08:09:14.545Z","comments":true,"path":"api/articles/JS中的一些小技巧，精妙且实用.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这里总结了我在项目中经常会用到的一些 JS 小技巧，同时参考了其他开发者对于 JS 小技巧的总结，从而形成了这篇文章，如果在日后我发现了更多的小技巧，我会及时更新</p>\n<h2 id=\"使用-操作符转换布尔值\"><a href=\"#使用-操作符转换布尔值\" class=\"headerlink\" title=\"使用 !! 操作符转换布尔值\"></a>使用 !! 操作符转换布尔值</h2><p>有时候我们需要对一个变量检查其是否存在或者检查值是否有一个有效值，如果存在就返回 true 值。为了做这样的验证，我们可以使用 !! 操作符来实现是非常的方便与简单。对于变量可以使用 !!variable 进行检测</p>\n<p><strong>只要变量的值为：0、null、” “、undefined 或者 NaN 都将返回的是 false，反之返回的是 true</strong>。</p>\n<h2 id=\"使用-“-”-或-“-“-转化数值\"><a href=\"#使用-“-”-或-“-“-转化数值\" class=\"headerlink\" title=\"使用 “+” 或 “-“ 转化数值\"></a>使用 “+” 或 “-“ 转化数值</h2><p>这个技巧非常有用，其非常简单，可以将字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回 NaN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">strNumber</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> +strNumber;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"1234\"</span>)); <span class=\"comment\">// 1234</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"ACB\"</span>)); <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"检测对象中属性\"><a href=\"#检测对象中属性\" class=\"headerlink\" title=\"检测对象中属性\"></a>检测对象中属性</h2><p>当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用 document.querySelector() 来选择一个 id，并且让它能兼容 IE6 浏览器，但是在 IE6 浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">'querySelector'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#id\"</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，如果 document 不存在 querySelector 函数，那么就会调用 docuemnt.getElementById(“id”)。</p>\n<h2 id=\"数组截断\"><a href=\"#数组截断\" class=\"headerlink\" title=\"数组截断\"></a>数组截断</h2><p>这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有 10 个元素，但你只想只要前五个元素，那么你可以通过 array.length = 5 来截断数组。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 6</span></span><br><span class=\"line\">array.length = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array); <span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"合并数组\"><a href=\"#合并数组\" class=\"headerlink\" title=\"合并数组\"></a>合并数组</h2><p>如果你要合并两个数组，一般情况之下你都会使用 Array.concat() 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1.concat(array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure>\n<p>然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之下，可以使用 Array.pus().apply(arr1,arr2) 来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1.push.apply(array1, array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"将-NodeList-转换成数组\"><a href=\"#将-NodeList-转换成数组\" class=\"headerlink\" title=\"将 NodeList 转换成数组\"></a>将 NodeList 转换成数组</h2><p>如果你运行 document.querySelectorAll(“p”) 函数时，它可能返回 DOM 元素的数组，也就是 NodeList 对象。但这个对象不具有数组的函数功能，比如 sort()、reduce()、map()、filter() 等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用 <strong>[].slice.call(elements)</strong> 来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elements = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"p\"</span>); <span class=\"comment\">// NodeListvar </span></span><br><span class=\"line\">arrayElements = [].slice.call(elements); <span class=\"comment\">// Now the NodeList is an array</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayElements = <span class=\"built_in\">Array</span>.from(elements); <span class=\"comment\">// This is another way of converting NodeList to Array</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"数组元素随机排序\"><a href=\"#数组元素随机排序\" class=\"headerlink\" title=\"数组元素随机排序\"></a>数组元素随机排序</h2><p>利用随机数模拟随机排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(list.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">Math</span>.random() - <span class=\"number\">0.5</span>&#125;)); <span class=\"comment\">// [2,1,3]</span></span><br></pre></td></tr></table></figure>\n<p>其实利用 Math.random() 得到的结果并不是真正的随机排序，参见我的另外一篇文章：<a href=\"/20170322/summary-of-array-method-in-js.html\">JS中数组方法总结</a>，这篇文章中的数组随机排序方法是比较好的一个方法</p>\n<h2 id=\"从数组中获取一个随机项\"><a href=\"#从数组中获取一个随机项\" class=\"headerlink\" title=\"从数组中获取一个随机项\"></a>从数组中获取一个随机项</h2><p>很难说这是一个技巧，如果你的前端水平还算可以的话，这个应该难不倒你：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [<span class=\"number\">12</span>, <span class=\"number\">548</span> , <span class=\"string\">'a'</span> , <span class=\"number\">2</span> , <span class=\"number\">5478</span> , <span class=\"string\">'foo'</span> , <span class=\"number\">8852</span>, , <span class=\"string\">'Doe'</span> , <span class=\"number\">2145</span> , <span class=\"number\">119</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> randomItem = items[<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * items.length)];</span><br></pre></td></tr></table></figure>\n<h2 id=\"在特定范围内获取一个随机数\"><a href=\"#在特定范围内获取一个随机数\" class=\"headerlink\" title=\"在特定范围内获取一个随机数\"></a>在特定范围内获取一个随机数</h2><p>这个在生成测试数据的时候非常有用，比如一个在最小最大值之间的一个随机薪水值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min + <span class=\"number\">1</span>)) + min;</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成一个随机的数字字母字符串\"><a href=\"#生成一个随机的数字字母字符串\" class=\"headerlink\" title=\"生成一个随机的数字字母字符串\"></a>生成一个随机的数字字母字符串</h2><p>有时候，我们需要给某个元素赋一个唯一的 id，这个时候随机字符串就可以派上用场了，在这个技巧里，你可以见识到 js 中的 toString() 方法是多么的强大；Math.random() 生成 0 到 1 之间的随机数，number.toString(36) 是将这个数字转换成36进制（0-9，a-z），最后 substr 去掉前面的 “0.” 字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateRandomAlphaNum</span>(<span class=\"params\">len</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rdmstring = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ;rdmString.length &lt; len; ) &#123;</span><br><span class=\"line\">        rdmString += <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substr(<span class=\"number\">2</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rdmString.substr(<span class=\"number\">0</span>, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"更快的四舍五入\"><a href=\"#更快的四舍五入\" class=\"headerlink\" title=\"更快的四舍五入\"></a>更快的四舍五入</h2><p>见到过双波浪线 “~~” 操作符吗？它有时也被称为 <code>double NOT</code> 运算符。你可以更快的使用它来作为 Math.floor() 替代品。为什么呢？单位移 ~ 将 32 位转换输入 -(输入+1)，因此双位移将输入转换为 -(-(输入+1))，这是个趋于 0 的伟大的工具。对于输入的数字，它将模仿 Math.ceil() 取负值和 Math.floor() 取正值。如果执行失败，则返回 0，这可能在用来代替 Math.floor() 失败时返回一个 NaN 的时候发挥作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单位移</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~<span class=\"number\">1337</span>) <span class=\"comment\">// -1338</span></span><br><span class=\"line\"><span class=\"comment\">// 双位移</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"number\">47.11</span>) <span class=\"comment\">// -&gt; 47</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"number\">-12.88</span>) <span class=\"comment\">// -&gt; -12</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"number\">1.9999</span>) <span class=\"comment\">// -&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"number\">3</span>) <span class=\"comment\">// -&gt; 3</span></span><br><span class=\"line\"><span class=\"comment\">//失败的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~[]) <span class=\"comment\">// -&gt; 0 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"literal\">NaN</span>) <span class=\"comment\">// -&gt; 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"literal\">null</span>) <span class=\"comment\">// -&gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">//大于32位整数则失败</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~(<span class=\"number\">2147483647</span> + <span class=\"number\">1</span>) === (<span class=\"number\">2147483647</span> + <span class=\"number\">1</span>)) <span class=\"comment\">// -&gt; 0</span></span><br></pre></td></tr></table></figure>\n<p>虽然 ~~ 可能有更好的表现，不过为了可读性，还是推荐使用 Math.floor()。</p>\n<h2 id=\"测量一个-JavaScript-代码块的性能\"><a href=\"#测量一个-JavaScript-代码块的性能\" class=\"headerlink\" title=\"测量一个 JavaScript 代码块的性能\"></a>测量一个 JavaScript 代码块的性能</h2><p>快速测量一个 JavaScript 块的性能，我们可以使用控制台的功能像 console.time(label) 和console.timeEnd(label)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">\"Array initialize\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">100</span>),</span><br><span class=\"line\">    len = arr.length,</span><br><span class=\"line\">    i;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    arr[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"Array initialize\"</span>); <span class=\"comment\">// 输出: Array initialize: 0.711ms</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"自调用函数\"><a href=\"#自调用函数\" class=\"headerlink\" title=\"自调用函数\"></a>自调用函数</h2><p>这个经常被称为自调用匿名函数（Self-Invoked Anonymous Function）或者即时调用函数表达式（IIFE-Immediately Invoked Function Expression)。这是一个在创建后立即自动执行的函数，可以用于数据回填以及窗口 resize() 事件，我在项目中屡试不爽，示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// some private code that will be executed automatically</span></span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = a + b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;)(<span class=\"number\">10</span>, <span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现-String-的-trim-函数\"><a href=\"#实现-String-的-trim-函数\" class=\"headerlink\" title=\"实现 String 的 trim 函数\"></a>实现 String 的 trim 函数</h2><p>在 Java、C#、PHP 和很多其他语言中都有一个经典的 trim 函数，用来去除字符串中首尾的空格符，而在 JavaScript 中并没有，所以我们需要在 String 对象上加上这个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.trim = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.replace(<span class=\"regexp\">/^\\s+|\\s+$/g</span>, <span class=\"string\">\"\"</span>);&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"将-arguments-对象转换成一个数组\"><a href=\"#将-arguments-对象转换成一个数组\" class=\"headerlink\" title=\"将 arguments 对象转换成一个数组\"></a>将 arguments 对象转换成一个数组</h2><p>arguments 对象是一个类数组对象，但不是一个真正的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> argArray = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"验证是否是数字\"><a href=\"#验证是否是数字\" class=\"headerlink\" title=\"验证是否是数字\"></a>验证是否是数字</h2><p>这是一个可以称得上技巧的 js 方法，当然你也可以用正则表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"built_in\">isNaN</span>(<span class=\"built_in\">parseFloat</span>(n)) &amp;&amp; <span class=\"built_in\">isFinite</span>(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"验证是否是数组\"><a href=\"#验证是否是数组\" class=\"headerlink\" title=\"验证是否是数组\"></a>验证是否是数组</h3><p>call() 这个方法在 js 里如同神技，而这里也是它的一个应用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj) === <span class=\"string\">'[object Array]'</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不要使用-delete-来删除一个数组中的项\"><a href=\"#不要使用-delete-来删除一个数组中的项\" class=\"headerlink\" title=\"不要使用 delete 来删除一个数组中的项\"></a>不要使用 delete 来删除一个数组中的项</h2><p>使用 splice 而不要使用 delete 来删除数组中的某个项。使用 delete 只是用 undefined 来替换掉原有的项，并不是真正的从数组中删除。 不要使用这种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [<span class=\"number\">12</span>, <span class=\"number\">548</span>, <span class=\"string\">'a'</span>, <span class=\"number\">2</span>, <span class=\"number\">5478</span>, <span class=\"string\">'foo'</span>, <span class=\"number\">8852</span>, , <span class=\"string\">'Doe'</span>, <span class=\"number\">2154</span>, <span class=\"number\">119</span>];</span><br><span class=\"line\">items.length; <span class=\"comment\">// return 11</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> items[<span class=\"number\">3</span>]; <span class=\"comment\">// return true</span></span><br><span class=\"line\">items.length; <span class=\"comment\">// return 11</span></span><br><span class=\"line\"><span class=\"comment\">/* items will be equal to [12, 548, \"a\", undefined × 1, 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119] */</span></span><br></pre></td></tr></table></figure>\n<p>而使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [<span class=\"number\">12</span>, <span class=\"number\">548</span>, <span class=\"string\">'a'</span>, <span class=\"number\">2</span>, <span class=\"number\">5478</span>, <span class=\"string\">'foo'</span>, <span class=\"number\">8852</span>, , <span class=\"string\">'Doe'</span>, <span class=\"number\">2154</span>, <span class=\"number\">119</span>];</span><br><span class=\"line\">items.length; <span class=\"comment\">// return 11</span></span><br><span class=\"line\">items.splice(<span class=\"number\">3</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">items.length; <span class=\"comment\">// return 10</span></span><br><span class=\"line\"><span class=\"comment\">/* items will be equal to [12, 548, \"a\", 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119] */</span></span><br></pre></td></tr></table></figure>\n<p>delete 方法应该被用来删除一个对象的某个属性。</p>\n<h2 id=\"使用逻辑-AND-OR-做条件判断\"><a href=\"#使用逻辑-AND-OR-做条件判断\" class=\"headerlink\" title=\"使用逻辑 AND / OR 做条件判断\"></a>使用逻辑 AND / OR 做条件判断</h2><p>这个技巧在一定程度上降低了可读性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">10</span>;</span><br><span class=\"line\">foo == <span class=\"number\">10</span> &amp;&amp; doSomething(); <span class=\"comment\">// 等价于 if (foo == 10) doSomething();</span></span><br><span class=\"line\">foo == <span class=\"number\">5</span> || doSomething(); <span class=\"comment\">// 等价于 if (foo != 5) doSomething();</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用逻辑-OR-为函数参数设置默认值\"><a href=\"#使用逻辑-OR-为函数参数设置默认值\" class=\"headerlink\" title=\"使用逻辑 OR 为函数参数设置默认值\"></a>使用逻辑 OR 为函数参数设置默认值</h2><p>这个技巧实用到爆，尤其是开发插件的时候</p>\n<blockquote>\n<p>不过 ES6 语法已经支持默认值了</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">arg1</span>) </span>&#123;</span><br><span class=\"line\">    Arg1 = arg1 || <span class=\"number\">10</span>; <span class=\"comment\">// 如果 arg1 没有被设置的话，Arg1 将被默认设成 10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"浮点数问题\"><a href=\"#浮点数问题\" class=\"headerlink\" title=\"浮点数问题\"></a>浮点数问题</h2><p>这是一个需要注意的地方，但是计算机专业的人应该早就知道了吧</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> === <span class=\"number\">0.3</span> <span class=\"comment\">// is false</span></span><br><span class=\"line\"><span class=\"number\">9007199254740992</span> + <span class=\"number\">1</span> <span class=\"comment\">// is equal to 9007199254740992</span></span><br><span class=\"line\"><span class=\"number\">9007199254740992</span> + <span class=\"number\">2</span> <span class=\"comment\">// is equal to 9007199254740994</span></span><br></pre></td></tr></table></figure>\n<p>为什么会这样？ 0.1 + 0.2 等于 0.30000000000000004。这是因为，所有的 JavaScript 数字在内部都是以 64 位二进制表示的浮点数，符合 IEEE 754 标准。更多的介绍，可以阅读<a href=\"http://www.2ality.com/2012/04/number-encoding.html\" target=\"_blank\" rel=\"noopener\">这篇博文</a>。你可以使用 toFixed() 和 toPrecision() 方法解决这个问题。</p>\n<h2 id=\"使用-for-in-遍历一个对象内部属性的时候注意检查属性\"><a href=\"#使用-for-in-遍历一个对象内部属性的时候注意检查属性\" class=\"headerlink\" title=\"使用 for-in 遍历一个对象内部属性的时候注意检查属性\"></a>使用 for-in 遍历一个对象内部属性的时候注意检查属性</h2><p>下面的代码片段能够避免在遍历一个对象属性的时候访问原型的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> object) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (object.hasOwnProperty(name)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something with name</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"isFinite\"><a href=\"#isFinite\" class=\"headerlink\" title=\"isFinite()\"></a>isFinite()</h2><p>在使用这个方法之前需要验证一下参数，因为 null 的存在</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">0</span>/<span class=\"number\">0</span>) ; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"foo\"</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"10\"</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">10</span>);   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(undifined);  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>();   <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"literal\">null</span>);  <span class=\"comment\">// true  !!!</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在调用-setTimeout-和-setInterval-的时候传入函数，而不是字符串\"><a href=\"#在调用-setTimeout-和-setInterval-的时候传入函数，而不是字符串\" class=\"headerlink\" title=\"在调用 setTimeout() 和 setInterval() 的时候传入函数，而不是字符串\"></a>在调用 setTimeout() 和 setInterval() 的时候传入函数，而不是字符串</h2><p>如果你将字符串传递给 setTimeout() 或者 setInterval()，这个字符串将被如使用 eval 一样被解析，这个是非常耗时的 不要使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(<span class=\"string\">'doSomethingPeriodically()'</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">setTimeOut(<span class=\"string\">'doSomethingAfterFiveSeconds()'</span>, <span class=\"number\">5000</span>)</span><br></pre></td></tr></table></figure>\n<p>而用:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(doSomethingPeriodically, <span class=\"number\">1000</span>);</span><br><span class=\"line\">setTimeOut(doSomethingAfterFiveSeconds, <span class=\"number\">5000</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"用-JavaScript-获取伪元素-pseudo-element-属性\"><a href=\"#用-JavaScript-获取伪元素-pseudo-element-属性\" class=\"headerlink\" title=\"用 JavaScript 获取伪元素 (pseudo-element) 属性\"></a>用 JavaScript 获取伪元素 (pseudo-element) 属性</h2><p>大家都知道如何通过一个元素的 style 属性获取它的 CSS 样式值，但能获取伪元素 (pseudo-element) 的属性值吗？可以的，使用 JavaScript 也可以访问页面中的伪元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get the color value of .element:before</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"built_in\">window</span>.getComputedStyle(</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.element'</span>), <span class=\"string\">':before'</span></span><br><span class=\"line\">).getPropertyValue(<span class=\"string\">'color'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the content value of .element:before</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"built_in\">window</span>.getComputedStyle(</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.element'</span>), <span class=\"string\">':before'</span></span><br><span class=\"line\">).getPropertyValue(<span class=\"string\">'content'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"classList-API\"><a href=\"#classList-API\" class=\"headerlink\" title=\"classList API\"></a>classList API</h2><p>很多的 JavaScript 工具库里都有 <code>addClass</code>，<code>removeClass</code> 和 <code>toggleClass</code> 等方法。为了对老式浏览器的兼容，这些类库采用的方法都是先搜索元素的 <code>className</code>，追加和删除这个类，然后更新 <code>className</code>。其实有一个 API 提供了添加，删除和反转 CSS 类属性的方法，叫做 classList：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDiv.classList.add(<span class=\"string\">'myCssClass'</span>); <span class=\"comment\">// Adds a class</span></span><br><span class=\"line\">myDiv.classList.remove(<span class=\"string\">'myCssClass'</span>); <span class=\"comment\">// Removes a class</span></span><br><span class=\"line\">myDiv.classList.toggle(<span class=\"string\">'myCssClass'</span>); <span class=\"comment\">// Toggles a class</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"直接对样式表进行添加和删除样式规则\"><a href=\"#直接对样式表进行添加和删除样式规则\" class=\"headerlink\" title=\"直接对样式表进行添加和删除样式规则\"></a>直接对样式表进行添加和删除样式规则</h2><p>我们都非常熟悉使用 <code>element.style.propertyName</code> 来修改样式，使用 JavaScript 能帮助我们做到这些，但你知道如何新增或修一个现有的 CSS 样式规则吗？其实非常的简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addCSSRule</span>(<span class=\"params\">sheet, selector, rules, index</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sheet.insertRule) &#123;</span><br><span class=\"line\">\t\tsheet.insertRule(selector + <span class=\"string\">\"&#123;\"</span> + rules + <span class=\"string\">\"&#125;\"</span>, index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tsheet.addRule(selector, rules, index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Use it!</span></span><br><span class=\"line\">addCSSRule(<span class=\"built_in\">document</span>.styleSheets[<span class=\"number\">0</span>], <span class=\"string\">\"header\"</span>, <span class=\"string\">\"float: left\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"加载-CSS-文件\"><a href=\"#加载-CSS-文件\" class=\"headerlink\" title=\"加载 CSS 文件\"></a>加载 CSS 文件</h2><p>延迟加载图片、JSON、脚本等是用来加快页面显示速度的好方法。我们可以使用 curl.js 等这样 JavaScript 加载器来延迟加载这些外部资源，可你知道 CSS 样式表也可以延迟加载吗，而且在加载成功后回调函数会给予通知。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl(</span><br><span class=\"line\">\t[</span><br><span class=\"line\">\t\t<span class=\"string\">\"namespace/MyWidget\"</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"css!namespace/resources/MyWidget.css\"</span></span><br><span class=\"line\">\t], </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">MyWidget</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 你可以对MyWidget进行操作</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 这里没有对这个CSS文件引用，因为不需要;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 我们只需要它已经加载到页面上了</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"CSS-鼠标指针事件\"><a href=\"#CSS-鼠标指针事件\" class=\"headerlink\" title=\"CSS 鼠标指针事件\"></a>CSS 鼠标指针事件</h2><p>CSS 鼠标指针事件 <code>pointer-events</code> 属性非常的有趣，它的功效非常像 JavaScript，当你把这个属性设置为 none 时，它能有效的阻止禁止这个元素，你也许会说“这又如何？”，但事实上，它是禁止了这个元素上的任何 JavaScript 事件或回调函数！</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.disabled</span> &#123; <span class=\"attribute\">pointer-events</span>: none; &#125;</span><br></pre></td></tr></table></figure>\n<p>点击这个元素，你会发现任何你放置在这个元素上的监听器都不会触发任何事件。一个神奇的功能——你不再需要为了防止某个事件会被触发而去检查某个 css 类是否存在。</p>\n<h2 id=\"拓展阅读\"><a href=\"#拓展阅读\" class=\"headerlink\" title=\"拓展阅读\"></a>拓展阅读</h2><ul>\n<li><a href=\"http://blog.sae.sina.com.cn/archives/2291\" target=\"_blank\" rel=\"noopener\">45个实用的JavaScript技巧、窍门和最佳实践</a></li>\n<li><a href=\"http://blog.sae.sina.com.cn/archives/5569\" target=\"_blank\" rel=\"noopener\">5种你未必知道的JavaScript和CSS交互的方法</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"JS","path":"api/tags/JS.json"}]},{"title":"前端可以这样玩儿！","slug":"前端可以这样玩儿！","date":"2017-04-12T13:36:41.000Z","updated":"2019-07-04T08:09:14.549Z","comments":true,"path":"api/articles/前端可以这样玩儿！.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_40.png","content":"<p>本文总结了一些前端冷知识，相信看完之后的你一定会觉得前端为什么如此好玩儿？！（源自 Quora 上的一个帖子，同时又查阅了一些其他资料）</p>\n<h2 id=\"HTML-篇\"><a href=\"#HTML-篇\" class=\"headerlink\" title=\"HTML 篇\"></a>HTML 篇</h2><h3 id=\"浏览器地址栏运行-JavaScript-代码\"><a href=\"#浏览器地址栏运行-JavaScript-代码\" class=\"headerlink\" title=\"浏览器地址栏运行 JavaScript 代码\"></a>浏览器地址栏运行 JavaScript 代码</h3><p>这个相信很多人是知道的，在浏览器地址栏可以直接运行 JavaScript 代码，做法是以 javascript: 开头后跟要执行的语句。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript:alert(<span class=\"string\">'hello \bMerrier :)'</span>);</span><br></pre></td></tr></table></figure>\n<p>将以上代码贴到浏览器地址栏回车后 alert 正常执行，一个弹窗神现。需要注意的是如果是通过 copy paste 代码到浏览器地址栏的话，IE 及 Chrome 会自动去掉代码开头的 javascript:，所以需要手动添加起来才能正确执行，而 Firefox 中虽然不会自动去掉，但它根本就不支持在地址栏运行 JS 代码，sigh~</p>\n<h3 id=\"浏览器地址栏运行-HTML-代码\"><a href=\"#浏览器地址栏运行-HTML-代码\" class=\"headerlink\" title=\"浏览器地址栏运行 HTML 代码\"></a>浏览器地址栏运行 HTML 代码</h3><p>如果说上面那条小秘密知道的人还算多的话，这条秘笈知道的人就要少一些了，在非 IE 内核的浏览器地址栏可以直接运行 HTML 代码！比如在地址栏输入以下代码然后回车运行，会出现指定的页面内容。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:text/html,<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_40.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"你造么，可以把浏览器当编辑器\"><a href=\"#你造么，可以把浏览器当编辑器\" class=\"headerlink\" title=\"你造么，可以把浏览器当编辑器\"></a>你造么，可以把浏览器当编辑器</h3><p>还是浏览器地址栏上做文章，将以下代码贴到地址栏运行后浏览器变成了一个原始而简单的编辑器，与 Windows 自带的 notepad 一样，吼吼。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:text/html, <span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">contenteditable</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_47.gif\" alt=\"\" width=\"500\"></div>\n\n<p>归根结底多亏了 HTML5 中新加的 contenteditable 属性，当元素指定了该属性后，元素的内容成为可编辑状态。</p>\n<h3 id=\"整个页面变得可编辑\"><a href=\"#整个页面变得可编辑\" class=\"headerlink\" title=\"整个页面变得可编辑\"></a>整个页面变得可编辑</h3><p>将以下代码放到 console 执行后，整个页面将变得可编辑，随意践踏吧~</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.contentEditable=<span class=\"string\">'true'</span>;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_45.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"利用-a-标签自动解析-URL\"><a href=\"#利用-a-标签自动解析-URL\" class=\"headerlink\" title=\"利用 a 标签自动解析 URL\"></a>利用 a 标签自动解析 URL</h3><p>很多时候我们有从一个 URL 中提取域名，查询关键字，变量参数值等的需要，而万万没想到可以让浏览器方便地帮我们完成这一任务而不用我们写正则去抓取。方法就在 JS 代码里先创建一个a标签然后将需要解析的 URL 赋值给 a 的 href 属性，然后就得到了一切我们想要的了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">a.href = <span class=\"string\">'http://www.cnblogs.com/wayou/p/'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.host);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_41.png\" alt=\"\" width=\"500\"></div>\n\n<p>利用这一原理，稍微扩展一下，就得到了一个更加健壮的解析 URL 各部分的通用方法了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseURL</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a =  <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    a.href = url;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        source: url,</span><br><span class=\"line\">        protocol: a.protocol.replace(<span class=\"string\">':'</span>,<span class=\"string\">''</span>),</span><br><span class=\"line\">        host: a.hostname,</span><br><span class=\"line\">        port: a.port,</span><br><span class=\"line\">        query: a.search,</span><br><span class=\"line\">        params: (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> ret = &#123;&#125;,</span><br><span class=\"line\">                seg = a.search.replace(<span class=\"regexp\">/^\\?/</span>,<span class=\"string\">''</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">                len = seg.length, i = <span class=\"number\">0</span>, s;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;i&lt;len;i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!seg[i]) &#123; <span class=\"keyword\">continue</span>; &#125;</span><br><span class=\"line\">                s = seg[i].split(<span class=\"string\">'='</span>);</span><br><span class=\"line\">                ret[s[<span class=\"number\">0</span>]] = s[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;)(),</span><br><span class=\"line\">        file: (a.pathname.match(<span class=\"regexp\">/\\/([^\\/?#]+)$/i</span>) || [,<span class=\"string\">''</span>])[<span class=\"number\">1</span>],</span><br><span class=\"line\">        hash: a.hash.replace(<span class=\"string\">'#'</span>,<span class=\"string\">''</span>),</span><br><span class=\"line\">        path: a.pathname.replace(<span class=\"regexp\">/^([^\\/])/</span>,<span class=\"string\">'/$1'</span>),</span><br><span class=\"line\">        relative: (a.href.match(<span class=\"regexp\">/tps?:\\/\\/[^\\/]+(.+)/</span>) || [,<span class=\"string\">''</span>])[<span class=\"number\">1</span>],</span><br><span class=\"line\">        segments: a.pathname.replace(<span class=\"regexp\">/^\\//</span>,<span class=\"string\">''</span>).split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"页面拥有-ID-的元素会创建全局变量\"><a href=\"#页面拥有-ID-的元素会创建全局变量\" class=\"headerlink\" title=\"页面拥有 ID 的元素会创建全局变量\"></a>页面拥有 ID 的元素会创建全局变量</h3><p>在一张 HTML 页面中，所有设置了 ID 属性的元素会在 JavaScript 的执行环境中创建对应的全局变量，这意味着 document.getElementById 像人的阑尾一样显得多余了。但实际项目中最好老老实实该怎么写就怎么写，毕竟常规代码出乱子的机会要小得多。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sample\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(sample);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_42.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"加载-CDN-文件时，可以省掉-HTTP-标识\"><a href=\"#加载-CDN-文件时，可以省掉-HTTP-标识\" class=\"headerlink\" title=\"加载 CDN 文件时，可以省掉 HTTP 标识\"></a>加载 CDN 文件时，可以省掉 HTTP 标识</h3><p>现在很流行的 CDN 即从专门的服务器加载一些通用的 JS 和 CSS 文件，出于安全考虑有的 CDN 服务器使用 HTTPS 方式连接，而有的是传统的 HTTP，其实我们在使用时可以忽略掉这个，将它从 URL 中省去。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//domain.com/path/to/script.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"利用-script-标签保存任意信息\"><a href=\"#利用-script-标签保存任意信息\" class=\"headerlink\" title=\"利用 script 标签保存任意信息\"></a>利用 script 标签保存任意信息</h3><p>将 script 标签设置为 type=’text’ 然后可以在里面保存任意信息，之后可以在 JavaScript 代码中很方便地获取。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"template\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>This won't display<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'template'</span>).innerHTML</span><br></pre></td></tr></table></figure>\n<h2 id=\"CSS-篇\"><a href=\"#CSS-篇\" class=\"headerlink\" title=\"CSS 篇\"></a>CSS 篇</h2><h3 id=\"我的鼠标呢？\"><a href=\"#我的鼠标呢？\" class=\"headerlink\" title=\"我的鼠标呢？\"></a>我的鼠标呢？</h3><p>相信你看完以下代码后能够预料到会出现什么效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: none<span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的文字模糊效果\"><a href=\"#简单的文字模糊效果\" class=\"headerlink\" title=\"简单的文字模糊效果\"></a>简单的文字模糊效果</h3><p>以下两行简单的 CSS3 代码可达到将文字模糊化处理的目的，出来的效果有点像使用 PS 的滤镜，so cool!</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: transparent;</span><br><span class=\"line\">    <span class=\"attribute\">text-shadow</span>: <span class=\"number\">#111</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">5px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h3><p>当然你可以将容器设置为 display: table，然后将子元素也就是要垂直居中显示的元素设置为 display: table-cell，然后加上 vertical-align: middle 来实现，但此种实现往往会因为 display: table 而破坏整体布局，那还不如直接用 table 标签了呢。下面这个样式利用了 translate 来巧妙实现了垂直居中样式，需 IE9+。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.center-vertical</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比而言，水平居中要简单得多，像上面提到的 text-align: center，经常用到的技巧还有 margin: 0 auto。但对于 margin 大法也只在子元素宽度小于容器宽度时管用，当子元素宽度大于容器宽度时此法失效。如法炮制，利用 left 和 transform 同样可实现水平居中，不过意义不大，毕竟 text-align 和 margin 差不多满足需求了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.center-horizontal</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(-50%); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多重边框\"><a href=\"#多重边框\" class=\"headerlink\" title=\"多重边框\"></a>多重边框</h3><p>利用重复指定 box-shadow 来达到多个边框的效果</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* CSS Border with Box-Shadow Example */</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">6px</span> <span class=\"built_in\">rgba</span>(0, 0, 0, 0.2),</span><br><span class=\"line\">                <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">12px</span> <span class=\"built_in\">rgba</span>(0, 0, 0, 0.2),</span><br><span class=\"line\">                <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">18px</span> <span class=\"built_in\">rgba</span>(0, 0, 0, 0.2),</span><br><span class=\"line\">                <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">24px</span> <span class=\"built_in\">rgba</span>(0, 0, 0, 0.2);</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">50px</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_43.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"实时编辑-CSS\"><a href=\"#实时编辑-CSS\" class=\"headerlink\" title=\"实时编辑 CSS\"></a>实时编辑 CSS</h3><p>通过设置 style 标签的 display: block 样式可以让页面的 style 标签显示出来，并且加上 contentEditable 属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现的。此技巧在 IE 下无效。拥有此技能者，逆天也！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:block\"</span> <span class=\"attr\">contentEditable</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\">        \t<span class=\"selector-tag\">body</span> &#123; <span class=\"attribute\">color</span>: blue &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_46.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"创建长宽比固定的元素\"><a href=\"#创建长宽比固定的元素\" class=\"headerlink\" title=\"创建长宽比固定的元素\"></a>创建长宽比固定的元素</h3><p>通过设置父级窗口的 padding-bottom 可以达到让容器保持一定的长度比的目的，这在响应式页面设计中比较有用，能够保持元素不变形。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100%; position: relative; padding-bottom: 20%;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position: absolute; left: 0; top: 0; right: 0; bottom: 0;background-color:yellow;\"</span>&gt;</span></span><br><span class=\"line\">        this content will have a constant aspect ratio that varies based on the width.</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_48.gif\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"CSS-中也可以做简单运算\"><a href=\"#CSS-中也可以做简单运算\" class=\"headerlink\" title=\"CSS 中也可以做简单运算\"></a>CSS 中也可以做简单运算</h3><p>通过 CSS 中的 calc 方法可以进行一些简单的运算，从而达到动态指定元素样式的目的。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: <span class=\"built_in\">calc</span>(100% - 50px) <span class=\"built_in\">calc</span>(100% - 20px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JavaScript-篇\"><a href=\"#JavaScript-篇\" class=\"headerlink\" title=\"JavaScript 篇\"></a>JavaScript 篇</h2><h3 id=\"生成随机字符串\"><a href=\"#生成随机字符串\" class=\"headerlink\" title=\"生成随机字符串\"></a>生成随机字符串</h3><p>利用 Math.random 和 toString 生成随机字符串，来自前一阵子看到的一篇<a href=\"http://flippinawesome.org/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/\" target=\"_blank\" rel=\"noopener\">博文</a>。这里的技巧是利用了 toString 方法可以接收一个基数作为参数的原理，这个基数从 2 到 36 封顶。如果不指定，默认基数是 10 进制。略屌！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateRandomAlphaNum</span>(<span class=\"params\">len</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rdmString = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; rdmString.length &lt; len; )&#123;</span><br><span class=\"line\">        rdmString += <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substr(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rdmString.substr(<span class=\"number\">0</span>, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_44.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"整数的操作\"><a href=\"#整数的操作\" class=\"headerlink\" title=\"整数的操作\"></a>整数的操作</h3><p>JavaScript 中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。|0 和 ~~ 是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的 parseInt, Math.round 要快。在处理像素及动画位移等效果的时候会很有用。性能比较<a href=\"http://jsperf.com/math-floor-vs-math-round-vs-parseint/42\" target=\"_blank\" rel=\"noopener\">见此</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"number\">12.4</span> / <span class=\"number\">4.13</span>) | <span class=\"number\">0</span>; <span class=\"comment\">// 结果为3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = ~~(<span class=\"number\">12.4</span> / <span class=\"number\">4.13</span>); <span class=\"comment\">// 结果为3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重写原生浏览器方法以实现新功能\"><a href=\"#重写原生浏览器方法以实现新功能\" class=\"headerlink\" title=\"重写原生浏览器方法以实现新功能\"></a>重写原生浏览器方法以实现新功能</h3><p>下面的代码通过重写浏览器的 alert 让它可以记录弹窗的次数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldAlert = <span class=\"built_in\">window</span>.alert,</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.alert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">        count ++;</span><br><span class=\"line\">        oldAlert(a + <span class=\"string\">\"\\n You've called alert \"</span> + count + <span class=\"string\">\" times now. Stop, it's evil!\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">alert(<span class=\"string\">\"Hello World\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"console-显示图片以及为文字加样式\"><a href=\"#console-显示图片以及为文字加样式\" class=\"headerlink\" title=\"console 显示图片以及为文字加样式\"></a>console 显示图片以及为文字加样式</h3><p>在 Chrome 的开发者工具里，console 可以加样式，可以显示缤纷的颜色，甚至图片。简直爽翻了。具体来说，是可以对输出到 console 控制台的文字进行 CSS 控制。格式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"%c需要输出的信息 \"</span>, <span class=\"string\">\"css 代码\"</span>);</span><br></pre></td></tr></table></figure>\n<p>下面是一些已经写好的 console 新玩法代码，可以在 chrome 控制台里面实测（关于 console 的更多玩法，推荐 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Console#示例\" target=\"_blank\" rel=\"noopener\">MDN关于console的文档</a>）：</p>\n<h4 id=\"1-3D-Text\"><a href=\"#1-3D-Text\" class=\"headerlink\" title=\"1. 3D Text\"></a>1. 3D Text</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"%c3D Text\"</span>,<span class=\"string\">\" text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,</span></span><br><span class=\"line\"><span class=\"string\">0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),</span></span><br><span class=\"line\"><span class=\"string\">0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em\"</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-Colorful-CSS\"><a href=\"#2-Colorful-CSS\" class=\"headerlink\" title=\"2. Colorful CSS\"></a>2. Colorful CSS</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"%cColorful CSS\"</span>,<span class=\"string\">\"background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, </span></span><br><span class=\"line\"><span class=\"string\">color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), </span></span><br><span class=\"line\"><span class=\"string\">color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), </span></span><br><span class=\"line\"><span class=\"string\">color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));</span></span><br><span class=\"line\"><span class=\"string\">background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, </span></span><br><span class=\"line\"><span class=\"string\">rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);</span></span><br><span class=\"line\"><span class=\"string\">filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em\"</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-Rainbow-Text\"><a href=\"#3-Rainbow-Text\" class=\"headerlink\" title=\"3. Rainbow Text\"></a>3. Rainbow Text</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'%cRainbow Text '</span>, <span class=\"string\">'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), </span></span><br><span class=\"line\"><span class=\"string\">color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), </span></span><br><span class=\"line\"><span class=\"string\">color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-输出图片\"><a href=\"#4-输出图片\" class=\"headerlink\" title=\"4. 输出图片\"></a>4. 输出图片</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"%c\"</span>, <span class=\"string\">\"padding:50px 300px;line-height:120px;background:url('https://ss0.bdstatic.com/5aV1bjqh\\_Q23odCf/static/superman/img/logo/bd\\_logo1_31bdc765.png') no-repeat;\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"不声明第三个变量的值交换\"><a href=\"#不声明第三个变量的值交换\" class=\"headerlink\" title=\"不声明第三个变量的值交换\"></a>不声明第三个变量的值交换</h3><p>我们都知道交换两个变量值的常规做法，那就是声明一个中间变量来暂存。但鲜有人去挑战不声明中间变量的情况，下面的代码给出了这种实现。蛮有创意的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">a= [b, b = a][<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_49.jpg\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"万物皆对象\"><a href=\"#万物皆对象\" class=\"headerlink\" title=\"万物皆对象\"></a>万物皆对象</h3><p>在 JavaScript 的世界，万物皆对象。除了 null 和 undefined，其他基本类型数字，字符串和布尔值都有对应有包装对象。对象的一个特征是你可以在它身上直接调用方法。对于数字基本类型，当试图在其身上调用 toString 方法会失败，但用括号括起来后再调用就不会失败了，内部实现是用相应的包装对象将基本类型转为对象。所以 <strong>(1).toString()</strong> 相当于 <strong>new Number(1).toString()</strong>。因此，你的确可以把基本类型数字，字符串，布尔等当对象使用的，只是注意语法要得体。同时我们注意到，JavaScript 中数字是不分浮点和整形的，所有数字其实均是浮点类型，只是把小数点省略了而已，比如你看到的 1 可以写成 1.，这也就是为什么当你试图 1.toString() 时会报错，所以正确的写法应该是这样：<strong>1..toString()</strong>，或者如上面所述加上括号，这里括号的作用是纠正 JS 解析器，不要把 1 后面的点当成小数点。内部实现如上面所述，是将 1. 用包装对象转成对象再调用方法。</p>\n<h3 id=\"If-语句的变形\"><a href=\"#If-语句的变形\" class=\"headerlink\" title=\"If 语句的变形\"></a>If 语句的变形</h3><p>当你需要写一个 if 语句的时候，不妨尝试另一种更简便的方法，用 JavaScript 中的逻辑操作符来代替。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> day = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>).getDay() === <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//传统if语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (day) &#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'Today is Sunday!'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//运用逻辑与代替if</span></span><br><span class=\"line\">day &amp;&amp; alert(<span class=\"string\">'Today is Sunday!'</span>);</span><br></pre></td></tr></table></figure>\n<p>比如上面的代码，首先得到今天的日期，如果是星期天，则弹窗，否则什么也不做。我们知道逻辑操作存在短路的情况，对于逻辑与表达式，只有两者都真才结果才为真，如果前面的 day 变量被判断为假了，那么对于整个与表达式来说结果就是假，所以就不会继续去执行后面的 alert 了，如果前面 day 为真，则还要继续执行后面的代码来确定整个表达式的真假。利用这点达到了 if 的效果。</p>\n<h3 id=\"禁止别人以-iframe-加载你的页面\"><a href=\"#禁止别人以-iframe-加载你的页面\" class=\"headerlink\" title=\"禁止别人以 iframe 加载你的页面\"></a>禁止别人以 iframe 加载你的页面</h3><p>下面的代码已经不言自明了，没什么好多说的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.location != <span class=\"built_in\">window</span>.parent.location) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.parent.location = <span class=\"built_in\">window</span>.location;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://www.quora.com/Web-Development/What-are-the-most-interesting-HTML-JS-DOM-CSS-hacks-that-most-web-developers-dont-know-about?utm\\_source=html5weekly&amp;utm\\_medium=email\" target=\"_blank\" rel=\"noopener\">What are the most interesting HTML/JS/DOM/CSS hacks that most web developers don’t know about?</a></li>\n<li><a href=\"http://www.cnblogs.com/Wayou/p/things_you_dont_know_about_frontend.html\" target=\"_blank\" rel=\"noopener\">前端不为人知的一面–前端冷知识集锦</a></li>\n</ul>\n","raw":null,"categories":[{"name":"summary","path":"api/categories/summary.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"JS","path":"api/tags/JS.json"},{"name":"HTML","path":"api/tags/HTML.json"},{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"前端面试系列（11）——window.onload和document.ready的区别","slug":"前端面试系列（11）——window.onload和document.ready的区别","date":"2017-04-12T09:14:30.000Z","updated":"2019-07-04T08:09:14.553Z","comments":true,"path":"api/articles/前端面试系列（11）——window.onload和document.ready的区别.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_11.png","content":"<p>这个问题虽然比较简单，但是依然是前端面试中经常会问到的一道题，所以为了让自己“与众不同”，必须全面了解这两者的区别，才能从众多候选人中脱颖而出</p>\n<h2 id=\"一张表格\"><a href=\"#一张表格\" class=\"headerlink\" title=\"一张表格\"></a>一张表格</h2><p>下面这张表格简单的介绍了两者的区别：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>window.onload()</th>\n<th>$(document).ready()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>执行时机</td>\n<td>在页面所有元素（包括图片，引用文件）加载完后执行</td>\n<td>页面中所有HTML DOM，CSS DOM结构加载完之后就会执行，其他图片等内容可能没有加载完</td>\n</tr>\n<tr>\n<td>编写个数</td>\n<td>不能同时写多个，后面的将会覆盖前面的</td>\n<td>可以同时写多个</td>\n</tr>\n<tr>\n<td>简写</td>\n<td>无</td>\n<td>$().ready(function(){}) // $()不带参数默认是document；$(function(){})</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"jQ-的-document-ready-实现\"><a href=\"#jQ-的-document-ready-实现\" class=\"headerlink\" title=\"jQ 的 document.ready() 实现\"></a>jQ 的 document.ready() 实现</h2><p>在 jQuery 脚本加载的时候，会监听 DOMContentLoaded 事件。当事件触发时候，会执行 ready 事件的回调；（document.readyState === “complete” 时相当于 dom 加载完毕<br>由于用的是原生的 DOMContentLoaded 事件，所以<strong>目前的 ready 函数仅能用于当前 document，无需选择器</strong></p>\n<h2 id=\"谁更快\"><a href=\"#谁更快\" class=\"headerlink\" title=\"谁更快\"></a>谁更快</h2><p>jQuery 的 document.ready 就一定比 window.onload 快吗？下面是一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en-US\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>加载时机<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">onload</span>=<span class=\"string\">\"console.log('jquery.js loaded')\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">'define functions'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\">type, info</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"built_in\">console</span>.log(type + <span class=\"string\">' onload '</span> + (info || <span class=\"string\">\"\"</span>), <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">     $(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'document ready'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">document</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'document'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;;    </span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'window'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"load\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'window addEventListener'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">document</span>.addEventListener( <span class=\"string\">\"DOMContentLoaded\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'DOMContentLoaded'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('body')\"</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('text')\"</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('img',1)\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.deskcar.com/desktop/else/2013714232149/17.jpg\"</span> /&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('img',2)\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.deskcar.com/desktop/else/2013714232149/16.jpg\"</span> /&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('js')\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/react/15.2.0/react.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"执行之后有两种结果：\"><a href=\"#执行之后有两种结果：\" class=\"headerlink\" title=\"执行之后有两种结果：\"></a>执行之后有两种结果：</h3><h4 id=\"首次加载：\"><a href=\"#首次加载：\" class=\"headerlink\" title=\"首次加载：\"></a>首次加载：</h4><div align=\"center\"><img src=\"/images/hexo_post_11.png\" alt=\"\" width=\"400\"></div>\n\n<h4 id=\"二次加载：\"><a href=\"#二次加载：\" class=\"headerlink\" title=\"二次加载：\"></a>二次加载：</h4><div align=\"center\"><img src=\"/images/hexo_post_12.png\" alt=\"\" width=\"400\"></div>\n\n<p>第一种情况非常符合我们的想法，ready 比 onload 快，顺序也比较合理。而第二种情况就有些怪异，应该依照上面 jquery ready 事件的实现，那 ready 应该要 DOMContentLoaded 后面啊。我思来想去，我觉得这是个误会，由于二次加载时利用到缓存，导致文件资源都很快加载，各个事件触发的时间非常相近，顺序也不定，就给人一种 ready 顺序不对之感，大家应该发现这几个事件都是在几十毫秒之内触发。PS：js 执行需要时间，几十毫秒不同的顺序我觉得很正常。另外尝试几次，二次加载顺序确实会有变化，但时间都很相近。所以，jQuery 的 document ready 不一定比 window.onload 快执行。</p>\n<h2 id=\"为什么外部-script-文件放页面内容后面好？\"><a href=\"#为什么外部-script-文件放页面内容后面好？\" class=\"headerlink\" title=\"为什么外部 script 文件放页面内容后面好？\"></a>为什么外部 script 文件放页面内容后面好？</h2><h3 id=\"script-执行顺序\"><a href=\"#script-执行顺序\" class=\"headerlink\" title=\"script 执行顺序\"></a>script 执行顺序</h3><blockquote>\n<p>无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照 <code>&lt;script&gt;</code> 元素在页面中出现的先后顺序对它们依次进行解析。——《JavaScript高级程序设计》</p>\n</blockquote>\n<p>换句话说，在第一个 <code>&lt;script&gt;</code> 元素包含的代码解析完成后，第二个 <code>&lt;script&gt;</code> 包含代码才会被解析，然后才是第三个…..<br>如果在 head 元素里包含所有 JavaScript 文件，就必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能呈现页面的内容（浏览器在遇到 <code>&lt;body&gt;</code> 标签时才开始呈现内容）。在有 JavaScript 文件时候，浏览器呈现页面会出现明显的延迟，延时期间浏览器是一片空白。所以，外部 script 文件放页面内容后面。这样，在解析 JavaScript 代码之前，页面内容将完全呈现出来。</p>\n<h3 id=\"一定是放页面内容后面吗？\"><a href=\"#一定是放页面内容后面吗？\" class=\"headerlink\" title=\"一定是放页面内容后面吗？\"></a>一定是放页面内容后面吗？</h3><p>有种情况是 JavaScript 放哪里都一样的，那就是内容是依赖 JavaScript 的执行渲染时候，放哪都一样。所以我们需要尽量避免在 JS 中对 dom 进行修改，对于性能优化有比较大的帮助。</p>\n<h2 id=\"Load-方法\"><a href=\"#Load-方法\" class=\"headerlink\" title=\"Load() 方法\"></a>Load() 方法</h2><p>由于在 $(document).ready() 方法内注册的事件，只要 DOM 就绪就会被执行，因此可能此时元素的关联文件未下载完。例如与图片有关的 html 下载完毕，并且已经解析为 DOM 树了，但很有可能图片还没有加载完毕，所以例如图片的高度和宽度这样的属性此时不一定有效。要解决这个问题，可以使用 Jquery 中另一个关于页面加载的方法—— load() 方法。Load() 方法会在元素的 onload 事件中绑定一个处理函数。如果处理函数绑定给 window 对象，则会在所有内容（包括窗口、框架、对象和图像等）加载完毕后触发，如果处理函数绑定在元素上，则会在元素的内容加载完毕后触发。</p>\n<h2 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h2><ul>\n<li>$(window).load()：等价于 window.onload()</li>\n<li>$(window).unload()：页面关闭时触发</li>\n</ul>\n<h2 id=\"坑爹的-IE-or-jQ？\"><a href=\"#坑爹的-IE-or-jQ？\" class=\"headerlink\" title=\"坑爹的 IE or jQ？\"></a>坑爹的 IE or jQ？</h2><p>最近在改一个嵌入在 iframe 中的页面的时候，使用了 jquery 做效果，而页面本身也绑定了 onload 事件。改完后，Firefox 下测试正常流畅，IE 下就要等个十几秒 jquery 的效果才出现，黄花菜都凉了。起初以为是和本身 onload 加载的方法冲突。网上普遍的说法是 $(document).ready() 是在页面 DOM 解析完成后执行，而 onload 事件是在所有资源都准备完成之后才执行，也就是说 $(document).ready() 是要在 onload 之前执行的，尤其当页面图片较大较多的时候，这个时间差可能更大。可是我这页面分明是图片都显示出来十几秒了，还不见 jquery 的效果出来。 删了 onload 加载的方法试试，结果还是一样，看来没有必要把原本的 onload 事件绑定也改用 $(document).ready() 来写。那是什么原因使得 Firefox 正常而 IE 就能呢？接着调试，发现 IE 下原来绑定的 onload 方法竟然先于 $(document).ready() 的内容执行，而 Firefox 则是先执行 $(document).ready() 的内容，再执行原来的 onload 方法。这个和网上的说法似乎不完全一致啊，走投无路的时候就看看源码，翻翻 jQuery 的源码看看 $(document).ready() 是如何实现的吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( jQuery.browser.msie &amp;&amp; <span class=\"built_in\">window</span> == top ) (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">if</span> (jQuery.isReady) <span class=\"keyword\">return</span>; </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\"><span class=\"built_in\">document</span>.documentElement.doScroll(<span class=\"string\">\"left\"</span>); </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>( error ) &#123; </span><br><span class=\"line\">　　　　　　setTimeout( <span class=\"built_in\">arguments</span>.callee, <span class=\"number\">0</span> ); </span><br><span class=\"line\">　　　　　　 <span class=\"keyword\">return</span>; </span><br><span class=\"line\">　　　　&#125; </span><br><span class=\"line\">　　 <span class=\"comment\">// and execute any waiting functions </span></span><br><span class=\"line\">　　　jQuery.ready(); </span><br><span class=\"line\">&#125;)(); </span><br><span class=\"line\">jQuery.event.add( <span class=\"built_in\">window</span>, <span class=\"string\">\"load\"</span>, jQuery.ready );</span><br></pre></td></tr></table></figure>\n<p>结果很明了了，IE 只有在页面不是嵌入 iframe 中的情况下才和 Firefox 等一样，先执行 $(document).ready() 的内容，再执行原来的 onload 方法。对于嵌入 iframe 中的页面，也只是绑定在 load 事件上执行，所以自然是在原来的 onload 绑定的方法执行之后才轮到。而这个页面中正好在测试环境下有一个访问不到的资源，那十几秒的延迟正是它放大出的时间差。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.jb51.net/article/50185.htm\" target=\"_blank\" rel=\"noopener\">一张表格告诉你windows.onload()与$(document).ready()的区别</a></li>\n<li><a href=\"http://www.cnblogs.com/lovesong/p/5641834.html\" target=\"_blank\" rel=\"noopener\">jQuery的document ready与 onload事件——你真的思考过吗？</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"读书笔记系列（6）——大话数据结构","slug":"读书笔记系列（6）——大话数据结构","date":"2017-04-08T12:50:00.000Z","updated":"2019-07-04T08:09:14.557Z","comments":true,"path":"api/articles/读书笔记系列（6）——大话数据结构.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_147.png","content":"<p>这本书我是在网上下载的电子版，所以可能会有一些错别字，但是无伤大雅；《大话数据结构》被誉为程序员面试必读书籍，我大概用了 3 天的时间详读了一遍，感觉作者的文笔很好，而且很擅长通过生活中的小故事总结相关知识和算法思路，对于计算机初级童鞋来说是一本很好的数据结构入门读物，而且作者对于代码的讲解很详尽，接近逐行解释了，和其他数据结构的书籍形成了鲜明的对比，总体评价五星吧；不过我是在刷完 Leetcode 的 easy 题才看的这本书，感觉先看这本书再刷题的话会好很多</p>\n<h2 id=\"一、数据结构与算法\"><a href=\"#一、数据结构与算法\" class=\"headerlink\" title=\"一、数据结构与算法\"></a>一、数据结构与算法</h2><h3 id=\"1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\"><a href=\"#1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\" class=\"headerlink\" title=\"1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\"></a>1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子</h3><h3 id=\"2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\"><a href=\"#2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\" class=\"headerlink\" title=\"2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\"></a>2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科</h3><h3 id=\"3、数据元素的存储结构形式有两种：顺序存储和链式存储\"><a href=\"#3、数据元素的存储结构形式有两种：顺序存储和链式存储\" class=\"headerlink\" title=\"3、数据元素的存储结构形式有两种：顺序存储和链式存储\"></a>3、数据元素的存储结构形式有两种：顺序存储和链式存储</h3><ul>\n<li>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（谁也别插谁的队）</li>\n<li>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的（需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置）</li>\n</ul>\n<h3 id=\"4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\"><a href=\"#4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\" class=\"headerlink\" title=\"4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\"></a>4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性</h3><h3 id=\"5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\"><a href=\"#5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\" class=\"headerlink\" title=\"5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\"></a>5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征</h3><h3 id=\"6、推导时间复杂度大-O-阶方法：\"><a href=\"#6、推导时间复杂度大-O-阶方法：\" class=\"headerlink\" title=\"6、推导时间复杂度大 O 阶方法：\"></a>6、推导时间复杂度大 O 阶方法：</h3><ol>\n<li>用常数 1 取代运行时间中的所有加法常数</li>\n<li>在修改后的运行次数函数中，只保留最高阶项</li>\n<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>\n</ol>\n<h3 id=\"7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\"><a href=\"#7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\" class=\"headerlink\" title=\"7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\"></a>7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</h3><h3 id=\"8、常见的时间复杂度所耗费的时间：\"><a href=\"#8、常见的时间复杂度所耗费的时间：\" class=\"headerlink\" title=\"8、常见的时间复杂度所耗费的时间：\"></a>8、常见的时间复杂度所耗费的时间：</h3><div align=\"center\"><img src=\"/images/hexo_post_147.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\"><a href=\"#9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\" class=\"headerlink\" title=\"9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\"></a>9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。</h3><p>在应用中，这是一种最重要的需求，通常，除非特别制定，我们提到的运行时间都是最坏情况的运行时间 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间</p>\n<h3 id=\"10、算法的空间复杂度\"><a href=\"#10、算法的空间复杂度\" class=\"headerlink\" title=\"10、算法的空间复杂度\"></a>10、算法的空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数</p>\n<h2 id=\"二、线性表\"><a href=\"#二、线性表\" class=\"headerlink\" title=\"二、线性表\"></a>二、线性表</h2><h3 id=\"1、描述顺序存储结构需要三个属性：\"><a href=\"#1、描述顺序存储结构需要三个属性：\" class=\"headerlink\" title=\"1、描述顺序存储结构需要三个属性：\"></a>1、描述顺序存储结构需要三个属性：</h3><ul>\n<li>存储空间的起始位置：数组 data，它的存储位置就是存储空间的存储位置</li>\n<li>线性表的最大存储容量：数组长度 MaxSize</li>\n<li>线性表的当前长度：length</li>\n</ul>\n<h3 id=\"2、插入算法的思路：\"><a href=\"#2、插入算法的思路：\" class=\"headerlink\" title=\"2、插入算法的思路：\"></a>2、插入算法的思路：</h3><ol>\n<li>如果插入位置不合理，抛出异常</li>\n<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li>\n<li>从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置</li>\n<li>将要插入元素填入位置 i 处</li>\n<li>表长加 1</li>\n</ol>\n<h3 id=\"3、删除算法的思路：\"><a href=\"#3、删除算法的思路：\" class=\"headerlink\" title=\"3、删除算法的思路：\"></a>3、删除算法的思路：</h3><ol>\n<li>如果删除位置不合理，抛出异常</li>\n<li>取出删除元素</li>\n<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置</li>\n<li>表长减 1</li>\n</ol>\n<h3 id=\"4、线性表的顺序存储结构的优缺点：\"><a href=\"#4、线性表的顺序存储结构的优缺点：\" class=\"headerlink\" title=\"4、线性表的顺序存储结构的优缺点：\"></a>4、线性表的顺序存储结构的优缺点：</h3><p><strong>优点：</strong></p>\n<ul>\n<li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li>\n<li>可以快速地存取表中任一位置的元素</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>插入和删除操作需要移动大量元素</li>\n<li>当线性表长度变化较大时，难以确定存储空间的容量</li>\n<li>造成存储空间的“碎片”</li>\n</ul>\n<h3 id=\"5、单链表\"><a href=\"#5、单链表\" class=\"headerlink\" title=\"5、单链表\"></a>5、单链表</h3><p>n 个结点（ai 的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起</p>\n<div align=\"center\"><img src=\"/images/hexo_post_148.png\" alt=\"\" width=\"400\"></div>\n\n<p>有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_149.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"6、头指针与头结点的异同\"><a href=\"#6、头指针与头结点的异同\" class=\"headerlink\" title=\"6、头指针与头结点的异同\"></a>6、头指针与头结点的异同</h3><h4 id=\"头指针\"><a href=\"#头指针\" class=\"headerlink\" title=\"头指针\"></a>头指针</h4><ul>\n<li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li>\n<li>头指针具有标识作用，所以常用头指针冠以链表的名字</li>\n<li>无论链表是否为空，头指针均不为空。头指针式链表的必要元素</li>\n</ul>\n<h4 id=\"头结点\"><a href=\"#头结点\" class=\"headerlink\" title=\"头结点\"></a>头结点</h4><ul>\n<li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</li>\n<li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li>\n<li>头结点不一定是链表必须要素</li>\n</ul>\n<h3 id=\"7、获取链表第-i-个数据的算法思路\"><a href=\"#7、获取链表第-i-个数据的算法思路\" class=\"headerlink\" title=\"7、获取链表第 i 个数据的算法思路\"></a>7、获取链表第 i 个数据的算法思路</h3><ol>\n<li>声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，返回结点 p 的数据</li>\n</ol>\n<h3 id=\"8、单链表第-i-个数据插入结点的算法思路\"><a href=\"#8、单链表第-i-个数据插入结点的算法思路\" class=\"headerlink\" title=\"8、单链表第 i 个数据插入结点的算法思路\"></a>8、单链表第 i 个数据插入结点的算法思路</h3><ol>\n<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，在系统中生成一个空结点 s</li>\n<li>将数据元素 e 赋值给 s -&gt; data</li>\n<li>单链表的插入标准语句 s-&gt;next=p-&gt;next;p-&gt;next=s</li>\n<li>返回成功</li>\n</ol>\n<h3 id=\"9、单链表第-i-个数据删除结点的算法思路\"><a href=\"#9、单链表第-i-个数据删除结点的算法思路\" class=\"headerlink\" title=\"9、单链表第 i 个数据删除结点的算法思路\"></a>9、单链表第 i 个数据删除结点的算法思路</h3><ol>\n<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，\b将欲删除的结点 p -&gt; next 赋值给 q</li>\n<li>单链表的删除标准语句 p-&gt;next=q-&gt;next</li>\n<li>将 q 结点中的数据赋值给 e，作为返回</li>\n<li>释放 q 结点</li>\n<li>返回成功</li>\n</ol>\n<h3 id=\"10、单链表整表创建的算法思路\"><a href=\"#10、单链表整表创建的算法思路\" class=\"headerlink\" title=\"10、单链表整表创建的算法思路\"></a>10、单链表整表创建的算法思路</h3><ol>\n<li>声明一结点 p 和计数器变量 i</li>\n<li>初始化一空链表 L</li>\n<li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表</li>\n<li>循环：</li>\n</ol>\n<ul>\n<li>生成一新结点赋值给 p</li>\n<li>随机生成一数字赋值给 p 的数据域 p-&gt;data</li>\n<li>将 p 插入到头结点与前一新节点之间</li>\n</ul>\n<h3 id=\"11、单链表的整表删除\"><a href=\"#11、单链表的整表删除\" class=\"headerlink\" title=\"11、单链表的整表删除\"></a>11、单链表的整表删除</h3><ol>\n<li>声明一结点 p 和 q</li>\n<li>将第一个结点赋值给 p</li>\n<li>循环：</li>\n</ol>\n<ul>\n<li>将下一结点赋值给 q</li>\n<li>释放 p</li>\n<li>将 q 赋值给 p</li>\n</ul>\n<h3 id=\"12、单链表结构和顺序存储结构做对比\"><a href=\"#12、单链表结构和顺序存储结构做对比\" class=\"headerlink\" title=\"12、单链表结构和顺序存储结构做对比\"></a>12、单链表结构和顺序存储结构做对比</h3><div align=\"center\"><img src=\"/images/hexo_post_150.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"13、所谓的成功男人就是-3-岁时不尿裤子，5-岁能自己吃饭……80-岁能自己吃饭，90-岁能不尿裤子\"><a href=\"#13、所谓的成功男人就是-3-岁时不尿裤子，5-岁能自己吃饭……80-岁能自己吃饭，90-岁能不尿裤子\" class=\"headerlink\" title=\"13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子\"></a>13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子</h3><h3 id=\"14、循环链表\"><a href=\"#14、循环链表\" class=\"headerlink\" title=\"14、循环链表\"></a>14、循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）:</p>\n<div align=\"center\"><img src=\"/images/hexo_post_151.png\" alt=\"\" width=\"500\"></div>\n\n<p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断 p-&gt;next 是否为空，现在则是 <strong>p-&gt;next 不等于头结点，则循环未结束</strong></p>\n<h3 id=\"15、合并两个循环链表\"><a href=\"#15、合并两个循环链表\" class=\"headerlink\" title=\"15、合并两个循环链表\"></a>15、合并两个循环链表</h3><div align=\"center\"><img src=\"/images/hexo_post_152.png\" alt=\"\" width=\"500\"></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p=rearA-&gt;next;                   /* 保存A表的头结点，即① */</span><br><span class=\"line\">rearA-&gt;next=rearB-&gt;next-&gt;next;   /* 将本是指向B表的第一个结点（不是头结点） */</span><br><span class=\"line\">                                 /* 赋值给rearA-&gt;next，即 ②*/</span><br><span class=\"line\">rearB-&gt;next=p;                   /* 将原A表的头结点赋值给rearB-&gt;next，即③ */</span><br><span class=\"line\">free(p);                         /* 释放p */</span><br></pre></td></tr></table></figure>\n<h3 id=\"16、双向链表\"><a href=\"#16、双向链表\" class=\"headerlink\" title=\"16、双向链表\"></a>16、双向链表</h3><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域</p>\n<h3 id=\"17、双向链表的插入\"><a href=\"#17、双向链表的插入\" class=\"headerlink\" title=\"17、双向链表的插入\"></a>17、双向链表的插入</h3><p>假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间需要下面几步：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_153.png\" alt=\"\" width=\"400\"></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-&gt;prior=p;           /* 把 p 赋值给 s 的前驱，如图中① */</span><br><span class=\"line\">s-&gt;next=p-&gt;next;      /* 把 p-&gt;next 赋值给 s 的后继，如图中② */</span><br><span class=\"line\">p-&gt;next-&gt;prior=s;     /* 把 s 赋值给 p-&gt;next 的前驱，如图中③ */</span><br><span class=\"line\">p-&gt;next=s;            /* 把 s 赋值给 p 的后继，如图中④ */</span><br></pre></td></tr></table></figure>\n<h3 id=\"18、线性表的总结\"><a href=\"#18、线性表的总结\" class=\"headerlink\" title=\"18、线性表的总结\"></a>18、线性表的总结</h3><div align=\"center\"><img src=\"/images/hexo_post_154.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"三、栈与队列\"><a href=\"#三、栈与队列\" class=\"headerlink\" title=\"三、栈与队列\"></a>三、栈与队列</h2><h3 id=\"1、栈的定义\"><a href=\"#1、栈的定义\" class=\"headerlink\" title=\"1、栈的定义\"></a>1、栈的定义</h3><p>栈（stack）是限定<strong>仅在表尾进行插入和删除操作</strong>的线性表，我们把允许插入和删除的一端称为<strong>栈顶</strong>（top），另一端称为<strong>栈底</strong>（bottom），不含任何数据元素的栈称为<strong>空栈</strong></p>\n<h3 id=\"2、当栈存在一个元素时，top-等于-0，因此通常把空栈的判定条件定位-top-等于-1（索引值从-0-开始）\"><a href=\"#2、当栈存在一个元素时，top-等于-0，因此通常把空栈的判定条件定位-top-等于-1（索引值从-0-开始）\" class=\"headerlink\" title=\"2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）\"></a>2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）</h3><h3 id=\"3、用一个数组来存储两个栈\"><a href=\"#3、用一个数组来存储两个栈\" class=\"headerlink\" title=\"3、用一个数组来存储两个栈\"></a>3、用一个数组来存储两个栈</h3><div align=\"center\"><img src=\"/images/hexo_post_155.png\" alt=\"\" width=\"700\"></div>\n\n<p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 n - 1 处。这样，如果两个栈增加元素，就是两端点向中间延伸</p>\n<p><strong>两个栈见面之时，也就是两个指针之间相差 1 时，即 top1 + 1 == top2为栈满</strong></p>\n<h3 id=\"4、递归定义\"><a href=\"#4、递归定义\" class=\"headerlink\" title=\"4、递归定义\"></a>4、递归定义</h3><p>一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数；每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>\n<h3 id=\"5、队列定义\"><a href=\"#5、队列定义\" class=\"headerlink\" title=\"5、队列定义\"></a>5、队列定义</h3><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表；允许插入的一端称为队尾，允许删除的一端称为队头</p>\n<h3 id=\"6、队列的链式存储结构\"><a href=\"#6、队列的链式存储结构\" class=\"headerlink\" title=\"6、队列的链式存储结构\"></a>6、队列的链式存储结构</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；队头指针指向链队列的头结点，而队尾指针指向终端结点：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_156.png\" alt=\"\" width=\"400\"></div>\n\n<p>空队列时，front 和 rear 都指向头结点</p>\n<h3 id=\"7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\"><a href=\"#7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\" class=\"headerlink\" title=\"7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\"></a>7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列</h3><h3 id=\"8、栈和队列的存储结构\"><a href=\"#8、栈和队列的存储结构\" class=\"headerlink\" title=\"8、栈和队列的存储结构\"></a>8、栈和队列的存储结构</h3><div align=\"center\"><img src=\"/images/hexo_post_295.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"9、关于栈和队列的人生感悟\"><a href=\"#9、关于栈和队列的人生感悟\" class=\"headerlink\" title=\"9、关于栈和队列的人生感悟\"></a>9、关于栈和队列的人生感悟</h3><p>人生，就像是一个很大的栈演变。出生时你赤条条地来到人世，慢慢地长大，渐渐地变老，最终还得赤条条地离开世间。<br>人生，又仿佛是一天一天小小的栈重现。童年父母每天抱你不断地进出家门，壮年你每天奔波于家与事业之间，老年你每天独自蹒跚于养老院的门里屋前。<br>人生，更需要有进栈出栈精神的体现。在哪里跌倒，就应该在哪里爬起来。无论陷入何等困境，只要抬头能仰望蓝天，就有希望，不断进取，你就可以让出头之日重现。困难不会永远存在，强者才能勇往直前。<br>人生，其实就是一个大大的队列演变。无知童年、快乐少年，稚傲青年，成熟中年，安逸晚年。<br>人生，又是一个又一个小小的队列重现。春夏秋冬轮回年年，早中晚夜循环天天。变化的是时间，不变的是你对未来执着的信念。<br>人生，更需要有队列精神的体现。南极到北极，不过是南纬90度到北纬90度的队列，如果你中途犹豫，临时转向，也许你就只能和企鹅相伴永远。可事实上，无论哪个方向，只要你坚持到底，你都可以到达终点。</p>\n<h2 id=\"四、串（字符串）\"><a href=\"#四、串（字符串）\" class=\"headerlink\" title=\"四、串（字符串）\"></a>四、串（字符串）</h2><h3 id=\"1、一首回文诗（李禺《两相思》）\"><a href=\"#1、一首回文诗（李禺《两相思》）\" class=\"headerlink\" title=\"1、一首回文诗（李禺《两相思》）\"></a>1、一首回文诗（李禺《两相思》）</h3><blockquote>\n<p>枯眼望遥山隔水，<br>往来曾见几心知？<br>壶空怕酌一杯酒，<br>笔下难成和韵诗。<br>途路阻人离别久，<br>讯音无雁寄回迟。<br>孤灯夜守长寥寂，<br>夫忆妻兮父忆儿。</p>\n</blockquote>\n<p>更多回文诗可以<a href=\"http://baike.baidu.com/link?url=VNTgFjBN0q2gekPkKqes9MWMtdOqf8_THZ-MuEh3vJTBKi88oJmvcrHNAkswt_oKY5pR58CL8C0CPKEHFfLFQpb6ZOQPU3W4G-P9z9gv6P2D4cO1CxwgyrBQNUg3fGfu\" target=\"_blank\" rel=\"noopener\">戳我一下</a></p>\n<h3 id=\"2、英语单词中的字符串\"><a href=\"#2、英语单词中的字符串\" class=\"headerlink\" title=\"2、英语单词中的字符串\"></a>2、英语单词中的字符串</h3><p>即使是 lover 也有个 over，即使是 friend 也有个 end，即使是 believe 也有个lie</p>\n<h3 id=\"3、关于字符串的一些概念\"><a href=\"#3、关于字符串的一些概念\" class=\"headerlink\" title=\"3、关于字符串的一些概念\"></a>3、关于字符串的一些概念</h3><p><strong>空格串</strong>：是只包含空格的串，空格串是有内容有长度的，而且可以不止一个空格<br>子串与主串：串中任意个数的连续字符组成的子序列称为该串的<strong>子串</strong>，相应地，包含子串的串称为<strong>主串</strong><br><strong>子串在主串中的位置</strong>：就是子串的第一个字符在主串中的序号</p>\n<h3 id=\"4、Unicode-和-ASCII-编码\"><a href=\"#4、Unicode-和-ASCII-编码\" class=\"headerlink\" title=\"4、Unicode 和 ASCII 编码\"></a>4、Unicode 和 ASCII 编码</h3><p>\b计算机中的常用字符是使用标准的 ASCII 编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展 ASCII 码由 8 位二进制数表示一个字符，总共可以表示 256 个字符；可是换做全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了 Unicode 编码，比较常用的是由 16 位的二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和 ASCII 码兼容，Unicode 的前 256 个字符与 ASCII 码完全相同</p>\n<h3 id=\"5、两个字符串的比较\"><a href=\"#5、两个字符串的比较\" class=\"headerlink\" title=\"5、两个字符串的比较\"></a>5、两个字符串的比较</h3><p>给定两个串：s=”a1a2……an”，t=”b1b2……bm”，当满足以下条件之一时，s &lt; t</p>\n<ul>\n<li>n &lt; m，且 ai=bi（i=1，2，……n），例如当 s=”hap”，t=”happy”，就有 s &lt; t。因为 t 比 s 多出了两个字母</li>\n<li>存在某个 k ≤ min(m,n)，使得 ai = bi（i=1，2，……，,k-1），ak &lt; bk，例如当 s=”happen”，t=”happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母（k 值），字母 e 的 ASCII 码是 101，而字母 y 的 ASCII 码是 121，显然 e &lt; y，所以 s &lt; t</li>\n</ul>\n<h2 id=\"五、树\"><a href=\"#五、树\" class=\"headerlink\" title=\"五、树\"></a>五、树</h2><h3 id=\"1、一些概念\"><a href=\"#1、一些概念\" class=\"headerlink\" title=\"1、一些概念\"></a>1、一些概念</h3><ul>\n<li>结点拥有的子树数称为结点的度（Degree）；</li>\n<li>度为 0 的结点称为叶节点（Leaf）或终端结点；</li>\n<li>度不为 0 的结点称为非终端结点或分支结点；</li>\n<li>除根结点之外，分支结点也成为内部结点树的度是树内各结点的度的最大值</li>\n<li>树中结点的最大层次称为树的深度（Depth）或高度</li>\n</ul>\n<h3 id=\"2、线性表与树的结构\"><a href=\"#2、线性表与树的结构\" class=\"headerlink\" title=\"2、线性表与树的结构\"></a>2、线性表与树的结构</h3><div align=\"center\"><img src=\"/images/hexo_post_158.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"3、双亲表示法\"><a href=\"#3、双亲表示法\" class=\"headerlink\" title=\"3、双亲表示法\"></a>3、双亲表示法</h3><p>以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置；由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_159.png\" alt=\"\" width=\"300\"></div>\n\n<p>这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，知道 parent 为 -1 时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，需要遍历整个结构。</p>\n<h3 id=\"4、多重链表表示法\"><a href=\"#4、多重链表表示法\" class=\"headerlink\" title=\"4、多重链表表示法\"></a>4、多重链表表示法</h3><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法；不过，树的每个结点的度，也就是孩子个数是不同的，所以可以设计两种方案来解决：</p>\n<h4 id=\"方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\"><a href=\"#方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\" class=\"headerlink\" title=\"方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\"></a>方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）</h4><div align=\"center\"><img src=\"/images/hexo_post_160.png\" alt=\"\" width=\"500\"></div>\n\n<p>其中 data 是数据域，child1 到 childd 是指针域，用来指向该结点的孩子结点，这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的</p>\n<h4 id=\"方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\"><a href=\"#方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\" class=\"headerlink\" title=\"方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\"></a>方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数</h4><div align=\"center\"><img src=\"/images/hexo_post_296.png\" alt=\"\" width=\"500\"></div>\n\n<p>这种方法提升了空间利用率，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗</p>\n<h3 id=\"5、孩子表示法\"><a href=\"#5、孩子表示法\" class=\"headerlink\" title=\"5、孩子表示法\"></a>5、孩子表示法</h3><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_162.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"6、双亲孩子表示法\"><a href=\"#6、双亲孩子表示法\" class=\"headerlink\" title=\"6、双亲孩子表示法\"></a>6、双亲孩子表示法</h3><div align=\"center\"><img src=\"/images/hexo_post_163.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"7、孩子兄弟表示法\"><a href=\"#7、孩子兄弟表示法\" class=\"headerlink\" title=\"7、孩子兄弟表示法\"></a>7、孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_164.png\" alt=\"\" width=\"300\"></div>\n\n<p>data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址，这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树</p>\n<h3 id=\"8、二叉树特点\"><a href=\"#8、二叉树特点\" class=\"headerlink\" title=\"8、二叉树特点\"></a>8、二叉树特点</h3><ul>\n<li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点（没有子树或者有一棵子树都是可以的）</li>\n<li>左子树和右子树是有顺序的，次序不能任意颠倒</li>\n<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</li>\n</ul>\n<h3 id=\"9、二叉树五种基本形态\"><a href=\"#9、二叉树五种基本形态\" class=\"headerlink\" title=\"9、二叉树五种基本形态\"></a>9、二叉树五种基本形态</h3><ol>\n<li>空二叉树</li>\n<li>只有一个根结点</li>\n<li>根结点只有左子树</li>\n<li>根结点只有右子树</li>\n<li>根结点既有左子树又有右子树</li>\n</ol>\n<h3 id=\"10、特殊二叉树\"><a href=\"#10、特殊二叉树\" class=\"headerlink\" title=\"10、特殊二叉树\"></a>10、特殊二叉树</h3><h4 id=\"斜树\"><a href=\"#斜树\" class=\"headerlink\" title=\"斜树\"></a>斜树</h4><p>所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树，这两者统称为斜树</p>\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</p>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_165.png\" alt=\"\" width=\"400\"></div>\n\n<p><strong>完全二叉树的特点：</strong></p>\n<ul>\n<li>叶子结点只能出现在最下两层</li>\n<li>最下层的叶子一定集中在左部连续位置</li>\n<li>倒数二层，若有叶子结点，一定都在右部连续位置</li>\n<li>如果结点度为 1，则该节点只有左孩子，即不存在只有右子树的情况</li>\n<li>同样结点数的二叉树，完全二叉树的深度最小</li>\n</ul>\n<h3 id=\"11、二叉树的性质\"><a href=\"#11、二叉树的性质\" class=\"headerlink\" title=\"11、二叉树的性质\"></a>11、二叉树的性质</h3><ol>\n<li>在二叉树的第 i 层上至多有 <strong>2i-1</strong> 个结点（i ≥ 1）</li>\n<li>深度为 k 的二叉树至多有 <strong>2k-1</strong> 个结点（k ≥ 1）</li>\n<li>对任何一棵二叉树 T，如果其终端结点数为 <strong>n0</strong>，度为 2 的节点数为 <strong>n2</strong>，则 <strong>n0 = n2 + 1</strong>（解释见下图）</li>\n<li>具有 n 个结点的完全二叉树的深度为 <strong>⌊log2n⌋ + 1</strong>（⌊x⌋ 表示不大于 x 的最大整数）</li>\n<li>如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log2n⌋+1）的结点按层序编号（从第 1 层到第 ⌊log2n⌋ + 1 层，每层从左到右），对任一结点 i（1≤i≤n）有：</li>\n</ol>\n<ul>\n<li>如果 i = 1，则结点i是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 ⌊i / 2⌋</li>\n<li>如果 2i &gt; n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左结点是结点 2i</li>\n<li>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_166.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"12、二叉链表\"><a href=\"#12、二叉链表\" class=\"headerlink\" title=\"12、二叉链表\"></a>12、二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_167.png\" alt=\"\" width=\"300\"></div>\n\n<p>其中 data 是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针</p>\n<h3 id=\"13、二叉树遍历方法\"><a href=\"#13、二叉树遍历方法\" class=\"headerlink\" title=\"13、二叉树遍历方法\"></a>13、二叉树遍历方法</h3><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树，遍历的顺序为：ABDGHCEIF</p>\n<div align=\"center\"><img src=\"/images/hexo_post_168.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树，遍历的顺序为：GDHBAEICF</p>\n<div align=\"center\"><img src=\"/images/hexo_post_169.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点，遍历的顺序为：GHDBIEFCA</p>\n<div align=\"center\"><img src=\"/images/hexo_post_170.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><p>若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序堆结点逐个访问，遍历的顺序为：ABCDEFGHI</p>\n<div align=\"center\"><img src=\"/images/hexo_post_171.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"14、两个二叉树遍历的性质\"><a href=\"#14、两个二叉树遍历的性质\" class=\"headerlink\" title=\"14、两个二叉树遍历的性质\"></a>14、两个二叉树遍历的性质</h3><ul>\n<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>\n<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>\n<li>但是已知前序和后序遍历，是不能确定一棵二叉树的</li>\n</ul>\n<h3 id=\"15、线索二叉树\"><a href=\"#15、线索二叉树\" class=\"headerlink\" title=\"15、线索二叉树\"></a>15、线索二叉树</h3><p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树</p>\n<div align=\"center\"><img src=\"/images/hexo_post_172.png\" alt=\"\" width=\"500\"></div>\n\n<p>通过上图（空心箭头实线为前驱，虚线黑箭头为后继），可以看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表；所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化；但是，我们并不知道某一结点的 lchild 是指向它的左孩子还是指向前驱，所以需要一个区分标致；因此，我们在每个结点再增设两个标志域 ltag 和 rtag，这两个 tag 只是存放 0 或 1 数字的布尔型变量，其占用的内存空间要小于像 lchild 和 rchild 的指针变量，结点结构如下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_173.png\" alt=\"\" width=\"400\"></div>\n\n<ul>\n<li>ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱</li>\n<li>rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_174.png\" alt=\"\" width=\"500\"></div>\n\n<p><strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong></p>\n<h3 id=\"16、树转换为二叉树\"><a href=\"#16、树转换为二叉树\" class=\"headerlink\" title=\"16、树转换为二叉树\"></a>16、树转换为二叉树</h3><ol>\n<li>加线，在所有兄弟结点之间加一条连线</li>\n<li>去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>\n<li>层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_175.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"17、森林转换为二叉树\"><a href=\"#17、森林转换为二叉树\" class=\"headerlink\" title=\"17、森林转换为二叉树\"></a>17、森林转换为二叉树</h3><ol>\n<li>把每个树转换为二叉树</li>\n<li>第一棵二叉树不动，从第二棵二叉树开始，以此把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来，当所有的二叉树连接起来后就得到了由森林转换来的二叉树</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_176.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"18、二叉树转换为树\"><a href=\"#18、二叉树转换为树\" class=\"headerlink\" title=\"18、二叉树转换为树\"></a>18、二叉树转换为树</h3><ol>\n<li>加线，若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接起来</li>\n<li>去线，删除原二叉树中所有结点与其右孩子结点的连线</li>\n<li>层次调整，使之结构层次分明</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_177.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"19、二叉树转换为森林\"><a href=\"#19、二叉树转换为森林\" class=\"headerlink\" title=\"19、二叉树转换为森林\"></a>19、二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树</p>\n<ol>\n<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树</li>\n<li>再将每棵分离后的二叉树转换为树即可</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_178.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"20、树的遍历\"><a href=\"#20、树的遍历\" class=\"headerlink\" title=\"20、树的遍历\"></a>20、树的遍历</h3><ol>\n<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树</li>\n<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li>\n</ol>\n<h3 id=\"21、森林的遍历\"><a href=\"#21、森林的遍历\" class=\"headerlink\" title=\"21、森林的遍历\"></a>21、森林的遍历</h3><ol>\n<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先跟遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林</li>\n<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林</li>\n</ol>\n<p><strong>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树中的中序遍历结果相同</strong></p>\n<h3 id=\"22、赫夫曼树算法描述\"><a href=\"#22、赫夫曼树算法描述\" class=\"headerlink\" title=\"22、赫夫曼树算法描述\"></a>22、赫夫曼树算法描述</h3><ol>\n<li>根据给定的n个权值 {w1，w2，···wn} 构成 n 棵二叉树的集合 F={T1，T2，···Tn}，其中每个二叉树 Ti 中只有一个带权为 wi 的根结点，其左右子树均为空。</li>\n<li>在 F 中选择两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。</li>\n<li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li>\n<li>重复 2 和 3，直到 F 只含一棵树为止。这棵树便是赫夫曼树。</li>\n</ol>\n<h3 id=\"23、赫夫曼编码\"><a href=\"#23、赫夫曼编码\" class=\"headerlink\" title=\"23、赫夫曼编码\"></a>23、赫夫曼编码</h3><p>一般地，设需要编码的字符集为 {d1，d2，···dn}，各个字符在电文中出现的次数或频率集合为 {w1，w2，···wn}，以 d1，d2，···dn 作为叶子结点，以 w1，w2，···wn 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码</p>\n<h2 id=\"六、图\"><a href=\"#六、图\" class=\"headerlink\" title=\"六、图\"></a>六、图</h2><h3 id=\"1、图的定义\"><a href=\"#1、图的定义\" class=\"headerlink\" title=\"1、图的定义\"></a>1、图的定义</h3><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合</p>\n<h3 id=\"2、关于图的一些定义\"><a href=\"#2、关于图的一些定义\" class=\"headerlink\" title=\"2、关于图的一些定义\"></a>2、关于图的一些定义</h3><ul>\n<li><strong>无向边</strong>：若顶点 vi 到 vj 之间的边没有方向，则称这条边为无向边（Edge），用无需偶对（vi，vj）来表示</li>\n<li><p><strong>有向边</strong>：若从顶点 vi 到 vj 的边有方向，则称这条边为有向边，也成为弧（Arc）<br><strong>无向边用小括号 “()” 表示，而有向边则是用尖括号 “&lt;&gt;” 表示</strong></p>\n</li>\n<li><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为<strong>简单图</strong></p>\n</li>\n<li>在无向图中，如果任意两个顶点之间都存在边，则称该图为<strong>无向完全图</strong></li>\n<li>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为<strong>有向完全图</strong></li>\n<li>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong></li>\n<li>这里稀疏和稠密是模糊的概念，是相对而言的 有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做<strong>权</strong>（Weight）</li>\n<li>带权的图通常称为<strong>网</strong>（Network）</li>\n<li>假设有两个图 G =（V，{E}）和G’ =（V’，{E’}），如果 V’ ⊆ V 且 E’ ⊆ E，则称 G’ 为 G 的<strong>子图</strong>（Subgraph）</li>\n<li>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。</li>\n<li>若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。</li>\n<li>图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量 无向图中连通且n个顶点n-1条边叫生成树。</li>\n<li>有向图中一顶点入度为0其余顶点入度为1的叫有向树。</li>\n<li>一个有向图由若干棵有向树构成生成森林</li>\n</ul>\n<blockquote>\n<p>由于定义实在太多，就不再叙述了，可以<a href=\"http://blog.csdn.net/luoweifu/article/details/9270439\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看关于图的其他定义</p>\n</blockquote>\n<h3 id=\"3、图的邻接矩阵\"><a href=\"#3、图的邻接矩阵\" class=\"headerlink\" title=\"3、图的邻接矩阵\"></a>3、图的邻接矩阵</h3><p>图的邻接矩阵（Adiacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息 n 个顶点和 e 条边的无向网图的创建，时间复杂度为 O（n+n2+e），其中对邻接矩阵的初始化需要耗费 O（n2）的时间</p>\n<h3 id=\"4、邻接表\"><a href=\"#4、邻接表\" class=\"headerlink\" title=\"4、邻接表\"></a>4、邻接表</h3><p>数组与链表相结合的存储方法称为邻接表 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息 图中每个顶点 vi 的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点 vi 的边表，有向图则称为顶点 vi 作为弧尾的出边表</p>\n<div align=\"center\"><img src=\"/images/hexo_post_179.png\" alt=\"\" width=\"600\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_180.png\" alt=\"\" width=\"600\"></div>\n\n<p>若是有向图，邻接表结构是类似的，但我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度，但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立<strong>一个有向图的逆邻接表，即对每个顶点 vi 都建立一个链接为 vi 为弧头的表</strong> 对于带权值的网图，可以在边表结点定义中再<strong>增加一个 weight 的数据域</strong>，存储权值信息即可</p>\n<h3 id=\"5、图的遍历\"><a href=\"#5、图的遍历\" class=\"headerlink\" title=\"5、图的遍历\"></a>5、图的遍历</h3><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）</p>\n<h3 id=\"6、深度优先遍历（DFS）\"><a href=\"#6、深度优先遍历（DFS）\" class=\"headerlink\" title=\"6、深度优先遍历（DFS）\"></a>6、深度优先遍历（DFS）</h3><p>从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止</p>\n<h3 id=\"7、广度优先遍历（BFS）\"><a href=\"#7、广度优先遍历（BFS）\" class=\"headerlink\" title=\"7、广度优先遍历（BFS）\"></a>7、广度优先遍历（BFS）</h3><p>如果说<strong>图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历</strong>了，如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_181.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"8、图的两种遍历方式的比较\"><a href=\"#8、图的两种遍历方式的比较\" class=\"headerlink\" title=\"8、图的两种遍历方式的比较\"></a>8、图的两种遍历方式的比较</h3><p>两者在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同，可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过，深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>\n<h3 id=\"9、最小生成树\"><a href=\"#9、最小生成树\" class=\"headerlink\" title=\"9、最小生成树\"></a>9、最小生成树</h3><p>我们把构造连通网的最小代价生成树称为<strong>最小生成树</strong>（Minimum Cost Spanning Tree）<br>找连通网的最小生成树，经典的有两种算法，<strong>普利姆算法</strong>和<strong>克鲁斯卡尔算法</strong></p>\n<h3 id=\"10、普利姆（Prim）算法\"><a href=\"#10、普利姆（Prim）算法\" class=\"headerlink\" title=\"10、普利姆（Prim）算法\"></a>10、普利姆（Prim）算法</h3><h4 id=\"算法思路：\"><a href=\"#算法思路：\" class=\"headerlink\" title=\"算法思路：\"></a>算法思路：</h4><p>以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</p>\n<h4 id=\"算法步骤：\"><a href=\"#算法步骤：\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><ol>\n<li>输入：一个加权连通图，其中顶点集合为 V，边集合为 E；</li>\n<li>初始化：Vnew = {x}，其中 x 为集合 V 中的任一节点（起始点），Enew = {}，为空；</li>\n<li>重复下列操作，直到 Vnew = V：</li>\n</ol>\n<ul>\n<li>在集合 E 中选取权值最小的边 <code>&lt;u, v&gt;</code>，其中 u 为集合 Vnew 中的元素，而 v 不在 <code>Vnew</code> 集合当中，并且 v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</li>\n<li>将 v 加入集合 Vnew 中，将 <code>&lt;u, v&gt;</code> 边加入集合 Enew 中；</li>\n</ul>\n<ol start=\"4\">\n<li>输出：使用集合 Vnew 和 Enew 来描述所得到的最小生成树。</li>\n</ol>\n<p>书中有非常详尽的解释，但是感觉解释的比较繁琐，建议去看一下<a href=\"http://baike.baidu.com/link?url=9SZQiA3Zm97fe1rIVtGuUCX0FszUTNnk2Qv5XwbPNZpFvjKgRfCL5PnqfPrEo2RdJQo1Asw2bdQx4RujLJL78X8AbfsvN6TUbVKl7w8a2CNQEADeXcqZydK4wrEmYFXybxEKUnpa83ksvSxsJS-zSbyMgjt-9r5Zx3aMquBsMJ26Qj_m2irhgVvsJsxw0QB8\" target=\"_blank\" rel=\"noopener\">百度百科</a>中的讲解</p>\n<h3 id=\"11、克鲁斯卡尔（Kruskal）算法\"><a href=\"#11、克鲁斯卡尔（Kruskal）算法\" class=\"headerlink\" title=\"11、克鲁斯卡尔（Kruskal）算法\"></a>11、克鲁斯卡尔（Kruskal）算法</h3><h4 id=\"算法思路：-1\"><a href=\"#算法思路：-1\" class=\"headerlink\" title=\"算法思路：\"></a>算法思路：</h4><p>因为权值是在边上，所以直接去找最小权值的边来构建生成树，只不过构建时要考虑是否会形成环路而已</p>\n<h4 id=\"算法步骤：-1\"><a href=\"#算法步骤：-1\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><p>先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。关于这个算法，百度百科上的讲解就不是很清楚了，如果感兴趣的话可以自行查阅其他资料</p>\n<h3 id=\"12、Prim-算法和-Kruskal-算法的对比\"><a href=\"#12、Prim-算法和-Kruskal-算法的对比\" class=\"headerlink\" title=\"12、Prim 算法和 Kruskal 算法的对比\"></a>12、Prim 算法和 Kruskal 算法的对比</h3><p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以堆于稀疏图有很大的优势；而普利姆算法对于稠密图，即边数非常多的情况会更好一些</p>\n<h3 id=\"13、最短路径\"><a href=\"#13、最短路径\" class=\"headerlink\" title=\"13、最短路径\"></a>13、最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点 主要有两种求最短路径的算法：迪杰斯特拉算法和</p>\n<h3 id=\"14、迪杰斯特拉（Dijkstra）算法\"><a href=\"#14、迪杰斯特拉（Dijkstra）算法\" class=\"headerlink\" title=\"14、迪杰斯特拉（Dijkstra）算法\"></a>14、迪杰斯特拉（Dijkstra）算法</h3><h4 id=\"算法步骤：-2\"><a href=\"#算法步骤：-2\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><p>G = {V,E}</p>\n<ol>\n<li>初始时令 S = {V0}, T = V - S = {其余顶点}，T 中顶点对应的距离值</li>\n</ol>\n<p>若存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 &lt;V0,Vi&gt; 弧上的权值</p>\n<p>若不存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 ∞</p>\n<ol start=\"2\">\n<li><p>从 T 中选取一个与 S 中顶点有关联边且权值最小的顶点 W，加入到 S 中</p>\n</li>\n<li><p>对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值</p>\n</li>\n</ol>\n<p>重复上述步骤 2、3，直到 S 中包含所有顶点，即 W = Vi 为止</p>\n<h3 id=\"15、弗洛伊德（Floyd）算法\"><a href=\"#15、弗洛伊德（Floyd）算法\" class=\"headerlink\" title=\"15、弗洛伊德（Floyd）算法\"></a>15、弗洛伊德（Floyd）算法</h3><h4 id=\"算法步骤：-3\"><a href=\"#算法步骤：-3\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><ol>\n<li><p>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</p>\n</li>\n<li><p>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</p>\n</li>\n</ol>\n<p>把图用邻接矩阵 G 表示出来，如果从 Vi 到 Vj 有路可达，则 G[i][j] = d，d 表示该路的长度；否则 G[i][j] = 无穷大。定义一个矩阵D用来记录所插入点的信息，D[i][j] 表示从 Vi 到 Vj 需要经过的点，初始化 D[i][j] = j。把各个顶点插入图中，比较插点后的距离与原来的距离，G[i][j] = min( G[i][j], G[i][k]+G[k][j])，如果 G[i][j] 的值变小，则 D[i][j] = k。在 G 中包含有两点之间最短道路的信息，而在 D 中则包含了最短通路径的信息。</p>\n<p>比如，要寻找从 V5 到 V1 的路径。根据 D，假如 D(5,1) = 3 则说明从 V5 到 V1 经过 V3，路径为 {V5,V3,V1}，如果 D(5,3)=3，说明 V5 与 V3 直接相连，如果 D(3,1) = 1，说明 V3 与 V1 直接相连。</p>\n<h3 id=\"16、拓扑排序\"><a href=\"#16、拓扑排序\" class=\"headerlink\" title=\"16、拓扑排序\"></a>16、拓扑排序</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 <strong>AOV 网</strong>（Activity On Vertex Network）<br><strong>拓扑序列</strong>：设 G = (V,E)是一个具有 n 个顶点的有向图，V 中的顶点序列 V1，V2，……，Vn，满足若从顶点 Vi 到 Vj 有一条路径，则在顶点序列中顶点 Vi 必在顶点 Vj 之前。则我们称这样的顶点序列为一个<strong>拓扑序列</strong><br><strong>拓扑排序</strong>：其实就是对一个有向图构造拓扑序列的过程；构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的 AOV 网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是 AOV 网。</p>\n<h3 id=\"17、拓扑排序算法\"><a href=\"#17、拓扑排序算法\" class=\"headerlink\" title=\"17、拓扑排序算法\"></a>17、拓扑排序算法</h3><p><strong>对 AOV 网进行拓扑排序的基本思路</strong>是：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止</p>\n<h3 id=\"18、关键路径\"><a href=\"#18、关键路径\" class=\"headerlink\" title=\"18、关键路径\"></a>18、关键路径</h3><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为 <strong>AOE 网</strong>（Activity On Edge Network）；我们把 AOE 网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点；正常情况下，AOE 网只有一个源点一个汇点，我们把路径上各个活动所持续的时间之和称为<strong>路径长度</strong>，从源点到汇点具有最大长度的路径叫<strong>关键路径</strong>，在关键路径上的活动叫<strong>关键活动</strong></p>\n<h3 id=\"19、关键路径算法\"><a href=\"#19、关键路径算法\" class=\"headerlink\" title=\"19、关键路径算法\"></a>19、关键路径算法</h3><p>原理：我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。为此，我们需要定义如下几个参数：</p>\n<ol>\n<li>事件的<strong>最早发生时间etv</strong>（earliest time of vertex）：即顶点 Vk 的最早发生时间</li>\n<li>事件的<strong>最晚发生时间ltv</strong>（latest time of vertex）：即顶点 Vk 的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期</li>\n<li>活动的<strong>最早开工时间ete</strong>（earliest time of edge）：即弧 ak 的最早发生时间</li>\n<li>活动的<strong>最晚开工时间lte</strong>（latest time of edge）：即弧 ak 的最晚发生时间，也就是不推迟工期的最晚开工时间</li>\n</ol>\n<p>我们是由 1 和 2 可以求得 3 和 4，然后再根据 ete[k] 是否与 lte[k] 相等来判断 ak 是否是关键活动</p>\n<h3 id=\"20、世界上最遥远的距离……\"><a href=\"#20、世界上最遥远的距离……\" class=\"headerlink\" title=\"20、世界上最遥远的距离……\"></a>20、世界上最遥远的距离……</h3><blockquote>\n<p>世界上最遥远的距离，不是从南极到北极，而是我在讲解算法为何如此精妙，你却能够安详在课堂上休息。<br>世界上最遥远的距离，不是珠峰与马里亚纳海沟的距离，而是我欲把古人的智慧全盘给你，你却不屑一顾毫不怜惜。<br>世界上最遥远的距离，不是牛 A 与牛 C 之间狭小空隙，而是你们当中，有人在通往牛逼的路上一路狂奔，而有人步入大学校园就学会放弃。</p>\n</blockquote>\n<h3 id=\"七、查找\"><a href=\"#七、查找\" class=\"headerlink\" title=\"七、查找\"></a>七、查找</h3><h4 id=\"1、查找概论\"><a href=\"#1、查找概论\" class=\"headerlink\" title=\"1、查找概论\"></a>1、查找概论</h4><ul>\n<li><strong>查找表</strong>（Search Table）是由同一类型的数据元素（或记录）构成的集合</li>\n<li><strong>关键字</strong>（Key）是数据元素中某个数据项的值，又称为<strong>键值</strong></li>\n<li>若此关键字可以唯一地标识一个记录，则称此关键字为<strong>主关键字</strong>（Primary Key）</li>\n<li>那些可以识别多个数据元素（或记录）的关键字，我们称为<strong>次关键字</strong>（Secondary Key）</li>\n<li><strong>查找</strong>（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值得数据元素（或记录）</li>\n</ul>\n<h4 id=\"2、查找表操作方式\"><a href=\"#2、查找表操作方式\" class=\"headerlink\" title=\"2、查找表操作方式\"></a>2、查找表操作方式</h4><p>分为两大种：静态查找表和动态查找表 <strong>静态查找表</strong>（Static Search Table）：只作查找操作的查找表。它的主要操作有：</p>\n<ul>\n<li>查询某个“特定的”数据元素是否在查找表中</li>\n<li>检索某个“特定的”数据元素和各种属性</li>\n</ul>\n<p><strong>动态查找表</strong>（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：</p>\n<ul>\n<li>查找时插入数据元素</li>\n<li>查找时删除数据元素</li>\n</ul>\n<h4 id=\"3、顺序查找\"><a href=\"#3、顺序查找\" class=\"headerlink\" title=\"3、顺序查找\"></a>3、顺序查找</h4><p>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是： 从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</p>\n<h3 id=\"4、二分查找\"><a href=\"#4、二分查找\" class=\"headerlink\" title=\"4、二分查找\"></a>4、二分查找</h3><p>折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是： 在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</p>\n<h4 id=\"5、插值查找\"><a href=\"#5、插值查找\" class=\"headerlink\" title=\"5、插值查找\"></a>5、插值查找</h4><p>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])，对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多</p>\n<h3 id=\"6、斐波那契查找算法\"><a href=\"#6、斐波那契查找算法\" class=\"headerlink\" title=\"6、斐波那契查找算法\"></a>6、斐波那契查找算法</h3><h4 id=\"算法核心：\"><a href=\"#算法核心：\" class=\"headerlink\" title=\"算法核心：\"></a>算法核心：</h4><ol>\n<li>当 key = a[mid] 时，查找就成功</li>\n<li>当 key &lt; a[mid] 时，新范围是第 low 个到第 mid - 1 个，此时范围个数为 F[k-1] - 1 个</li>\n<li>当 key &gt; a[mid] 时，新范围是第 m + 1 个到第 high 个，此时范围个数为 F[k-2] - 1 个</li>\n</ol>\n<h3 id=\"7、三种查找算法的比较\"><a href=\"#7、三种查找算法的比较\" class=\"headerlink\" title=\"7、三种查找算法的比较\"></a>7、三种查找算法的比较</h3><p>折半查找是进行加法与除法运算 (mid = (low + high) / 2)，插值查找进行复杂的四则运算(mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]))，而斐波那契查找只是最简单加减法运算(mid = low + F[k-1] - 1)，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率</p>\n<h3 id=\"8、线性索引\"><a href=\"#8、线性索引\" class=\"headerlink\" title=\"8、线性索引\"></a>8、线性索引</h3><p><strong>索引</strong>就是把一个关键字与它对应的记录相关联的过程 所谓<strong>线性索引</strong>就是将索引项集合组织为线性结构，也称为<strong>索引表</strong> 三种线性索引：稠密索引、分块索引和倒排索引</p>\n<h3 id=\"9、稠密索引\"><a href=\"#9、稠密索引\" class=\"headerlink\" title=\"9、稠密索引\"></a>9、稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</p>\n<div align=\"center\"><img src=\"/images/hexo_post_182.png\" alt=\"\" width=\"400\"></div>\n\n<p>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列 索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率</p>\n<h3 id=\"10、分块索引\"><a href=\"#10、分块索引\" class=\"headerlink\" title=\"10、分块索引\"></a>10、分块索引</h3><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p>\n<ul>\n<li><strong>块内无序</strong>：当然如果能够让块内有序对查找来说更理想</li>\n<li><strong>块间有序</strong>：只有块间有序，才有可能在查找时带来效率</li>\n</ul>\n<h4 id=\"分块索引的索引项结构分三个数据项：\"><a href=\"#分块索引的索引项结构分三个数据项：\" class=\"headerlink\" title=\"分块索引的索引项结构分三个数据项：\"></a>分块索引的索引项结构分三个数据项：</h4><ul>\n<li><strong>最大关键码</strong>，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>\n<li>存储了<strong>块中的记录个数</strong>，以便于循环时使用</li>\n<li>用于<strong>指向块首数据元素的指针</strong>，便于开始对这一块中记录进行遍历</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_183.png\" alt=\"\" width=\"400\"></div>\n\n<h4 id=\"分块索引表中查找的步骤：\"><a href=\"#分块索引表中查找的步骤：\" class=\"headerlink\" title=\"分块索引表中查找的步骤：\"></a>分块索引表中查找的步骤：</h4><ol>\n<li>在分块索引表中查找要查关键字所在的块，可以利用折半、插值等算法</li>\n<li>根据块首指针找到响应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找</li>\n</ol>\n<h3 id=\"11、倒排索引\"><a href=\"#11、倒排索引\" class=\"headerlink\" title=\"11、倒排索引\"></a>11、倒排索引</h3><p>记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index） 倒排索引的优点就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长</p>\n<h3 id=\"12、二叉排序树\"><a href=\"#12、二叉排序树\" class=\"headerlink\" title=\"12、二叉排序树\"></a>12、二叉排序树</h3><p>二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>\n<li>它的左、右子树也分别为二叉排序树</li>\n</ul>\n<p>如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。</p>\n<h3 id=\"13、平衡二叉树\"><a href=\"#13、平衡二叉树\" class=\"headerlink\" title=\"13、平衡二叉树\"></a>13、平衡二叉树</h3><p>平衡二叉树（Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于 1；我们将二叉树上结点的左子树深度减去右子树深度的值称为<strong>平衡因子</strong>BF（Balance Factor），那么平衡二叉树上所有结点的平衡因子只可能是 -1，0，1</p>\n<h3 id=\"14、最小不平衡子树\"><a href=\"#14、最小不平衡子树\" class=\"headerlink\" title=\"14、最小不平衡子树\"></a>14、最小不平衡子树</h3><p>距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，我们称为<strong>最小不平衡子树</strong></p>\n<div align=\"center\"><img src=\"/images/hexo_post_184.png\" alt=\"\" width=\"400\"></div>\n\n<p>如上图所示，当新插入结点 37 时，距离它最近的平衡因子绝对值超过 1 的结点是 58（即它的左子树高度 2 减去右子树高度 0），所以从 58 开始以下的子树为最小不平衡子树</p>\n<h3 id=\"15、平衡二叉树实现算法\"><a href=\"#15、平衡二叉树实现算法\" class=\"headerlink\" title=\"15、平衡二叉树实现算法\"></a>15、平衡二叉树实现算法</h3><h4 id=\"算法原理：\"><a href=\"#算法原理：\" class=\"headerlink\" title=\"算法原理：\"></a>算法原理：</h4><p>基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应地旋转，使之成为新的平衡子树</p>\n<h4 id=\"右旋操作：\"><a href=\"#右旋操作：\" class=\"headerlink\" title=\"右旋操作：\"></a>右旋操作：</h4><div align=\"center\"><img src=\"/images/hexo_post_185.png\" alt=\"\" width=\"500\"></div>\n\n<p>左旋和右旋代码是对称的</p>\n<h3 id=\"16、多路查找树\"><a href=\"#16、多路查找树\" class=\"headerlink\" title=\"16、多路查找树\"></a>16、多路查找树</h3><p>多路查找树（multi-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</p>\n<h3 id=\"17、2-3-树\"><a href=\"#17、2-3-树\" class=\"headerlink\" title=\"17、2-3 树\"></a>17、2-3 树</h3><p>2-3 树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）。</p>\n<ul>\n<li>一个 2 结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似</li>\n<li>一个 3 结点包含一小一大两个元素和三个孩子（或没有孩子），左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素</li>\n<li>2-3 树中所有的叶子都在同一层次上</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_186.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"18、2-3树的插入实现\"><a href=\"#18、2-3树的插入实现\" class=\"headerlink\" title=\"18、2-3树的插入实现\"></a>18、2-3树的插入实现</h3><p>可分为三种情况：</p>\n<ol>\n<li>对于空树，插入一个 2 结点即可，这很容易理解</li>\n<li>插入结点到一个 2 结点的叶子上。由于其本身就只有一个元素，所以只需要将其升级为 3 结点即可</li>\n<li>要往 3 结点中插入一个新元素。因为 3 结点本身已经是 2-3 树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</li>\n</ol>\n<h3 id=\"19、2-3-4树\"><a href=\"#19、2-3-4树\" class=\"headerlink\" title=\"19、2-3-4树\"></a>19、2-3-4树</h3><p>就是 2-3 树的概念扩展，包括了 4 结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个 4 结点要么没有孩子，要么具有 4 个孩子。如果某个 4 结点有孩子的话，从左到右按照由小到大的顺序排列</p>\n<h3 id=\"20、B树\"><a href=\"#20、B树\" class=\"headerlink\" title=\"20、B树\"></a>20、B树</h3><p>B树（B-tree）是一种平衡的多路查找树，2-3树和 2-3-4树都是 B树的特例。结点最大的孩子数目称为 <strong>B树的阶</strong>（order），因此，2-3树是 3 阶 B树，2-3-4树是 4 阶 B树</p>\n<h4 id=\"一个-m-阶的-B-树具有如下属性：\"><a href=\"#一个-m-阶的-B-树具有如下属性：\" class=\"headerlink\" title=\"一个 m 阶的 B 树具有如下属性：\"></a>一个 m 阶的 B 树具有如下属性：</h4><ul>\n<li>如果根结点不是叶节点，则其至少有两棵子树</li>\n<li>每一个非根的分支结点都有 k-1 个元素和k个孩子，其中 ⌈m/2⌉ ≤ k ≤ m。每一个叶子节点 n 都有 k - 1 个元素，其中 ⌈m/2⌉ ≤ k ≤m</li>\n<li>所有叶子结点都位于同一层次</li>\n<li>所有分支结点包含下列信息数据（n,A0,K1,A1,K2,A2,…,Kn,An），其中：Ki(i=1,2,…,n) 为关键字，且 Ki&lt;Ki+1(i=1,2,…,n-1)；Ai(i=0,2,…,n) 为指向子树根结点的指针，且指针 A(i-1) 所指子树中所有结点的关键字均小于 Ki(i=1,2,…,n),An 所指子树中所有结点的关键字均大于 Kn，n·(⌈m/2⌉-1≤n≤m-1) 为关键字的个数（或 n + 1 为子树的个数）</li>\n</ul>\n<h3 id=\"21、B-树\"><a href=\"#21、B-树\" class=\"headerlink\" title=\"21、B+树\"></a>21、B+树</h3><p>在 B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子节点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针</p>\n<div align=\"center\"><img src=\"/images/hexo_post_187.png\" alt=\"\" width=\"400\"></div>\n\n<p>一棵 m 阶的 B+树和 m 阶的 B树的差异在于：</p>\n<ul>\n<li>有 n 棵子树的结点中包含有 n 个关键字</li>\n<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</li>\n<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字</li>\n</ul>\n<p>如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是沿着指向下一叶子结点的指针就可遍历所有的关键字</p>\n<h3 id=\"22、散列表（哈希表）\"><a href=\"#22、散列表（哈希表）\" class=\"headerlink\" title=\"22、散列表（哈希表）\"></a>22、散列表（哈希表）</h3><p><strong>散列技术</strong>是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)，散列技术既是一种存储方法，也是一种查找方法<br>散列技术最适合的求解问题是查找与给定值相等的记录 f称为散列函数，又称为<strong>哈希（Hash）函数</strong><br>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为<strong>散列表或哈希表</strong>（Hash table）</p>\n<h4 id=\"散列过程有两步：\"><a href=\"#散列过程有两步：\" class=\"headerlink\" title=\"散列过程有两步：\"></a>散列过程有两步：</h4><ol>\n<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录</li>\n<li>当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录</li>\n</ol>\n<h3 id=\"23、散列函数构造方法\"><a href=\"#23、散列函数构造方法\" class=\"headerlink\" title=\"23、散列函数构造方法\"></a>23、散列函数构造方法</h3><h4 id=\"直接定址法\"><a href=\"#直接定址法\" class=\"headerlink\" title=\"直接定址法\"></a>直接定址法</h4><p>取关键字的某个线性函数值为散列地址</p>\n<h4 id=\"数字分析法\"><a href=\"#数字分析法\" class=\"headerlink\" title=\"数字分析法\"></a>数字分析法</h4><p>如果我们的关键字是位数较多的数字，可以对数字进行翻转、右环位移、左环位移、甚至前两数与后两数叠加等方法，合理地将关键字分配到散列表的各位置</p>\n<h4 id=\"平方取中法\"><a href=\"#平方取中法\" class=\"headerlink\" title=\"平方取中法\"></a>平方取中法</h4><p>假设关键字是 1234，那么它的平方就是 1522756，再抽取中间的 3 位就是 227，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况</p>\n<h4 id=\"折叠法\"><a href=\"#折叠法\" class=\"headerlink\" title=\"折叠法\"></a>折叠法</h4><p>将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况 比如我们的关键字是 9876543210，散列表表长为三位，我们将它分为四组，987|654|321|0，然后将它们叠加求和 987 + 654 + 321 + 0 = 1962，再求后 3 位得到散列地址为 962。</p>\n<h4 id=\"除留余数法\"><a href=\"#除留余数法\" class=\"headerlink\" title=\"除留余数法\"></a>除留余数法</h4><p>对关键字直接取模，也可在折叠、平方取中后再取模，对于散列表长为 m 的散列函数公式为：</p>\n<blockquote>\n<p>f(key)=key mod p(p≤m)</p>\n</blockquote>\n<p>根据前辈们的经验，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m）的最小质数或不包含小于 20 质因子的合数</p>\n<h4 id=\"随机数法\"><a href=\"#随机数法\" class=\"headerlink\" title=\"随机数法\"></a>随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址</p>\n<h3 id=\"24、采用不同的散列函数应该考虑的因素\"><a href=\"#24、采用不同的散列函数应该考虑的因素\" class=\"headerlink\" title=\"24、采用不同的散列函数应该考虑的因素\"></a>24、采用不同的散列函数应该考虑的因素</h3><ul>\n<li>计算散列地址所需的时间</li>\n<li>关键字的长度</li>\n<li>散列表的大小</li>\n<li>关键字的分布情况</li>\n<li>记录查找的频率</li>\n</ul>\n<h3 id=\"25、处理散列冲突的方法\"><a href=\"#25、处理散列冲突的方法\" class=\"headerlink\" title=\"25、处理散列冲突的方法\"></a>25、处理散列冲突的方法</h3><h4 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h4><p>一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入，公式是：</p>\n<blockquote>\n<p>fi(key)=（f(key)+di）MOD m(di=1,2,3,……,m-1)</p>\n</blockquote>\n<p>这种解决冲突的开放定址法称为<strong>线性探测法</strong><br>如果 di 改进为正负两类值，等于是可以双向寻找到可能的空位置，可以不让关键字都聚集在某一块区域。我们称这种方法为<strong>二次探测法</strong><br>如果 di 采用随机函数计算得到，我们称之为<strong>随机探测法</strong></p>\n<h4 id=\"再散列函数法\"><a href=\"#再散列函数法\" class=\"headerlink\" title=\"再散列函数法\"></a>再散列函数法</h4><p>我们事先准备多个散列函数，每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉</p>\n<h4 id=\"链地址法\"><a href=\"#链地址法\" class=\"headerlink\" title=\"链地址法\"></a>链地址法</h4><p>将所有关键字为同义词的记录存储在一个单链表红，我们称这种表尾同义词子表，在散列表中只存储所有同义词子表的头指针</p>\n<h4 id=\"公共溢出区法\"><a href=\"#公共溢出区法\" class=\"headerlink\" title=\"公共溢出区法\"></a>公共溢出区法</h4><p>凡是冲突的都将它们存储到溢出表中</p>\n<h2 id=\"八、排序\"><a href=\"#八、排序\" class=\"headerlink\" title=\"八、排序\"></a>八、排序</h2><p>关于排序，推荐我的另一篇文章：<a href=\"/20170318/js-implementation-of-ten-sorting-algorithms.html\">\b十大排序算法的Javascript实现</a>，这篇文章里有一些常见排序算法的实现步骤以及演示，是一个比较好的排序算法讲解</p>\n<h2 id=\"九、总结\"><a href=\"#九、总结\" class=\"headerlink\" title=\"九、总结\"></a>九、总结</h2><h3 id=\"1、数据结构和算法\"><a href=\"#1、数据结构和算法\" class=\"headerlink\" title=\"1、数据结构和算法\"></a>1、数据结构和算法</h3><p>数据结构和算法对于程序员的职业人生来说，那就是两个圆圈的交集部分，用心去掌握它，你的编程之路将会是坦途</p>\n<div align=\"center\"><img src=\"/images/hexo_post_188.png\" alt=\"\" width=\"350\"></div>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]},{"title":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","slug":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","date":"2017-04-06T09:17:52.000Z","updated":"2019-07-04T08:09:14.557Z","comments":true,"path":"api/articles/读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_297.png","content":"<h2 id=\"1-一句话概括响应式设计\"><a href=\"#1-一句话概括响应式设计\" class=\"headerlink\" title=\"1. 一句话概括响应式设计\"></a>1. 一句话概括响应式设计</h2><p>如果要用一句话概括响应式网页设计，我觉得它是针对任意设备对网页内容进行完美布局的一种显示机制.相反，如果需要根据不同设备提供特定的内容和功能，那就需要一个真正的“手机版”网站.这种情况下，手机版网站会提供与桌面版网站完全不同的用户体验.</p>\n<h2 id=\"2-CSS-reset-网站\"><a href=\"#2-CSS-reset-网站\" class=\"headerlink\" title=\"2. CSS reset 网站\"></a>2. CSS reset 网站</h2><ul>\n<li><a href=\"http://meyerweb.com/eric/tools/css/reset/\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/css/reset/</a>，Eric Meyer的原版，主要针对HTML4</li>\n<li><a href=\"http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/</a>，针对HTML5</li>\n</ul>\n<h2 id=\"3-CSS-网格系统\"><a href=\"#3-CSS-网格系统\" class=\"headerlink\" title=\"3. CSS 网格系统\"></a>3. CSS 网格系统</h2><div align=\"center\"><img src=\"/images/hexo_post_297.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"4-地标角色属性\"><a href=\"#4-地标角色属性\" class=\"headerlink\" title=\"4. 地标角色属性\"></a>4. 地标角色属性</h2><p>role=”” 针对文档结构的各部分分别有如下的地标角色：</p>\n<ul>\n<li>application：用来定义用作网页应用的区域；</li>\n<li>banner：用来定义一个站点级别(而不是某个特定文档的)的区域.如网站的头部和logo；</li>\n<li>complementary：一个对页面主要区域进行补充说明的区域；</li>\n<li>contentinfo：与页面主要内容相关的信息区域，例如页脚的网站版权信息区域；</li>\n<li>form：定义表单，但是如果表单用于搜索，请使用search来替代；</li>\n<li>main：页面的主体内容；</li>\n<li>navigation：链向当前文档或相关文档的导航链接；</li>\n<li>search：一个用于搜索的区域。</li>\n</ul>\n<h2 id=\"5-导航栏使用-table-显示模式\"><a href=\"#5-导航栏使用-table-显示模式\" class=\"headerlink\" title=\"5. 导航栏使用 table 显示模式\"></a>5. 导航栏使用 table 显示模式</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-row;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做可以保证如果有另外的列表项追加进来，同样会自动地调整它们之间的间距。最后，使用 CSS3 选择器将最后一个列表项的文字置为右对齐，将第一个列表项的文字置为左对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:last-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-在响应式设计中使用自定义-font-face-字体的注意事项\"><a href=\"#6-在响应式设计中使用自定义-font-face-字体的注意事项\" class=\"headerlink\" title=\"6. 在响应式设计中使用自定义 @font-face 字体的注意事项\"></a>6. 在响应式设计中使用自定义 @font-face 字体的注意事项</h2><p>唯一需要注意的，是在响应式设计中使用该技术时要考虑到字体文件大小。有些字体可能会非常庞大，如果你想保持网站的高性能，请注意控制自定义字体的文件尺寸。</p>\n<h2 id=\"7-浮雕文字效果\"><a href=\"#7-浮雕文字效果\" class=\"headerlink\" title=\"7. 浮雕文字效果\"></a>7. 浮雕文字效果</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 1<span class=\"selector-tag\">px</span> 0 <span class=\"selector-tag\">hsla</span>(0， 0%， 100%， 0<span class=\"selector-class\">.75</span>);</span><br></pre></td></tr></table></figure>\n<p>不要模糊，不要水平阴影，仅在垂直方向设置 1 或 2 像素的”白影”即可。</p>\n<h2 id=\"8-让整个屏幕飞舞\"><a href=\"#8-让整个屏幕飞舞\" class=\"headerlink\" title=\"8. 让整个屏幕飞舞\"></a>8. 让整个屏幕飞舞</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123; <span class=\"attribute\">transition</span>: all <span class=\"number\">1s</span>; &#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_298.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"9-CSS3-实现-3D-变形效果\"><a href=\"#9-CSS3-实现-3D-变形效果\" class=\"headerlink\" title=\"9. CSS3 实现 3D 变形效果\"></a>9. CSS3 实现 3D 变形效果</h2><h3 id=\"在父级元素上设置透视，这样就开启了-3D-场景\"><a href=\"#在父级元素上设置透视，这样就开启了-3D-场景\" class=\"headerlink\" title=\"在父级元素上设置透视，这样就开启了 3D 场景\"></a>在父级元素上设置透视，这样就开启了 3D 场景</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123; <span class=\"attribute\">-webkit-perspective</span>: <span class=\"number\">200</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>透视的值越大，就表示你的视点与 3D 场景之间的景深越大。因此，如果想要一点隐约的 3D 效果，就增大透视值；如果想要非常明显的 3D 效果，则减小透视值。</p>\n<h3 id=\"延续父元素的透视\"><a href=\"#延续父元素的透视\" class=\"headerlink\" title=\"延续父元素的透视\"></a>延续父元素的透视</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son</span>&#123; <span class=\"attribute\">-webkit-transform-style</span>: perserve-<span class=\"number\">3</span>d; <span class=\"attribute\">-webkit-transition</span>: <span class=\"number\">1s</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>.father 类中添加的透视声明只会应用到其第一个子元素上。因此，为了延续父元素的透视，我们给 .son 元素设定了 preserve-3d (这样可以设置一个 3D 场景)。</p>\n<h3 id=\"当鼠标悬停在-father-模块上时，我们给-son-这个-div-添加一个翻转效果\"><a href=\"#当鼠标悬停在-father-模块上时，我们给-son-这个-div-添加一个翻转效果\" class=\"headerlink\" title=\"当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果\"></a>当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.son</span>&#123; <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"当海报翻转之后隐藏在其背面内容\"><a href=\"#当海报翻转之后隐藏在其背面内容\" class=\"headerlink\" title=\"当海报翻转之后隐藏在其背面内容\"></a>当海报翻转之后隐藏在其背面内容</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.face</span> &#123; <span class=\"attribute\">position</span>: absolute; <span class=\"attribute\">-webkit-backface-visibility</span>: hidden; &#125;</span><br></pre></td></tr></table></figure>\n<p>.face 必须使用绝对定位，这样海报才能盖在 .back 这个 div 的上面</p>\n<h3 id=\"给-back-加上-rotateY\"><a href=\"#给-back-加上-rotateY\" class=\"headerlink\" title=\"给 .back 加上 rotateY\"></a>给 .back 加上 rotateY</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.back</span> &#123; <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg); &#125;</span><br></pre></td></tr></table></figure>\n<p>不加这句的话，.back 这个 div 就会显示在正面海报之上。最终的 HTML 结构以及 CSS 样式如下:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"Qcontainer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"film\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"face front\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/goonies.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"The Goonies\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"face back\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>HOT!<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.Qcontainer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">28%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-perspective</span>: <span class=\"number\">800</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">2%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.film</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">15em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transition</span>: <span class=\"number\">1s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.Qcontainer</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.film</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.face</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-backface-visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.back</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">66%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">127%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg);</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#3b3b3b</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(top，</span><br><span class=\"line\">  rgba(0，0，0，0.65) <span class=\"number\">0%</span>，</span><br><span class=\"line\">  <span class=\"built_in\">rgba</span>(0，0，0，0) <span class=\"number\">100%</span>);</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">15%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-list-及对应的-datalist-元素\"><a href=\"#10-list-及对应的-datalist-元素\" class=\"headerlink\" title=\"10. list(及对应的 datalist 元素)\"></a>10. list(及对应的 datalist 元素)</h2><p>list 属性以及对应的 datalist 元素可以让用户在输入框中开始输入值的时候，显示一组备选值。下面是一个包含在 div 中的使用 list 属性及对应 datalist 元素的代码示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"awardWon\"</span>&gt;</span>Award Won<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"awardWon\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"awardWon\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">list</span>=<span class=\"string\">\"awards\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">datalist</span> <span class=\"attr\">id</span>=<span class=\"string\">\"awards\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Picture\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Director\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Adapted Screenplay\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Original Screenplay\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">datalist</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>list 属性中的值（awards）同时也是 datalist 元素的 id。这样就可以让 datalist 与输入项关联起来。虽然将 option 包裹在 select 中不是必需的，但这样做便于为老版本浏览器提供降级方案。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_299.png\" alt=\"\" width=\"550\"></div>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"HTML","path":"api/tags/HTML.json"},{"name":"CSS","path":"api/tags/CSS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","slug":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","date":"2017-04-06T08:42:13.000Z","updated":"2019-07-04T08:09:14.557Z","comments":true,"path":"api/articles/读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_300.png","content":"<h2 id=\"1-Web-标准——结构、样式和行为的分离\"><a href=\"#1-Web-标准——结构、样式和行为的分离\" class=\"headerlink\" title=\"1. Web 标准——结构、样式和行为的分离\"></a>1. Web 标准——结构、样式和行为的分离</h2><p>Web 标准由一系列标准组合而成，其核心理念就是将网页的结构，样式和行为分离开来，所以它可以分为三大部分：结构标准，央视标准和行为标准。<br>结构标准包括 XML 标准，XHTML 标准，HTML 标准；<br>样式标准主要是指 CSS 标准；<br>行为标准主要包括 DOM 标准和 ECMAScript 标准。</p>\n<h2 id=\"2-打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\"><a href=\"#2-打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\" class=\"headerlink\" title=\"2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\"></a>2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序</h2><p>精简的代码可以让文件变小，有利于客户端快速下载；重用可以让代码更易于精简，同时有助于提升开发速度；有序可以让我们更清晰地组织代码，使代码易于维护，有效应对变化。</p>\n<h2 id=\"3-欲精一行，必先通十行\"><a href=\"#3-欲精一行，必先通十行\" class=\"headerlink\" title=\"3. 欲精一行，必先通十行\"></a>3. 欲精一行，必先通十行</h2><p>在前端开发领域，不通十行就无法精一行。专精很难，甚至不可能，一专多能才是现实的。在前端开发这个领域，一专多能更是非常必要的。</p>\n<h2 id=\"4-增加代码可读性——注释\"><a href=\"#4-增加代码可读性——注释\" class=\"headerlink\" title=\"4.增加代码可读性——注释\"></a>4.增加代码可读性——注释</h2><p>一个好的代码，注释要占 1/3 的篇幅</p>\n<h2 id=\"5-磨刀不误砍柴工——前期的构思很重要\"><a href=\"#5-磨刀不误砍柴工——前期的构思很重要\" class=\"headerlink\" title=\"5. 磨刀不误砍柴工——前期的构思很重要\"></a>5. 磨刀不误砍柴工——前期的构思很重要</h2><p>构思的内容主要包括规范的指定，公共组件的设计和复杂功能的技术方案等。一般来说，前期构思占整个项目 30% ~ 60% 的时间都算是正常的.</p>\n<h2 id=\"6-标签的语义\"><a href=\"#6-标签的语义\" class=\"headerlink\" title=\"6. 标签的语义\"></a>6. 标签的语义</h2><p>HTML 标签的设计都是有语义考虑的。下表是部分标签的全称和中文翻译：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_300.png\" alt=\"\" width=\"600\"></div><br><div align=\"center\"><img src=\"/images/hexo_post_301.png\" alt=\"\" width=\"600\"></div>\n\n<p>其中，<strong>div 和 span 其实是没有语义的</strong>，它们只是分别用作块级元素和行内元素的区域分隔符。事实上，CSS 布局只是 Web 标准的一部分。在 HTML，CSS，JavaScript 这三大元素中，HTML 才是最重要的，结构才是重点，样式是用来修饰结构的。正确的做法是，先确定 HTML，确定语义的标签，再来选用合适的 CSS。</p>\n<h2 id=\"7-如何确定你的标签是否语义良好\"><a href=\"#7-如何确定你的标签是否语义良好\" class=\"headerlink\" title=\"7. 如何确定你的标签是否语义良好\"></a>7. 如何确定你的标签是否语义良好</h2><p>判断网页标签语义是否良好的一个简单方法就是：<strong>去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性</strong>。除了去样式后的可读性外，值得重点提及的还有 h 标签。h 标签的含义是”标题”，搜索引擎对这个标签比较敏感，尤其是 h1 和 h2。一个语义良好的页面，h 标签应该是完整有序没有断层的。也就是说，<strong>要按照 h1，h2，h3，h4 这样依次排列下来，不要出现类似 h1，h2，h3，h4，漏掉 h2 的情况</strong>。</p>\n<h2 id=\"8-常见模块\"><a href=\"#8-常见模块\" class=\"headerlink\" title=\"8. 常见模块\"></a>8. 常见模块</h2><h3 id=\"标题和内容\"><a href=\"#标题和内容\" class=\"headerlink\" title=\"标题和内容\"></a>标题和内容</h3><p>当页面内标签无法满足设计需要时，才会适当添加 div 和 span 等无语义标签来辅助实现。</p>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>登录表单<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"name\"</span>&gt;</span>账号：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"pw\"</span>&gt;</span>密码：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pw\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"登录\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"subBtn\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>一般来说，表单域要用 fieldset 标签包起来，并用 legend 标签说明表单的用途。因为 fieldset 默认有边框，而 legend 也有默认的样式，为满足设计需要，我们可以将 fieldset 的 “border” 设为 “none”，把 legend 的 “display” 设为 “none”，以此来兼顾语义和设计两方面的要求。每个 input 标签对应的说明文本都需要 label1 标签，并且通过为 input 设置 id 属性，在 label 标签中设置 “for=someld” 来让说明文本和相应的 input 关联起来.</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>表格标题要用 caption，表头要用 thead 包围，主体部分用 tbody 包围，尾部要用 tfoot 包围，表头和一般单元格要区分开，表头用 th，一般单元格用 td。</p>\n<h2 id=\"9-语义化标签应注意的一些其他问题\"><a href=\"#9-语义化标签应注意的一些其他问题\" class=\"headerlink\" title=\"9. 语义化标签应注意的一些其他问题\"></a>9. 语义化标签应注意的一些其他问题</h2><p>为了保证网页去样式后的可读性，并且又符合 Web 标准，我们应注意以下几点：</p>\n<ul>\n<li>尽可能少的使用无语义标签 div 和 span；</li>\n<li>在语义不明显，既可以用 p 也可以用 div 的地方，尽量用 p，因为 p 默认情况下有上下间距，去样式后的可读性更好，对兼容特殊终端有利；</li>\n<li>不要使用纯样式标签，例如 b，font 和 u 等，改用 CSS 设置。语义上需要强调的文本可以包在 strong 或 em 标签里，strong 和 em 有”强调”的语意，其中 strong 的默认样式是加粗，而 em 的默认样式是斜体。</li>\n</ul>\n<h2 id=\"10-如何组织-CSS\"><a href=\"#10-如何组织-CSS\" class=\"headerlink\" title=\"10. 如何组织 CSS\"></a>10. 如何组织 CSS</h2><p>一种组织 CSS 的方法：<strong>base.css+common.css+page.css</strong>。将网站内的所有样式，按照职能分成三大类：base，common 和 page。</p>\n<h3 id=\"base-层\"><a href=\"#base-层\" class=\"headerlink\" title=\"base 层\"></a>base 层</h3><p>这一层位于三者的最底层，提供 CSS reset 功能和粒度最小的通用类——原子类。这一层会被所有页面引用，是页面样式所需依赖的最底层。这一层与具体 UI 无关，无论何种风格的设计都可以引用它，所以 base 层要力求精简和通用。base 层具有高度可移植性，不同设计风格的网站可以使用同一个 base 层. base 层相对稳定，基本上不需要维护。</p>\n<h3 id=\"common-层\"><a href=\"#common-层\" class=\"headerlink\" title=\"common 层\"></a>common 层</h3><p>这一层位于中间，提供组件级的 CSS 类。我们可以将页面内的元素拆分成一小块一小块功能和样式相对独立的小”模块”，这些”模块”有些是很少重复的，有些是会大量重复的，我们可以将大量重复的”模块”视为一个组件。我们从页面里尽可能多的将组件提取出来，放在 common 层里。common 层就相当于 MVC 模式中的 M(Model，模型)。为了保证重用性和灵活性，M 需要尽可能将内部实现封装，对可能会经常变化的部分提供灵活的接口。common 层是网站级的，不同的网站有不同的 common 层，同一个网站只有一个 common 层。在团队合作中，common 层最好由一个人负责，统一管理。</p>\n<h3 id=\"page-层\"><a href=\"#page-层\" class=\"headerlink\" title=\"page 层\"></a>page 层</h3><p>网站中高度重用的模块，我们把它们视为组件，放在 common 层；非高度重用的模块，可以把它们放在 page 层。page 层位于最高层，提供页面级的样式，对重用性没有要求。base 层基本上不需要维护，common 层修改的幅度不会很大，通常只由一个人负责维护，但到了 page 层，代码可能由多人开发，如何避免冲突是个需要注意的问题。通常我们通过命名规则来避免这种冲突。</p>\n<h2 id=\"11-推荐的-base-css\"><a href=\"#11-推荐的-base-css\" class=\"headerlink\" title=\"11. 推荐的 base.css\"></a>11. 推荐的 base.css</h2><p>通常情况下，为了让浮动元素的父容器能够根据浮动元素的高度而自适应高度，有三种做法：</p>\n<ul>\n<li>让父容器同时浮动起来，例如：<code>&lt;div class=&quot;fl&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>；</li>\n<li>让浮动元素后面紧跟一个用于清楚浮动的空标签，例如 <code>&lt;div&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;div class=&quot;cb&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>；</li>\n<li><strong>给父容器挂一个特殊 class，直接从父容器清除浮动元素的浮动，例如 <code>&lt;div class=&quot;clearfix&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></strong></li>\n</ul>\n<p><strong>第一种方法会让父容器也浮动起来，影响父元素后面的元素的布局，有副作用；第二种方法增加了一个空标签，破坏了语义化。第三种方法没有任何副作用，推荐使用。</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  <span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:inline-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-拆分模块\"><a href=\"#12-拆分模块\" class=\"headerlink\" title=\"12. 拆分模块\"></a>12. 拆分模块</h2><ul>\n<li>模块与模块之间尽量不要包含相同的部分，如果有相同部分，应将它们提取出来，拆分成一个独立的模块.</li>\n<li>模块应在保证数量尽可能少的原则下，做到尽可能简单，以提高重用性.</li>\n</ul>\n<p>##13. CSS 的命名</p>\n<p>推荐使用英语，不要使用汉语拼音。我们可以根据内容来选用合适的英文单词命名 CSS。比如头部用 head，底部用 foot，主体部分用 main，导航用 nav，菜单用 menu 等，page 层 css 命名不可过短，可以将开发人员名字缩写作为前缀，以免发生冲突。</p>\n<h2 id=\"14-挂多个-class-还是新建-class——多用组合，少用继承\"><a href=\"#14-挂多个-class-还是新建-class——多用组合，少用继承\" class=\"headerlink\" title=\"14. 挂多个 class 还是新建 class——多用组合，少用继承\"></a>14. 挂多个 class 还是新建 class——多用组合，少用继承</h2><p>在面向对象编程里，有个很重要的原则就是”多用组合，少用继承”. HTML 的 class 与程序中”类”有相同的”味道”，class 可以挂多个，从技术上支持了”组合”的用法。我们在使用 CSS 时，如果能灵活运用这点就可以大大减少类的数量，一方面减少了代码量，提高了可维护性，另一方面时类的职责更单一，弹性更强，增加了类的重用性，提高了开发效率。</p>\n<h2 id=\"15-组件的-margin\"><a href=\"#15-组件的-margin\" class=\"headerlink\" title=\"15 .组件的 margin\"></a>15 .组件的 margin</h2><p>如果对相邻的模块同时使用了 margin-top 和 margin-bottom，边距会重合带来不必要的麻烦，所以最好统一使用 margin-top 或者 margin-bottom，不要混合使用，从而降低出现问题的风险。<br>总结：如果不确定模块的上下 margin 特别稳定，最好不要将它写到模块的类里，而是使用类的祝贺，单独为上下 margin 挂用于边距的原子类(例如 mt10，mb20)。模块最好不要混用 margin-top 和 margin-bottom，统一使用 margin-top 或 margin-bottom。</p>\n<h2 id=\"16-低权重原则——避免滥用子选择器\"><a href=\"#16-低权重原则——避免滥用子选择器\" class=\"headerlink\" title=\"16. 低权重原则——避免滥用子选择器\"></a>16. 低权重原则——避免滥用子选择器</h2><p>除非确定 HTML 结构非常稳定，一定不会再修改了，否则尽量不要使用子选择器。为了保证样式容易被覆盖，提高可维护性，CSS 选择符需保证权重尽可能低。</p>\n<h2 id=\"17-CSS-sprit-技术\"><a href=\"#17-CSS-sprit-技术\" class=\"headerlink\" title=\"17. CSS sprit 技术\"></a>17. CSS sprit 技术</h2><p>CSS sprite 技术看似简单，其实不容易掌握，主要有如下原因:</p>\n<ul>\n<li>它能合并的只能是用于背景的图片，对于 <code>&lt;img src=&quot;&quot; /&gt;</code> 设置的图片，是不能合并到 CSS sprite 大图中的，如果合并这些图片会影响页面可读性。</li>\n<li>对于横向和纵向都平铺的图片，也不能使用 CSS sprite；如果是横向平铺的，只能将所有横向平铺的图合并成一张大图，只能竖直排列，不能水平排列；如果是纵向平铺的，我们只能将所有纵向平铺的图合并成一张大图，只能水平排列，不能竖直排列。</li>\n<li>图片如何排列能够尽量紧凑，同时保证不会影响扩展性。这点是 CSS sprite 技术最困难也是最具挑战性的地方。</li>\n</ul>\n<h2 id=\"18-CSS-hack\"><a href=\"#18-CSS-hack\" class=\"headerlink\" title=\"18. CSS hack\"></a>18. CSS hack</h2><h3 id=\"IE-条件注释法\"><a href=\"#IE-条件注释法\" class=\"headerlink\" title=\"IE 条件注释法\"></a>IE 条件注释法</h3><h4 id=\"只在IE下生效\"><a href=\"#只在IE下生效\" class=\"headerlink\" title=\"只在IE下生效\"></a>只在IE下生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE6-下生效\"><a href=\"#只在-IE6-下生效\" class=\"headerlink\" title=\"只在 IE6 下生效\"></a>只在 IE6 下生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE6-以上版本生效\"><a href=\"#只在-IE6-以上版本生效\" class=\"headerlink\" title=\"只在 IE6 以上版本生效\"></a>只在 IE6 以上版本生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if gt IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE7-上不生效\"><a href=\"#只在-IE7-上不生效\" class=\"headerlink\" title=\"只在 IE7 上不生效\"></a>只在 IE7 上不生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if ! IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注释和-style-标签\"><a href=\"#条件注释和-style-标签\" class=\"headerlink\" title=\"条件注释和 style 标签\"></a>条件注释和 style 标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;style type=\"text/CSS\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">.test&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注释和-script-标签\"><a href=\"#条件注释和-script-标签\" class=\"headerlink\" title=\"条件注释和 script 标签\"></a>条件注释和 script 标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;script type=\"text/JavaScript\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">alert(\"我是 IE 6\");</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"选择符前缀法\"><a href=\"#选择符前缀法\" class=\"headerlink\" title=\"选择符前缀法\"></a>选择符前缀法</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/CSS\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">80px</span>; &#125;               <span class=\"comment\">/* IE 6,IE 7,IE 8 */</span></span></span><br><span class=\"line\"><span class=\"css\">*<span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">60px</span>; &#125;         <span class=\"comment\">/* only for IE 6 */</span></span></span><br><span class=\"line\"><span class=\"css\">*+<span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">70px</span>; &#125;        <span class=\"comment\">/* only for IE 7 */</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>选择符前缀法相较于 IE 条件注释法来说，可维护性强了很多，但在向后兼容性上存在一点风险。另外，选择符前缀法不能用于内联样式上。</p>\n<h3 id=\"样式属性前缀法\"><a href=\"#样式属性前缀法\" class=\"headerlink\" title=\"样式属性前缀法\"></a>样式属性前缀法</h3><p>样式属性前缀法的原理是在样式的属性名前加前缀，这些前缀只在特定浏览器下才生效.例如 “_” 只在 IE6 下生效，”*” 在 IE6 和 IE7 下生效。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/CSS\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.test</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 80px;</span></span><br><span class=\"line\"><span class=\"undefined\">  *width: 70px;</span></span><br><span class=\"line\"><span class=\"undefined\">  _width: 60px;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"19-a-标签的四种状态\"><a href=\"#19-a-标签的四种状态\" class=\"headerlink\" title=\"19. a 标签的四种状态\"></a>19. a 标签的四种状态</h2><p>关于 a 标签的四种状态的排序问题，有个简单好记的原则，叫做 love hate 原则，即 l(link)ov(visited)e h(hover)a(active)te</p>\n<h2 id=\"20-hasLayout\"><a href=\"#20-hasLayout\" class=\"headerlink\" title=\"20. hasLayout\"></a>20. hasLayout</h2><p>hasLayout 是 IE 浏览器专有的一个属性，用于 CSS 的解析引擎。有时候在 IE 下一些复杂的 CSS 设置解析起来会出现 Bug，其原因可能与 hasLayout 没有被自动触发有关，我们通过一些技巧，手动触发 hasLayout 属性就可以解决Bug了。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_302.png\" alt=\"\" width=\"550\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_303.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"21-块级元素和行内元素的区别\"><a href=\"#21-块级元素和行内元素的区别\" class=\"headerlink\" title=\"21. 块级元素和行内元素的区别\"></a>21. 块级元素和行内元素的区别</h2><ul>\n<li>块级元素会独占一行，默认情况下，其宽度自动填满其父元素宽度，行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化；</li>\n<li>块级元素可以设置 width，height 属性。行内元素设置 width，height 属性无效。块级元素即使设置了宽度，仍然是独占一行的；</li>\n<li>块级元素可以设置 margin 和 padding 属性。行内元素的 margin 和 padding 属性很奇怪，水平方向的 padding 和 margin 都产生边距效果，但竖直方向的 padding，margin 却不会产生边距效果。</li>\n</ul>\n<h2 id=\"22-display-inline-block\"><a href=\"#22-display-inline-block\" class=\"headerlink\" title=\"22. display:inline-block\"></a>22. display:inline-block</h2><p>它是行内的块级元素，它拥有块级元素的特点，可以设置长宽，可以设置 margin 和 padding 值，但它却不是独占一行，它的宽度并不占满父元素，而是和行内元素一样，可以和其他行内元素排在同一行里.</p>\n<h2 id=\"23-relative，absolute-和-float\"><a href=\"#23-relative，absolute-和-float\" class=\"headerlink\" title=\"23. relative，absolute 和 float\"></a>23. relative，absolute 和 float</h2><p>设置 position: relative 或 position: absolute 都可以让元素激活 left，top，right，bottom 和 z-index 属性(默认情况下，这些属性未激活，设置了也无效) 设置 position:relative 或 position:absolute 会让元素”浮”起来，也就是 z-index 值大于 0，它会改变正常情况下的文档流。float 也能改变文档流，不同的是，float 属性不会让元素”上浮”到另一个 z-index 层，它仍然让元素在 z-index: 0 层排列。另外，不论之前什么类型的元素(display: none 除外)，只要设置了 position: absolute，float: left 或 float: right 中的任意一个，都会让元素以 display: inline-block 的方式显示，可以设置长宽，默认宽度并不占满父元素。就算我们显示地设置 display: inline 或者 display: block，也仍然无效。position: relative 不会隐式改变 display 的类型。</p>\n<h2 id=\"24-居中\"><a href=\"#24-居中\" class=\"headerlink\" title=\"24. 居中\"></a>24. 居中</h2><h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3><h4 id=\"文本，图片等行内元素的水平居中\"><a href=\"#文本，图片等行内元素的水平居中\" class=\"headerlink\" title=\"文本，图片等行内元素的水平居中\"></a>文本，图片等行内元素的水平居中</h4><p>父元素设置text-align:center</p>\n<h4 id=\"确定宽度的块级元素的水平居中\"><a href=\"#确定宽度的块级元素的水平居中\" class=\"headerlink\" title=\"确定宽度的块级元素的水平居中\"></a>确定宽度的块级元素的水平居中</h4><p>margin:0 auto</p>\n<h4 id=\"不确定宽度的块级元素的水平居中\"><a href=\"#不确定宽度的块级元素的水平居中\" class=\"headerlink\" title=\"不确定宽度的块级元素的水平居中\"></a>不确定宽度的块级元素的水平居中</h4><ul>\n<li>第一种方法：将 ul 包含在 table 标签内，对 table 设置 margin: 0 auto 就可以使 table 水平居中，间接地使 ul 实现了水平居中；</li>\n<li>第二种方法：改变块级元素的 display 为 inline 类型，然后使用 text-align: center 来实现居中；</li>\n<li>第三种方法：给父元素设置 float，然后父元素设置 position: relative 和 left: 50%，子元素设置 position: relative 和 left: -50% 来实现水平居中</li>\n</ul>\n<h3 id=\"竖直居中\"><a href=\"#竖直居中\" class=\"headerlink\" title=\"竖直居中\"></a>竖直居中</h3><h4 id=\"父元素高度不确定的文本，图片，块级元素的竖直居中\"><a href=\"#父元素高度不确定的文本，图片，块级元素的竖直居中\" class=\"headerlink\" title=\"父元素高度不确定的文本，图片，块级元素的竖直居中\"></a>父元素高度不确定的文本，图片，块级元素的竖直居中</h4><p>给父容器设置相同上下边距实现的</p>\n<h4 id=\"父元素高度确定的单行文本的竖直居中\"><a href=\"#父元素高度确定的单行文本的竖直居中\" class=\"headerlink\" title=\"父元素高度确定的单行文本的竖直居中\"></a>父元素高度确定的单行文本的竖直居中</h4><p>通过给父元素设置 line-height 来实现的，line-height 值和父元素的高度值相同。</p>\n<h4 id=\"父元素高度确定的多行文本，图片，块级元素的竖直居中\"><a href=\"#父元素高度确定的多行文本，图片，块级元素的竖直居中\" class=\"headerlink\" title=\"父元素高度确定的多行文本，图片，块级元素的竖直居中\"></a>父元素高度确定的多行文本，图片，块级元素的竖直居中</h4><p>块级元素的 display:table-cell，vertical-align:center。</p>\n<h2 id=\"25-使用匿名函数控制变量的作用域\"><a href=\"#25-使用匿名函数控制变量的作用域\" class=\"headerlink\" title=\"25. 使用匿名函数控制变量的作用域\"></a>25. 使用匿名函数控制变量的作用域</h2><p><code>(function(){ var a，c=&quot;abc&quot;; })();</code> 这种形式很巧妙，先定义一个匿名的 function，然后立即执行它.包在这个匿名 function 里的变量，作用域就不再是 window，而是局限在函数内部。用匿名函数将脚本包起来，可以有效控制全局变量，避免冲突隐患。让 JS 不产生冲突，需要避免全局变量的泛滥，合理使用命名空间以及为代码添加必要的注释。</p>\n<h2 id=\"26-window-onload-和-DOMReady\"><a href=\"#26-window-onload-和-DOMReady\" class=\"headerlink\" title=\"26. window.onload 和 DOMReady\"></a>26. window.onload 和 DOMReady</h2><p>window.onload 需要当页面完全加载完成时才会触发，包括图片，Flash 等富媒体，DOMReady 只判断页面内所有的 DOM 节点是否已经全部生成，至于节点的内容是否加载完成，它并不关心. DOMReady 比 window.onload 更适合用来调用初始化函数。值得注意的是，DOMReady 并不是原生 JavaScript 支持的事件，它不能像 window.load 那样直接调用，一般我们都是结合 JS 框架来使用它。</p>\n<h2 id=\"27-CSS-放在页头，JavaScript-放在页尾\"><a href=\"#27-CSS-放在页头，JavaScript-放在页尾\" class=\"headerlink\" title=\"27. CSS 放在页头，JavaScript 放在页尾\"></a>27. CSS 放在页头，JavaScript 放在页尾</h2><p>将 CSS 放在页头，在载入 HTML 元素之前，先载入它们的样式，这样可以避免 HTML 出现无样式状态；将 JavaScript 放在页尾，先将网页呈现给用户，再来加载页面内的脚本，避免 JavaScirpt 阻塞网页的呈现，减少页面空白的时间。</p>\n<h2 id=\"28-引入编译的概念——文件压缩\"><a href=\"#28-引入编译的概念——文件压缩\" class=\"headerlink\" title=\"28. 引入编译的概念——文件压缩\"></a>28. 引入编译的概念——文件压缩</h2><p>为了减小网页的大小，缩短网页的下载时间，在正式发布 JavaScript 之前，我们可以先对它进行一下压缩。JS 压缩通常的做法是去掉空格和换行，去掉注释，将复杂变量名替换成简单的变量名。</p>\n<h2 id=\"29-JavaScript-如何分层\"><a href=\"#29-JavaScript-如何分层\" class=\"headerlink\" title=\"29. JavaScript 如何分层\"></a>29. JavaScript 如何分层</h2><p>把 JavaScript 也分成三层，从下往上依次是 base 层，common 层和 page 层</p>\n<h3 id=\"base-层-1\"><a href=\"#base-层-1\" class=\"headerlink\" title=\"base 层\"></a>base 层</h3><p>有两个职责，职责一是封装不同浏览器下 JavaScript 的差异，提供统一的接口，我们可以依靠它来完成跨浏览器兼容的工作。职责二是扩展 JavaScript 语言底层提供的接口，让它提供更多更为易用的接口。</p>\n<h3 id=\"common-层-1\"><a href=\"#common-层-1\" class=\"headerlink\" title=\"common 层\"></a>common 层</h3><p>依赖于 base 层提供的接口。common 层提供可供复用的组件，它是典型的 mvc 模式中的 m，和页面内的具体功能没有直接关系。common 层的功能是给 page 层提供组件。</p>\n<h3 id=\"page-层-1\"><a href=\"#page-层-1\" class=\"headerlink\" title=\"page 层\"></a>page 层</h3><p>这一层和页面里的具体功能需求直接相关，是 mvc 模式中的 c。page 层的功能是完成页面内的功能需求。</p>\n<h2 id=\"30-JavaScript-中的参数\"><a href=\"#30-JavaScript-中的参数\" class=\"headerlink\" title=\"30. JavaScript 中的参数\"></a>30. JavaScript 中的参数</h2><p>如果一个函数内某个因素很不稳定，我们可以将它从函数内部分离出来，以参数的形式传入，从而将不稳定因素和函数解耦。在编程里有一个很出名的规则叫做 DRY——don’t repeat yourself，强调在程序中不要将相同的代码重复编写多次，更好的做法是只写一次，然后在多处引用。</p>\n<h2 id=\"31-JavaScript-与面向对象\"><a href=\"#31-JavaScript-与面向对象\" class=\"headerlink\" title=\"31. JavaScript 与面向对象\"></a>31. JavaScript 与面向对象</h2><p>JavaScript 很奇怪，它没有 Class 关键字，在 JavaScript 中是用函数来充当类的。函数在 JavaScript 中既可以当作普通函数使用，也可以当作类来使用，在充当类的时候，它本身又担负着构造函数的责任。函数作为普通函数使用时，通常直接使用 “()” 进行调用，而作为类使用时，通常使用 new 来实例化。通常情况下，作为函数时我们更倾向于用动词来命名，而作为类时用名词来命名。按照习惯，类名的首字母大写。JavaScript 是基于原型的语言，通过 new 实例化出来的对象，其属性和行为来自于两部分，一部分来自于构造函数，另一部分来自于原型。当我们声明一个类时，其实同时生成了一个对应的原型，例如我们定义 Animal 这个类时，会生成一个与 Animal 类对应的原型，通过 Animal.prototype 可以指向这个原型，原型可以通过 constructor 指向 Animal 类，更确切地说，是指向 Animal 类的构造函数。构造函数中定义的属性和行为的优先级比原型中定义的属性和行为优先级高，如果构造函数和原型定义了同名的属性和行为，构造函数中的属性和行为会覆盖原型中的同名的属性和行为。 this 关键字无论出现在构造函数中，还是出现在原型中，指向的都是实例对象，通过 this 关键字，可以让属性和方法在构造函数和原型间通信。正统的面向对象语言会提供 public，protect，private 等关键字来声明属性和行为的可访问性是公有还是私有。但 JavaScript 并不提供这些关键字，在 JavaScript 中公有还是私有是通过作用域实现的。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_304.png\" alt=\"\" width=\"550\"></div>\n\n<p>把行为写在原型里可以减少内存消耗，没有特殊原因，推荐尽量把行为写在原型里。写在原型中的行为一定是公有的，而且无法访问私有属性。</p>\n<h2 id=\"32-传值与传址\"><a href=\"#32-传值与传址\" class=\"headerlink\" title=\"32. 传值与传址\"></a>32. 传值与传址</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;             <span class=\"comment\">// 基本数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;              <span class=\"comment\">// 将变量 a 保存的值复制一份，传给变量 b，a 和 b 各保存一份数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = [<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>];       <span class=\"comment\">// 复杂数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = c;              <span class=\"comment\">// 将变量 c 指向的数据的内存地址传给变量d，c 和 b 指向同一份数据</span></span><br><span class=\"line\">b++;</span><br><span class=\"line\">d.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">alert(a);     <span class=\"comment\">// 10 </span></span><br><span class=\"line\">alert(b);     <span class=\"comment\">// 11        变量 b 保存的数据更改不会影响到变量 a</span></span><br><span class=\"line\">alert(c);     <span class=\"comment\">// 1，2，3，4 变量 c 和 d 指向同一份数据，数据更改会互相影响</span></span><br><span class=\"line\">alert(d);     <span class=\"comment\">// 1，2，3，4</span></span><br></pre></td></tr></table></figure>\n<p>在原生 JavaScript中，选择传值还是传址是根据数据类型自动判定的，但传址有时候会给我们带来意想不到的麻烦，所以我们需要对复杂类型数据的赋值进行控制，让复杂数据类型也可以进行传值。</p>\n<h2 id=\"33-UML-描述类\"><a href=\"#33-UML-描述类\" class=\"headerlink\" title=\"33. UML 描述类\"></a>33. UML 描述类</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">PhonebookManager</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">+getTel():string</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+addItem():void</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+removeItem():void</td>\n</tr>\n</tbody>\n</table>\n<p>一个方框代表一个类，将方框划分成上中下三栏，第一栏填入类名，第二栏填入类的属性，第三栏填入类的行为，其中公有属性和公有行为需要在属性和行为名前加上 “+” 号，而私有属性和私有行为需要在属性和行为名前加上 “-” 号。</p>\n<h2 id=\"34-prototype-和内置类\"><a href=\"#34-prototype-和内置类\" class=\"headerlink\" title=\"34. prototype 和内置类\"></a>34. prototype 和内置类</h2><div align=\"center\"><img src=\"/images/hexo_post_305.png\" alt=\"\" width=\"600\"></div>\n\n<p>只要是类就会有原型，不管它是自定义类还是 JavaScript 的内置类，我们可以通过修改内置类的原型，让 JavaScript 基本类型的对象获得一些有趣的功能。无论在类的构造函数中还是在原型中，this 都指向实例化的对象。内置类的方法可以重写，但属性却不能重写。在 JavaScript 中，包括内置类和自定义类，所有类的祖先类都是 Object，所以如果想对所有对象都扩展方法，可以通过修改 Object 类的原型实现。</p>\n<h2 id=\"35-修改内置类\"><a href=\"#35-修改内置类\" class=\"headerlink\" title=\"35. 修改内置类\"></a>35. 修改内置类</h2><p>使用自定义类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myArray</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getArray=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myArray.prototype=&#123;</span><br><span class=\"line\">  each:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fun</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o=<span class=\"keyword\">this</span>.getArray();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=-，n=o.length;i&lt;n;i++)&#123;</span><br><span class=\"line\">      fun(o\\[i\\]，i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"keyword\">new</span> nyArray(\\[<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>\\])，str=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">a.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v，k</span>)</span>&#123;</span><br><span class=\"line\">  str += k+<span class=\"string\">\":\"</span>+v+<span class=\"string\">\"\\\\n\"</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">alert(str);    <span class=\"comment\">// 0:1 1:2 2:3</span></span><br></pre></td></tr></table></figure>\n<p>代替直接修改内置类原型的做法，定义一个自定义类，将内置类的实例作为参数传给构造函数，在自定义类里定义扩展方法。这种做法的思路是将内置类再封装一层，以此保护内置类的原型不被污染。两种方法都各有优缺点，修改内置类的原型非常方便，缺点是可能会带来冲突隐患；自定义类可以保护原型不被修改，但它需要用 new 来实例化自定义类，相对麻烦一点。如果是小应用，不用过多考虑可维护性，推荐使用前者，如果是大中型应用，需要考虑可维护性，推荐使用后者。</p>\n<h2 id=\"36-自定义属性\"><a href=\"#36-自定义属性\" class=\"headerlink\" title=\"36. 自定义属性\"></a>36. 自定义属性</h2><p>对于常规属性，统一使用 node.XXX 的方式读取，对于自定义属性，统一使用 node.getAttribute(“XXX”) 读取。将复杂类型的数据转化成字符串，称为数据的序列化，其逆操作叫做数据的反序列化。字符串的反序列化是通过 eval 函数实现的。只要字符串长的像 JavaScript 支持的数据格式，就可以进行反序列化。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">\"a\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://www.adanghome.com\"</span> <span class=\"attr\">blogInfo</span>=<span class=\"string\">\"&#123;name:'阿当的博客'，</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">type:'前端开发'&#125;\"</span>&gt;</span>my blog<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/JavaScript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> node=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"a\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> info=node.getAttribute(<span class=\"string\">\"blogInfo\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  alert(<span class=\"keyword\">typeof</span> info);    <span class=\"comment\">//string</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.name);      <span class=\"comment\">//undefined</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.type);      <span class=\"comment\">//undefined</span></span></span><br><span class=\"line\"><span class=\"javascript\">  info=<span class=\"built_in\">eval</span>(<span class=\"string\">\"(\"</span> + info + <span class=\"string\">\")\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  alert(<span class=\"keyword\">typeof</span> info);    <span class=\"comment\">//object</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.name);      <span class=\"comment\">//阿当的博客</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.type);      <span class=\"comment\">//前端开发</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"37-代码可维护性\"><a href=\"#37-代码可维护性\" class=\"headerlink\" title=\"37. 代码可维护性\"></a>37. 代码可维护性</h2><p>好的可维护性可以从四个方面获得：</p>\n<ul>\n<li>代码的松耦合，高度模块化，将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从 HTML、CSS、JavaScript 三个层面考虑模块化。</li>\n<li>良好的注释。</li>\n<li>注意代码的弹性，在性能和弹性的选择上，一般情况下以弹性为优先考虑条件，在保证弹性的基础上，适当优化性能。</li>\n<li>严格按照规范编写代码。</li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]}]}