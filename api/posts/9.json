{"total":114,"pageSize":10,"pageCount":12,"data":[{"title":"读书笔记系列（6）——大话数据结构","slug":"读书笔记系列（6）——大话数据结构","date":"2017-04-08T12:50:00.000Z","updated":"2019-02-02T10:19:58.054Z","comments":true,"path":"api/articles/读书笔记系列（6）——大话数据结构.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_147.png","content":"<p>这本书我是在网上下载的电子版，所以可能会有一些错别字，但是无伤大雅；《大话数据结构》被誉为程序员面试必读书籍，我大概用了 3 天的时间详读了一遍，感觉作者的文笔很好，而且很擅长通过生活中的小故事总结相关知识和算法思路，对于计算机初级童鞋来说是一本很好的数据结构入门读物，而且作者对于代码的讲解很详尽，接近逐行解释了，和其他数据结构的书籍形成了鲜明的对比，总体评价五星吧；不过我是在刷完 Leetcode 的 easy 题才看的这本书，感觉先看这本书再刷题的话会好很多</p>\n<h2 id=\"一、数据结构与算法\"><a href=\"#一、数据结构与算法\" class=\"headerlink\" title=\"一、数据结构与算法\"></a>一、数据结构与算法</h2><h3 id=\"1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\"><a href=\"#1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\" class=\"headerlink\" title=\"1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\"></a>1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子</h3><h3 id=\"2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\"><a href=\"#2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\" class=\"headerlink\" title=\"2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\"></a>2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科</h3><h3 id=\"3、数据元素的存储结构形式有两种：顺序存储和链式存储\"><a href=\"#3、数据元素的存储结构形式有两种：顺序存储和链式存储\" class=\"headerlink\" title=\"3、数据元素的存储结构形式有两种：顺序存储和链式存储\"></a>3、数据元素的存储结构形式有两种：顺序存储和链式存储</h3><ul>\n<li>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（谁也别插谁的队）</li>\n<li>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的（需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置）</li>\n</ul>\n<h3 id=\"4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\"><a href=\"#4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\" class=\"headerlink\" title=\"4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\"></a>4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性</h3><h3 id=\"5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\"><a href=\"#5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\" class=\"headerlink\" title=\"5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\"></a>5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征</h3><h3 id=\"6、推导时间复杂度大-O-阶方法：\"><a href=\"#6、推导时间复杂度大-O-阶方法：\" class=\"headerlink\" title=\"6、推导时间复杂度大 O 阶方法：\"></a>6、推导时间复杂度大 O 阶方法：</h3><ol>\n<li>用常数 1 取代运行时间中的所有加法常数</li>\n<li>在修改后的运行次数函数中，只保留最高阶项</li>\n<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>\n</ol>\n<h3 id=\"7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\"><a href=\"#7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\" class=\"headerlink\" title=\"7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\"></a>7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</h3><h3 id=\"8、常见的时间复杂度所耗费的时间：\"><a href=\"#8、常见的时间复杂度所耗费的时间：\" class=\"headerlink\" title=\"8、常见的时间复杂度所耗费的时间：\"></a>8、常见的时间复杂度所耗费的时间：</h3><div align=\"center\"><img src=\"/images/hexo_post_147.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\"><a href=\"#9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\" class=\"headerlink\" title=\"9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\"></a>9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。</h3><p>在应用中，这是一种最重要的需求，通常，除非特别制定，我们提到的运行时间都是最坏情况的运行时间 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间</p>\n<h3 id=\"10、算法的空间复杂度\"><a href=\"#10、算法的空间复杂度\" class=\"headerlink\" title=\"10、算法的空间复杂度\"></a>10、算法的空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数</p>\n<h2 id=\"二、线性表\"><a href=\"#二、线性表\" class=\"headerlink\" title=\"二、线性表\"></a>二、线性表</h2><h3 id=\"1、描述顺序存储结构需要三个属性：\"><a href=\"#1、描述顺序存储结构需要三个属性：\" class=\"headerlink\" title=\"1、描述顺序存储结构需要三个属性：\"></a>1、描述顺序存储结构需要三个属性：</h3><ul>\n<li>存储空间的起始位置：数组 data，它的存储位置就是存储空间的存储位置</li>\n<li>线性表的最大存储容量：数组长度 MaxSize</li>\n<li>线性表的当前长度：length</li>\n</ul>\n<h3 id=\"2、插入算法的思路：\"><a href=\"#2、插入算法的思路：\" class=\"headerlink\" title=\"2、插入算法的思路：\"></a>2、插入算法的思路：</h3><ol>\n<li>如果插入位置不合理，抛出异常</li>\n<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li>\n<li>从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置</li>\n<li>将要插入元素填入位置 i 处</li>\n<li>表长加 1</li>\n</ol>\n<h3 id=\"3、删除算法的思路：\"><a href=\"#3、删除算法的思路：\" class=\"headerlink\" title=\"3、删除算法的思路：\"></a>3、删除算法的思路：</h3><ol>\n<li>如果删除位置不合理，抛出异常</li>\n<li>取出删除元素</li>\n<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置</li>\n<li>表长减 1</li>\n</ol>\n<h3 id=\"4、线性表的顺序存储结构的优缺点：\"><a href=\"#4、线性表的顺序存储结构的优缺点：\" class=\"headerlink\" title=\"4、线性表的顺序存储结构的优缺点：\"></a>4、线性表的顺序存储结构的优缺点：</h3><p><strong>优点：</strong></p>\n<ul>\n<li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li>\n<li>可以快速地存取表中任一位置的元素</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>插入和删除操作需要移动大量元素</li>\n<li>当线性表长度变化较大时，难以确定存储空间的容量</li>\n<li>造成存储空间的“碎片”</li>\n</ul>\n<h3 id=\"5、单链表\"><a href=\"#5、单链表\" class=\"headerlink\" title=\"5、单链表\"></a>5、单链表</h3><p>n 个结点（ai 的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起</p>\n<div align=\"center\"><img src=\"/images/hexo_post_148.png\" alt=\"\" width=\"400\"></div>\n\n<p>有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_149.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"6、头指针与头结点的异同\"><a href=\"#6、头指针与头结点的异同\" class=\"headerlink\" title=\"6、头指针与头结点的异同\"></a>6、头指针与头结点的异同</h3><h4 id=\"头指针\"><a href=\"#头指针\" class=\"headerlink\" title=\"头指针\"></a>头指针</h4><ul>\n<li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li>\n<li>头指针具有标识作用，所以常用头指针冠以链表的名字</li>\n<li>无论链表是否为空，头指针均不为空。头指针式链表的必要元素</li>\n</ul>\n<h4 id=\"头结点\"><a href=\"#头结点\" class=\"headerlink\" title=\"头结点\"></a>头结点</h4><ul>\n<li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</li>\n<li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li>\n<li>头结点不一定是链表必须要素</li>\n</ul>\n<h3 id=\"7、获取链表第-i-个数据的算法思路\"><a href=\"#7、获取链表第-i-个数据的算法思路\" class=\"headerlink\" title=\"7、获取链表第 i 个数据的算法思路\"></a>7、获取链表第 i 个数据的算法思路</h3><ol>\n<li>声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，返回结点 p 的数据</li>\n</ol>\n<h3 id=\"8、单链表第-i-个数据插入结点的算法思路\"><a href=\"#8、单链表第-i-个数据插入结点的算法思路\" class=\"headerlink\" title=\"8、单链表第 i 个数据插入结点的算法思路\"></a>8、单链表第 i 个数据插入结点的算法思路</h3><ol>\n<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，在系统中生成一个空结点 s</li>\n<li>将数据元素 e 赋值给 s -&gt; data</li>\n<li>单链表的插入标准语句 s-&gt;next=p-&gt;next;p-&gt;next=s</li>\n<li>返回成功</li>\n</ol>\n<h3 id=\"9、单链表第-i-个数据删除结点的算法思路\"><a href=\"#9、单链表第-i-个数据删除结点的算法思路\" class=\"headerlink\" title=\"9、单链表第 i 个数据删除结点的算法思路\"></a>9、单链表第 i 个数据删除结点的算法思路</h3><ol>\n<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，\b将欲删除的结点 p -&gt; next 赋值给 q</li>\n<li>单链表的删除标准语句 p-&gt;next=q-&gt;next</li>\n<li>将 q 结点中的数据赋值给 e，作为返回</li>\n<li>释放 q 结点</li>\n<li>返回成功</li>\n</ol>\n<h3 id=\"10、单链表整表创建的算法思路\"><a href=\"#10、单链表整表创建的算法思路\" class=\"headerlink\" title=\"10、单链表整表创建的算法思路\"></a>10、单链表整表创建的算法思路</h3><ol>\n<li>声明一结点 p 和计数器变量 i</li>\n<li>初始化一空链表 L</li>\n<li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表</li>\n<li>循环：</li>\n</ol>\n<ul>\n<li>生成一新结点赋值给 p</li>\n<li>随机生成一数字赋值给 p 的数据域 p-&gt;data</li>\n<li>将 p 插入到头结点与前一新节点之间</li>\n</ul>\n<h3 id=\"11、单链表的整表删除\"><a href=\"#11、单链表的整表删除\" class=\"headerlink\" title=\"11、单链表的整表删除\"></a>11、单链表的整表删除</h3><ol>\n<li>声明一结点 p 和 q</li>\n<li>将第一个结点赋值给 p</li>\n<li>循环：</li>\n</ol>\n<ul>\n<li>将下一结点赋值给 q</li>\n<li>释放 p</li>\n<li>将 q 赋值给 p</li>\n</ul>\n<h3 id=\"12、单链表结构和顺序存储结构做对比\"><a href=\"#12、单链表结构和顺序存储结构做对比\" class=\"headerlink\" title=\"12、单链表结构和顺序存储结构做对比\"></a>12、单链表结构和顺序存储结构做对比</h3><div align=\"center\"><img src=\"/images/hexo_post_150.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"13、所谓的成功男人就是-3-岁时不尿裤子，5-岁能自己吃饭……80-岁能自己吃饭，90-岁能不尿裤子\"><a href=\"#13、所谓的成功男人就是-3-岁时不尿裤子，5-岁能自己吃饭……80-岁能自己吃饭，90-岁能不尿裤子\" class=\"headerlink\" title=\"13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子\"></a>13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子</h3><h3 id=\"14、循环链表\"><a href=\"#14、循环链表\" class=\"headerlink\" title=\"14、循环链表\"></a>14、循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）:</p>\n<div align=\"center\"><img src=\"/images/hexo_post_151.png\" alt=\"\" width=\"500\"></div>\n\n<p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断 p-&gt;next 是否为空，现在则是 <strong>p-&gt;next 不等于头结点，则循环未结束</strong></p>\n<h3 id=\"15、合并两个循环链表\"><a href=\"#15、合并两个循环链表\" class=\"headerlink\" title=\"15、合并两个循环链表\"></a>15、合并两个循环链表</h3><div align=\"center\"><img src=\"/images/hexo_post_152.png\" alt=\"\" width=\"500\"></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p=rearA-&gt;next;                   /* 保存A表的头结点，即① */</span><br><span class=\"line\">rearA-&gt;next=rearB-&gt;next-&gt;next;   /* 将本是指向B表的第一个结点（不是头结点） */</span><br><span class=\"line\">                                 /* 赋值给rearA-&gt;next，即 ②*/</span><br><span class=\"line\">rearB-&gt;next=p;                   /* 将原A表的头结点赋值给rearB-&gt;next，即③ */</span><br><span class=\"line\">free(p);                         /* 释放p */</span><br></pre></td></tr></table></figure>\n<h3 id=\"16、双向链表\"><a href=\"#16、双向链表\" class=\"headerlink\" title=\"16、双向链表\"></a>16、双向链表</h3><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域</p>\n<h3 id=\"17、双向链表的插入\"><a href=\"#17、双向链表的插入\" class=\"headerlink\" title=\"17、双向链表的插入\"></a>17、双向链表的插入</h3><p>假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间需要下面几步：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_153.png\" alt=\"\" width=\"400\"></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-&gt;prior=p;           /* 把 p 赋值给 s 的前驱，如图中① */</span><br><span class=\"line\">s-&gt;next=p-&gt;next;      /* 把 p-&gt;next 赋值给 s 的后继，如图中② */</span><br><span class=\"line\">p-&gt;next-&gt;prior=s;     /* 把 s 赋值给 p-&gt;next 的前驱，如图中③ */</span><br><span class=\"line\">p-&gt;next=s;            /* 把 s 赋值给 p 的后继，如图中④ */</span><br></pre></td></tr></table></figure>\n<h3 id=\"18、线性表的总结\"><a href=\"#18、线性表的总结\" class=\"headerlink\" title=\"18、线性表的总结\"></a>18、线性表的总结</h3><div align=\"center\"><img src=\"/images/hexo_post_154.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"三、栈与队列\"><a href=\"#三、栈与队列\" class=\"headerlink\" title=\"三、栈与队列\"></a>三、栈与队列</h2><h3 id=\"1、栈的定义\"><a href=\"#1、栈的定义\" class=\"headerlink\" title=\"1、栈的定义\"></a>1、栈的定义</h3><p>栈（stack）是限定<strong>仅在表尾进行插入和删除操作</strong>的线性表，我们把允许插入和删除的一端称为<strong>栈顶</strong>（top），另一端称为<strong>栈底</strong>（bottom），不含任何数据元素的栈称为<strong>空栈</strong></p>\n<h3 id=\"2、当栈存在一个元素时，top-等于-0，因此通常把空栈的判定条件定位-top-等于-1（索引值从-0-开始）\"><a href=\"#2、当栈存在一个元素时，top-等于-0，因此通常把空栈的判定条件定位-top-等于-1（索引值从-0-开始）\" class=\"headerlink\" title=\"2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）\"></a>2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）</h3><h3 id=\"3、用一个数组来存储两个栈\"><a href=\"#3、用一个数组来存储两个栈\" class=\"headerlink\" title=\"3、用一个数组来存储两个栈\"></a>3、用一个数组来存储两个栈</h3><div align=\"center\"><img src=\"/images/hexo_post_155.png\" alt=\"\" width=\"700\"></div>\n\n<p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 n - 1 处。这样，如果两个栈增加元素，就是两端点向中间延伸</p>\n<p><strong>两个栈见面之时，也就是两个指针之间相差 1 时，即 top1 + 1 == top2为栈满</strong></p>\n<h3 id=\"4、递归定义\"><a href=\"#4、递归定义\" class=\"headerlink\" title=\"4、递归定义\"></a>4、递归定义</h3><p>一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数；每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>\n<h3 id=\"5、队列定义\"><a href=\"#5、队列定义\" class=\"headerlink\" title=\"5、队列定义\"></a>5、队列定义</h3><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表；允许插入的一端称为队尾，允许删除的一端称为队头</p>\n<h3 id=\"6、队列的链式存储结构\"><a href=\"#6、队列的链式存储结构\" class=\"headerlink\" title=\"6、队列的链式存储结构\"></a>6、队列的链式存储结构</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；队头指针指向链队列的头结点，而队尾指针指向终端结点：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_156.png\" alt=\"\" width=\"400\"></div>\n\n<p>空队列时，front 和 rear 都指向头结点</p>\n<h3 id=\"7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\"><a href=\"#7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\" class=\"headerlink\" title=\"7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\"></a>7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列</h3><h3 id=\"8、栈和队列的存储结构\"><a href=\"#8、栈和队列的存储结构\" class=\"headerlink\" title=\"8、栈和队列的存储结构\"></a>8、栈和队列的存储结构</h3><div align=\"center\"><img src=\"/images/hexo_post_295.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"9、关于栈和队列的人生感悟\"><a href=\"#9、关于栈和队列的人生感悟\" class=\"headerlink\" title=\"9、关于栈和队列的人生感悟\"></a>9、关于栈和队列的人生感悟</h3><p>人生，就像是一个很大的栈演变。出生时你赤条条地来到人世，慢慢地长大，渐渐地变老，最终还得赤条条地离开世间。<br>人生，又仿佛是一天一天小小的栈重现。童年父母每天抱你不断地进出家门，壮年你每天奔波于家与事业之间，老年你每天独自蹒跚于养老院的门里屋前。<br>人生，更需要有进栈出栈精神的体现。在哪里跌倒，就应该在哪里爬起来。无论陷入何等困境，只要抬头能仰望蓝天，就有希望，不断进取，你就可以让出头之日重现。困难不会永远存在，强者才能勇往直前。<br>人生，其实就是一个大大的队列演变。无知童年、快乐少年，稚傲青年，成熟中年，安逸晚年。<br>人生，又是一个又一个小小的队列重现。春夏秋冬轮回年年，早中晚夜循环天天。变化的是时间，不变的是你对未来执着的信念。<br>人生，更需要有队列精神的体现。南极到北极，不过是南纬90度到北纬90度的队列，如果你中途犹豫，临时转向，也许你就只能和企鹅相伴永远。可事实上，无论哪个方向，只要你坚持到底，你都可以到达终点。</p>\n<h2 id=\"四、串（字符串）\"><a href=\"#四、串（字符串）\" class=\"headerlink\" title=\"四、串（字符串）\"></a>四、串（字符串）</h2><h3 id=\"1、一首回文诗（李禺《两相思》）\"><a href=\"#1、一首回文诗（李禺《两相思》）\" class=\"headerlink\" title=\"1、一首回文诗（李禺《两相思》）\"></a>1、一首回文诗（李禺《两相思》）</h3><blockquote>\n<p>枯眼望遥山隔水，<br>往来曾见几心知？<br>壶空怕酌一杯酒，<br>笔下难成和韵诗。<br>途路阻人离别久，<br>讯音无雁寄回迟。<br>孤灯夜守长寥寂，<br>夫忆妻兮父忆儿。</p>\n</blockquote>\n<p>更多回文诗可以<a href=\"http://baike.baidu.com/link?url=VNTgFjBN0q2gekPkKqes9MWMtdOqf8_THZ-MuEh3vJTBKi88oJmvcrHNAkswt_oKY5pR58CL8C0CPKEHFfLFQpb6ZOQPU3W4G-P9z9gv6P2D4cO1CxwgyrBQNUg3fGfu\" target=\"_blank\" rel=\"noopener\">戳我一下</a></p>\n<h3 id=\"2、英语单词中的字符串\"><a href=\"#2、英语单词中的字符串\" class=\"headerlink\" title=\"2、英语单词中的字符串\"></a>2、英语单词中的字符串</h3><p>即使是 lover 也有个 over，即使是 friend 也有个 end，即使是 believe 也有个lie</p>\n<h3 id=\"3、关于字符串的一些概念\"><a href=\"#3、关于字符串的一些概念\" class=\"headerlink\" title=\"3、关于字符串的一些概念\"></a>3、关于字符串的一些概念</h3><p><strong>空格串</strong>：是只包含空格的串，空格串是有内容有长度的，而且可以不止一个空格<br>子串与主串：串中任意个数的连续字符组成的子序列称为该串的<strong>子串</strong>，相应地，包含子串的串称为<strong>主串</strong><br><strong>子串在主串中的位置</strong>：就是子串的第一个字符在主串中的序号</p>\n<h3 id=\"4、Unicode-和-ASCII-编码\"><a href=\"#4、Unicode-和-ASCII-编码\" class=\"headerlink\" title=\"4、Unicode 和 ASCII 编码\"></a>4、Unicode 和 ASCII 编码</h3><p>\b计算机中的常用字符是使用标准的 ASCII 编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展 ASCII 码由 8 位二进制数表示一个字符，总共可以表示 256 个字符；可是换做全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了 Unicode 编码，比较常用的是由 16 位的二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和 ASCII 码兼容，Unicode 的前 256 个字符与 ASCII 码完全相同</p>\n<h3 id=\"5、两个字符串的比较\"><a href=\"#5、两个字符串的比较\" class=\"headerlink\" title=\"5、两个字符串的比较\"></a>5、两个字符串的比较</h3><p>给定两个串：s=”a1a2……an”，t=”b1b2……bm”，当满足以下条件之一时，s &lt; t</p>\n<ul>\n<li>n &lt; m，且 ai=bi（i=1，2，……n），例如当 s=”hap”，t=”happy”，就有 s &lt; t。因为 t 比 s 多出了两个字母</li>\n<li>存在某个 k ≤ min(m,n)，使得 ai = bi（i=1，2，……，,k-1），ak &lt; bk，例如当 s=”happen”，t=”happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母（k 值），字母 e 的 ASCII 码是 101，而字母 y 的 ASCII 码是 121，显然 e &lt; y，所以 s &lt; t</li>\n</ul>\n<h2 id=\"五、树\"><a href=\"#五、树\" class=\"headerlink\" title=\"五、树\"></a>五、树</h2><h3 id=\"1、一些概念\"><a href=\"#1、一些概念\" class=\"headerlink\" title=\"1、一些概念\"></a>1、一些概念</h3><ul>\n<li>结点拥有的子树数称为结点的度（Degree）；</li>\n<li>度为 0 的结点称为叶节点（Leaf）或终端结点；</li>\n<li>度不为 0 的结点称为非终端结点或分支结点；</li>\n<li>除根结点之外，分支结点也成为内部结点树的度是树内各结点的度的最大值</li>\n<li>树中结点的最大层次称为树的深度（Depth）或高度</li>\n</ul>\n<h3 id=\"2、线性表与树的结构\"><a href=\"#2、线性表与树的结构\" class=\"headerlink\" title=\"2、线性表与树的结构\"></a>2、线性表与树的结构</h3><div align=\"center\"><img src=\"/images/hexo_post_158.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"3、双亲表示法\"><a href=\"#3、双亲表示法\" class=\"headerlink\" title=\"3、双亲表示法\"></a>3、双亲表示法</h3><p>以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置；由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_159.png\" alt=\"\" width=\"300\"></div>\n\n<p>这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，知道 parent 为 -1 时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，需要遍历整个结构。</p>\n<h3 id=\"4、多重链表表示法\"><a href=\"#4、多重链表表示法\" class=\"headerlink\" title=\"4、多重链表表示法\"></a>4、多重链表表示法</h3><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法；不过，树的每个结点的度，也就是孩子个数是不同的，所以可以设计两种方案来解决：</p>\n<h4 id=\"方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\"><a href=\"#方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\" class=\"headerlink\" title=\"方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\"></a>方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）</h4><div align=\"center\"><img src=\"/images/hexo_post_160.png\" alt=\"\" width=\"500\"></div>\n\n<p>其中 data 是数据域，child1 到 childd 是指针域，用来指向该结点的孩子结点，这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的</p>\n<h4 id=\"方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\"><a href=\"#方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\" class=\"headerlink\" title=\"方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\"></a>方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数</h4><div align=\"center\"><img src=\"/images/hexo_post_296.png\" alt=\"\" width=\"500\"></div>\n\n<p>这种方法提升了空间利用率，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗</p>\n<h3 id=\"5、孩子表示法\"><a href=\"#5、孩子表示法\" class=\"headerlink\" title=\"5、孩子表示法\"></a>5、孩子表示法</h3><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_162.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"6、双亲孩子表示法\"><a href=\"#6、双亲孩子表示法\" class=\"headerlink\" title=\"6、双亲孩子表示法\"></a>6、双亲孩子表示法</h3><div align=\"center\"><img src=\"/images/hexo_post_163.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"7、孩子兄弟表示法\"><a href=\"#7、孩子兄弟表示法\" class=\"headerlink\" title=\"7、孩子兄弟表示法\"></a>7、孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_164.png\" alt=\"\" width=\"300\"></div>\n\n<p>data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址，这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树</p>\n<h3 id=\"8、二叉树特点\"><a href=\"#8、二叉树特点\" class=\"headerlink\" title=\"8、二叉树特点\"></a>8、二叉树特点</h3><ul>\n<li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点（没有子树或者有一棵子树都是可以的）</li>\n<li>左子树和右子树是有顺序的，次序不能任意颠倒</li>\n<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</li>\n</ul>\n<h3 id=\"9、二叉树五种基本形态\"><a href=\"#9、二叉树五种基本形态\" class=\"headerlink\" title=\"9、二叉树五种基本形态\"></a>9、二叉树五种基本形态</h3><ol>\n<li>空二叉树</li>\n<li>只有一个根结点</li>\n<li>根结点只有左子树</li>\n<li>根结点只有右子树</li>\n<li>根结点既有左子树又有右子树</li>\n</ol>\n<h3 id=\"10、特殊二叉树\"><a href=\"#10、特殊二叉树\" class=\"headerlink\" title=\"10、特殊二叉树\"></a>10、特殊二叉树</h3><h4 id=\"斜树\"><a href=\"#斜树\" class=\"headerlink\" title=\"斜树\"></a>斜树</h4><p>所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树，这两者统称为斜树</p>\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</p>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_165.png\" alt=\"\" width=\"400\"></div>\n\n<p><strong>完全二叉树的特点：</strong></p>\n<ul>\n<li>叶子结点只能出现在最下两层</li>\n<li>最下层的叶子一定集中在左部连续位置</li>\n<li>倒数二层，若有叶子结点，一定都在右部连续位置</li>\n<li>如果结点度为 1，则该节点只有左孩子，即不存在只有右子树的情况</li>\n<li>同样结点数的二叉树，完全二叉树的深度最小</li>\n</ul>\n<h3 id=\"11、二叉树的性质\"><a href=\"#11、二叉树的性质\" class=\"headerlink\" title=\"11、二叉树的性质\"></a>11、二叉树的性质</h3><ol>\n<li>在二叉树的第 i 层上至多有 <strong>2i-1</strong> 个结点（i ≥ 1）</li>\n<li>深度为 k 的二叉树至多有 <strong>2k-1</strong> 个结点（k ≥ 1）</li>\n<li>对任何一棵二叉树 T，如果其终端结点数为 <strong>n0</strong>，度为 2 的节点数为 <strong>n2</strong>，则 <strong>n0 = n2 + 1</strong>（解释见下图）</li>\n<li>具有 n 个结点的完全二叉树的深度为 <strong>⌊log2n⌋ + 1</strong>（⌊x⌋ 表示不大于 x 的最大整数）</li>\n<li>如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log2n⌋+1）的结点按层序编号（从第 1 层到第 ⌊log2n⌋ + 1 层，每层从左到右），对任一结点 i（1≤i≤n）有：</li>\n</ol>\n<ul>\n<li>如果 i = 1，则结点i是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 ⌊i / 2⌋</li>\n<li>如果 2i &gt; n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左结点是结点 2i</li>\n<li>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_166.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"12、二叉链表\"><a href=\"#12、二叉链表\" class=\"headerlink\" title=\"12、二叉链表\"></a>12、二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_167.png\" alt=\"\" width=\"300\"></div>\n\n<p>其中 data 是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针</p>\n<h3 id=\"13、二叉树遍历方法\"><a href=\"#13、二叉树遍历方法\" class=\"headerlink\" title=\"13、二叉树遍历方法\"></a>13、二叉树遍历方法</h3><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树，遍历的顺序为：ABDGHCEIF</p>\n<div align=\"center\"><img src=\"/images/hexo_post_168.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树，遍历的顺序为：GDHBAEICF</p>\n<div align=\"center\"><img src=\"/images/hexo_post_169.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点，遍历的顺序为：GHDBIEFCA</p>\n<div align=\"center\"><img src=\"/images/hexo_post_170.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><p>若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序堆结点逐个访问，遍历的顺序为：ABCDEFGHI</p>\n<div align=\"center\"><img src=\"/images/hexo_post_171.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"14、两个二叉树遍历的性质\"><a href=\"#14、两个二叉树遍历的性质\" class=\"headerlink\" title=\"14、两个二叉树遍历的性质\"></a>14、两个二叉树遍历的性质</h3><ul>\n<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>\n<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>\n<li>但是已知前序和后序遍历，是不能确定一棵二叉树的</li>\n</ul>\n<h3 id=\"15、线索二叉树\"><a href=\"#15、线索二叉树\" class=\"headerlink\" title=\"15、线索二叉树\"></a>15、线索二叉树</h3><p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树</p>\n<div align=\"center\"><img src=\"/images/hexo_post_172.png\" alt=\"\" width=\"500\"></div>\n\n<p>通过上图（空心箭头实线为前驱，虚线黑箭头为后继），可以看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表；所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化；但是，我们并不知道某一结点的 lchild 是指向它的左孩子还是指向前驱，所以需要一个区分标致；因此，我们在每个结点再增设两个标志域 ltag 和 rtag，这两个 tag 只是存放 0 或 1 数字的布尔型变量，其占用的内存空间要小于像 lchild 和 rchild 的指针变量，结点结构如下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_173.png\" alt=\"\" width=\"400\"></div>\n\n<ul>\n<li>ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱</li>\n<li>rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_174.png\" alt=\"\" width=\"500\"></div>\n\n<p><strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong></p>\n<h3 id=\"16、树转换为二叉树\"><a href=\"#16、树转换为二叉树\" class=\"headerlink\" title=\"16、树转换为二叉树\"></a>16、树转换为二叉树</h3><ol>\n<li>加线，在所有兄弟结点之间加一条连线</li>\n<li>去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>\n<li>层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_175.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"17、森林转换为二叉树\"><a href=\"#17、森林转换为二叉树\" class=\"headerlink\" title=\"17、森林转换为二叉树\"></a>17、森林转换为二叉树</h3><ol>\n<li>把每个树转换为二叉树</li>\n<li>第一棵二叉树不动，从第二棵二叉树开始，以此把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来，当所有的二叉树连接起来后就得到了由森林转换来的二叉树</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_176.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"18、二叉树转换为树\"><a href=\"#18、二叉树转换为树\" class=\"headerlink\" title=\"18、二叉树转换为树\"></a>18、二叉树转换为树</h3><ol>\n<li>加线，若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接起来</li>\n<li>去线，删除原二叉树中所有结点与其右孩子结点的连线</li>\n<li>层次调整，使之结构层次分明</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_177.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"19、二叉树转换为森林\"><a href=\"#19、二叉树转换为森林\" class=\"headerlink\" title=\"19、二叉树转换为森林\"></a>19、二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树</p>\n<ol>\n<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树</li>\n<li>再将每棵分离后的二叉树转换为树即可</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_178.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"20、树的遍历\"><a href=\"#20、树的遍历\" class=\"headerlink\" title=\"20、树的遍历\"></a>20、树的遍历</h3><ol>\n<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树</li>\n<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li>\n</ol>\n<h3 id=\"21、森林的遍历\"><a href=\"#21、森林的遍历\" class=\"headerlink\" title=\"21、森林的遍历\"></a>21、森林的遍历</h3><ol>\n<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先跟遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林</li>\n<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林</li>\n</ol>\n<p><strong>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树中的中序遍历结果相同</strong></p>\n<h3 id=\"22、赫夫曼树算法描述\"><a href=\"#22、赫夫曼树算法描述\" class=\"headerlink\" title=\"22、赫夫曼树算法描述\"></a>22、赫夫曼树算法描述</h3><ol>\n<li>根据给定的n个权值 {w1，w2，···wn} 构成 n 棵二叉树的集合 F={T1，T2，···Tn}，其中每个二叉树 Ti 中只有一个带权为 wi 的根结点，其左右子树均为空。</li>\n<li>在 F 中选择两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。</li>\n<li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li>\n<li>重复 2 和 3，直到 F 只含一棵树为止。这棵树便是赫夫曼树。</li>\n</ol>\n<h3 id=\"23、赫夫曼编码\"><a href=\"#23、赫夫曼编码\" class=\"headerlink\" title=\"23、赫夫曼编码\"></a>23、赫夫曼编码</h3><p>一般地，设需要编码的字符集为 {d1，d2，···dn}，各个字符在电文中出现的次数或频率集合为 {w1，w2，···wn}，以 d1，d2，···dn 作为叶子结点，以 w1，w2，···wn 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码</p>\n<h2 id=\"六、图\"><a href=\"#六、图\" class=\"headerlink\" title=\"六、图\"></a>六、图</h2><h3 id=\"1、图的定义\"><a href=\"#1、图的定义\" class=\"headerlink\" title=\"1、图的定义\"></a>1、图的定义</h3><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合</p>\n<h3 id=\"2、关于图的一些定义\"><a href=\"#2、关于图的一些定义\" class=\"headerlink\" title=\"2、关于图的一些定义\"></a>2、关于图的一些定义</h3><ul>\n<li><strong>无向边</strong>：若顶点 vi 到 vj 之间的边没有方向，则称这条边为无向边（Edge），用无需偶对（vi，vj）来表示</li>\n<li><p><strong>有向边</strong>：若从顶点 vi 到 vj 的边有方向，则称这条边为有向边，也成为弧（Arc）<br><strong>无向边用小括号 “()” 表示，而有向边则是用尖括号 “&lt;&gt;” 表示</strong></p>\n</li>\n<li><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为<strong>简单图</strong></p>\n</li>\n<li>在无向图中，如果任意两个顶点之间都存在边，则称该图为<strong>无向完全图</strong></li>\n<li>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为<strong>有向完全图</strong></li>\n<li>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong></li>\n<li>这里稀疏和稠密是模糊的概念，是相对而言的 有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做<strong>权</strong>（Weight）</li>\n<li>带权的图通常称为<strong>网</strong>（Network）</li>\n<li>假设有两个图 G =（V，{E}）和G’ =（V’，{E’}），如果 V’ ⊆ V 且 E’ ⊆ E，则称 G’ 为 G 的<strong>子图</strong>（Subgraph）</li>\n<li>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。</li>\n<li>若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。</li>\n<li>图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量 无向图中连通且n个顶点n-1条边叫生成树。</li>\n<li>有向图中一顶点入度为0其余顶点入度为1的叫有向树。</li>\n<li>一个有向图由若干棵有向树构成生成森林</li>\n</ul>\n<blockquote>\n<p>由于定义实在太多，就不再叙述了，可以<a href=\"http://blog.csdn.net/luoweifu/article/details/9270439\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看关于图的其他定义</p>\n</blockquote>\n<h3 id=\"3、图的邻接矩阵\"><a href=\"#3、图的邻接矩阵\" class=\"headerlink\" title=\"3、图的邻接矩阵\"></a>3、图的邻接矩阵</h3><p>图的邻接矩阵（Adiacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息 n 个顶点和 e 条边的无向网图的创建，时间复杂度为 O（n+n2+e），其中对邻接矩阵的初始化需要耗费 O（n2）的时间</p>\n<h3 id=\"4、邻接表\"><a href=\"#4、邻接表\" class=\"headerlink\" title=\"4、邻接表\"></a>4、邻接表</h3><p>数组与链表相结合的存储方法称为邻接表 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息 图中每个顶点 vi 的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点 vi 的边表，有向图则称为顶点 vi 作为弧尾的出边表</p>\n<div align=\"center\"><img src=\"/images/hexo_post_179.png\" alt=\"\" width=\"600\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_180.png\" alt=\"\" width=\"600\"></div>\n\n<p>若是有向图，邻接表结构是类似的，但我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度，但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立<strong>一个有向图的逆邻接表，即对每个顶点 vi 都建立一个链接为 vi 为弧头的表</strong> 对于带权值的网图，可以在边表结点定义中再<strong>增加一个 weight 的数据域</strong>，存储权值信息即可</p>\n<h3 id=\"5、图的遍历\"><a href=\"#5、图的遍历\" class=\"headerlink\" title=\"5、图的遍历\"></a>5、图的遍历</h3><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）</p>\n<h3 id=\"6、深度优先遍历（DFS）\"><a href=\"#6、深度优先遍历（DFS）\" class=\"headerlink\" title=\"6、深度优先遍历（DFS）\"></a>6、深度优先遍历（DFS）</h3><p>从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止</p>\n<h3 id=\"7、广度优先遍历（BFS）\"><a href=\"#7、广度优先遍历（BFS）\" class=\"headerlink\" title=\"7、广度优先遍历（BFS）\"></a>7、广度优先遍历（BFS）</h3><p>如果说<strong>图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历</strong>了，如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_181.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"8、图的两种遍历方式的比较\"><a href=\"#8、图的两种遍历方式的比较\" class=\"headerlink\" title=\"8、图的两种遍历方式的比较\"></a>8、图的两种遍历方式的比较</h3><p>两者在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同，可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过，深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>\n<h3 id=\"9、最小生成树\"><a href=\"#9、最小生成树\" class=\"headerlink\" title=\"9、最小生成树\"></a>9、最小生成树</h3><p>我们把构造连通网的最小代价生成树称为<strong>最小生成树</strong>（Minimum Cost Spanning Tree）<br>找连通网的最小生成树，经典的有两种算法，<strong>普利姆算法</strong>和<strong>克鲁斯卡尔算法</strong></p>\n<h3 id=\"10、普利姆（Prim）算法\"><a href=\"#10、普利姆（Prim）算法\" class=\"headerlink\" title=\"10、普利姆（Prim）算法\"></a>10、普利姆（Prim）算法</h3><h4 id=\"算法思路：\"><a href=\"#算法思路：\" class=\"headerlink\" title=\"算法思路：\"></a>算法思路：</h4><p>以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</p>\n<h4 id=\"算法步骤：\"><a href=\"#算法步骤：\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><ol>\n<li>输入：一个加权连通图，其中顶点集合为 V，边集合为 E；</li>\n<li>初始化：Vnew = {x}，其中 x 为集合 V 中的任一节点（起始点），Enew = {}，为空；</li>\n<li>重复下列操作，直到 Vnew = V：</li>\n</ol>\n<ul>\n<li>在集合 E 中选取权值最小的边 <code>&lt;u, v&gt;</code>，其中 u 为集合 Vnew 中的元素，而 v 不在 <code>Vnew</code> 集合当中，并且 v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</li>\n<li>将 v 加入集合 Vnew 中，将 <code>&lt;u, v&gt;</code> 边加入集合 Enew 中；</li>\n</ul>\n<ol start=\"4\">\n<li>输出：使用集合 Vnew 和 Enew 来描述所得到的最小生成树。</li>\n</ol>\n<p>书中有非常详尽的解释，但是感觉解释的比较繁琐，建议去看一下<a href=\"http://baike.baidu.com/link?url=9SZQiA3Zm97fe1rIVtGuUCX0FszUTNnk2Qv5XwbPNZpFvjKgRfCL5PnqfPrEo2RdJQo1Asw2bdQx4RujLJL78X8AbfsvN6TUbVKl7w8a2CNQEADeXcqZydK4wrEmYFXybxEKUnpa83ksvSxsJS-zSbyMgjt-9r5Zx3aMquBsMJ26Qj_m2irhgVvsJsxw0QB8\" target=\"_blank\" rel=\"noopener\">百度百科</a>中的讲解</p>\n<h3 id=\"11、克鲁斯卡尔（Kruskal）算法\"><a href=\"#11、克鲁斯卡尔（Kruskal）算法\" class=\"headerlink\" title=\"11、克鲁斯卡尔（Kruskal）算法\"></a>11、克鲁斯卡尔（Kruskal）算法</h3><h4 id=\"算法思路：-1\"><a href=\"#算法思路：-1\" class=\"headerlink\" title=\"算法思路：\"></a>算法思路：</h4><p>因为权值是在边上，所以直接去找最小权值的边来构建生成树，只不过构建时要考虑是否会形成环路而已</p>\n<h4 id=\"算法步骤：-1\"><a href=\"#算法步骤：-1\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><p>先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。关于这个算法，百度百科上的讲解就不是很清楚了，如果感兴趣的话可以自行查阅其他资料</p>\n<h3 id=\"12、Prim-算法和-Kruskal-算法的对比\"><a href=\"#12、Prim-算法和-Kruskal-算法的对比\" class=\"headerlink\" title=\"12、Prim 算法和 Kruskal 算法的对比\"></a>12、Prim 算法和 Kruskal 算法的对比</h3><p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以堆于稀疏图有很大的优势；而普利姆算法对于稠密图，即边数非常多的情况会更好一些</p>\n<h3 id=\"13、最短路径\"><a href=\"#13、最短路径\" class=\"headerlink\" title=\"13、最短路径\"></a>13、最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点 主要有两种求最短路径的算法：迪杰斯特拉算法和</p>\n<h3 id=\"14、迪杰斯特拉（Dijkstra）算法\"><a href=\"#14、迪杰斯特拉（Dijkstra）算法\" class=\"headerlink\" title=\"14、迪杰斯特拉（Dijkstra）算法\"></a>14、迪杰斯特拉（Dijkstra）算法</h3><h4 id=\"算法步骤：-2\"><a href=\"#算法步骤：-2\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><p>G = {V,E}</p>\n<ol>\n<li>初始时令 S = {V0}, T = V - S = {其余顶点}，T 中顶点对应的距离值</li>\n</ol>\n<p>若存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 &lt;V0,Vi&gt; 弧上的权值</p>\n<p>若不存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 ∞</p>\n<ol start=\"2\">\n<li><p>从 T 中选取一个与 S 中顶点有关联边且权值最小的顶点 W，加入到 S 中</p>\n</li>\n<li><p>对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值</p>\n</li>\n</ol>\n<p>重复上述步骤 2、3，直到 S 中包含所有顶点，即 W = Vi 为止</p>\n<h3 id=\"15、弗洛伊德（Floyd）算法\"><a href=\"#15、弗洛伊德（Floyd）算法\" class=\"headerlink\" title=\"15、弗洛伊德（Floyd）算法\"></a>15、弗洛伊德（Floyd）算法</h3><h4 id=\"算法步骤：-3\"><a href=\"#算法步骤：-3\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><ol>\n<li><p>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</p>\n</li>\n<li><p>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</p>\n</li>\n</ol>\n<p>把图用邻接矩阵 G 表示出来，如果从 Vi 到 Vj 有路可达，则 G[i][j] = d，d 表示该路的长度；否则 G[i][j] = 无穷大。定义一个矩阵D用来记录所插入点的信息，D[i][j] 表示从 Vi 到 Vj 需要经过的点，初始化 D[i][j] = j。把各个顶点插入图中，比较插点后的距离与原来的距离，G[i][j] = min( G[i][j], G[i][k]+G[k][j])，如果 G[i][j] 的值变小，则 D[i][j] = k。在 G 中包含有两点之间最短道路的信息，而在 D 中则包含了最短通路径的信息。</p>\n<p>比如，要寻找从 V5 到 V1 的路径。根据 D，假如 D(5,1) = 3 则说明从 V5 到 V1 经过 V3，路径为 {V5,V3,V1}，如果 D(5,3)=3，说明 V5 与 V3 直接相连，如果 D(3,1) = 1，说明 V3 与 V1 直接相连。</p>\n<h3 id=\"16、拓扑排序\"><a href=\"#16、拓扑排序\" class=\"headerlink\" title=\"16、拓扑排序\"></a>16、拓扑排序</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 <strong>AOV 网</strong>（Activity On Vertex Network）<br><strong>拓扑序列</strong>：设 G = (V,E)是一个具有 n 个顶点的有向图，V 中的顶点序列 V1，V2，……，Vn，满足若从顶点 Vi 到 Vj 有一条路径，则在顶点序列中顶点 Vi 必在顶点 Vj 之前。则我们称这样的顶点序列为一个<strong>拓扑序列</strong><br><strong>拓扑排序</strong>：其实就是对一个有向图构造拓扑序列的过程；构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的 AOV 网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是 AOV 网。</p>\n<h3 id=\"17、拓扑排序算法\"><a href=\"#17、拓扑排序算法\" class=\"headerlink\" title=\"17、拓扑排序算法\"></a>17、拓扑排序算法</h3><p><strong>对 AOV 网进行拓扑排序的基本思路</strong>是：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止</p>\n<h3 id=\"18、关键路径\"><a href=\"#18、关键路径\" class=\"headerlink\" title=\"18、关键路径\"></a>18、关键路径</h3><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为 <strong>AOE 网</strong>（Activity On Edge Network）；我们把 AOE 网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点；正常情况下，AOE 网只有一个源点一个汇点，我们把路径上各个活动所持续的时间之和称为<strong>路径长度</strong>，从源点到汇点具有最大长度的路径叫<strong>关键路径</strong>，在关键路径上的活动叫<strong>关键活动</strong></p>\n<h3 id=\"19、关键路径算法\"><a href=\"#19、关键路径算法\" class=\"headerlink\" title=\"19、关键路径算法\"></a>19、关键路径算法</h3><p>原理：我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。为此，我们需要定义如下几个参数：</p>\n<ol>\n<li>事件的<strong>最早发生时间etv</strong>（earliest time of vertex）：即顶点 Vk 的最早发生时间</li>\n<li>事件的<strong>最晚发生时间ltv</strong>（latest time of vertex）：即顶点 Vk 的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期</li>\n<li>活动的<strong>最早开工时间ete</strong>（earliest time of edge）：即弧 ak 的最早发生时间</li>\n<li>活动的<strong>最晚开工时间lte</strong>（latest time of edge）：即弧 ak 的最晚发生时间，也就是不推迟工期的最晚开工时间</li>\n</ol>\n<p>我们是由 1 和 2 可以求得 3 和 4，然后再根据 ete[k] 是否与 lte[k] 相等来判断 ak 是否是关键活动</p>\n<h3 id=\"20、世界上最遥远的距离……\"><a href=\"#20、世界上最遥远的距离……\" class=\"headerlink\" title=\"20、世界上最遥远的距离……\"></a>20、世界上最遥远的距离……</h3><blockquote>\n<p>世界上最遥远的距离，不是从南极到北极，而是我在讲解算法为何如此精妙，你却能够安详在课堂上休息。<br>世界上最遥远的距离，不是珠峰与马里亚纳海沟的距离，而是我欲把古人的智慧全盘给你，你却不屑一顾毫不怜惜。<br>世界上最遥远的距离，不是牛 A 与牛 C 之间狭小空隙，而是你们当中，有人在通往牛逼的路上一路狂奔，而有人步入大学校园就学会放弃。</p>\n</blockquote>\n<h3 id=\"七、查找\"><a href=\"#七、查找\" class=\"headerlink\" title=\"七、查找\"></a>七、查找</h3><h4 id=\"1、查找概论\"><a href=\"#1、查找概论\" class=\"headerlink\" title=\"1、查找概论\"></a>1、查找概论</h4><ul>\n<li><strong>查找表</strong>（Search Table）是由同一类型的数据元素（或记录）构成的集合</li>\n<li><strong>关键字</strong>（Key）是数据元素中某个数据项的值，又称为<strong>键值</strong></li>\n<li>若此关键字可以唯一地标识一个记录，则称此关键字为<strong>主关键字</strong>（Primary Key）</li>\n<li>那些可以识别多个数据元素（或记录）的关键字，我们称为<strong>次关键字</strong>（Secondary Key）</li>\n<li><strong>查找</strong>（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值得数据元素（或记录）</li>\n</ul>\n<h4 id=\"2、查找表操作方式\"><a href=\"#2、查找表操作方式\" class=\"headerlink\" title=\"2、查找表操作方式\"></a>2、查找表操作方式</h4><p>分为两大种：静态查找表和动态查找表 <strong>静态查找表</strong>（Static Search Table）：只作查找操作的查找表。它的主要操作有：</p>\n<ul>\n<li>查询某个“特定的”数据元素是否在查找表中</li>\n<li>检索某个“特定的”数据元素和各种属性</li>\n</ul>\n<p><strong>动态查找表</strong>（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：</p>\n<ul>\n<li>查找时插入数据元素</li>\n<li>查找时删除数据元素</li>\n</ul>\n<h4 id=\"3、顺序查找\"><a href=\"#3、顺序查找\" class=\"headerlink\" title=\"3、顺序查找\"></a>3、顺序查找</h4><p>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是： 从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</p>\n<h3 id=\"4、二分查找\"><a href=\"#4、二分查找\" class=\"headerlink\" title=\"4、二分查找\"></a>4、二分查找</h3><p>折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是： 在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</p>\n<h4 id=\"5、插值查找\"><a href=\"#5、插值查找\" class=\"headerlink\" title=\"5、插值查找\"></a>5、插值查找</h4><p>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])，对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多</p>\n<h3 id=\"6、斐波那契查找算法\"><a href=\"#6、斐波那契查找算法\" class=\"headerlink\" title=\"6、斐波那契查找算法\"></a>6、斐波那契查找算法</h3><h4 id=\"算法核心：\"><a href=\"#算法核心：\" class=\"headerlink\" title=\"算法核心：\"></a>算法核心：</h4><ol>\n<li>当 key = a[mid] 时，查找就成功</li>\n<li>当 key &lt; a[mid] 时，新范围是第 low 个到第 mid - 1 个，此时范围个数为 F[k-1] - 1 个</li>\n<li>当 key &gt; a[mid] 时，新范围是第 m + 1 个到第 high 个，此时范围个数为 F[k-2] - 1 个</li>\n</ol>\n<h3 id=\"7、三种查找算法的比较\"><a href=\"#7、三种查找算法的比较\" class=\"headerlink\" title=\"7、三种查找算法的比较\"></a>7、三种查找算法的比较</h3><p>折半查找是进行加法与除法运算 (mid = (low + high) / 2)，插值查找进行复杂的四则运算(mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]))，而斐波那契查找只是最简单加减法运算(mid = low + F[k-1] - 1)，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率</p>\n<h3 id=\"8、线性索引\"><a href=\"#8、线性索引\" class=\"headerlink\" title=\"8、线性索引\"></a>8、线性索引</h3><p><strong>索引</strong>就是把一个关键字与它对应的记录相关联的过程 所谓<strong>线性索引</strong>就是将索引项集合组织为线性结构，也称为<strong>索引表</strong> 三种线性索引：稠密索引、分块索引和倒排索引</p>\n<h3 id=\"9、稠密索引\"><a href=\"#9、稠密索引\" class=\"headerlink\" title=\"9、稠密索引\"></a>9、稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</p>\n<div align=\"center\"><img src=\"/images/hexo_post_182.png\" alt=\"\" width=\"400\"></div>\n\n<p>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列 索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率</p>\n<h3 id=\"10、分块索引\"><a href=\"#10、分块索引\" class=\"headerlink\" title=\"10、分块索引\"></a>10、分块索引</h3><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p>\n<ul>\n<li><strong>块内无序</strong>：当然如果能够让块内有序对查找来说更理想</li>\n<li><strong>块间有序</strong>：只有块间有序，才有可能在查找时带来效率</li>\n</ul>\n<h4 id=\"分块索引的索引项结构分三个数据项：\"><a href=\"#分块索引的索引项结构分三个数据项：\" class=\"headerlink\" title=\"分块索引的索引项结构分三个数据项：\"></a>分块索引的索引项结构分三个数据项：</h4><ul>\n<li><strong>最大关键码</strong>，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>\n<li>存储了<strong>块中的记录个数</strong>，以便于循环时使用</li>\n<li>用于<strong>指向块首数据元素的指针</strong>，便于开始对这一块中记录进行遍历</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_183.png\" alt=\"\" width=\"400\"></div>\n\n<h4 id=\"分块索引表中查找的步骤：\"><a href=\"#分块索引表中查找的步骤：\" class=\"headerlink\" title=\"分块索引表中查找的步骤：\"></a>分块索引表中查找的步骤：</h4><ol>\n<li>在分块索引表中查找要查关键字所在的块，可以利用折半、插值等算法</li>\n<li>根据块首指针找到响应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找</li>\n</ol>\n<h3 id=\"11、倒排索引\"><a href=\"#11、倒排索引\" class=\"headerlink\" title=\"11、倒排索引\"></a>11、倒排索引</h3><p>记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index） 倒排索引的优点就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长</p>\n<h3 id=\"12、二叉排序树\"><a href=\"#12、二叉排序树\" class=\"headerlink\" title=\"12、二叉排序树\"></a>12、二叉排序树</h3><p>二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>\n<li>它的左、右子树也分别为二叉排序树</li>\n</ul>\n<p>如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。</p>\n<h3 id=\"13、平衡二叉树\"><a href=\"#13、平衡二叉树\" class=\"headerlink\" title=\"13、平衡二叉树\"></a>13、平衡二叉树</h3><p>平衡二叉树（Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于 1；我们将二叉树上结点的左子树深度减去右子树深度的值称为<strong>平衡因子</strong>BF（Balance Factor），那么平衡二叉树上所有结点的平衡因子只可能是 -1，0，1</p>\n<h3 id=\"14、最小不平衡子树\"><a href=\"#14、最小不平衡子树\" class=\"headerlink\" title=\"14、最小不平衡子树\"></a>14、最小不平衡子树</h3><p>距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，我们称为<strong>最小不平衡子树</strong></p>\n<div align=\"center\"><img src=\"/images/hexo_post_184.png\" alt=\"\" width=\"400\"></div>\n\n<p>如上图所示，当新插入结点 37 时，距离它最近的平衡因子绝对值超过 1 的结点是 58（即它的左子树高度 2 减去右子树高度 0），所以从 58 开始以下的子树为最小不平衡子树</p>\n<h3 id=\"15、平衡二叉树实现算法\"><a href=\"#15、平衡二叉树实现算法\" class=\"headerlink\" title=\"15、平衡二叉树实现算法\"></a>15、平衡二叉树实现算法</h3><h4 id=\"算法原理：\"><a href=\"#算法原理：\" class=\"headerlink\" title=\"算法原理：\"></a>算法原理：</h4><p>基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应地旋转，使之成为新的平衡子树</p>\n<h4 id=\"右旋操作：\"><a href=\"#右旋操作：\" class=\"headerlink\" title=\"右旋操作：\"></a>右旋操作：</h4><div align=\"center\"><img src=\"/images/hexo_post_185.png\" alt=\"\" width=\"500\"></div>\n\n<p>左旋和右旋代码是对称的</p>\n<h3 id=\"16、多路查找树\"><a href=\"#16、多路查找树\" class=\"headerlink\" title=\"16、多路查找树\"></a>16、多路查找树</h3><p>多路查找树（multi-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</p>\n<h3 id=\"17、2-3-树\"><a href=\"#17、2-3-树\" class=\"headerlink\" title=\"17、2-3 树\"></a>17、2-3 树</h3><p>2-3 树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）。</p>\n<ul>\n<li>一个 2 结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似</li>\n<li>一个 3 结点包含一小一大两个元素和三个孩子（或没有孩子），左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素</li>\n<li>2-3 树中所有的叶子都在同一层次上</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_186.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"18、2-3树的插入实现\"><a href=\"#18、2-3树的插入实现\" class=\"headerlink\" title=\"18、2-3树的插入实现\"></a>18、2-3树的插入实现</h3><p>可分为三种情况：</p>\n<ol>\n<li>对于空树，插入一个 2 结点即可，这很容易理解</li>\n<li>插入结点到一个 2 结点的叶子上。由于其本身就只有一个元素，所以只需要将其升级为 3 结点即可</li>\n<li>要往 3 结点中插入一个新元素。因为 3 结点本身已经是 2-3 树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</li>\n</ol>\n<h3 id=\"19、2-3-4树\"><a href=\"#19、2-3-4树\" class=\"headerlink\" title=\"19、2-3-4树\"></a>19、2-3-4树</h3><p>就是 2-3 树的概念扩展，包括了 4 结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个 4 结点要么没有孩子，要么具有 4 个孩子。如果某个 4 结点有孩子的话，从左到右按照由小到大的顺序排列</p>\n<h3 id=\"20、B树\"><a href=\"#20、B树\" class=\"headerlink\" title=\"20、B树\"></a>20、B树</h3><p>B树（B-tree）是一种平衡的多路查找树，2-3树和 2-3-4树都是 B树的特例。结点最大的孩子数目称为 <strong>B树的阶</strong>（order），因此，2-3树是 3 阶 B树，2-3-4树是 4 阶 B树</p>\n<h4 id=\"一个-m-阶的-B-树具有如下属性：\"><a href=\"#一个-m-阶的-B-树具有如下属性：\" class=\"headerlink\" title=\"一个 m 阶的 B 树具有如下属性：\"></a>一个 m 阶的 B 树具有如下属性：</h4><ul>\n<li>如果根结点不是叶节点，则其至少有两棵子树</li>\n<li>每一个非根的分支结点都有 k-1 个元素和k个孩子，其中 ⌈m/2⌉ ≤ k ≤ m。每一个叶子节点 n 都有 k - 1 个元素，其中 ⌈m/2⌉ ≤ k ≤m</li>\n<li>所有叶子结点都位于同一层次</li>\n<li>所有分支结点包含下列信息数据（n,A0,K1,A1,K2,A2,…,Kn,An），其中：Ki(i=1,2,…,n) 为关键字，且 Ki&lt;Ki+1(i=1,2,…,n-1)；Ai(i=0,2,…,n) 为指向子树根结点的指针，且指针 A(i-1) 所指子树中所有结点的关键字均小于 Ki(i=1,2,…,n),An 所指子树中所有结点的关键字均大于 Kn，n·(⌈m/2⌉-1≤n≤m-1) 为关键字的个数（或 n + 1 为子树的个数）</li>\n</ul>\n<h3 id=\"21、B-树\"><a href=\"#21、B-树\" class=\"headerlink\" title=\"21、B+树\"></a>21、B+树</h3><p>在 B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子节点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针</p>\n<div align=\"center\"><img src=\"/images/hexo_post_187.png\" alt=\"\" width=\"400\"></div>\n\n<p>一棵 m 阶的 B+树和 m 阶的 B树的差异在于：</p>\n<ul>\n<li>有 n 棵子树的结点中包含有 n 个关键字</li>\n<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</li>\n<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字</li>\n</ul>\n<p>如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是沿着指向下一叶子结点的指针就可遍历所有的关键字</p>\n<h3 id=\"22、散列表（哈希表）\"><a href=\"#22、散列表（哈希表）\" class=\"headerlink\" title=\"22、散列表（哈希表）\"></a>22、散列表（哈希表）</h3><p><strong>散列技术</strong>是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)，散列技术既是一种存储方法，也是一种查找方法<br>散列技术最适合的求解问题是查找与给定值相等的记录 f称为散列函数，又称为<strong>哈希（Hash）函数</strong><br>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为<strong>散列表或哈希表</strong>（Hash table）</p>\n<h4 id=\"散列过程有两步：\"><a href=\"#散列过程有两步：\" class=\"headerlink\" title=\"散列过程有两步：\"></a>散列过程有两步：</h4><ol>\n<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录</li>\n<li>当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录</li>\n</ol>\n<h3 id=\"23、散列函数构造方法\"><a href=\"#23、散列函数构造方法\" class=\"headerlink\" title=\"23、散列函数构造方法\"></a>23、散列函数构造方法</h3><h4 id=\"直接定址法\"><a href=\"#直接定址法\" class=\"headerlink\" title=\"直接定址法\"></a>直接定址法</h4><p>取关键字的某个线性函数值为散列地址</p>\n<h4 id=\"数字分析法\"><a href=\"#数字分析法\" class=\"headerlink\" title=\"数字分析法\"></a>数字分析法</h4><p>如果我们的关键字是位数较多的数字，可以对数字进行翻转、右环位移、左环位移、甚至前两数与后两数叠加等方法，合理地将关键字分配到散列表的各位置</p>\n<h4 id=\"平方取中法\"><a href=\"#平方取中法\" class=\"headerlink\" title=\"平方取中法\"></a>平方取中法</h4><p>假设关键字是 1234，那么它的平方就是 1522756，再抽取中间的 3 位就是 227，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况</p>\n<h4 id=\"折叠法\"><a href=\"#折叠法\" class=\"headerlink\" title=\"折叠法\"></a>折叠法</h4><p>将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况 比如我们的关键字是 9876543210，散列表表长为三位，我们将它分为四组，987|654|321|0，然后将它们叠加求和 987 + 654 + 321 + 0 = 1962，再求后 3 位得到散列地址为 962。</p>\n<h4 id=\"除留余数法\"><a href=\"#除留余数法\" class=\"headerlink\" title=\"除留余数法\"></a>除留余数法</h4><p>对关键字直接取模，也可在折叠、平方取中后再取模，对于散列表长为 m 的散列函数公式为：</p>\n<blockquote>\n<p>f(key)=key mod p(p≤m)</p>\n</blockquote>\n<p>根据前辈们的经验，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m）的最小质数或不包含小于 20 质因子的合数</p>\n<h4 id=\"随机数法\"><a href=\"#随机数法\" class=\"headerlink\" title=\"随机数法\"></a>随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址</p>\n<h3 id=\"24、采用不同的散列函数应该考虑的因素\"><a href=\"#24、采用不同的散列函数应该考虑的因素\" class=\"headerlink\" title=\"24、采用不同的散列函数应该考虑的因素\"></a>24、采用不同的散列函数应该考虑的因素</h3><ul>\n<li>计算散列地址所需的时间</li>\n<li>关键字的长度</li>\n<li>散列表的大小</li>\n<li>关键字的分布情况</li>\n<li>记录查找的频率</li>\n</ul>\n<h3 id=\"25、处理散列冲突的方法\"><a href=\"#25、处理散列冲突的方法\" class=\"headerlink\" title=\"25、处理散列冲突的方法\"></a>25、处理散列冲突的方法</h3><h4 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h4><p>一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入，公式是：</p>\n<blockquote>\n<p>fi(key)=（f(key)+di）MOD m(di=1,2,3,……,m-1)</p>\n</blockquote>\n<p>这种解决冲突的开放定址法称为<strong>线性探测法</strong><br>如果 di 改进为正负两类值，等于是可以双向寻找到可能的空位置，可以不让关键字都聚集在某一块区域。我们称这种方法为<strong>二次探测法</strong><br>如果 di 采用随机函数计算得到，我们称之为<strong>随机探测法</strong></p>\n<h4 id=\"再散列函数法\"><a href=\"#再散列函数法\" class=\"headerlink\" title=\"再散列函数法\"></a>再散列函数法</h4><p>我们事先准备多个散列函数，每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉</p>\n<h4 id=\"链地址法\"><a href=\"#链地址法\" class=\"headerlink\" title=\"链地址法\"></a>链地址法</h4><p>将所有关键字为同义词的记录存储在一个单链表红，我们称这种表尾同义词子表，在散列表中只存储所有同义词子表的头指针</p>\n<h4 id=\"公共溢出区法\"><a href=\"#公共溢出区法\" class=\"headerlink\" title=\"公共溢出区法\"></a>公共溢出区法</h4><p>凡是冲突的都将它们存储到溢出表中</p>\n<h2 id=\"八、排序\"><a href=\"#八、排序\" class=\"headerlink\" title=\"八、排序\"></a>八、排序</h2><p>关于排序，推荐我的另一篇文章：<a href=\"/20170318/js-implementation-of-ten-sorting-algorithms.html\">\b十大排序算法的Javascript实现</a>，这篇文章里有一些常见排序算法的实现步骤以及演示，是一个比较好的排序算法讲解</p>\n<h2 id=\"九、总结\"><a href=\"#九、总结\" class=\"headerlink\" title=\"九、总结\"></a>九、总结</h2><h3 id=\"1、数据结构和算法\"><a href=\"#1、数据结构和算法\" class=\"headerlink\" title=\"1、数据结构和算法\"></a>1、数据结构和算法</h3><p>数据结构和算法对于程序员的职业人生来说，那就是两个圆圈的交集部分，用心去掌握它，你的编程之路将会是坦途</p>\n<div align=\"center\"><img src=\"/images/hexo_post_188.png\" alt=\"\" width=\"350\"></div>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]},{"title":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","slug":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","date":"2017-04-06T09:17:52.000Z","updated":"2019-02-02T10:19:58.054Z","comments":true,"path":"api/articles/读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_297.png","content":"<h2 id=\"1-一句话概括响应式设计\"><a href=\"#1-一句话概括响应式设计\" class=\"headerlink\" title=\"1. 一句话概括响应式设计\"></a>1. 一句话概括响应式设计</h2><p>如果要用一句话概括响应式网页设计，我觉得它是针对任意设备对网页内容进行完美布局的一种显示机制.相反，如果需要根据不同设备提供特定的内容和功能，那就需要一个真正的“手机版”网站.这种情况下，手机版网站会提供与桌面版网站完全不同的用户体验.</p>\n<h2 id=\"2-CSS-reset-网站\"><a href=\"#2-CSS-reset-网站\" class=\"headerlink\" title=\"2. CSS reset 网站\"></a>2. CSS reset 网站</h2><ul>\n<li><a href=\"http://meyerweb.com/eric/tools/css/reset/\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/css/reset/</a>，Eric Meyer的原版，主要针对HTML4</li>\n<li><a href=\"http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/</a>，针对HTML5</li>\n</ul>\n<h2 id=\"3-CSS-网格系统\"><a href=\"#3-CSS-网格系统\" class=\"headerlink\" title=\"3. CSS 网格系统\"></a>3. CSS 网格系统</h2><div align=\"center\"><img src=\"/images/hexo_post_297.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"4-地标角色属性\"><a href=\"#4-地标角色属性\" class=\"headerlink\" title=\"4. 地标角色属性\"></a>4. 地标角色属性</h2><p>role=”” 针对文档结构的各部分分别有如下的地标角色：</p>\n<ul>\n<li>application：用来定义用作网页应用的区域；</li>\n<li>banner：用来定义一个站点级别(而不是某个特定文档的)的区域.如网站的头部和logo；</li>\n<li>complementary：一个对页面主要区域进行补充说明的区域；</li>\n<li>contentinfo：与页面主要内容相关的信息区域，例如页脚的网站版权信息区域；</li>\n<li>form：定义表单，但是如果表单用于搜索，请使用search来替代；</li>\n<li>main：页面的主体内容；</li>\n<li>navigation：链向当前文档或相关文档的导航链接；</li>\n<li>search：一个用于搜索的区域。</li>\n</ul>\n<h2 id=\"5-导航栏使用-table-显示模式\"><a href=\"#5-导航栏使用-table-显示模式\" class=\"headerlink\" title=\"5. 导航栏使用 table 显示模式\"></a>5. 导航栏使用 table 显示模式</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-row;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做可以保证如果有另外的列表项追加进来，同样会自动地调整它们之间的间距。最后，使用 CSS3 选择器将最后一个列表项的文字置为右对齐，将第一个列表项的文字置为左对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:last-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-在响应式设计中使用自定义-font-face-字体的注意事项\"><a href=\"#6-在响应式设计中使用自定义-font-face-字体的注意事项\" class=\"headerlink\" title=\"6. 在响应式设计中使用自定义 @font-face 字体的注意事项\"></a>6. 在响应式设计中使用自定义 @font-face 字体的注意事项</h2><p>唯一需要注意的，是在响应式设计中使用该技术时要考虑到字体文件大小。有些字体可能会非常庞大，如果你想保持网站的高性能，请注意控制自定义字体的文件尺寸。</p>\n<h2 id=\"7-浮雕文字效果\"><a href=\"#7-浮雕文字效果\" class=\"headerlink\" title=\"7. 浮雕文字效果\"></a>7. 浮雕文字效果</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 1<span class=\"selector-tag\">px</span> 0 <span class=\"selector-tag\">hsla</span>(0， 0%， 100%， 0<span class=\"selector-class\">.75</span>);</span><br></pre></td></tr></table></figure>\n<p>不要模糊，不要水平阴影，仅在垂直方向设置 1 或 2 像素的”白影”即可。</p>\n<h2 id=\"8-让整个屏幕飞舞\"><a href=\"#8-让整个屏幕飞舞\" class=\"headerlink\" title=\"8. 让整个屏幕飞舞\"></a>8. 让整个屏幕飞舞</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123; <span class=\"attribute\">transition</span>: all <span class=\"number\">1s</span>; &#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_298.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"9-CSS3-实现-3D-变形效果\"><a href=\"#9-CSS3-实现-3D-变形效果\" class=\"headerlink\" title=\"9. CSS3 实现 3D 变形效果\"></a>9. CSS3 实现 3D 变形效果</h2><h3 id=\"在父级元素上设置透视，这样就开启了-3D-场景\"><a href=\"#在父级元素上设置透视，这样就开启了-3D-场景\" class=\"headerlink\" title=\"在父级元素上设置透视，这样就开启了 3D 场景\"></a>在父级元素上设置透视，这样就开启了 3D 场景</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123; <span class=\"attribute\">-webkit-perspective</span>: <span class=\"number\">200</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>透视的值越大，就表示你的视点与 3D 场景之间的景深越大。因此，如果想要一点隐约的 3D 效果，就增大透视值；如果想要非常明显的 3D 效果，则减小透视值。</p>\n<h3 id=\"延续父元素的透视\"><a href=\"#延续父元素的透视\" class=\"headerlink\" title=\"延续父元素的透视\"></a>延续父元素的透视</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son</span>&#123; <span class=\"attribute\">-webkit-transform-style</span>: perserve-<span class=\"number\">3</span>d; <span class=\"attribute\">-webkit-transition</span>: <span class=\"number\">1s</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>.father 类中添加的透视声明只会应用到其第一个子元素上。因此，为了延续父元素的透视，我们给 .son 元素设定了 preserve-3d (这样可以设置一个 3D 场景)。</p>\n<h3 id=\"当鼠标悬停在-father-模块上时，我们给-son-这个-div-添加一个翻转效果\"><a href=\"#当鼠标悬停在-father-模块上时，我们给-son-这个-div-添加一个翻转效果\" class=\"headerlink\" title=\"当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果\"></a>当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.son</span>&#123; <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"当海报翻转之后隐藏在其背面内容\"><a href=\"#当海报翻转之后隐藏在其背面内容\" class=\"headerlink\" title=\"当海报翻转之后隐藏在其背面内容\"></a>当海报翻转之后隐藏在其背面内容</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.face</span> &#123; <span class=\"attribute\">position</span>: absolute; <span class=\"attribute\">-webkit-backface-visibility</span>: hidden; &#125;</span><br></pre></td></tr></table></figure>\n<p>.face 必须使用绝对定位，这样海报才能盖在 .back 这个 div 的上面</p>\n<h3 id=\"给-back-加上-rotateY\"><a href=\"#给-back-加上-rotateY\" class=\"headerlink\" title=\"给 .back 加上 rotateY\"></a>给 .back 加上 rotateY</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.back</span> &#123; <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg); &#125;</span><br></pre></td></tr></table></figure>\n<p>不加这句的话，.back 这个 div 就会显示在正面海报之上。最终的 HTML 结构以及 CSS 样式如下:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"Qcontainer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"film\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"face front\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/goonies.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"The Goonies\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"face back\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>HOT!<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.Qcontainer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">28%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-perspective</span>: <span class=\"number\">800</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">2%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.film</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">15em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transition</span>: <span class=\"number\">1s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.Qcontainer</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.film</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.face</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-backface-visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.back</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">66%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">127%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg);</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#3b3b3b</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(top，</span><br><span class=\"line\">  rgba(0，0，0，0.65) <span class=\"number\">0%</span>，</span><br><span class=\"line\">  <span class=\"built_in\">rgba</span>(0，0，0，0) <span class=\"number\">100%</span>);</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">15%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-list-及对应的-datalist-元素\"><a href=\"#10-list-及对应的-datalist-元素\" class=\"headerlink\" title=\"10. list(及对应的 datalist 元素)\"></a>10. list(及对应的 datalist 元素)</h2><p>list 属性以及对应的 datalist 元素可以让用户在输入框中开始输入值的时候，显示一组备选值。下面是一个包含在 div 中的使用 list 属性及对应 datalist 元素的代码示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"awardWon\"</span>&gt;</span>Award Won<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"awardWon\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"awardWon\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">list</span>=<span class=\"string\">\"awards\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">datalist</span> <span class=\"attr\">id</span>=<span class=\"string\">\"awards\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Picture\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Director\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Adapted Screenplay\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Original Screenplay\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">datalist</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>list 属性中的值（awards）同时也是 datalist 元素的 id。这样就可以让 datalist 与输入项关联起来。虽然将 option 包裹在 select 中不是必需的，但这样做便于为老版本浏览器提供降级方案。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_299.png\" alt=\"\" width=\"550\"></div>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"HTML","path":"api/tags/HTML.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","slug":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","date":"2017-04-06T08:42:13.000Z","updated":"2019-02-02T10:19:58.054Z","comments":true,"path":"api/articles/读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_300.png","content":"<h2 id=\"1-Web-标准——结构、样式和行为的分离\"><a href=\"#1-Web-标准——结构、样式和行为的分离\" class=\"headerlink\" title=\"1. Web 标准——结构、样式和行为的分离\"></a>1. Web 标准——结构、样式和行为的分离</h2><p>Web 标准由一系列标准组合而成，其核心理念就是将网页的结构，样式和行为分离开来，所以它可以分为三大部分：结构标准，央视标准和行为标准。<br>结构标准包括 XML 标准，XHTML 标准，HTML 标准；<br>样式标准主要是指 CSS 标准；<br>行为标准主要包括 DOM 标准和 ECMAScript 标准。</p>\n<h2 id=\"2-打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\"><a href=\"#2-打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\" class=\"headerlink\" title=\"2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\"></a>2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序</h2><p>精简的代码可以让文件变小，有利于客户端快速下载；重用可以让代码更易于精简，同时有助于提升开发速度；有序可以让我们更清晰地组织代码，使代码易于维护，有效应对变化。</p>\n<h2 id=\"3-欲精一行，必先通十行\"><a href=\"#3-欲精一行，必先通十行\" class=\"headerlink\" title=\"3. 欲精一行，必先通十行\"></a>3. 欲精一行，必先通十行</h2><p>在前端开发领域，不通十行就无法精一行。专精很难，甚至不可能，一专多能才是现实的。在前端开发这个领域，一专多能更是非常必要的。</p>\n<h2 id=\"4-增加代码可读性——注释\"><a href=\"#4-增加代码可读性——注释\" class=\"headerlink\" title=\"4.增加代码可读性——注释\"></a>4.增加代码可读性——注释</h2><p>一个好的代码，注释要占 1/3 的篇幅</p>\n<h2 id=\"5-磨刀不误砍柴工——前期的构思很重要\"><a href=\"#5-磨刀不误砍柴工——前期的构思很重要\" class=\"headerlink\" title=\"5. 磨刀不误砍柴工——前期的构思很重要\"></a>5. 磨刀不误砍柴工——前期的构思很重要</h2><p>构思的内容主要包括规范的指定，公共组件的设计和复杂功能的技术方案等。一般来说，前期构思占整个项目 30% ~ 60% 的时间都算是正常的.</p>\n<h2 id=\"6-标签的语义\"><a href=\"#6-标签的语义\" class=\"headerlink\" title=\"6. 标签的语义\"></a>6. 标签的语义</h2><p>HTML 标签的设计都是有语义考虑的。下表是部分标签的全称和中文翻译：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_300.png\" alt=\"\" width=\"600\"></div><br><div align=\"center\"><img src=\"/images/hexo_post_301.png\" alt=\"\" width=\"600\"></div>\n\n<p>其中，<strong>div 和 span 其实是没有语义的</strong>，它们只是分别用作块级元素和行内元素的区域分隔符。事实上，CSS 布局只是 Web 标准的一部分。在 HTML，CSS，JavaScript 这三大元素中，HTML 才是最重要的，结构才是重点，样式是用来修饰结构的。正确的做法是，先确定 HTML，确定语义的标签，再来选用合适的 CSS。</p>\n<h2 id=\"7-如何确定你的标签是否语义良好\"><a href=\"#7-如何确定你的标签是否语义良好\" class=\"headerlink\" title=\"7. 如何确定你的标签是否语义良好\"></a>7. 如何确定你的标签是否语义良好</h2><p>判断网页标签语义是否良好的一个简单方法就是：<strong>去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性</strong>。除了去样式后的可读性外，值得重点提及的还有 h 标签。h 标签的含义是”标题”，搜索引擎对这个标签比较敏感，尤其是 h1 和 h2。一个语义良好的页面，h 标签应该是完整有序没有断层的。也就是说，<strong>要按照 h1，h2，h3，h4 这样依次排列下来，不要出现类似 h1，h2，h3，h4，漏掉 h2 的情况</strong>。</p>\n<h2 id=\"8-常见模块\"><a href=\"#8-常见模块\" class=\"headerlink\" title=\"8. 常见模块\"></a>8. 常见模块</h2><h3 id=\"标题和内容\"><a href=\"#标题和内容\" class=\"headerlink\" title=\"标题和内容\"></a>标题和内容</h3><p>当页面内标签无法满足设计需要时，才会适当添加 div 和 span 等无语义标签来辅助实现。</p>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>登录表单<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"name\"</span>&gt;</span>账号：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"pw\"</span>&gt;</span>密码：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pw\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"登录\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"subBtn\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>一般来说，表单域要用 fieldset 标签包起来，并用 legend 标签说明表单的用途。因为 fieldset 默认有边框，而 legend 也有默认的样式，为满足设计需要，我们可以将 fieldset 的 “border” 设为 “none”，把 legend 的 “display” 设为 “none”，以此来兼顾语义和设计两方面的要求。每个 input 标签对应的说明文本都需要 label1 标签，并且通过为 input 设置 id 属性，在 label 标签中设置 “for=someld” 来让说明文本和相应的 input 关联起来.</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>表格标题要用 caption，表头要用 thead 包围，主体部分用 tbody 包围，尾部要用 tfoot 包围，表头和一般单元格要区分开，表头用 th，一般单元格用 td。</p>\n<h2 id=\"9-语义化标签应注意的一些其他问题\"><a href=\"#9-语义化标签应注意的一些其他问题\" class=\"headerlink\" title=\"9. 语义化标签应注意的一些其他问题\"></a>9. 语义化标签应注意的一些其他问题</h2><p>为了保证网页去样式后的可读性，并且又符合 Web 标准，我们应注意以下几点：</p>\n<ul>\n<li>尽可能少的使用无语义标签 div 和 span；</li>\n<li>在语义不明显，既可以用 p 也可以用 div 的地方，尽量用 p，因为 p 默认情况下有上下间距，去样式后的可读性更好，对兼容特殊终端有利；</li>\n<li>不要使用纯样式标签，例如 b，font 和 u 等，改用 CSS 设置。语义上需要强调的文本可以包在 strong 或 em 标签里，strong 和 em 有”强调”的语意，其中 strong 的默认样式是加粗，而 em 的默认样式是斜体。</li>\n</ul>\n<h2 id=\"10-如何组织-CSS\"><a href=\"#10-如何组织-CSS\" class=\"headerlink\" title=\"10. 如何组织 CSS\"></a>10. 如何组织 CSS</h2><p>一种组织 CSS 的方法：<strong>base.css+common.css+page.css</strong>。将网站内的所有样式，按照职能分成三大类：base，common 和 page。</p>\n<h3 id=\"base-层\"><a href=\"#base-层\" class=\"headerlink\" title=\"base 层\"></a>base 层</h3><p>这一层位于三者的最底层，提供 CSS reset 功能和粒度最小的通用类——原子类。这一层会被所有页面引用，是页面样式所需依赖的最底层。这一层与具体 UI 无关，无论何种风格的设计都可以引用它，所以 base 层要力求精简和通用。base 层具有高度可移植性，不同设计风格的网站可以使用同一个 base 层. base 层相对稳定，基本上不需要维护。</p>\n<h3 id=\"common-层\"><a href=\"#common-层\" class=\"headerlink\" title=\"common 层\"></a>common 层</h3><p>这一层位于中间，提供组件级的 CSS 类。我们可以将页面内的元素拆分成一小块一小块功能和样式相对独立的小”模块”，这些”模块”有些是很少重复的，有些是会大量重复的，我们可以将大量重复的”模块”视为一个组件。我们从页面里尽可能多的将组件提取出来，放在 common 层里。common 层就相当于 MVC 模式中的 M(Model，模型)。为了保证重用性和灵活性，M 需要尽可能将内部实现封装，对可能会经常变化的部分提供灵活的接口。common 层是网站级的，不同的网站有不同的 common 层，同一个网站只有一个 common 层。在团队合作中，common 层最好由一个人负责，统一管理。</p>\n<h3 id=\"page-层\"><a href=\"#page-层\" class=\"headerlink\" title=\"page 层\"></a>page 层</h3><p>网站中高度重用的模块，我们把它们视为组件，放在 common 层；非高度重用的模块，可以把它们放在 page 层。page 层位于最高层，提供页面级的样式，对重用性没有要求。base 层基本上不需要维护，common 层修改的幅度不会很大，通常只由一个人负责维护，但到了 page 层，代码可能由多人开发，如何避免冲突是个需要注意的问题。通常我们通过命名规则来避免这种冲突。</p>\n<h2 id=\"11-推荐的-base-css\"><a href=\"#11-推荐的-base-css\" class=\"headerlink\" title=\"11. 推荐的 base.css\"></a>11. 推荐的 base.css</h2><p>通常情况下，为了让浮动元素的父容器能够根据浮动元素的高度而自适应高度，有三种做法：</p>\n<ul>\n<li>让父容器同时浮动起来，例如：<code>&lt;div class=&quot;fl&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>；</li>\n<li>让浮动元素后面紧跟一个用于清楚浮动的空标签，例如 <code>&lt;div&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;div class=&quot;cb&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>；</li>\n<li><strong>给父容器挂一个特殊 class，直接从父容器清除浮动元素的浮动，例如 <code>&lt;div class=&quot;clearfix&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></strong></li>\n</ul>\n<p><strong>第一种方法会让父容器也浮动起来，影响父元素后面的元素的布局，有副作用；第二种方法增加了一个空标签，破坏了语义化。第三种方法没有任何副作用，推荐使用。</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  <span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:inline-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-拆分模块\"><a href=\"#12-拆分模块\" class=\"headerlink\" title=\"12. 拆分模块\"></a>12. 拆分模块</h2><ul>\n<li>模块与模块之间尽量不要包含相同的部分，如果有相同部分，应将它们提取出来，拆分成一个独立的模块.</li>\n<li>模块应在保证数量尽可能少的原则下，做到尽可能简单，以提高重用性.</li>\n</ul>\n<p>##13. CSS 的命名</p>\n<p>推荐使用英语，不要使用汉语拼音。我们可以根据内容来选用合适的英文单词命名 CSS。比如头部用 head，底部用 foot，主体部分用 main，导航用 nav，菜单用 menu 等，page 层 css 命名不可过短，可以将开发人员名字缩写作为前缀，以免发生冲突。</p>\n<h2 id=\"14-挂多个-class-还是新建-class——多用组合，少用继承\"><a href=\"#14-挂多个-class-还是新建-class——多用组合，少用继承\" class=\"headerlink\" title=\"14. 挂多个 class 还是新建 class——多用组合，少用继承\"></a>14. 挂多个 class 还是新建 class——多用组合，少用继承</h2><p>在面向对象编程里，有个很重要的原则就是”多用组合，少用继承”. HTML 的 class 与程序中”类”有相同的”味道”，class 可以挂多个，从技术上支持了”组合”的用法。我们在使用 CSS 时，如果能灵活运用这点就可以大大减少类的数量，一方面减少了代码量，提高了可维护性，另一方面时类的职责更单一，弹性更强，增加了类的重用性，提高了开发效率。</p>\n<h2 id=\"15-组件的-margin\"><a href=\"#15-组件的-margin\" class=\"headerlink\" title=\"15 .组件的 margin\"></a>15 .组件的 margin</h2><p>如果对相邻的模块同时使用了 margin-top 和 margin-bottom，边距会重合带来不必要的麻烦，所以最好统一使用 margin-top 或者 margin-bottom，不要混合使用，从而降低出现问题的风险。<br>总结：如果不确定模块的上下 margin 特别稳定，最好不要将它写到模块的类里，而是使用类的祝贺，单独为上下 margin 挂用于边距的原子类(例如 mt10，mb20)。模块最好不要混用 margin-top 和 margin-bottom，统一使用 margin-top 或 margin-bottom。</p>\n<h2 id=\"16-低权重原则——避免滥用子选择器\"><a href=\"#16-低权重原则——避免滥用子选择器\" class=\"headerlink\" title=\"16. 低权重原则——避免滥用子选择器\"></a>16. 低权重原则——避免滥用子选择器</h2><p>除非确定 HTML 结构非常稳定，一定不会再修改了，否则尽量不要使用子选择器。为了保证样式容易被覆盖，提高可维护性，CSS 选择符需保证权重尽可能低。</p>\n<h2 id=\"17-CSS-sprit-技术\"><a href=\"#17-CSS-sprit-技术\" class=\"headerlink\" title=\"17. CSS sprit 技术\"></a>17. CSS sprit 技术</h2><p>CSS sprite 技术看似简单，其实不容易掌握，主要有如下原因:</p>\n<ul>\n<li>它能合并的只能是用于背景的图片，对于 <code>&lt;img src=&quot;&quot; /&gt;</code> 设置的图片，是不能合并到 CSS sprite 大图中的，如果合并这些图片会影响页面可读性。</li>\n<li>对于横向和纵向都平铺的图片，也不能使用 CSS sprite；如果是横向平铺的，只能将所有横向平铺的图合并成一张大图，只能竖直排列，不能水平排列；如果是纵向平铺的，我们只能将所有纵向平铺的图合并成一张大图，只能水平排列，不能竖直排列。</li>\n<li>图片如何排列能够尽量紧凑，同时保证不会影响扩展性。这点是 CSS sprite 技术最困难也是最具挑战性的地方。</li>\n</ul>\n<h2 id=\"18-CSS-hack\"><a href=\"#18-CSS-hack\" class=\"headerlink\" title=\"18. CSS hack\"></a>18. CSS hack</h2><h3 id=\"IE-条件注释法\"><a href=\"#IE-条件注释法\" class=\"headerlink\" title=\"IE 条件注释法\"></a>IE 条件注释法</h3><h4 id=\"只在IE下生效\"><a href=\"#只在IE下生效\" class=\"headerlink\" title=\"只在IE下生效\"></a>只在IE下生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE6-下生效\"><a href=\"#只在-IE6-下生效\" class=\"headerlink\" title=\"只在 IE6 下生效\"></a>只在 IE6 下生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE6-以上版本生效\"><a href=\"#只在-IE6-以上版本生效\" class=\"headerlink\" title=\"只在 IE6 以上版本生效\"></a>只在 IE6 以上版本生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if gt IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE7-上不生效\"><a href=\"#只在-IE7-上不生效\" class=\"headerlink\" title=\"只在 IE7 上不生效\"></a>只在 IE7 上不生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if ! IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注释和-style-标签\"><a href=\"#条件注释和-style-标签\" class=\"headerlink\" title=\"条件注释和 style 标签\"></a>条件注释和 style 标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;style type=\"text/CSS\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">.test&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注释和-script-标签\"><a href=\"#条件注释和-script-标签\" class=\"headerlink\" title=\"条件注释和 script 标签\"></a>条件注释和 script 标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;script type=\"text/JavaScript\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">alert(\"我是 IE 6\");</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"选择符前缀法\"><a href=\"#选择符前缀法\" class=\"headerlink\" title=\"选择符前缀法\"></a>选择符前缀法</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/CSS\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">80px</span>; &#125;               <span class=\"comment\">/* IE 6,IE 7,IE 8 */</span></span></span><br><span class=\"line\"><span class=\"css\">*<span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">60px</span>; &#125;         <span class=\"comment\">/* only for IE 6 */</span></span></span><br><span class=\"line\"><span class=\"css\">*+<span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">70px</span>; &#125;        <span class=\"comment\">/* only for IE 7 */</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>选择符前缀法相较于 IE 条件注释法来说，可维护性强了很多，但在向后兼容性上存在一点风险。另外，选择符前缀法不能用于内联样式上。</p>\n<h3 id=\"样式属性前缀法\"><a href=\"#样式属性前缀法\" class=\"headerlink\" title=\"样式属性前缀法\"></a>样式属性前缀法</h3><p>样式属性前缀法的原理是在样式的属性名前加前缀，这些前缀只在特定浏览器下才生效.例如 “_” 只在 IE6 下生效，”*” 在 IE6 和 IE7 下生效。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/CSS\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.test</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 80px;</span></span><br><span class=\"line\"><span class=\"undefined\">  *width: 70px;</span></span><br><span class=\"line\"><span class=\"undefined\">  _width: 60px;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"19-a-标签的四种状态\"><a href=\"#19-a-标签的四种状态\" class=\"headerlink\" title=\"19. a 标签的四种状态\"></a>19. a 标签的四种状态</h2><p>关于 a 标签的四种状态的排序问题，有个简单好记的原则，叫做 love hate 原则，即 l(link)ov(visited)e h(hover)a(active)te</p>\n<h2 id=\"20-hasLayout\"><a href=\"#20-hasLayout\" class=\"headerlink\" title=\"20. hasLayout\"></a>20. hasLayout</h2><p>hasLayout 是 IE 浏览器专有的一个属性，用于 CSS 的解析引擎。有时候在 IE 下一些复杂的 CSS 设置解析起来会出现 Bug，其原因可能与 hasLayout 没有被自动触发有关，我们通过一些技巧，手动触发 hasLayout 属性就可以解决Bug了。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_302.png\" alt=\"\" width=\"550\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_303.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"21-块级元素和行内元素的区别\"><a href=\"#21-块级元素和行内元素的区别\" class=\"headerlink\" title=\"21. 块级元素和行内元素的区别\"></a>21. 块级元素和行内元素的区别</h2><ul>\n<li>块级元素会独占一行，默认情况下，其宽度自动填满其父元素宽度，行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化；</li>\n<li>块级元素可以设置 width，height 属性。行内元素设置 width，height 属性无效。块级元素即使设置了宽度，仍然是独占一行的；</li>\n<li>块级元素可以设置 margin 和 padding 属性。行内元素的 margin 和 padding 属性很奇怪，水平方向的 padding 和 margin 都产生边距效果，但竖直方向的 padding，margin 却不会产生边距效果。</li>\n</ul>\n<h2 id=\"22-display-inline-block\"><a href=\"#22-display-inline-block\" class=\"headerlink\" title=\"22. display:inline-block\"></a>22. display:inline-block</h2><p>它是行内的块级元素，它拥有块级元素的特点，可以设置长宽，可以设置 margin 和 padding 值，但它却不是独占一行，它的宽度并不占满父元素，而是和行内元素一样，可以和其他行内元素排在同一行里.</p>\n<h2 id=\"23-relative，absolute-和-float\"><a href=\"#23-relative，absolute-和-float\" class=\"headerlink\" title=\"23. relative，absolute 和 float\"></a>23. relative，absolute 和 float</h2><p>设置 position: relative 或 position: absolute 都可以让元素激活 left，top，right，bottom 和 z-index 属性(默认情况下，这些属性未激活，设置了也无效) 设置 position:relative 或 position:absolute 会让元素”浮”起来，也就是 z-index 值大于 0，它会改变正常情况下的文档流。float 也能改变文档流，不同的是，float 属性不会让元素”上浮”到另一个 z-index 层，它仍然让元素在 z-index: 0 层排列。另外，不论之前什么类型的元素(display: none 除外)，只要设置了 position: absolute，float: left 或 float: right 中的任意一个，都会让元素以 display: inline-block 的方式显示，可以设置长宽，默认宽度并不占满父元素。就算我们显示地设置 display: inline 或者 display: block，也仍然无效。position: relative 不会隐式改变 display 的类型。</p>\n<h2 id=\"24-居中\"><a href=\"#24-居中\" class=\"headerlink\" title=\"24. 居中\"></a>24. 居中</h2><h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3><h4 id=\"文本，图片等行内元素的水平居中\"><a href=\"#文本，图片等行内元素的水平居中\" class=\"headerlink\" title=\"文本，图片等行内元素的水平居中\"></a>文本，图片等行内元素的水平居中</h4><p>父元素设置text-align:center</p>\n<h4 id=\"确定宽度的块级元素的水平居中\"><a href=\"#确定宽度的块级元素的水平居中\" class=\"headerlink\" title=\"确定宽度的块级元素的水平居中\"></a>确定宽度的块级元素的水平居中</h4><p>margin:0 auto</p>\n<h4 id=\"不确定宽度的块级元素的水平居中\"><a href=\"#不确定宽度的块级元素的水平居中\" class=\"headerlink\" title=\"不确定宽度的块级元素的水平居中\"></a>不确定宽度的块级元素的水平居中</h4><ul>\n<li>第一种方法：将 ul 包含在 table 标签内，对 table 设置 margin: 0 auto 就可以使 table 水平居中，间接地使 ul 实现了水平居中；</li>\n<li>第二种方法：改变块级元素的 display 为 inline 类型，然后使用 text-align: center 来实现居中；</li>\n<li>第三种方法：给父元素设置 float，然后父元素设置 position: relative 和 left: 50%，子元素设置 position: relative 和 left: -50% 来实现水平居中</li>\n</ul>\n<h3 id=\"竖直居中\"><a href=\"#竖直居中\" class=\"headerlink\" title=\"竖直居中\"></a>竖直居中</h3><h4 id=\"父元素高度不确定的文本，图片，块级元素的竖直居中\"><a href=\"#父元素高度不确定的文本，图片，块级元素的竖直居中\" class=\"headerlink\" title=\"父元素高度不确定的文本，图片，块级元素的竖直居中\"></a>父元素高度不确定的文本，图片，块级元素的竖直居中</h4><p>给父容器设置相同上下边距实现的</p>\n<h4 id=\"父元素高度确定的单行文本的竖直居中\"><a href=\"#父元素高度确定的单行文本的竖直居中\" class=\"headerlink\" title=\"父元素高度确定的单行文本的竖直居中\"></a>父元素高度确定的单行文本的竖直居中</h4><p>通过给父元素设置 line-height 来实现的，line-height 值和父元素的高度值相同。</p>\n<h4 id=\"父元素高度确定的多行文本，图片，块级元素的竖直居中\"><a href=\"#父元素高度确定的多行文本，图片，块级元素的竖直居中\" class=\"headerlink\" title=\"父元素高度确定的多行文本，图片，块级元素的竖直居中\"></a>父元素高度确定的多行文本，图片，块级元素的竖直居中</h4><p>块级元素的 display:table-cell，vertical-align:center。</p>\n<h2 id=\"25-使用匿名函数控制变量的作用域\"><a href=\"#25-使用匿名函数控制变量的作用域\" class=\"headerlink\" title=\"25. 使用匿名函数控制变量的作用域\"></a>25. 使用匿名函数控制变量的作用域</h2><p><code>(function(){ var a，c=&quot;abc&quot;; })();</code> 这种形式很巧妙，先定义一个匿名的 function，然后立即执行它.包在这个匿名 function 里的变量，作用域就不再是 window，而是局限在函数内部。用匿名函数将脚本包起来，可以有效控制全局变量，避免冲突隐患。让 JS 不产生冲突，需要避免全局变量的泛滥，合理使用命名空间以及为代码添加必要的注释。</p>\n<h2 id=\"26-window-onload-和-DOMReady\"><a href=\"#26-window-onload-和-DOMReady\" class=\"headerlink\" title=\"26. window.onload 和 DOMReady\"></a>26. window.onload 和 DOMReady</h2><p>window.onload 需要当页面完全加载完成时才会触发，包括图片，Flash 等富媒体，DOMReady 只判断页面内所有的 DOM 节点是否已经全部生成，至于节点的内容是否加载完成，它并不关心. DOMReady 比 window.onload 更适合用来调用初始化函数。值得注意的是，DOMReady 并不是原生 JavaScript 支持的事件，它不能像 window.load 那样直接调用，一般我们都是结合 JS 框架来使用它。</p>\n<h2 id=\"27-CSS-放在页头，JavaScript-放在页尾\"><a href=\"#27-CSS-放在页头，JavaScript-放在页尾\" class=\"headerlink\" title=\"27. CSS 放在页头，JavaScript 放在页尾\"></a>27. CSS 放在页头，JavaScript 放在页尾</h2><p>将 CSS 放在页头，在载入 HTML 元素之前，先载入它们的样式，这样可以避免 HTML 出现无样式状态；将 JavaScript 放在页尾，先将网页呈现给用户，再来加载页面内的脚本，避免 JavaScirpt 阻塞网页的呈现，减少页面空白的时间。</p>\n<h2 id=\"28-引入编译的概念——文件压缩\"><a href=\"#28-引入编译的概念——文件压缩\" class=\"headerlink\" title=\"28. 引入编译的概念——文件压缩\"></a>28. 引入编译的概念——文件压缩</h2><p>为了减小网页的大小，缩短网页的下载时间，在正式发布 JavaScript 之前，我们可以先对它进行一下压缩。JS 压缩通常的做法是去掉空格和换行，去掉注释，将复杂变量名替换成简单的变量名。</p>\n<h2 id=\"29-JavaScript-如何分层\"><a href=\"#29-JavaScript-如何分层\" class=\"headerlink\" title=\"29. JavaScript 如何分层\"></a>29. JavaScript 如何分层</h2><p>把 JavaScript 也分成三层，从下往上依次是 base 层，common 层和 page 层</p>\n<h3 id=\"base-层-1\"><a href=\"#base-层-1\" class=\"headerlink\" title=\"base 层\"></a>base 层</h3><p>有两个职责，职责一是封装不同浏览器下 JavaScript 的差异，提供统一的接口，我们可以依靠它来完成跨浏览器兼容的工作。职责二是扩展 JavaScript 语言底层提供的接口，让它提供更多更为易用的接口。</p>\n<h3 id=\"common-层-1\"><a href=\"#common-层-1\" class=\"headerlink\" title=\"common 层\"></a>common 层</h3><p>依赖于 base 层提供的接口。common 层提供可供复用的组件，它是典型的 mvc 模式中的 m，和页面内的具体功能没有直接关系。common 层的功能是给 page 层提供组件。</p>\n<h3 id=\"page-层-1\"><a href=\"#page-层-1\" class=\"headerlink\" title=\"page 层\"></a>page 层</h3><p>这一层和页面里的具体功能需求直接相关，是 mvc 模式中的 c。page 层的功能是完成页面内的功能需求。</p>\n<h2 id=\"30-JavaScript-中的参数\"><a href=\"#30-JavaScript-中的参数\" class=\"headerlink\" title=\"30. JavaScript 中的参数\"></a>30. JavaScript 中的参数</h2><p>如果一个函数内某个因素很不稳定，我们可以将它从函数内部分离出来，以参数的形式传入，从而将不稳定因素和函数解耦。在编程里有一个很出名的规则叫做 DRY——don’t repeat yourself，强调在程序中不要将相同的代码重复编写多次，更好的做法是只写一次，然后在多处引用。</p>\n<h2 id=\"31-JavaScript-与面向对象\"><a href=\"#31-JavaScript-与面向对象\" class=\"headerlink\" title=\"31. JavaScript 与面向对象\"></a>31. JavaScript 与面向对象</h2><p>JavaScript 很奇怪，它没有 Class 关键字，在 JavaScript 中是用函数来充当类的。函数在 JavaScript 中既可以当作普通函数使用，也可以当作类来使用，在充当类的时候，它本身又担负着构造函数的责任。函数作为普通函数使用时，通常直接使用 “()” 进行调用，而作为类使用时，通常使用 new 来实例化。通常情况下，作为函数时我们更倾向于用动词来命名，而作为类时用名词来命名。按照习惯，类名的首字母大写。JavaScript 是基于原型的语言，通过 new 实例化出来的对象，其属性和行为来自于两部分，一部分来自于构造函数，另一部分来自于原型。当我们声明一个类时，其实同时生成了一个对应的原型，例如我们定义 Animal 这个类时，会生成一个与 Animal 类对应的原型，通过 Animal.prototype 可以指向这个原型，原型可以通过 constructor 指向 Animal 类，更确切地说，是指向 Animal 类的构造函数。构造函数中定义的属性和行为的优先级比原型中定义的属性和行为优先级高，如果构造函数和原型定义了同名的属性和行为，构造函数中的属性和行为会覆盖原型中的同名的属性和行为。 this 关键字无论出现在构造函数中，还是出现在原型中，指向的都是实例对象，通过 this 关键字，可以让属性和方法在构造函数和原型间通信。正统的面向对象语言会提供 public，protect，private 等关键字来声明属性和行为的可访问性是公有还是私有。但 JavaScript 并不提供这些关键字，在 JavaScript 中公有还是私有是通过作用域实现的。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_304.png\" alt=\"\" width=\"550\"></div>\n\n<p>把行为写在原型里可以减少内存消耗，没有特殊原因，推荐尽量把行为写在原型里。写在原型中的行为一定是公有的，而且无法访问私有属性。</p>\n<h2 id=\"32-传值与传址\"><a href=\"#32-传值与传址\" class=\"headerlink\" title=\"32. 传值与传址\"></a>32. 传值与传址</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;             <span class=\"comment\">// 基本数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;              <span class=\"comment\">// 将变量 a 保存的值复制一份，传给变量 b，a 和 b 各保存一份数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = [<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>];       <span class=\"comment\">// 复杂数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = c;              <span class=\"comment\">// 将变量 c 指向的数据的内存地址传给变量d，c 和 b 指向同一份数据</span></span><br><span class=\"line\">b++;</span><br><span class=\"line\">d.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">alert(a);     <span class=\"comment\">// 10 </span></span><br><span class=\"line\">alert(b);     <span class=\"comment\">// 11        变量 b 保存的数据更改不会影响到变量 a</span></span><br><span class=\"line\">alert(c);     <span class=\"comment\">// 1，2，3，4 变量 c 和 d 指向同一份数据，数据更改会互相影响</span></span><br><span class=\"line\">alert(d);     <span class=\"comment\">// 1，2，3，4</span></span><br></pre></td></tr></table></figure>\n<p>在原生 JavaScript中，选择传值还是传址是根据数据类型自动判定的，但传址有时候会给我们带来意想不到的麻烦，所以我们需要对复杂类型数据的赋值进行控制，让复杂数据类型也可以进行传值。</p>\n<h2 id=\"33-UML-描述类\"><a href=\"#33-UML-描述类\" class=\"headerlink\" title=\"33. UML 描述类\"></a>33. UML 描述类</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">PhonebookManager</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">+getTel():string</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+addItem():void</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+removeItem():void</td>\n</tr>\n</tbody>\n</table>\n<p>一个方框代表一个类，将方框划分成上中下三栏，第一栏填入类名，第二栏填入类的属性，第三栏填入类的行为，其中公有属性和公有行为需要在属性和行为名前加上 “+” 号，而私有属性和私有行为需要在属性和行为名前加上 “-” 号。</p>\n<h2 id=\"34-prototype-和内置类\"><a href=\"#34-prototype-和内置类\" class=\"headerlink\" title=\"34. prototype 和内置类\"></a>34. prototype 和内置类</h2><div align=\"center\"><img src=\"/images/hexo_post_305.png\" alt=\"\" width=\"600\"></div>\n\n<p>只要是类就会有原型，不管它是自定义类还是 JavaScript 的内置类，我们可以通过修改内置类的原型，让 JavaScript 基本类型的对象获得一些有趣的功能。无论在类的构造函数中还是在原型中，this 都指向实例化的对象。内置类的方法可以重写，但属性却不能重写。在 JavaScript 中，包括内置类和自定义类，所有类的祖先类都是 Object，所以如果想对所有对象都扩展方法，可以通过修改 Object 类的原型实现。</p>\n<h2 id=\"35-修改内置类\"><a href=\"#35-修改内置类\" class=\"headerlink\" title=\"35. 修改内置类\"></a>35. 修改内置类</h2><p>使用自定义类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myArray</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getArray=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myArray.prototype=&#123;</span><br><span class=\"line\">  each:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fun</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o=<span class=\"keyword\">this</span>.getArray();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=-，n=o.length;i&lt;n;i++)&#123;</span><br><span class=\"line\">      fun(o\\[i\\]，i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"keyword\">new</span> nyArray(\\[<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>\\])，str=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">a.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v，k</span>)</span>&#123;</span><br><span class=\"line\">  str += k+<span class=\"string\">\":\"</span>+v+<span class=\"string\">\"\\\\n\"</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">alert(str);    <span class=\"comment\">// 0:1 1:2 2:3</span></span><br></pre></td></tr></table></figure>\n<p>代替直接修改内置类原型的做法，定义一个自定义类，将内置类的实例作为参数传给构造函数，在自定义类里定义扩展方法。这种做法的思路是将内置类再封装一层，以此保护内置类的原型不被污染。两种方法都各有优缺点，修改内置类的原型非常方便，缺点是可能会带来冲突隐患；自定义类可以保护原型不被修改，但它需要用 new 来实例化自定义类，相对麻烦一点。如果是小应用，不用过多考虑可维护性，推荐使用前者，如果是大中型应用，需要考虑可维护性，推荐使用后者。</p>\n<h2 id=\"36-自定义属性\"><a href=\"#36-自定义属性\" class=\"headerlink\" title=\"36. 自定义属性\"></a>36. 自定义属性</h2><p>对于常规属性，统一使用 node.XXX 的方式读取，对于自定义属性，统一使用 node.getAttribute(“XXX”) 读取。将复杂类型的数据转化成字符串，称为数据的序列化，其逆操作叫做数据的反序列化。字符串的反序列化是通过 eval 函数实现的。只要字符串长的像 JavaScript 支持的数据格式，就可以进行反序列化。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">\"a\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://www.adanghome.com\"</span> <span class=\"attr\">blogInfo</span>=<span class=\"string\">\"&#123;name:'阿当的博客'，</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">type:'前端开发'&#125;\"</span>&gt;</span>my blog<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/JavaScript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> node=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"a\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> info=node.getAttribute(<span class=\"string\">\"blogInfo\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  alert(<span class=\"keyword\">typeof</span> info);    <span class=\"comment\">//string</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.name);      <span class=\"comment\">//undefined</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.type);      <span class=\"comment\">//undefined</span></span></span><br><span class=\"line\"><span class=\"javascript\">  info=<span class=\"built_in\">eval</span>(<span class=\"string\">\"(\"</span> + info + <span class=\"string\">\")\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  alert(<span class=\"keyword\">typeof</span> info);    <span class=\"comment\">//object</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.name);      <span class=\"comment\">//阿当的博客</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.type);      <span class=\"comment\">//前端开发</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"37-代码可维护性\"><a href=\"#37-代码可维护性\" class=\"headerlink\" title=\"37. 代码可维护性\"></a>37. 代码可维护性</h2><p>好的可维护性可以从四个方面获得：</p>\n<ul>\n<li>代码的松耦合，高度模块化，将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从 HTML、CSS、JavaScript 三个层面考虑模块化。</li>\n<li>良好的注释。</li>\n<li>注意代码的弹性，在性能和弹性的选择上，一般情况下以弹性为优先考虑条件，在保证弹性的基础上，适当优化性能。</li>\n<li>严格按照规范编写代码。</li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（3）——精彩绝伦的CSS","slug":"读书笔记系列（3）——精彩绝伦的CSS","date":"2017-04-06T08:13:16.000Z","updated":"2019-02-02T10:19:58.054Z","comments":true,"path":"api/articles/读书笔记系列（3）——精彩绝伦的CSS.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_309.png","content":"<h2 id=\"1-特殊性\"><a href=\"#1-特殊性\" class=\"headerlink\" title=\"1. 特殊性\"></a>1. 特殊性</h2><p>特殊性是一个选择器“特殊程度”的数字表示，有 3 样东西经常被用来确定选择器的特殊性：</p>\n<ul>\n<li>每个元素描述符贡献 0，0，0，1；</li>\n<li>每个类、伪类或者属性描述符贡献 0，0，1，0；</li>\n<li>每个 ID 描述符贡献 0，1，0，0.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>权重</th>\n<th>描述符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>div ul ul li</td>\n<td>0,0,0,4</td>\n<td>4个元素描述符</td>\n</tr>\n<tr>\n<td>div.aside ul li</td>\n<td>0,0,1,3</td>\n<td>1个类描述符，3个元素描述符</td>\n</tr>\n<tr>\n<td>a:hover</td>\n<td>0,0,1,1</td>\n<td>1个伪类描述符，1个元素描述符</td>\n</tr>\n<tr>\n<td>div.navlinks a:hover</td>\n<td>0,0,2,2</td>\n<td>1个伪类描述符，1个类描述符，2个元素描述符</td>\n</tr>\n<tr>\n<td>#title em</td>\n<td>0,1,0,1</td>\n<td>1个ID描述符，1个元素描述符</td>\n</tr>\n<tr>\n<td>h1#title em</td>\n<td>0,1,0,2</td>\n<td>1个ID描述符，2个元素描述符</td>\n</tr>\n</tbody>\n</table>\n<p>当特殊性相等时后声明的规则会胜出。特殊性标识符第一位的 0 是用于行内样式的，且仅用于行内样式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-id\">#header</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: purple;  <span class=\"comment\">/* 0，1，0，0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"header\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background: blue;\"</span>&gt;</span>  /* 1，0，0，0 */</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-重要性\"><a href=\"#2-重要性\" class=\"headerlink\" title=\"2. 重要性\"></a>2. 重要性</h2><p>任何标记为重要的声明都需要有自己的 <code>!important</code><br>任何重要的声明都会覆盖非重要的声明</p>\n<h2 id=\"3-通用选择\"><a href=\"#3-通用选择\" class=\"headerlink\" title=\"3. 通用选择\"></a>3. 通用选择</h2><p><code>*</code> 作用是选择文档中的全部元素并对其应用样式<br><code>div *</code> 作用是选择这个 div 中的全部子元素</p>\n<h2 id=\"4-简单的属性选择\"><a href=\"#4-简单的属性选择\" class=\"headerlink\" title=\"4. 简单的属性选择\"></a>4. 简单的属性选择</h2><p><code>a[href]</code> 会选择所有含有 href 属性的 a 元素<br><code>a[href=&quot;http://w3.org/&quot;]</code> 选择指向某个特定地址的全部超链接</p>\n<h2 id=\"5-部分属性值选择\"><a href=\"#5-部分属性值选择\" class=\"headerlink\" title=\"5. 部分属性值选择\"></a>5. 部分属性值选择</h2><p><code>a[href*=&quot;w3.org&quot;]</code> 属性值中包含该字符序列，应该区分属性值的大小写。</p>\n<p><code>img[src*=&quot;mainlogo.png&quot;]</code> 它会选择任何指向 mainlogo.png 文件的图像（img）元素，或者是 src 属性值中包含 mainlogo.png 这些字符的图像元素。因此，它将同时选择：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/img/2010/mainlogo.png.gif\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"ConHugoCo Inc.\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/img/2010/mainlogo.pngdir/big.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"ConHugoCo Inc.\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-更多部分属性值选择\"><a href=\"#6-更多部分属性值选择\" class=\"headerlink\" title=\"6. 更多部分属性值选择\"></a>6. 更多部分属性值选择</h2><p>a[href^=”http”] 选取任何 href 属性值是以 http 开头的链接元素<br>a[href$=”.pdf”] 选择 href 属性值是以 .pdf 结尾的链接元素</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>选取对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a[href^=”https”]</td>\n<td>安全服务器链接</td>\n</tr>\n<tr>\n<td>a[href^=”mailto”]</td>\n<td>电子邮件联系链接</td>\n</tr>\n<tr>\n<td>a[href^=”aim”]</td>\n<td>AOL即时通信服务链接</td>\n</tr>\n<tr>\n<td>a[href^=”.doc”]</td>\n<td>微软Word文档</td>\n</tr>\n<tr>\n<td>a[href^=”.xls”]</td>\n<td>微软Excel文档</td>\n</tr>\n<tr>\n<td>a[href^=”.zip”]</td>\n<td>压缩文档</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"7-兄弟选择\"><a href=\"#7-兄弟选择\" class=\"headerlink\" title=\"7. 兄弟选择\"></a>7. 兄弟选择</h2><p>h2 + p 紧跟在 h2 后的 p 元素<br>h1 ~ ul 位于 h1 元素后面且与之共享父元素的 ul 元素，不包括直接相邻的兄弟元素</p>\n<h2 id=\"8-调整字体值的顺序\"><a href=\"#8-调整字体值的顺序\" class=\"headerlink\" title=\"8. 调整字体值的顺序\"></a>8. 调整字体值的顺序</h2><blockquote>\n<p>font: <code>&lt;font-size&gt; &lt;font-family&gt;</code>;</p>\n</blockquote>\n<p>必须同时包含这两个值并且按照既定的顺序进行书写。如果颠倒了顺序，或者漏掉了其中的一个，则任何现代浏览器都会完全忽略这条声明。此外，如果在声明中包含了其他关键字，则它们全部都得放在这两个必备的值前面。</p>\n<h2 id=\"9-玩转行高\"><a href=\"#9-玩转行高\" class=\"headerlink\" title=\"9. 玩转行高\"></a>9. 玩转行高</h2><blockquote>\n<p>font: 100%/2.5 Helvetica， sans-serif;</p>\n</blockquote>\n<p>为 font 声明添加行高值得操作总是可选的，但是如果已经包含了行高值，则它的放置位置就是固定的了，必须紧跟在字号后面加一个斜杠再加上行高值才行。</p>\n<h2 id=\"10-无单位的行高值\"><a href=\"#10-无单位的行高值\" class=\"headerlink\" title=\"10. 无单位的行高值\"></a>10. 无单位的行高值</h2><p>无单位的行高值表示后代元素所使用的一个换算系数（比如一个乘数）<br>所有继承了行高值为 1 的元素会把这个值同它们自身的字号计算值相乘。声明了 font-size: 10px 的列表项元素会有一个 10px 的计算后的行高值。</p>\n<h2 id=\"11-抑制元素的可见性\"><a href=\"#11-抑制元素的可见性\" class=\"headerlink\" title=\"11. 抑制元素的可见性\"></a>11. 抑制元素的可见性</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">span&#123; visibility：hidden； &#125;  /* 被设置成 visibility: hidden 的元素仍然参与页面布局 */</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-将元素移出屏幕\"><a href=\"#12-将元素移出屏幕\" class=\"headerlink\" title=\"12. 将元素移出屏幕\"></a>12. 将元素移出屏幕</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.hide</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">10000em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">10000em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">**已经从页面上移除，但是屏幕阅读器也能识别**</span><br><span class=\"line\"></span><br><span class=\"line\">## 13. 图像替换</span><br><span class=\"line\"></span><br><span class=\"line\">使用负的文本缩进把文本移到元素的左侧</span><br><span class=\"line\"></span><br><span class=\"line\">```<span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">140px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">9999px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(page-hader.gif);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们没有移动元素框的情况下将元素的文本内容移动到了屏幕之外。</p>\n<h2 id=\"14-打印样式\"><a href=\"#14-打印样式\" class=\"headerlink\" title=\"14. 打印样式\"></a>14. 打印样式</h2><p>有 3 种方式可以将打印样式关联到页面：</p>\n<ul>\n<li><code>&lt;style type=&quot;text/css&quot; media=&quot;print&quot;&gt;...&lt;/style&gt;</code></li>\n<li><code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot; href=&quot;print.css&quot;&gt;</code></li>\n<li><code>@import url(print.css) print</code>;</li>\n</ul>\n<p>几乎所有人都会使用 link 的方式，这是因为在每个页面中都嵌入打印样式表的效率非常低。</p>\n<h2 id=\"15-凸排列表\"><a href=\"#15-凸排列表\" class=\"headerlink\" title=\"15. 凸排列表\"></a>15. 凸排列表</h2><p>使列表项的第一行悬挂在左侧，并使其他行保持在原位的一种技术。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_309.png\" alt=\"\" width=\"700\"></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">2em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>list-style: none 这条规则很重要，如果没有这个的话，每个列表项的第一行就不会被凸排，并且文本会跟列表标记重合。因此，不要把凸排和列表标记混着用。</p>\n<h2 id=\"16-为列表添加标记\"><a href=\"#16-为列表添加标记\" class=\"headerlink\" title=\"16. 为列表添加标记\"></a>16. 为列表添加标记</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-sytle-image</span>: <span class=\"built_in\">url</span>(star.gif);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>潜在的缺点是你完全无法掌控图像的放置位置。可以将每个列表项的内容用一个元素包裹一下，这个元素可以是 div 或者 span。就可以定制列表标记的样式。</p>\n<h2 id=\"17-生成列表标记\"><a href=\"#17-生成列表标记\" class=\"headerlink\" title=\"17. 生成列表标记\"></a>17. 生成列表标记</h2><p>通过混合凸排和生成内容来实现的。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"built_in\">url</span>(star.gif);</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">8px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"18-用轮廓代替边框\"><a href=\"#18-用轮廓代替边框\" class=\"headerlink\" title=\"18. 用轮廓代替边框\"></a>18. 用轮廓代替边框</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123; <span class=\"attribute\">outline</span>: <span class=\"number\">1px</span> dashed red; &#125;</span><br></pre></td></tr></table></figure>\n<p>边框是参与布局的，而轮廓并不参与。轮廓必然是环绕着元素的，并且在元素的四周永远保持一致。你不能只设置左轮廓或者上轮廓。<br>轮廓只有两种情况：环绕元素四周的简单轮廓，或者干脆没有轮廓。元素是可以同时具有边框和轮廓的。在这种情况下，轮廓会绘制在边框之外，所有轮廓的内边缘会紧挨着边框的外边缘。如果元素具有外边距的话，则轮廓将绘制在外边距所在区域之上，但是外边距并不会被轮廓改变或者替换掉。</p>\n<h2 id=\"19-框冲切\"><a href=\"#19-框冲切\" class=\"headerlink\" title=\"19. 框冲切\"></a>19. 框冲切</h2><p>是一种可以在视觉上将元素框的一部分移除的技术。它仅在单色或固定图像背景上起作用。框冲切的最简单形式就是把一个框放在另一个框的角落里，并确保它的背景与周围的内容一致，而不是与它的父元素一致。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_310.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"20-CSS-精灵\"><a href=\"#20-CSS-精灵\" class=\"headerlink\" title=\"20. CSS 精灵\"></a>20. CSS 精灵</h2><p>CSS 精灵(CSS sprite) 是一种可以实现快速悬停效果的技术，现在已经演变成了通过将装饰性的图片合并并下载，从而降低服务器负载的技术。CSS 精灵最基本的例子就是包含两种状态的图标，即一个挨着链接的正常显示版本，一个当链接被悬停时的”点亮”版本。</p>\n<h2 id=\"21-滑动门\"><a href=\"#21-滑动门\" class=\"headerlink\" title=\"21. 滑动门\"></a>21. 滑动门</h2><p>滑动门是一种可以使文本导航链接变成花哨的选项卡的技术。然而，通常的做法都只适用于效果而不试用于选项卡。</p>\n<h2 id=\"22-CSS-视差\"><a href=\"#22-CSS-视差\" class=\"headerlink\" title=\"22. CSS 视差\"></a>22. CSS 视差</h2><p>CSS 视差是一种很精巧的技术，它能让我们了解基于百分比的背景图像定位可以那么简单而直接地创造出意想不到的效果。首先，考虑一下百分比定位是怎么实现的。假设你把一个背景图像的位置设置为 50% 50%，那么它的中心将与背景区域的中心对齐。类似地，如果设置为 100% 100%，那么它的右下角就会和背景区域的右下角对齐。这就意味着背景图像位置的百分比值实际上被使用了两次。第一次用于找到背景区域中所定义的点，第二次用于找到图像本身中定义的点，然后再把这两个点对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(ice-1.png) -<span class=\"number\">75%</span> <span class=\"number\">0</span> repeat-x;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(ice-2.png) <span class=\"number\">75%</span> <span class=\"number\">0</span> repeat-x;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这样的设置，当浏览器窗口变宽时图片看起来就会使朝着远离窗口中心的方向移动的，这会产生类似”放大”的效果。而当窗口变窄时，图片会朝着窗口的中心移动，类似”缩小”的效果。</p>\n<h2 id=\"23-图像的框\"><a href=\"#23-图像的框\" class=\"headerlink\" title=\"23. 图像的框\"></a>23. 图像的框</h2><p>有些关于图像的东西，大多数人至今都没有意识到：它们与其他元素拥有相同的盒模型，这意味着你可以对图像元素应用诸如背景和内边距等样式。你可以为图像设置背景图像，做出一些有趣的组合效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_311.png\" alt=\"\" width=\"700\"></div>\n\n<p>内边距也可以很简单地应用在图像上。事实上，通过背景色、边框以及内边距的组合，可以使图像看上去具有深浅不一的双层边框。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_312.png\" alt=\"\" width=\"700\"></div>\n\n<p>再加上轮廓的话，你就会得到类似三层边框的效果了。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_313.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"24-受限的图像\"><a href=\"#24-受限的图像\" class=\"headerlink\" title=\"24. 受限的图像\"></a>24. 受限的图像</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span>&#123; <span class=\"attribute\">max-width</span>:<span class=\"number\">100%</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>这条简单的规则会保证图像不会比包含它们的元素更宽，不过在父元素比这些图像宽的情况下，它们会保持原始尺寸。你可以通过把图像在其父元素中居中来进行强化，像这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下图展示了将同一个图像放在 3 个不同宽度父元素中的例子，其中两个父元素比图像还窄，一个比图像宽(父元素的边缘已通过边框标出)。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_314.png\" alt=\"\" width=\"400\"></div>\n\n<p>这很明显会使你的图像任由浏览器的缩放操作摆布，因为它们会缩小图像。</p>\n<h2 id=\"25-表头、主体和脚注\"><a href=\"#25-表头、主体和脚注\" class=\"headerlink\" title=\"25. 表头、主体和脚注\"></a>25. 表头、主体和脚注</h2><p>HTML 为表格定义了 3 个元素用于对行进行分组，它们是 thead(表头)，tbody(表格主体) 和 tfoot(脚注)。毫不奇怪，这些元素分别代表了表格的表头，主体部分以及脚注部分。</p>\n<h2 id=\"26-行标题\"><a href=\"#26-行标题\" class=\"headerlink\" title=\"26. 行标题\"></a>26. 行标题</h2><p>有一个 HTML 属性在当初设计的时候就是用来让你指定一个 th 元素是列标题还是行标题的。表格主体中的每一行都以 th 元素开头，那些就是行标题。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"col\"</span>&gt;</span>Pageviews<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"col\"</span>&gt;</span>Visitors<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"row\"</span>&gt;</span>January 2010<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>1367234<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>326578<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"row\"</span>&gt;</span>February 2010<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>1491262<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>349091<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>为 th 元素恰当地添加已赋值的 scope(作用域)属性，相当于明确地告诉浏览器 th 元素与它周围单元格的关系。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_315.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"27-多背景\"><a href=\"#27-多背景\" class=\"headerlink\" title=\"27. 多背景\"></a>27. 多背景</h2><p>CSS3 中真正时髦的东西之一，就是它对于给定元素支持多个背景图像。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(bg01.png) top left no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg02.png) top right no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg03.png) bottom right no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg04.png) bottom left no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多背景的应用顺序是从“最高”到“最低”的，即以你观看页面的视角来看，是从最靠你的到离你最远的顺序应用。如果你把颜色放到第一个背景上，它就会位于其他背景的“上面”。这也意味着，如果你想让某种图案背景在所有背景的最后方，那么就需要把它放在最后一个并且确保把任何背景颜色的值也移到这个值中。</p>\n<h2 id=\"28-二维变换\"><a href=\"#28-二维变换\" class=\"headerlink\" title=\"28. 二维变换\"></a>28. 二维变换</h2><p>可以通过 <code>transform-origin</code> 改变旋转或缩放的原点</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform-origin</span>: <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transform-origin</span>: 75% 0;</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（2）——面向对象的分析与设计","slug":"读书笔记系列（2）——面向对象的分析与设计","date":"2017-04-06T08:09:41.000Z","updated":"2019-02-02T10:19:58.054Z","comments":true,"path":"api/articles/读书笔记系列（2）——面向对象的分析与设计.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>面向对象不仅是一些具体的软件开发技术与策略，而且是一整套关于如何看待软件系统与现实世界的关系，用什么观点来研究问题并进行求解，以及如何进行系统构造的软件方法学。面向对象方法比以往的方法更接近人类的日常思维方式。</p>\n<h2 id=\"2-面向对象方法有如下一些主要特点：\"><a href=\"#2-面向对象方法有如下一些主要特点：\" class=\"headerlink\" title=\"2. 面向对象方法有如下一些主要特点：\"></a>2. 面向对象方法有如下一些主要特点：</h2><ol>\n<li>从问题域中客观存在的事物出发来构造软件系统，用对象作为对这些事物的抽象表示，并以此作为系统的基本构成单位。</li>\n<li>用对象的属性表示事物的静态特征（即可以用一些数据来表达的特征），用对象的操作表示事物的动态特征（即事物的行为）</li>\n<li>对象的属性与操作结合在一起构成一个独立的实体，对外屏蔽其内部细节（封装）。</li>\n<li>对事物进行分类，把具有相同属性和相同操作的对象归为一类，类是这些对象的抽象描述，每个对象是它的类的一个实例。</li>\n<li>通过在不同程度上运用抽象的原则，可以得到较一般的类和较特殊的类。特殊类继承一般类的属性与操作，从而简化了系统的构造过程。</li>\n<li>复杂的对象可以用简单的对象作为其构成部分（聚合）。</li>\n<li>对象之间通过消息进行通信，以实现对象之间的动态联系。</li>\n<li>用关联表达某些类之间对用户业务有特定意义的关系。</li>\n</ol>\n<h2 id=\"3-每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\"><a href=\"#3-每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\" class=\"headerlink\" title=\"3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\"></a>3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。</h2><h2 id=\"4-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\"><a href=\"#4-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\" class=\"headerlink\" title=\"4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\"></a>4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。</h2><h2 id=\"5-一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\"><a href=\"#5-一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\" class=\"headerlink\" title=\"5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\"></a>5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。</h2><h2 id=\"6-一般类和特殊类也常常习惯地称为父类和子类。\"><a href=\"#6-一般类和特殊类也常常习惯地称为父类和子类。\" class=\"headerlink\" title=\"6. 一般类和特殊类也常常习惯地称为父类和子类。\"></a>6. 一般类和特殊类也常常习惯地称为父类和子类。</h2><ul>\n<li>特殊类的每个对象实例也都属于它的一般类，然而一般类含有其特殊类所没有的对象实例。</li>\n<li>特殊类拥有其一般类的全部属性与操作，称为特殊类对一般类的继承。</li>\n</ul>\n<h2 id=\"7-聚合的含义\"><a href=\"#7-聚合的含义\" class=\"headerlink\" title=\"7. 聚合的含义\"></a>7. 聚合的含义</h2><p>聚合的含义：一个复杂的对象以若干比较简单的对象作为其组成部分。另一方面，聚合也是对象之间的一种关系，即整体对象和部分对象之间的关系。聚合是两个类之间的一个二元关系，它表示一个类的对象实例以另一个类的对象实例作为其组成部分。</p>\n<h2 id=\"8-用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\"><a href=\"#8-用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\" class=\"headerlink\" title=\"8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\"></a>8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。</h2><h2 id=\"9-消息是向对象发出的服务请求。\"><a href=\"#9-消息是向对象发出的服务请求。\" class=\"headerlink\" title=\"9. 消息是向对象发出的服务请求。\"></a>9. 消息是向对象发出的服务请求。</h2><p>消息的实现手段，在顺序程序中主要是函数调用，或者其他类似于函数调用的机制。</p>\n<h2 id=\"10-对象的多态性\"><a href=\"#10-对象的多态性\" class=\"headerlink\" title=\"10. 对象的多态性\"></a>10. 对象的多态性</h2><p>对象的多态性通常是指一般-特殊结构中的对象所体现的多态性，即：在一般类中定义的属性或操作被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。</p>\n<h2 id=\"11-功能分解法\"><a href=\"#11-功能分解法\" class=\"headerlink\" title=\"11. 功能分解法\"></a>11. 功能分解法</h2><p>首先定义各项功能，然后把较大的功能分解为子功能，直到这些功能或子功能的大小比较适当，并能给出明确的定义。</p>\n<h2 id=\"12-结构化方法\"><a href=\"#12-结构化方法\" class=\"headerlink\" title=\"12. 结构化方法\"></a>12. 结构化方法</h2><p>研究问题域中数据如何流动以及在各个环节上如何进行处理，从而发现数据流和加工。最终得到的分析模型是数据流图。</p>\n<h2 id=\"13-数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\"><a href=\"#13-数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\" class=\"headerlink\" title=\"13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\"></a>13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。</h2><h2 id=\"14-实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\"><a href=\"#14-实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\" class=\"headerlink\" title=\"14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\"></a>14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。</h2><h2 id=\"15-信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\"><a href=\"#15-信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\" class=\"headerlink\" title=\"15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\"></a>15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。</h2><h2 id=\"16-先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\"><a href=\"#16-先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\" class=\"headerlink\" title=\"16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\"></a>16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。</h2><h2 id=\"17-面向对象建模方法具有如下优点：\"><a href=\"#17-面向对象建模方法具有如下优点：\" class=\"headerlink\" title=\"17. 面向对象建模方法具有如下优点：\"></a>17. 面向对象建模方法具有如下优点：</h2><ol>\n<li>对问题域和系统责任的复杂性具有较强的处理能力；</li>\n<li>提供了便于各类相关人员交流的共同语言；</li>\n<li>对需求的变化具有较强的适应性；</li>\n<li>为实现分析与设计级别的软件复用提供了强有力的支持。</li>\n</ol>\n<h2 id=\"18-UML是一种建模语言，而不是一种建模方法。\"><a href=\"#18-UML是一种建模语言，而不是一种建模方法。\" class=\"headerlink\" title=\"18. UML是一种建模语言，而不是一种建模方法。\"></a>18. UML是一种建模语言，而不是一种建模方法。</h2><h2 id=\"19-属性有类属性和实例属性之分，必要时要加以区别。\"><a href=\"#19-属性有类属性和实例属性之分，必要时要加以区别。\" class=\"headerlink\" title=\"19. 属性有类属性和实例属性之分，必要时要加以区别。\"></a>19. 属性有类属性和实例属性之分，必要时要加以区别。</h2><h2 id=\"20-数据抽象是面向对象方法的核心原则。\"><a href=\"#20-数据抽象是面向对象方法的核心原则。\" class=\"headerlink\" title=\"20. 数据抽象是面向对象方法的核心原则。\"></a>20. 数据抽象是面向对象方法的核心原则。</h2><h2 id=\"21-没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\"><a href=\"#21-没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\" class=\"headerlink\" title=\"21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\"></a>21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。</h2><h2 id=\"22-消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\"><a href=\"#22-消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\" class=\"headerlink\" title=\"22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\"></a>22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。</h2><h2 id=\"23-在面向对象的软件系统中，所有的对象都是通过类描述的。\"><a href=\"#23-在面向对象的软件系统中，所有的对象都是通过类描述的。\" class=\"headerlink\" title=\"23. 在面向对象的软件系统中，所有的对象都是通过类描述的。\"></a>23. 在面向对象的软件系统中，所有的对象都是通过类描述的。</h2><h2 id=\"24-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\"><a href=\"#24-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\" class=\"headerlink\" title=\"24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\"></a>24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。</h2><h2 id=\"25-可用以下-4-句话来概括对象和类这两个概念在面向对象建模中的应用规则：\"><a href=\"#25-可用以下-4-句话来概括对象和类这两个概念在面向对象建模中的应用规则：\" class=\"headerlink\" title=\"25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则：\"></a>25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则：</h2><ol>\n<li>从对象出发认识问题域，将问题域中的事物抽象为对象；</li>\n<li>将具有共同特征的对象抽象为类，用类以及它们之间的关系构成整个系统模型；</li>\n<li>模型中不包含实例级的元素，用类来表示属于该类的任何对象实例；</li>\n<li>在类的规约中说明这个类将创建哪些对象实例。</li>\n</ol>\n<h2 id=\"26-如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\"><a href=\"#26-如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\" class=\"headerlink\" title=\"26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\"></a>26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。</h2><h2 id=\"27-属性是用来描述对象静态特征的一个数据项-操作是用来描述对象动态特征（行为）的一个动作序列。\"><a href=\"#27-属性是用来描述对象静态特征的一个数据项-操作是用来描述对象动态特征（行为）的一个动作序列。\" class=\"headerlink\" title=\"27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。\"></a>27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。</h2><h2 id=\"28-确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\"><a href=\"#28-确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\" class=\"headerlink\" title=\"28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\"></a>28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。</h2><h2 id=\"29-一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\"><a href=\"#29-一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\" class=\"headerlink\" title=\"29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\"></a>29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。</h2><p>通过接口进行衔接，则接口在它的使用者和提供者之间起到了隔离作用，二者可以分别实现，并且可以有多种不同的实现，只要都遵守接口所规定的合约，就可以通过该接口相互衔接。</p>\n<h2 id=\"30-接口由某些类提供，为另外某些类所需要。\"><a href=\"#30-接口由某些类提供，为另外某些类所需要。\" class=\"headerlink\" title=\"30. 接口由某些类提供，为另外某些类所需要。\"></a>30. 接口由某些类提供，为另外某些类所需要。</h2><h2 id=\"31-接口与对象类相比，有以下几点不同：\"><a href=\"#31-接口与对象类相比，有以下几点不同：\" class=\"headerlink\" title=\"31. 接口与对象类相比，有以下几点不同：\"></a>31. 接口与对象类相比，有以下几点不同：</h2><ol>\n<li>类既有属性又有操作；接口只是声明了一组操作，没有属性。</li>\n<li>在一个类中定义了一个操作，就要在这个类中真正地实现它的功能；接口中的操作只是一个声明，不需要在接口中加以实现。</li>\n<li>类可以创建对象实例；接口则没有任何实例。</li>\n</ol>\n<h2 id=\"32-对象之间的-4-种重要关系，即继承、聚合、关联和信息。\"><a href=\"#32-对象之间的-4-种重要关系，即继承、聚合、关联和信息。\" class=\"headerlink\" title=\"32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。\"></a>32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。</h2><h2 id=\"33-系统中的一般类应该符合下述3个条件之一才有存在的价值：\"><a href=\"#33-系统中的一般类应该符合下述3个条件之一才有存在的价值：\" class=\"headerlink\" title=\"33. 系统中的一般类应该符合下述3个条件之一才有存在的价值：\"></a>33. 系统中的一般类应该符合下述3个条件之一才有存在的价值：</h2><ol>\n<li>它有两个或两个以上的特殊类；</li>\n<li>需要用它创建对象实例；</li>\n<li>它的存在有助于软件复用。</li>\n</ol>\n<h2 id=\"34-聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\"><a href=\"#34-聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\" class=\"headerlink\" title=\"34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\"></a>34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。</h2><h2 id=\"35-如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\"><a href=\"#35-如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\" class=\"headerlink\" title=\"35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\"></a>35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。</h2><h2 id=\"36-关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\"><a href=\"#36-关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\" class=\"headerlink\" title=\"36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\"></a>36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。</h2><h2 id=\"37-消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\"><a href=\"#37-消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\" class=\"headerlink\" title=\"37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\"></a>37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。</h2><h2 id=\"38-在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0-到多个），即接收消息的操作要求的输入参数；返回参数（0-到多个），即接收消息的操作提供的输出参数。\"><a href=\"#38-在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0-到多个），即接收消息的操作要求的输入参数；返回参数（0-到多个），即接收消息的操作提供的输出参数。\" class=\"headerlink\" title=\"38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。\"></a>38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。</h2>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（1）——HTML5移动Web开发指南","slug":"读书笔记系列（1）——HTML5移动Web开发指南","date":"2017-04-06T07:41:14.000Z","updated":"2019-02-02T10:19:58.054Z","comments":true,"path":"api/articles/读书笔记系列（1）——HTML5移动Web开发指南.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h2><h3 id=\"包含匹配选择器\"><a href=\"#包含匹配选择器\" class=\"headerlink\" title=\"包含匹配选择器\"></a>包含匹配选择器</h3><p>包含匹配比完全匹配范围更广。只要元素中的属性包含有指定的字符串，元素就使用该样式。其语法是：<code>[attribute*=value]</code>。</p>\n<p>其中 attribute 指的是属性名，value 指的是属性值，包含匹配采用 “ *=” 符号。</p>\n<h3 id=\"首字符匹配选择器\"><a href=\"#首字符匹配选择器\" class=\"headerlink\" title=\"首字符匹配选择器\"></a>首字符匹配选择器</h3><p>首字符匹配就是匹配属性值开头字符，只要开头字符符合匹配，则元素使用该样式。其语法是：<code>[attribute^=value]</code>。</p>\n<p>其中 attribute 指的是属性名，value 指的是属性值，首字符匹配采用“ ^=”符号。</p>\n<h3 id=\"尾字符匹配选择器\"><a href=\"#尾字符匹配选择器\" class=\"headerlink\" title=\"尾字符匹配选择器\"></a>尾字符匹配选择器</h3><p>尾字符匹配跟首字符匹配原理一样。尾字符只匹配结尾的字符串，只要结尾字符串符合匹配，则元素使用该样式。其语法是：<code>[attribute$=value]</code>。其中 attribute 指的是属性名，value 指的是属性值，尾字符匹配采用 “ $=”符号。</p>\n<h2 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h2><h3 id=\"before\"><a href=\"#before\" class=\"headerlink\" title=\"before\"></a>before</h3><p>before 伪类元素选择器主要的作用是在选择某个元素之前插入内容，一般用于清除浮动。before 选择器的语法是：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素标签<span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">\"插入的内容\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例如，在 p 元素之前插入“文字”：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-class\">.before</span>&#123; <span class=\"attribute\">content</span>: <span class=\"string\">\"文字\"</span> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\"after\"></a>after</h3><p>after 伪类元素选择器和 before 伪类元素选择器原理一样，但 after 是在选择某个元素之后插入内容。after 选择器的语法是：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素标签<span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"插入的内容\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"first-child\"><a href=\"#first-child\" class=\"headerlink\" title=\"first-child\"></a>first-child</h3><p>指定元素列表中第一个元素的样式。语法：<code>li:first-child</code></p>\n<h3 id=\"last-child\"><a href=\"#last-child\" class=\"headerlink\" title=\"last-child\"></a>last-child</h3><p>和 first-child 是同类型的选择器。last-child 指定元素列表中最后一个元素的样式。语法：<code>li:last-child</code></p>\n<h3 id=\"nth-child-和-nth-last-child\"><a href=\"#nth-child-和-nth-last-child\" class=\"headerlink\" title=\"nth-child 和 nth-last-child\"></a>nth-child 和 nth-last-child</h3><p>指定某个元素的样式或从后数起某个元素的样式。</p>\n<h2 id=\"阴影\"><a href=\"#阴影\" class=\"headerlink\" title=\"阴影\"></a>阴影</h2><h3 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h3><blockquote>\n<p>box-shadow: <code>&lt;length&gt; &lt;length&gt; &lt;length&gt;</code> || color</p>\n</blockquote>\n<p>第一个 length 值是阴影水平偏移值；第二个 length 值是阴影垂直偏移值；第三个 length 值是阴影模糊值。水平和垂直偏移值都可取正负值。</p>\n<p>基于 Webkit 的 Chrome 和 Safari 等浏览器：-webkit-box-shadow</p>\n<p>Firebox 浏览器：-moz-box-shadow</p>\n<h3 id=\"text-shadow\"><a href=\"#text-shadow\" class=\"headerlink\" title=\"text-shadow\"></a>text-shadow</h3><blockquote>\n<p>text-shadow: <code>&lt;length&gt; &lt;length&gt; &lt;length&gt;</code> || color</p>\n</blockquote>\n<p>第一个 length 值是阴影水平偏移值；第二个 length 值是阴影垂直偏移值；第三个 length 值是阴影模糊值。水平和垂直偏移值都可取正负值。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size**\"></a>background-size**</h3><p>背景图像的大小</p>\n<h3 id=\"background-clip\"><a href=\"#background-clip\" class=\"headerlink\" title=\"background-clip\"></a>background-clip</h3><p>背景的裁剪区域</p>\n<blockquote>\n<p>background-clip: border-box | padding-box | content-box | no-clip</p>\n</blockquote>\n<p>其中：</p>\n<ul>\n<li>border-box 是从 border 区域向外裁剪背景；</li>\n<li>padding-box 是从 padding 区域向外裁剪背景；</li>\n<li>content-box 是从内容区域向外裁剪背景；</li>\n<li>no-clip 是从 border 区域向外裁剪背景。</li>\n</ul>\n<h3 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h3><p>background-origin 属性是指定 background-position 属性的参考坐标的起始位置。 background-origin 属性有三种值可以选择，border 值指定从边框的左上角坐标开始；content 值指定从内容区域的左上角坐标开始；padding 值指定从 padding 区域开始。</p>\n<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>可以使用 Webkit 的其中一种特性对背景采用颜色渐变，而非采用图片方式。</p>\n<blockquote>\n<p>-webkit-gradient(<code>&lt;type&gt;, &lt;port&gt;[, &lt;radius&gt;]?,&lt;point&gt; [, &lt;radius&gt;]? [, &lt;stop&gt;]*</code>)</p>\n</blockquote>\n<p>type 类型是指采用渐变类型，如线性渐变 linear 或径向渐变 radial。如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">-webkit-gradient</span>(<span class=\"selector-tag\">linear</span>, 0 0, 0 100%, <span class=\"selector-tag\">form</span>(<span class=\"selector-id\">#FFF</span>), <span class=\"selector-tag\">to</span>(<span class=\"selector-id\">#000</span>));</span><br></pre></td></tr></table></figure>\n<p>上述代码的含义是定义一个渐变背景色，该渐变色是线性渐变并且是由白色向黑色渐变的。其中前两个 0 表示的是渐变开始 <strong>X</strong> 和 <strong>Y</strong> 坐标位置；0 和 100%表示的是渐变结束 <strong>X</strong> 和 <strong>Y</strong> 坐标位置。</p>\n<h2 id=\"Media-Queries-移动设备样式\"><a href=\"#Media-Queries-移动设备样式\" class=\"headerlink\" title=\"Media Queries 移动设备样式\"></a>Media Queries 移动设备样式</h2><h3 id=\"viewport设置适应移动设备屏幕大小\"><a href=\"#viewport设置适应移动设备屏幕大小\" class=\"headerlink\" title=\"viewport设置适应移动设备屏幕大小\"></a>viewport设置适应移动设备屏幕大小</h3><p>Android Browser 浏览器的默认值是 800 像素；IE 浏览器的默认值是 974 像素；Opera 浏览器的默认值是 850 像素。viewport 虚拟窗口是在 meta 元素中定义的，其主要作用是设置 Web 页面适应移动设备的屏幕大小。 如以下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1,user-scalable=0\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>代码中的 content 属性内共定义三种参数。实际上 content 属性允许设置 6 种不同的 参数，分别如下：</p>\n<ul>\n<li>width：指定虚拟窗口的屏幕宽度大小。</li>\n<li>height：指定虚拟窗口的屏幕高度大小。</li>\n<li>initial-scale：指定初始缩放比例。</li>\n<li>maximum-scale：指定允许用户缩放的最大比例。</li>\n<li>minimum-scale：指定允许用户缩放的最小比例。</li>\n<li>user-scalable：指定是否允许手动缩放。</li>\n</ul>\n<h3 id=\"Media-Queries-如何工作\"><a href=\"#Media-Queries-如何工作\" class=\"headerlink\" title=\"Media Queries 如何工作\"></a>Media Queries 如何工作</h3><p>要实现 Media Queries 样式模块，需要在 head 标签内导入一个 CSS 样式文件，例如，下面代码使用 media 属性定义当前屏幕可视区域的宽度最大值是 600 像素时应用该样式文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"screen and(max-width:600px)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"small.css\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在 small.css 样式文件内，需要定义 media 类型的样式，例如： </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> screen and (max-width:<span class=\"number\">600px</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.demo</span>&#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#CCC</span>; &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样也可以判断当移动设备（如 iPad）的方向发生变化时应用该样式。以下代码是当移动设备处于纵向（portrait）模式下时，应用 portrait 样式文件；当移动设备处于横向（landscape）模式下时，应用 landscape 样式文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"all and(orientation:portrait)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"portrait.css\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"all and(orientation:landscape)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"landscape.css\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Media-Queries-语法总结\"><a href=\"#Media-Queries-语法总结\" class=\"headerlink\" title=\"Media Queries 语法总结\"></a>Media Queries 语法总结</h3><p>Media Queries 的语法如下所示：</p>\n<blockquote>\n<p>@media [media_query] media_type and media_feature</p>\n</blockquote>\n<p>使用 Media Queries 样式模块时都必须以 “@media” 方式开头。media_query 表示查询关键字，在这里可以使用 not 关键字和 only 关键字。not 关键字表示对后面的样式表达式执行取反操作。例如如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> not screen and (max-device-width:<span class=\"number\">480px</span>)</span><br></pre></td></tr></table></figure>\n<p>only 关键字的作用是，让不支持 Media Queries 的设备但能读取 Media Type 类型的浏览器忽略这个样式。例如如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> only screen and (max-device-width:<span class=\"number\">480px</span>)</span><br></pre></td></tr></table></figure>\n<p>对于支持 Media Queries 的移动设备来说，如果存在 only 关键字，移动设备的 Web 浏览器会忽略 only 关键字并直接根据后面的表达式应用样式文件。对于不支持 Media Queries 的设备但能够读取 Media Type 类型的 Web 浏览器，遇到 only 关键字时会忽略这个样式文件。</p>\n<p>media_type 参数的作用是指定设备类型，通常称为媒体类型。实际上在 CSS2.1 版本时已经定义了该媒体类型。</p>\n<ul>\n<li><strong>all</strong>                 所有设备</li>\n<li><strong>aural</strong>               听觉设备</li>\n<li><strong>braille</strong>             点字触觉设备</li>\n<li><strong>handled</strong>             便携设备，如手机、平板电脑</li>\n<li><strong>print</strong>               打印预览图等</li>\n<li><strong>projection</strong>          投影设备</li>\n<li><strong>screen</strong>              显示器、笔记本、移动端等设备</li>\n<li><strong>tty</strong>                 如打字机或终端等设备</li>\n<li><strong>tv</strong>                  电视机等设备类型</li>\n<li><strong>embossed</strong>            盲文打印机</li>\n</ul>\n<p>media_feature 的主要作用是定义 CSS 中的设备特性，大部分移动设备特性都允许接受 min/max 的前缀。 例如，min-width 表示指定大于等于该值；max-width 表示指定小于等于该值。</p>\n","raw":null,"categories":[{"name":"html","path":"api/categories/html.json"}],"tags":[{"name":"HTML","path":"api/tags/HTML.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列","slug":"读书笔记系列","date":"2017-04-06T07:39:34.000Z","updated":"2019-02-02T10:19:58.054Z","comments":true,"path":"api/articles/读书笔记系列.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>“书中自有黄金屋”，这里汇集了我所读过的书的笔记，在闲下来的时候与其打游戏还不如看会书：</p>\n<ul>\n<li><a href=\"/20170406/html5-mobile-web-development-guide.html\">HTML5移动Web开发指南</a></li>\n<li><a href=\"/20170406/object-oriented-analysis-and-design.html\">面向对象的分析与设计</a></li>\n<li><a href=\"/20170406/excellent-css.html\">精彩绝伦的CSS</a></li>\n<li><a href=\"/20170406/the-way-to-practice-web-front-end-development.html\">编写高质量代码-Web前端开发修炼之道</a></li>\n<li><a href=\"/20170406/html5-and-css3-actual-warfare.html\">响应式Web设计-HTML5和CSS3实战</a></li>\n<li><a href=\"/20170408/dahua-data-structure.html\">大话数据结构</a></li>\n<li><a href=\"/20170706/css-secrets.html\">CSS Secrets</a></li>\n<li><a href=\"/20171010/you-dont-know-js-volume1.html\">你不知道的JavaScript（上卷）</a></li>\n</ul>\n","raw":null,"categories":[{"name":"series","path":"api/categories/series.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"前端面试系列（10）——JS中的闭包","slug":"前端面试系列（10）——JS中的闭包","date":"2017-04-05T13:12:15.000Z","updated":"2019-02-02T10:19:58.050Z","comments":true,"path":"api/articles/前端面试系列（10）——JS中的闭包.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>闭包这个概念其实并不是 JS 中独有的，很多开发者将其理解为 JS 的特有产物，其实是大错特错的；只不过 JS 中的闭包有着其他语言没有的特性和产生机理，所以对于闭包的理解成为了很多面试官垂青的问题，而真正理解闭包并且知道在什么时候用闭包、在什么时候避免闭包对于前端码农来说是一个不小的挑战，本篇文章就将深入剖析闭包的工作原理，以及如何使用和避免使用闭包</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>要理解闭包，首先必须理解 Javascript 特殊的变量作用域；在 JS 中，变量的作用域无非就是两种：全局变量和局部变量：</p>\n<ul>\n<li>全局变量，顾名思义，在函数内部也可以直接读取全局变量</li>\n<li>局部变量，在函数外部是无法读取函数内的局部变量的（<strong>函数内声明变量的时候，一定要使用 var / let 命令，否则相当于声明了一个全局变量</strong>）</li>\n</ul>\n<p>我们有时候需要得到函数内的局部变量，但是从上面的讲解可以看到，正常情况下是办不到的，所以只能变通：<strong>在函数的内部，再定义一个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(n);  <span class=\"comment\">//999</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就引出了另外一个概念，就是 Javascript 语言特有的“<strong>链式作用域</strong>”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量；援引<a href=\"http://www.yanshiba.com/\" target=\"_blank\" rel=\"noopener\">燕十八</a>老师的话，只要在一对大括号之内声明的变量，在这个大括号里面的任何地方都可以访问到该变量。<br>根据上面的代码，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们就可以在 f1 外部读取它的内部变量了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(n); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result=f1();</span><br><span class=\"line\">result(); <span class=\"comment\">// 999</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>上面代码中的 f2 函数，就是闭包。 闭包是 JavaScript（以及其他大多数编程语言）的一个极其强大的属性。正如在 MDN (Mozilla Developer Network) 中定义的那样：</p>\n<blockquote>\n<p>闭包是指能够访问自由变量的函数。换句话说，在闭包中定义的函数可以“记忆”它被创建的环境。</p>\n</blockquote>\n<p>自由变量是既不是在本地声明又不作为参数传递的一类变量。（如果一个作用域中使用的变量并不是在该作用域中声明的，那么这个变量对于该作用域来说就是自由变量），上面例子中的 n 在 f2 中 alert，但是 f2 中并没有声明 n，所以 n 对于 f2 这个大括号形成的作用域来说就是自由变量；更通俗来讲的话，闭包是能够读取其他函数内部变量的函数，所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>\n<h2 id=\"闭包的用途\"><a href=\"#闭包的用途\" class=\"headerlink\" title=\"闭包的用途\"></a>闭包的用途</h2><p>闭包一个非常重要的用途：保留外部作用域对一个变量的私有引用（仅通过唯一途径例如某一个特定函数来访问一个变量），来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 5, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 5, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 5, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 5, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 5, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>这里之所以会打印 5 个 “5”，是因为这五个函数的作用域全部相同（var i = 0 这一句可以提到 for 循环外面，对于 5 个函数来说，只有一个 i，就是循环结束时的那个 i）；也就是说，每次变量 i 增加时，作用域都会更新–这个作用域被所有函数共享。一个解决办法就是为每个函数创建一个额外的封闭环境，使得它们各自都有自己的执行上下文 / 作用域：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// additional enclosing context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 0, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 1, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 2, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 3, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 4, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>另外，因为 ES6 的缘故，所以我们可以使用 let 来代替 var，因为 let 声明的是块级作用域（在 ES5 中，是没有块级作用域的），因此每次迭代都会创建一个新的标示符绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 0, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 1, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 2, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 3, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 4, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>再来看一个例子（MDN 给出的一个闭包的例子）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>));  <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>我们定义了一个方法 makeAdder(x)，这个方法只有一个变量 x，然后返回了一个新的方法；返回的方法呢只有一个变量 y，然后 return 的结果是 x + y；所以，makeAdder(x) 就被我们打造成了一个“方法工厂”，在上面的例子中我们利用这个“工厂”生产了两个新的方法，一个返回的结果是 5 加上变量，另外一个返回 10 加上传进来的变量；不出所料，add5 和 add10 这两个方法都是闭包，他们共享同样的方法体定义，但是存储了不同的词法环境（关于词法环境，本文将不详细探讨，感兴趣的可以自行查阅资料，暂时可以简单的理解为变量所在的环境）；在 add5 的词法环境，x 是 5；而在 add10 的词法环境中，x 是 10；通过这个例子，我们可以看到闭包可以用来打造“方法工厂”，而这个特性也成为了我们避免使用闭包的理由</p>\n<h2 id=\"避免使用闭包\"><a href=\"#避免使用闭包\" class=\"headerlink\" title=\"避免使用闭包\"></a>避免使用闭包</h2><p>曾经我被闭包强大的特性所吸引，直到我看到一些关于“避免使用闭包”的博客，才知道闭包带来的麻烦会比其提供的方便更值得重视；JS 的内存释放和 Java 类似，有一个内存回收机制，没有被引用的对象都会被自动释放，而出现闭包的时候会导致变量无法被释放，下面看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> closure1 = closure();</span><br></pre></td></tr></table></figure>\n<p>closure 方法返回的这个方法，在 closure1 方法每次调用的时候，都可以访问 data 对象，所以由此可见，data 对象的引用没有被释放，否则的话 closure1 方法将无法访问到data对象。这里可以明显的看出来闭包是会把局部变量引用起来导致无法释放的“副作用”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> closure2 = closure();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(closure1 === closure2); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(closure1() === closure2()); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出来，closure 方法执行两次得到两个方法，这两个方法不是一个方法，两个方法可以访问的 data 对象也不是同一个对象。也就是说 closure 执行一次，就有一个新对象 data 产生，同时生成一个新的方法，返回出去。每次 closure 方法的执行就导致内存中多了一个 data 对象，多了一个 function(return data)，很明显<strong>这会导致内存的膨胀。使用不当就会导致内存的泄露</strong>。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><p>关于闭包就介绍到这里了，但是为了更容易让初学者理解，本文省略掉了很多相关概念的介绍（执行上下文、词法环境、静态作用域），感兴趣的话可以查阅相关资料，如果有机会的话，我会再查阅更多资料，详细的介绍一下和闭包有关的其他概念，下面是我推荐的一些关于闭包讲解的链接：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener\">MDN-Lexical scoping</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\" target=\"_blank\" rel=\"noopener\">学习Javascript闭包（Closure）</a></li>\n<li><a href=\"http://web.jobbole.com/88167/\" target=\"_blank\" rel=\"noopener\">让我们一起学习JavaScript闭包吧</a></li>\n<li><a href=\"http://www.jb51.net/article/83524.htm\" target=\"_blank\" rel=\"noopener\">一分钟理解js闭包</a></li>\n<li><a href=\"http://rainfall.blog.51cto.com/8402174/1344225\" target=\"_blank\" rel=\"noopener\">理解js闭包是为了避免使用闭包</a></li>\n<li><a href=\"https://stackoverflow.com/questions/111102/how-do-javascript-closures-work\" target=\"_blank\" rel=\"noopener\">Stackoverflow-How do JavaScript closures work?</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（9）——JS实现继承","slug":"前端面试系列（9）——JS实现继承","date":"2017-04-05T13:11:07.000Z","updated":"2019-02-02T10:19:58.050Z","comments":true,"path":"api/articles/前端面试系列（9）——JS实现继承.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_316.jpg","content":"<p>JS 虽然声称面向对象，但是其很多特性与真正的“面向对象”仍有一定差距；面向对象的一大特性就是可以继承，所以如何在 JS 这种弱类型语言中实现继承就成为了前端面试中的常见问题，下面我就总结一下在 JS 中实现继承的几种方式：</p>\n<h2 id=\"定义父类\"><a href=\"#定义父类\" class=\"headerlink\" title=\"定义父类\"></a>定义父类</h2><p>既然要实现继承，首先得有一个父类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1、原型链继承\"><a href=\"#1、原型链继承\" class=\"headerlink\" title=\"1、原型链继承\"></a>1、原型链继承</h2><p><strong>核心</strong>：将父类的实例作为子类的原型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>\n<li>父类新增原型方法 / 原型属性，子类都能访问到</li>\n<li>简单，易于实现</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>要想为子类新增属性和方法，必须要在 <code>new Animal()</code> 这样的语句之后执行，不能放到构造器中</li>\n<li>无法实现多继承</li>\n<li>来自原型对象的引用属性是所有实例共享的</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n</ol>\n<p><strong>推荐指数</strong>：★★（3、4 两大致命缺陷）</p>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p><strong>核心</strong>：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 除了 call 方法，也可以用 apply()，由于篇幅原因，就不再详细介绍这两种方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>解决了 1 中，子类实例共享父类引用属性的问题</li>\n<li>创建子类实例时，可以向父类传递参数</li>\n<li>可以实现多继承（call 多个父类对象）</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实例并不是父类的实例，只是子类的实例</li>\n<li>只能继承父类的实例属性和方法，不能继承原型属性 / 方法</li>\n<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>\n</ol>\n<p><strong>推荐指数</strong>：★★（缺点3）</p>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p><strong>核心：</strong>：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>不限制调用方式，不管是 <code>new 子类()</code>还是<code>子类()</code>，返回的对象具有相同的效果</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实例是父类的实例，不是子类的实例</li>\n<li>不支持多继承</li>\n</ol>\n<p><strong>推荐指数</strong>：★★</p>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><p><strong>特点</strong>：使用 for in 将父类实例中的方法赋给子类实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>\n<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）</li>\n</ol>\n<p><strong>推荐指数</strong>：★（缺点 1）</p>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p><strong>核</strong>：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>弥补了方式 2 的缺陷，可以继承实例属性 / 方法，也可以继承原型属性 / 方法</li>\n<li>既是子类的实例，也是父类的实例</li>\n<li>不存在引用属性共享问题</li>\n<li>可传参</li>\n<li>函数可复用</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<p><strong>推荐指数</strong>：★★★★（仅仅多消耗了一点内存，也是最常用的一种继承方式）</p>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p><strong>核心</strong>：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法 / 属性，避免的组合继承的缺点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>堪称完美</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实现较为复杂</li>\n</ol>\n<p><strong>推荐指数</strong>：★★★★（实现复杂，扣掉一颗星）</p>\n<h2 id=\"7、六种继承方式的联系\"><a href=\"#7、六种继承方式的联系\" class=\"headerlink\" title=\"7、六种继承方式的联系\"></a>7、六种继承方式的联系</h2><div align=\"center\"><img src=\"/images/hexo_post_316.jpg\" alt=\"\" width=\"300\"></div>\n\n<p>PS：虚线表示辅助作用，实现表示决定性作用</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/humin/p/4556820.html\" target=\"_blank\" rel=\"noopener\">JS继承的实现方式</a></li>\n<li><a href=\"http://www.cnblogs.com/ayqy/p/4471638.html\" target=\"_blank\" rel=\"noopener\">重新理解JS的6种继承方式</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（8）——TCP的三次握手与四次分手","slug":"前端面试系列（8）——TCP的三次握手与四次分手","date":"2017-04-05T08:07:21.000Z","updated":"2019-02-02T10:19:58.050Z","comments":true,"path":"api/articles/前端面试系列（8）——TCP的三次握手与四次分手.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_123.jpg","content":"<h2 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h2><h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><p><a href=\"http://baike.baidu.com/link?url=eNyUOgDeOV5z-03dVd8M1Y2jazNBA9n_eeqpsGs6DROKf_Eezztf31POgn2yMVtzxhX1BIcma9hIT2lzwaeswKAUZHNBSzFasHHI6SsZKnGJJVu2fKrPkMh3byyFTt1j4VqBV4re8SYTBTMDXY_L7clee5XEglKSOAWJqr5E_QRD6INjs03VMQNOUstxguVR-oOfOPGi4cah5m0VFukOkpT6STLUEGHWUIUUYFv0aAgMRFovp5EWN7V3iMdEZQ0a6ikGU90BRIYMLLIKsVNjP8Szj4c6SexwpfRM6D5CjjG\" target=\"_blank\" rel=\"noopener\">开放系统互连参考模型</a> (Open System Interconnect 简称 OSI）是国际标准化组织（ISO）和国际电报电话咨询委员会（CCITT）联合制定的开放系统互连参考模型，为开放式互连信息系统提供了一种功能结构的框架。它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每一层的功能是独立的。它利用其下一层提供的服务并为其上一层提供服务，而与其他层的具体实现无关。这里所谓的“服务”就是下一层向上一层提供的通信功能和层之间的会话规定，一般用通信原语实现。两个开放系统中的同等层之间的通信规则和约定称之为协议。通常把1～4层协议称为下层协议，5～7 层协议称为上层协议。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_123.jpg\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP / IP\"></a>TCP / IP</h3><p>TCP 工作在网络 OSI 的七层模型中的第四层——Transport 层，IP 在第三层——Network 层，ARP 在第二层——Data Link 层；在第二层上的数据，我们把它叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。在 OSI 七层模型中，每一层的作用和对应的协议如下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_58.jpeg\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h2><p>TCP 是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记 TCP 协议中每个字段的含义。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_223.jpg\" alt=\"\" width=\"700\"></div>\n\n<p>上面就是 TCP 协议头部的格式，下面就将每个字段的信息都详细的说明一下。</p>\n<ul>\n<li><strong>Source Port</strong>和<strong>Destination Port</strong>：分别占用 16 位，表示源端口号和目的端口号；用于区别主机中的不同进程，而 IP 地址是用来区分不同的主机的，源端口号和目的端口号配合上 IP 首部中的源 IP 地址和目的 IP 地址就能唯一的确定一个 TCP 连接；</li>\n<li><strong>Sequence Number</strong>：用来标识从 TCP 发端向 TCP 收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</li>\n<li><strong>Acknowledgment Number</strong>：32 位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加 1。不过，只有当标志位中的 ACK 标志（下面介绍）为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题；</li>\n<li><strong>Offset</strong>：给出首部中 32 bit 字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占 4bit（最多能表示 15 个 32bit 的的字，即 4*15=60 个字节的首部长度），因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节；</li>\n<li><strong>TCP Flags</strong>：TCP 首部中有 6 个标志比特，它们中的多个可同时被设置为 1，主要是用于操控 TCP 的状态机的，依次为 <code>URG</code>，<code>ACK</code>，<code>PSH</code>，<code>RST</code>，<code>SYN</code>，<code>FIN</code>。每个标志位的意思如下：<ul>\n<li>URG：此标志表示 TCP 包的紧急指针域（后面马上就要说到）有效，用来保证 TCP 连接不被中断，并且督促中间层设备要尽快处理这些数据；</li>\n<li><strong>ACK</strong>：此标志表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0；</li>\n<li>PSH：这个标志位表示 Push 操作。所谓 Push 操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li>\n<li>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li>\n<li><strong>SYN</strong>：表示同步序号，用来建立连接。<code>SYN</code> 标志位和 <code>ACK</code> 标志位搭配使用，当连接请求的时候，<code>SYN</code> = 1，<code>ACK</code> = 0；连接被响应的时候，<code>SYN</code> = 1，<code>ACK</code> = 1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 <code>SYN</code> 的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行 TCP 三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行 TCP 的三次握手；</li>\n<li>FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送 <code>FIN</code> 标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li>\n</ul>\n</li>\n<li><strong>Window</strong>：窗口大小，也就是有名的滑动窗口，用来进行流量控制；这是一个复杂的问题，这篇博文中并不会进行总结的；</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p>TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP / IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。这就是面试中经常会被问到的 <strong>TCP 三次握手</strong>。\b下图很形象的展示了三次握手和四次分手的数据交换：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_74.jpg\" alt=\"\" width=\"400\"></div>\n\n<ol>\n<li>第一次握手：建立连接。客户端发送连接请求报文段，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为 x；然后，客户端进入 <code>SYN_SEND</code> 状态，等待服务器的确认；</li>\n<li>第二次握手：服务器收到 <code>SYN</code> 报文段。服务器收到客户端的 <code>SYN</code> 报文段，需要对这个 <code>SYN</code> 报文段进行确认，设置 <code>Acknowledgment Number</code> 为 x+1(<code>Sequence Number</code> + 1)；同时，自己自己还要发送 <code>SYN</code> 请求信息，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为 y；服务器端将上述所有信息放到一个报文段（即 <code>SYN + ACK</code> 报文段）中，一并发送给客户端，此时服务器进入 <code>SYN_RECV</code> 状态；</li>\n<li>第三次握手：客户端收到服务器的<code>SYN + ACK</code> 报文段。然后将 <code>Acknowledgment Number</code> 设置为 y+1，向服务器发送 <code>ACK</code> 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <code>ESTABLISHED</code> 状态，完成 TCP 三次握手。</li>\n</ol>\n<p>完成了三次握手，客户端和服务器端就可以开始传送数据。</p>\n<h2 id=\"四次分手\"><a href=\"#四次分手\" class=\"headerlink\" title=\"四次分手\"></a>四次分手</h2><p>当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的啊。那对于 TCP 的断开连接，这里就有了神秘的“四次分手”。</p>\n<ol>\n<li>第一次分手：主机 1（可以是客户端，也可以是服务器端），设置 <code>Sequence Number</code> 和 <code>Acknowledgment Number</code>，向主机 2 发送一个 <code>FIN</code> 报文段；此时，主机 1 进入 <code>FIN_WAIT_1</code> 状态；这表示主机1没有数据要发送给主机 2 了；</li>\n<li>第二次分手：主机 2 收到了主机1发送的 <code>FIN</code> 报文段，向主机 1 回一个 <code>ACK</code> 报文段，<code>Acknowledgment Number</code> 为 <code>Sequence Number</code> 加 1；主机 1 进入 <code>FIN_WAIT_2</code> 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；</li>\n<li>第三次分手：主机 2 向主机 1 发送 <code>FIN</code> 报文段，请求关闭连接，同时主机 2 进入 <code>LAST_ACK</code> 状态；</li>\n<li>第四次分手：主机 1 收到主机 2 发送的 <code>FIN</code> 报文段，向主机 2 发送 <code>ACK</code> 报文段，然后主机 1 进入 <code>TIME_WAIT</code> 状态；主机 2 收到主机 1 的 <code>ACK</code> 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。</li>\n</ol>\n<p>至此，TCP 的四次分手就这么愉快的完成了。</p>\n<h3 id=\"为什么要握手三次\"><a href=\"#为什么要握手三次\" class=\"headerlink\" title=\"为什么要握手三次\"></a>为什么要握手三次</h3><p>既然总结了 TCP 的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那 TCP 为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p>\n<blockquote>\n<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>\n</blockquote>\n<p>在书中同时举了一个例子：</p>\n<blockquote>\n<p>“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p>\n</blockquote>\n<p>总结一下就是为了<strong>防止服务器端一直等待而浪费资源。</strong></p>\n<h2 id=\"为什么要分手四次\"><a href=\"#为什么要分手四次\" class=\"headerlink\" title=\"为什么要分手四次\"></a>为什么要分手四次</h2><p>那四次分手又是为何呢？TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 <code>FIN</code> 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 <code>ACK</code> 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 <code>FIN</code> 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>\n<ul>\n<li><code>FIN_WAIT_1</code>：这个状态要好好解释一下，其实 <code>FIN_WAIT_1</code> 和 <code>FIN_WAIT_2</code> 状态的真正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是：<code>FIN_WAIT_1</code> 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 <code>FIN</code> 报文，此时该 SOCKET 即进入到 <code>FIN_WAIT_1</code> 状态。而当对方回应 ACK 报文后，则进入到 <code>FIN_WAIT_2</code> 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 <code>FIN_WAIT_1</code> 状态一般是比较难见到的，而 <code>FIN_WAIT_2</code> 状态还有时常常可以用 netstat 看到。（主动方）</li>\n<li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上 <code>FIN_WAIT_2</code> 状态下的 SOCKET，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK 信息)，稍后再关闭连接。（主动方）</li>\n<li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 <code>FIN</code> 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 <code>CLOSE_WAIT</code> 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 <code>FIN</code> 报文给对方，也即关闭连接。所以你在 <code>CLOSE_WAIT</code> 状态下，需要完成的事情是等待你去关闭连接。（被动方）</li>\n<li><code>LAST_ACK</code>：这个状态还是比较容易好理解的，它是被动关闭一方在发送 <code>FIN</code> 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 CLOSED 可用状态了。（被动方）</li>\n<li><code>TIME_WAIT</code>：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 <code>TIME_WAIT</code> 状态，而无须经过 <code>FIN_WAIT_2</code> 状态。（主动方）</li>\n<li><code>CLOSED</code>：表示连接中断。</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h3 id=\"1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\"><a href=\"#1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\" class=\"headerlink\" title=\"1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\"></a>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h3><p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p>\n<h3 id=\"2．为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态？\"><a href=\"#2．为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态？\" class=\"headerlink\" title=\"2．为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？\"></a>2．为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？</h3><p>这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/20879359\" target=\"_blank\" rel=\"noopener\">怎样生动描述TCP的「三次握手」？</a></li>\n</ul>\n","raw":null,"categories":[{"name":"computer-base","path":"api/categories/computer-base.json"}],"tags":[{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"面试","path":"api/tags/面试.json"}]}]}