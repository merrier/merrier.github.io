{"total":121,"pageSize":10,"pageCount":13,"data":[{"title":"读书笔记系列（3）——精彩绝伦的CSS","slug":"读书笔记系列（3）——精彩绝伦的CSS","date":"2017-04-06T08:13:16.000Z","updated":"2019-06-03T04:46:43.383Z","comments":true,"path":"api/articles/读书笔记系列（3）——精彩绝伦的CSS.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_309.png","content":"<h2 id=\"1-特殊性\"><a href=\"#1-特殊性\" class=\"headerlink\" title=\"1. 特殊性\"></a>1. 特殊性</h2><p>特殊性是一个选择器“特殊程度”的数字表示，有 3 样东西经常被用来确定选择器的特殊性：</p>\n<ul>\n<li>每个元素描述符贡献 0，0，0，1；</li>\n<li>每个类、伪类或者属性描述符贡献 0，0，1，0；</li>\n<li>每个 ID 描述符贡献 0，1，0，0.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>权重</th>\n<th>描述符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>div ul ul li</td>\n<td>0,0,0,4</td>\n<td>4个元素描述符</td>\n</tr>\n<tr>\n<td>div.aside ul li</td>\n<td>0,0,1,3</td>\n<td>1个类描述符，3个元素描述符</td>\n</tr>\n<tr>\n<td>a:hover</td>\n<td>0,0,1,1</td>\n<td>1个伪类描述符，1个元素描述符</td>\n</tr>\n<tr>\n<td>div.navlinks a:hover</td>\n<td>0,0,2,2</td>\n<td>1个伪类描述符，1个类描述符，2个元素描述符</td>\n</tr>\n<tr>\n<td>#title em</td>\n<td>0,1,0,1</td>\n<td>1个ID描述符，1个元素描述符</td>\n</tr>\n<tr>\n<td>h1#title em</td>\n<td>0,1,0,2</td>\n<td>1个ID描述符，2个元素描述符</td>\n</tr>\n</tbody>\n</table>\n<p>当特殊性相等时后声明的规则会胜出。特殊性标识符第一位的 0 是用于行内样式的，且仅用于行内样式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-id\">#header</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: purple;  <span class=\"comment\">/* 0，1，0，0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"header\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background: blue;\"</span>&gt;</span>  /* 1，0，0，0 */</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-重要性\"><a href=\"#2-重要性\" class=\"headerlink\" title=\"2. 重要性\"></a>2. 重要性</h2><p>任何标记为重要的声明都需要有自己的 <code>!important</code><br>任何重要的声明都会覆盖非重要的声明</p>\n<h2 id=\"3-通用选择\"><a href=\"#3-通用选择\" class=\"headerlink\" title=\"3. 通用选择\"></a>3. 通用选择</h2><p><code>*</code> 作用是选择文档中的全部元素并对其应用样式<br><code>div *</code> 作用是选择这个 div 中的全部子元素</p>\n<h2 id=\"4-简单的属性选择\"><a href=\"#4-简单的属性选择\" class=\"headerlink\" title=\"4. 简单的属性选择\"></a>4. 简单的属性选择</h2><p><code>a[href]</code> 会选择所有含有 href 属性的 a 元素<br><code>a[href=&quot;http://w3.org/&quot;]</code> 选择指向某个特定地址的全部超链接</p>\n<h2 id=\"5-部分属性值选择\"><a href=\"#5-部分属性值选择\" class=\"headerlink\" title=\"5. 部分属性值选择\"></a>5. 部分属性值选择</h2><p><code>a[href*=&quot;w3.org&quot;]</code> 属性值中包含该字符序列，应该区分属性值的大小写。</p>\n<p><code>img[src*=&quot;mainlogo.png&quot;]</code> 它会选择任何指向 mainlogo.png 文件的图像（img）元素，或者是 src 属性值中包含 mainlogo.png 这些字符的图像元素。因此，它将同时选择：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/img/2010/mainlogo.png.gif\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"ConHugoCo Inc.\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/img/2010/mainlogo.pngdir/big.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"ConHugoCo Inc.\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-更多部分属性值选择\"><a href=\"#6-更多部分属性值选择\" class=\"headerlink\" title=\"6. 更多部分属性值选择\"></a>6. 更多部分属性值选择</h2><p>a[href^=”http”] 选取任何 href 属性值是以 http 开头的链接元素<br>a[href$=”.pdf”] 选择 href 属性值是以 .pdf 结尾的链接元素</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>选取对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a[href^=”https”]</td>\n<td>安全服务器链接</td>\n</tr>\n<tr>\n<td>a[href^=”mailto”]</td>\n<td>电子邮件联系链接</td>\n</tr>\n<tr>\n<td>a[href^=”aim”]</td>\n<td>AOL即时通信服务链接</td>\n</tr>\n<tr>\n<td>a[href^=”.doc”]</td>\n<td>微软Word文档</td>\n</tr>\n<tr>\n<td>a[href^=”.xls”]</td>\n<td>微软Excel文档</td>\n</tr>\n<tr>\n<td>a[href^=”.zip”]</td>\n<td>压缩文档</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"7-兄弟选择\"><a href=\"#7-兄弟选择\" class=\"headerlink\" title=\"7. 兄弟选择\"></a>7. 兄弟选择</h2><p>h2 + p 紧跟在 h2 后的 p 元素<br>h1 ~ ul 位于 h1 元素后面且与之共享父元素的 ul 元素，不包括直接相邻的兄弟元素</p>\n<h2 id=\"8-调整字体值的顺序\"><a href=\"#8-调整字体值的顺序\" class=\"headerlink\" title=\"8. 调整字体值的顺序\"></a>8. 调整字体值的顺序</h2><blockquote>\n<p>font: <code>&lt;font-size&gt; &lt;font-family&gt;</code>;</p>\n</blockquote>\n<p>必须同时包含这两个值并且按照既定的顺序进行书写。如果颠倒了顺序，或者漏掉了其中的一个，则任何现代浏览器都会完全忽略这条声明。此外，如果在声明中包含了其他关键字，则它们全部都得放在这两个必备的值前面。</p>\n<h2 id=\"9-玩转行高\"><a href=\"#9-玩转行高\" class=\"headerlink\" title=\"9. 玩转行高\"></a>9. 玩转行高</h2><blockquote>\n<p>font: 100%/2.5 Helvetica， sans-serif;</p>\n</blockquote>\n<p>为 font 声明添加行高值得操作总是可选的，但是如果已经包含了行高值，则它的放置位置就是固定的了，必须紧跟在字号后面加一个斜杠再加上行高值才行。</p>\n<h2 id=\"10-无单位的行高值\"><a href=\"#10-无单位的行高值\" class=\"headerlink\" title=\"10. 无单位的行高值\"></a>10. 无单位的行高值</h2><p>无单位的行高值表示后代元素所使用的一个换算系数（比如一个乘数）<br>所有继承了行高值为 1 的元素会把这个值同它们自身的字号计算值相乘。声明了 font-size: 10px 的列表项元素会有一个 10px 的计算后的行高值。</p>\n<h2 id=\"11-抑制元素的可见性\"><a href=\"#11-抑制元素的可见性\" class=\"headerlink\" title=\"11. 抑制元素的可见性\"></a>11. 抑制元素的可见性</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">span&#123; visibility：hidden； &#125;  /* 被设置成 visibility: hidden 的元素仍然参与页面布局 */</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-将元素移出屏幕\"><a href=\"#12-将元素移出屏幕\" class=\"headerlink\" title=\"12. 将元素移出屏幕\"></a>12. 将元素移出屏幕</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.hide</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">10000em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">10000em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">**已经从页面上移除，但是屏幕阅读器也能识别**</span><br><span class=\"line\"></span><br><span class=\"line\">## 13. 图像替换</span><br><span class=\"line\"></span><br><span class=\"line\">使用负的文本缩进把文本移到元素的左侧</span><br><span class=\"line\"></span><br><span class=\"line\">```<span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">140px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">9999px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(page-hader.gif);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们没有移动元素框的情况下将元素的文本内容移动到了屏幕之外。</p>\n<h2 id=\"14-打印样式\"><a href=\"#14-打印样式\" class=\"headerlink\" title=\"14. 打印样式\"></a>14. 打印样式</h2><p>有 3 种方式可以将打印样式关联到页面：</p>\n<ul>\n<li><code>&lt;style type=&quot;text/css&quot; media=&quot;print&quot;&gt;...&lt;/style&gt;</code></li>\n<li><code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot; href=&quot;print.css&quot;&gt;</code></li>\n<li><code>@import url(print.css) print</code>;</li>\n</ul>\n<p>几乎所有人都会使用 link 的方式，这是因为在每个页面中都嵌入打印样式表的效率非常低。</p>\n<h2 id=\"15-凸排列表\"><a href=\"#15-凸排列表\" class=\"headerlink\" title=\"15. 凸排列表\"></a>15. 凸排列表</h2><p>使列表项的第一行悬挂在左侧，并使其他行保持在原位的一种技术。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_309.png\" alt=\"\" width=\"700\"></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">2em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>list-style: none 这条规则很重要，如果没有这个的话，每个列表项的第一行就不会被凸排，并且文本会跟列表标记重合。因此，不要把凸排和列表标记混着用。</p>\n<h2 id=\"16-为列表添加标记\"><a href=\"#16-为列表添加标记\" class=\"headerlink\" title=\"16. 为列表添加标记\"></a>16. 为列表添加标记</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-sytle-image</span>: <span class=\"built_in\">url</span>(star.gif);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>潜在的缺点是你完全无法掌控图像的放置位置。可以将每个列表项的内容用一个元素包裹一下，这个元素可以是 div 或者 span。就可以定制列表标记的样式。</p>\n<h2 id=\"17-生成列表标记\"><a href=\"#17-生成列表标记\" class=\"headerlink\" title=\"17. 生成列表标记\"></a>17. 生成列表标记</h2><p>通过混合凸排和生成内容来实现的。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"built_in\">url</span>(star.gif);</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">8px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"18-用轮廓代替边框\"><a href=\"#18-用轮廓代替边框\" class=\"headerlink\" title=\"18. 用轮廓代替边框\"></a>18. 用轮廓代替边框</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123; <span class=\"attribute\">outline</span>: <span class=\"number\">1px</span> dashed red; &#125;</span><br></pre></td></tr></table></figure>\n<p>边框是参与布局的，而轮廓并不参与。轮廓必然是环绕着元素的，并且在元素的四周永远保持一致。你不能只设置左轮廓或者上轮廓。<br>轮廓只有两种情况：环绕元素四周的简单轮廓，或者干脆没有轮廓。元素是可以同时具有边框和轮廓的。在这种情况下，轮廓会绘制在边框之外，所有轮廓的内边缘会紧挨着边框的外边缘。如果元素具有外边距的话，则轮廓将绘制在外边距所在区域之上，但是外边距并不会被轮廓改变或者替换掉。</p>\n<h2 id=\"19-框冲切\"><a href=\"#19-框冲切\" class=\"headerlink\" title=\"19. 框冲切\"></a>19. 框冲切</h2><p>是一种可以在视觉上将元素框的一部分移除的技术。它仅在单色或固定图像背景上起作用。框冲切的最简单形式就是把一个框放在另一个框的角落里，并确保它的背景与周围的内容一致，而不是与它的父元素一致。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_310.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"20-CSS-精灵\"><a href=\"#20-CSS-精灵\" class=\"headerlink\" title=\"20. CSS 精灵\"></a>20. CSS 精灵</h2><p>CSS 精灵(CSS sprite) 是一种可以实现快速悬停效果的技术，现在已经演变成了通过将装饰性的图片合并并下载，从而降低服务器负载的技术。CSS 精灵最基本的例子就是包含两种状态的图标，即一个挨着链接的正常显示版本，一个当链接被悬停时的”点亮”版本。</p>\n<h2 id=\"21-滑动门\"><a href=\"#21-滑动门\" class=\"headerlink\" title=\"21. 滑动门\"></a>21. 滑动门</h2><p>滑动门是一种可以使文本导航链接变成花哨的选项卡的技术。然而，通常的做法都只适用于效果而不试用于选项卡。</p>\n<h2 id=\"22-CSS-视差\"><a href=\"#22-CSS-视差\" class=\"headerlink\" title=\"22. CSS 视差\"></a>22. CSS 视差</h2><p>CSS 视差是一种很精巧的技术，它能让我们了解基于百分比的背景图像定位可以那么简单而直接地创造出意想不到的效果。首先，考虑一下百分比定位是怎么实现的。假设你把一个背景图像的位置设置为 50% 50%，那么它的中心将与背景区域的中心对齐。类似地，如果设置为 100% 100%，那么它的右下角就会和背景区域的右下角对齐。这就意味着背景图像位置的百分比值实际上被使用了两次。第一次用于找到背景区域中所定义的点，第二次用于找到图像本身中定义的点，然后再把这两个点对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(ice-1.png) -<span class=\"number\">75%</span> <span class=\"number\">0</span> repeat-x;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(ice-2.png) <span class=\"number\">75%</span> <span class=\"number\">0</span> repeat-x;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这样的设置，当浏览器窗口变宽时图片看起来就会使朝着远离窗口中心的方向移动的，这会产生类似”放大”的效果。而当窗口变窄时，图片会朝着窗口的中心移动，类似”缩小”的效果。</p>\n<h2 id=\"23-图像的框\"><a href=\"#23-图像的框\" class=\"headerlink\" title=\"23. 图像的框\"></a>23. 图像的框</h2><p>有些关于图像的东西，大多数人至今都没有意识到：它们与其他元素拥有相同的盒模型，这意味着你可以对图像元素应用诸如背景和内边距等样式。你可以为图像设置背景图像，做出一些有趣的组合效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_311.png\" alt=\"\" width=\"700\"></div>\n\n<p>内边距也可以很简单地应用在图像上。事实上，通过背景色、边框以及内边距的组合，可以使图像看上去具有深浅不一的双层边框。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_312.png\" alt=\"\" width=\"700\"></div>\n\n<p>再加上轮廓的话，你就会得到类似三层边框的效果了。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_313.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"24-受限的图像\"><a href=\"#24-受限的图像\" class=\"headerlink\" title=\"24. 受限的图像\"></a>24. 受限的图像</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span>&#123; <span class=\"attribute\">max-width</span>:<span class=\"number\">100%</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>这条简单的规则会保证图像不会比包含它们的元素更宽，不过在父元素比这些图像宽的情况下，它们会保持原始尺寸。你可以通过把图像在其父元素中居中来进行强化，像这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下图展示了将同一个图像放在 3 个不同宽度父元素中的例子，其中两个父元素比图像还窄，一个比图像宽(父元素的边缘已通过边框标出)。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_314.png\" alt=\"\" width=\"400\"></div>\n\n<p>这很明显会使你的图像任由浏览器的缩放操作摆布，因为它们会缩小图像。</p>\n<h2 id=\"25-表头、主体和脚注\"><a href=\"#25-表头、主体和脚注\" class=\"headerlink\" title=\"25. 表头、主体和脚注\"></a>25. 表头、主体和脚注</h2><p>HTML 为表格定义了 3 个元素用于对行进行分组，它们是 thead(表头)，tbody(表格主体) 和 tfoot(脚注)。毫不奇怪，这些元素分别代表了表格的表头，主体部分以及脚注部分。</p>\n<h2 id=\"26-行标题\"><a href=\"#26-行标题\" class=\"headerlink\" title=\"26. 行标题\"></a>26. 行标题</h2><p>有一个 HTML 属性在当初设计的时候就是用来让你指定一个 th 元素是列标题还是行标题的。表格主体中的每一行都以 th 元素开头，那些就是行标题。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"col\"</span>&gt;</span>Pageviews<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"col\"</span>&gt;</span>Visitors<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"row\"</span>&gt;</span>January 2010<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>1367234<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>326578<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"row\"</span>&gt;</span>February 2010<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>1491262<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>349091<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>为 th 元素恰当地添加已赋值的 scope(作用域)属性，相当于明确地告诉浏览器 th 元素与它周围单元格的关系。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_315.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"27-多背景\"><a href=\"#27-多背景\" class=\"headerlink\" title=\"27. 多背景\"></a>27. 多背景</h2><p>CSS3 中真正时髦的东西之一，就是它对于给定元素支持多个背景图像。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(bg01.png) top left no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg02.png) top right no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg03.png) bottom right no-repeat,</span><br><span class=\"line\">              <span class=\"built_in\">url</span>(bg04.png) bottom left no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多背景的应用顺序是从“最高”到“最低”的，即以你观看页面的视角来看，是从最靠你的到离你最远的顺序应用。如果你把颜色放到第一个背景上，它就会位于其他背景的“上面”。这也意味着，如果你想让某种图案背景在所有背景的最后方，那么就需要把它放在最后一个并且确保把任何背景颜色的值也移到这个值中。</p>\n<h2 id=\"28-二维变换\"><a href=\"#28-二维变换\" class=\"headerlink\" title=\"28. 二维变换\"></a>28. 二维变换</h2><p>可以通过 <code>transform-origin</code> 改变旋转或缩放的原点</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform-origin</span>: <span class=\"selector-tag\">bottom</span> <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transform-origin</span>: 75% 0;</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（2）——面向对象的分析与设计","slug":"读书笔记系列（2）——面向对象的分析与设计","date":"2017-04-06T08:09:41.000Z","updated":"2019-06-03T04:46:43.383Z","comments":true,"path":"api/articles/读书笔记系列（2）——面向对象的分析与设计.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>面向对象不仅是一些具体的软件开发技术与策略，而且是一整套关于如何看待软件系统与现实世界的关系，用什么观点来研究问题并进行求解，以及如何进行系统构造的软件方法学。面向对象方法比以往的方法更接近人类的日常思维方式。</p>\n<h2 id=\"2-面向对象方法有如下一些主要特点：\"><a href=\"#2-面向对象方法有如下一些主要特点：\" class=\"headerlink\" title=\"2. 面向对象方法有如下一些主要特点：\"></a>2. 面向对象方法有如下一些主要特点：</h2><ol>\n<li>从问题域中客观存在的事物出发来构造软件系统，用对象作为对这些事物的抽象表示，并以此作为系统的基本构成单位。</li>\n<li>用对象的属性表示事物的静态特征（即可以用一些数据来表达的特征），用对象的操作表示事物的动态特征（即事物的行为）</li>\n<li>对象的属性与操作结合在一起构成一个独立的实体，对外屏蔽其内部细节（封装）。</li>\n<li>对事物进行分类，把具有相同属性和相同操作的对象归为一类，类是这些对象的抽象描述，每个对象是它的类的一个实例。</li>\n<li>通过在不同程度上运用抽象的原则，可以得到较一般的类和较特殊的类。特殊类继承一般类的属性与操作，从而简化了系统的构造过程。</li>\n<li>复杂的对象可以用简单的对象作为其构成部分（聚合）。</li>\n<li>对象之间通过消息进行通信，以实现对象之间的动态联系。</li>\n<li>用关联表达某些类之间对用户业务有特定意义的关系。</li>\n</ol>\n<h2 id=\"3-每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\"><a href=\"#3-每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\" class=\"headerlink\" title=\"3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\"></a>3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。</h2><h2 id=\"4-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\"><a href=\"#4-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\" class=\"headerlink\" title=\"4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\"></a>4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。</h2><h2 id=\"5-一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\"><a href=\"#5-一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\" class=\"headerlink\" title=\"5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\"></a>5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。</h2><h2 id=\"6-一般类和特殊类也常常习惯地称为父类和子类。\"><a href=\"#6-一般类和特殊类也常常习惯地称为父类和子类。\" class=\"headerlink\" title=\"6. 一般类和特殊类也常常习惯地称为父类和子类。\"></a>6. 一般类和特殊类也常常习惯地称为父类和子类。</h2><ul>\n<li>特殊类的每个对象实例也都属于它的一般类，然而一般类含有其特殊类所没有的对象实例。</li>\n<li>特殊类拥有其一般类的全部属性与操作，称为特殊类对一般类的继承。</li>\n</ul>\n<h2 id=\"7-聚合的含义\"><a href=\"#7-聚合的含义\" class=\"headerlink\" title=\"7. 聚合的含义\"></a>7. 聚合的含义</h2><p>聚合的含义：一个复杂的对象以若干比较简单的对象作为其组成部分。另一方面，聚合也是对象之间的一种关系，即整体对象和部分对象之间的关系。聚合是两个类之间的一个二元关系，它表示一个类的对象实例以另一个类的对象实例作为其组成部分。</p>\n<h2 id=\"8-用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\"><a href=\"#8-用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\" class=\"headerlink\" title=\"8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\"></a>8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。</h2><h2 id=\"9-消息是向对象发出的服务请求。\"><a href=\"#9-消息是向对象发出的服务请求。\" class=\"headerlink\" title=\"9. 消息是向对象发出的服务请求。\"></a>9. 消息是向对象发出的服务请求。</h2><p>消息的实现手段，在顺序程序中主要是函数调用，或者其他类似于函数调用的机制。</p>\n<h2 id=\"10-对象的多态性\"><a href=\"#10-对象的多态性\" class=\"headerlink\" title=\"10. 对象的多态性\"></a>10. 对象的多态性</h2><p>对象的多态性通常是指一般-特殊结构中的对象所体现的多态性，即：在一般类中定义的属性或操作被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。</p>\n<h2 id=\"11-功能分解法\"><a href=\"#11-功能分解法\" class=\"headerlink\" title=\"11. 功能分解法\"></a>11. 功能分解法</h2><p>首先定义各项功能，然后把较大的功能分解为子功能，直到这些功能或子功能的大小比较适当，并能给出明确的定义。</p>\n<h2 id=\"12-结构化方法\"><a href=\"#12-结构化方法\" class=\"headerlink\" title=\"12. 结构化方法\"></a>12. 结构化方法</h2><p>研究问题域中数据如何流动以及在各个环节上如何进行处理，从而发现数据流和加工。最终得到的分析模型是数据流图。</p>\n<h2 id=\"13-数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\"><a href=\"#13-数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\" class=\"headerlink\" title=\"13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\"></a>13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。</h2><h2 id=\"14-实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\"><a href=\"#14-实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\" class=\"headerlink\" title=\"14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\"></a>14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。</h2><h2 id=\"15-信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\"><a href=\"#15-信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\" class=\"headerlink\" title=\"15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\"></a>15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。</h2><h2 id=\"16-先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\"><a href=\"#16-先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\" class=\"headerlink\" title=\"16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\"></a>16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。</h2><h2 id=\"17-面向对象建模方法具有如下优点：\"><a href=\"#17-面向对象建模方法具有如下优点：\" class=\"headerlink\" title=\"17. 面向对象建模方法具有如下优点：\"></a>17. 面向对象建模方法具有如下优点：</h2><ol>\n<li>对问题域和系统责任的复杂性具有较强的处理能力；</li>\n<li>提供了便于各类相关人员交流的共同语言；</li>\n<li>对需求的变化具有较强的适应性；</li>\n<li>为实现分析与设计级别的软件复用提供了强有力的支持。</li>\n</ol>\n<h2 id=\"18-UML是一种建模语言，而不是一种建模方法。\"><a href=\"#18-UML是一种建模语言，而不是一种建模方法。\" class=\"headerlink\" title=\"18. UML是一种建模语言，而不是一种建模方法。\"></a>18. UML是一种建模语言，而不是一种建模方法。</h2><h2 id=\"19-属性有类属性和实例属性之分，必要时要加以区别。\"><a href=\"#19-属性有类属性和实例属性之分，必要时要加以区别。\" class=\"headerlink\" title=\"19. 属性有类属性和实例属性之分，必要时要加以区别。\"></a>19. 属性有类属性和实例属性之分，必要时要加以区别。</h2><h2 id=\"20-数据抽象是面向对象方法的核心原则。\"><a href=\"#20-数据抽象是面向对象方法的核心原则。\" class=\"headerlink\" title=\"20. 数据抽象是面向对象方法的核心原则。\"></a>20. 数据抽象是面向对象方法的核心原则。</h2><h2 id=\"21-没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\"><a href=\"#21-没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\" class=\"headerlink\" title=\"21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\"></a>21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。</h2><h2 id=\"22-消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\"><a href=\"#22-消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\" class=\"headerlink\" title=\"22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\"></a>22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。</h2><h2 id=\"23-在面向对象的软件系统中，所有的对象都是通过类描述的。\"><a href=\"#23-在面向对象的软件系统中，所有的对象都是通过类描述的。\" class=\"headerlink\" title=\"23. 在面向对象的软件系统中，所有的对象都是通过类描述的。\"></a>23. 在面向对象的软件系统中，所有的对象都是通过类描述的。</h2><h2 id=\"24-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\"><a href=\"#24-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\" class=\"headerlink\" title=\"24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\"></a>24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。</h2><h2 id=\"25-可用以下-4-句话来概括对象和类这两个概念在面向对象建模中的应用规则：\"><a href=\"#25-可用以下-4-句话来概括对象和类这两个概念在面向对象建模中的应用规则：\" class=\"headerlink\" title=\"25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则：\"></a>25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则：</h2><ol>\n<li>从对象出发认识问题域，将问题域中的事物抽象为对象；</li>\n<li>将具有共同特征的对象抽象为类，用类以及它们之间的关系构成整个系统模型；</li>\n<li>模型中不包含实例级的元素，用类来表示属于该类的任何对象实例；</li>\n<li>在类的规约中说明这个类将创建哪些对象实例。</li>\n</ol>\n<h2 id=\"26-如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\"><a href=\"#26-如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\" class=\"headerlink\" title=\"26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\"></a>26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。</h2><h2 id=\"27-属性是用来描述对象静态特征的一个数据项-操作是用来描述对象动态特征（行为）的一个动作序列。\"><a href=\"#27-属性是用来描述对象静态特征的一个数据项-操作是用来描述对象动态特征（行为）的一个动作序列。\" class=\"headerlink\" title=\"27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。\"></a>27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。</h2><h2 id=\"28-确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\"><a href=\"#28-确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\" class=\"headerlink\" title=\"28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\"></a>28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。</h2><h2 id=\"29-一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\"><a href=\"#29-一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\" class=\"headerlink\" title=\"29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\"></a>29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。</h2><p>通过接口进行衔接，则接口在它的使用者和提供者之间起到了隔离作用，二者可以分别实现，并且可以有多种不同的实现，只要都遵守接口所规定的合约，就可以通过该接口相互衔接。</p>\n<h2 id=\"30-接口由某些类提供，为另外某些类所需要。\"><a href=\"#30-接口由某些类提供，为另外某些类所需要。\" class=\"headerlink\" title=\"30. 接口由某些类提供，为另外某些类所需要。\"></a>30. 接口由某些类提供，为另外某些类所需要。</h2><h2 id=\"31-接口与对象类相比，有以下几点不同：\"><a href=\"#31-接口与对象类相比，有以下几点不同：\" class=\"headerlink\" title=\"31. 接口与对象类相比，有以下几点不同：\"></a>31. 接口与对象类相比，有以下几点不同：</h2><ol>\n<li>类既有属性又有操作；接口只是声明了一组操作，没有属性。</li>\n<li>在一个类中定义了一个操作，就要在这个类中真正地实现它的功能；接口中的操作只是一个声明，不需要在接口中加以实现。</li>\n<li>类可以创建对象实例；接口则没有任何实例。</li>\n</ol>\n<h2 id=\"32-对象之间的-4-种重要关系，即继承、聚合、关联和信息。\"><a href=\"#32-对象之间的-4-种重要关系，即继承、聚合、关联和信息。\" class=\"headerlink\" title=\"32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。\"></a>32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。</h2><h2 id=\"33-系统中的一般类应该符合下述3个条件之一才有存在的价值：\"><a href=\"#33-系统中的一般类应该符合下述3个条件之一才有存在的价值：\" class=\"headerlink\" title=\"33. 系统中的一般类应该符合下述3个条件之一才有存在的价值：\"></a>33. 系统中的一般类应该符合下述3个条件之一才有存在的价值：</h2><ol>\n<li>它有两个或两个以上的特殊类；</li>\n<li>需要用它创建对象实例；</li>\n<li>它的存在有助于软件复用。</li>\n</ol>\n<h2 id=\"34-聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\"><a href=\"#34-聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\" class=\"headerlink\" title=\"34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\"></a>34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。</h2><h2 id=\"35-如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\"><a href=\"#35-如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\" class=\"headerlink\" title=\"35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\"></a>35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。</h2><h2 id=\"36-关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\"><a href=\"#36-关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\" class=\"headerlink\" title=\"36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\"></a>36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。</h2><h2 id=\"37-消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\"><a href=\"#37-消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\" class=\"headerlink\" title=\"37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\"></a>37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。</h2><h2 id=\"38-在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0-到多个），即接收消息的操作要求的输入参数；返回参数（0-到多个），即接收消息的操作提供的输出参数。\"><a href=\"#38-在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0-到多个），即接收消息的操作要求的输入参数；返回参数（0-到多个），即接收消息的操作提供的输出参数。\" class=\"headerlink\" title=\"38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。\"></a>38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。</h2>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（1）——HTML5移动Web开发指南","slug":"读书笔记系列（1）——HTML5移动Web开发指南","date":"2017-04-06T07:41:14.000Z","updated":"2019-06-03T04:46:43.383Z","comments":true,"path":"api/articles/读书笔记系列（1）——HTML5移动Web开发指南.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h2><h3 id=\"包含匹配选择器\"><a href=\"#包含匹配选择器\" class=\"headerlink\" title=\"包含匹配选择器\"></a>包含匹配选择器</h3><p>包含匹配比完全匹配范围更广。只要元素中的属性包含有指定的字符串，元素就使用该样式。其语法是：<code>[attribute*=value]</code>。</p>\n<p>其中 attribute 指的是属性名，value 指的是属性值，包含匹配采用 “ *=” 符号。</p>\n<h3 id=\"首字符匹配选择器\"><a href=\"#首字符匹配选择器\" class=\"headerlink\" title=\"首字符匹配选择器\"></a>首字符匹配选择器</h3><p>首字符匹配就是匹配属性值开头字符，只要开头字符符合匹配，则元素使用该样式。其语法是：<code>[attribute^=value]</code>。</p>\n<p>其中 attribute 指的是属性名，value 指的是属性值，首字符匹配采用“ ^=”符号。</p>\n<h3 id=\"尾字符匹配选择器\"><a href=\"#尾字符匹配选择器\" class=\"headerlink\" title=\"尾字符匹配选择器\"></a>尾字符匹配选择器</h3><p>尾字符匹配跟首字符匹配原理一样。尾字符只匹配结尾的字符串，只要结尾字符串符合匹配，则元素使用该样式。其语法是：<code>[attribute$=value]</code>。其中 attribute 指的是属性名，value 指的是属性值，尾字符匹配采用 “ $=”符号。</p>\n<h2 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h2><h3 id=\"before\"><a href=\"#before\" class=\"headerlink\" title=\"before\"></a>before</h3><p>before 伪类元素选择器主要的作用是在选择某个元素之前插入内容，一般用于清除浮动。before 选择器的语法是：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素标签<span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">\"插入的内容\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例如，在 p 元素之前插入“文字”：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-class\">.before</span>&#123; <span class=\"attribute\">content</span>: <span class=\"string\">\"文字\"</span> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\"after\"></a>after</h3><p>after 伪类元素选择器和 before 伪类元素选择器原理一样，但 after 是在选择某个元素之后插入内容。after 选择器的语法是：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素标签<span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"插入的内容\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"first-child\"><a href=\"#first-child\" class=\"headerlink\" title=\"first-child\"></a>first-child</h3><p>指定元素列表中第一个元素的样式。语法：<code>li:first-child</code></p>\n<h3 id=\"last-child\"><a href=\"#last-child\" class=\"headerlink\" title=\"last-child\"></a>last-child</h3><p>和 first-child 是同类型的选择器。last-child 指定元素列表中最后一个元素的样式。语法：<code>li:last-child</code></p>\n<h3 id=\"nth-child-和-nth-last-child\"><a href=\"#nth-child-和-nth-last-child\" class=\"headerlink\" title=\"nth-child 和 nth-last-child\"></a>nth-child 和 nth-last-child</h3><p>指定某个元素的样式或从后数起某个元素的样式。</p>\n<h2 id=\"阴影\"><a href=\"#阴影\" class=\"headerlink\" title=\"阴影\"></a>阴影</h2><h3 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h3><blockquote>\n<p>box-shadow: <code>&lt;length&gt; &lt;length&gt; &lt;length&gt;</code> || color</p>\n</blockquote>\n<p>第一个 length 值是阴影水平偏移值；第二个 length 值是阴影垂直偏移值；第三个 length 值是阴影模糊值。水平和垂直偏移值都可取正负值。</p>\n<p>基于 Webkit 的 Chrome 和 Safari 等浏览器：-webkit-box-shadow</p>\n<p>Firebox 浏览器：-moz-box-shadow</p>\n<h3 id=\"text-shadow\"><a href=\"#text-shadow\" class=\"headerlink\" title=\"text-shadow\"></a>text-shadow</h3><blockquote>\n<p>text-shadow: <code>&lt;length&gt; &lt;length&gt; &lt;length&gt;</code> || color</p>\n</blockquote>\n<p>第一个 length 值是阴影水平偏移值；第二个 length 值是阴影垂直偏移值；第三个 length 值是阴影模糊值。水平和垂直偏移值都可取正负值。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size**\"></a>background-size**</h3><p>背景图像的大小</p>\n<h3 id=\"background-clip\"><a href=\"#background-clip\" class=\"headerlink\" title=\"background-clip\"></a>background-clip</h3><p>背景的裁剪区域</p>\n<blockquote>\n<p>background-clip: border-box | padding-box | content-box | no-clip</p>\n</blockquote>\n<p>其中：</p>\n<ul>\n<li>border-box 是从 border 区域向外裁剪背景；</li>\n<li>padding-box 是从 padding 区域向外裁剪背景；</li>\n<li>content-box 是从内容区域向外裁剪背景；</li>\n<li>no-clip 是从 border 区域向外裁剪背景。</li>\n</ul>\n<h3 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h3><p>background-origin 属性是指定 background-position 属性的参考坐标的起始位置。 background-origin 属性有三种值可以选择，border 值指定从边框的左上角坐标开始；content 值指定从内容区域的左上角坐标开始；padding 值指定从 padding 区域开始。</p>\n<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>可以使用 Webkit 的其中一种特性对背景采用颜色渐变，而非采用图片方式。</p>\n<blockquote>\n<p>-webkit-gradient(<code>&lt;type&gt;, &lt;port&gt;[, &lt;radius&gt;]?,&lt;point&gt; [, &lt;radius&gt;]? [, &lt;stop&gt;]*</code>)</p>\n</blockquote>\n<p>type 类型是指采用渐变类型，如线性渐变 linear 或径向渐变 radial。如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">-webkit-gradient</span>(<span class=\"selector-tag\">linear</span>, 0 0, 0 100%, <span class=\"selector-tag\">form</span>(<span class=\"selector-id\">#FFF</span>), <span class=\"selector-tag\">to</span>(<span class=\"selector-id\">#000</span>));</span><br></pre></td></tr></table></figure>\n<p>上述代码的含义是定义一个渐变背景色，该渐变色是线性渐变并且是由白色向黑色渐变的。其中前两个 0 表示的是渐变开始 <strong>X</strong> 和 <strong>Y</strong> 坐标位置；0 和 100%表示的是渐变结束 <strong>X</strong> 和 <strong>Y</strong> 坐标位置。</p>\n<h2 id=\"Media-Queries-移动设备样式\"><a href=\"#Media-Queries-移动设备样式\" class=\"headerlink\" title=\"Media Queries 移动设备样式\"></a>Media Queries 移动设备样式</h2><h3 id=\"viewport设置适应移动设备屏幕大小\"><a href=\"#viewport设置适应移动设备屏幕大小\" class=\"headerlink\" title=\"viewport设置适应移动设备屏幕大小\"></a>viewport设置适应移动设备屏幕大小</h3><p>Android Browser 浏览器的默认值是 800 像素；IE 浏览器的默认值是 974 像素；Opera 浏览器的默认值是 850 像素。viewport 虚拟窗口是在 meta 元素中定义的，其主要作用是设置 Web 页面适应移动设备的屏幕大小。 如以下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1,user-scalable=0\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>代码中的 content 属性内共定义三种参数。实际上 content 属性允许设置 6 种不同的 参数，分别如下：</p>\n<ul>\n<li>width：指定虚拟窗口的屏幕宽度大小。</li>\n<li>height：指定虚拟窗口的屏幕高度大小。</li>\n<li>initial-scale：指定初始缩放比例。</li>\n<li>maximum-scale：指定允许用户缩放的最大比例。</li>\n<li>minimum-scale：指定允许用户缩放的最小比例。</li>\n<li>user-scalable：指定是否允许手动缩放。</li>\n</ul>\n<h3 id=\"Media-Queries-如何工作\"><a href=\"#Media-Queries-如何工作\" class=\"headerlink\" title=\"Media Queries 如何工作\"></a>Media Queries 如何工作</h3><p>要实现 Media Queries 样式模块，需要在 head 标签内导入一个 CSS 样式文件，例如，下面代码使用 media 属性定义当前屏幕可视区域的宽度最大值是 600 像素时应用该样式文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"screen and(max-width:600px)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"small.css\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在 small.css 样式文件内，需要定义 media 类型的样式，例如： </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> screen and (max-width:<span class=\"number\">600px</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.demo</span>&#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#CCC</span>; &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样也可以判断当移动设备（如 iPad）的方向发生变化时应用该样式。以下代码是当移动设备处于纵向（portrait）模式下时，应用 portrait 样式文件；当移动设备处于横向（landscape）模式下时，应用 landscape 样式文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"all and(orientation:portrait)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"portrait.css\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"all and(orientation:landscape)\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"landscape.css\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Media-Queries-语法总结\"><a href=\"#Media-Queries-语法总结\" class=\"headerlink\" title=\"Media Queries 语法总结\"></a>Media Queries 语法总结</h3><p>Media Queries 的语法如下所示：</p>\n<blockquote>\n<p>@media [media_query] media_type and media_feature</p>\n</blockquote>\n<p>使用 Media Queries 样式模块时都必须以 “@media” 方式开头。media_query 表示查询关键字，在这里可以使用 not 关键字和 only 关键字。not 关键字表示对后面的样式表达式执行取反操作。例如如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> not screen and (max-device-width:<span class=\"number\">480px</span>)</span><br></pre></td></tr></table></figure>\n<p>only 关键字的作用是，让不支持 Media Queries 的设备但能读取 Media Type 类型的浏览器忽略这个样式。例如如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> only screen and (max-device-width:<span class=\"number\">480px</span>)</span><br></pre></td></tr></table></figure>\n<p>对于支持 Media Queries 的移动设备来说，如果存在 only 关键字，移动设备的 Web 浏览器会忽略 only 关键字并直接根据后面的表达式应用样式文件。对于不支持 Media Queries 的设备但能够读取 Media Type 类型的 Web 浏览器，遇到 only 关键字时会忽略这个样式文件。</p>\n<p>media_type 参数的作用是指定设备类型，通常称为媒体类型。实际上在 CSS2.1 版本时已经定义了该媒体类型。</p>\n<ul>\n<li><strong>all</strong>                 所有设备</li>\n<li><strong>aural</strong>               听觉设备</li>\n<li><strong>braille</strong>             点字触觉设备</li>\n<li><strong>handled</strong>             便携设备，如手机、平板电脑</li>\n<li><strong>print</strong>               打印预览图等</li>\n<li><strong>projection</strong>          投影设备</li>\n<li><strong>screen</strong>              显示器、笔记本、移动端等设备</li>\n<li><strong>tty</strong>                 如打字机或终端等设备</li>\n<li><strong>tv</strong>                  电视机等设备类型</li>\n<li><strong>embossed</strong>            盲文打印机</li>\n</ul>\n<p>media_feature 的主要作用是定义 CSS 中的设备特性，大部分移动设备特性都允许接受 min/max 的前缀。 例如，min-width 表示指定大于等于该值；max-width 表示指定小于等于该值。</p>\n","raw":null,"categories":[{"name":"html","path":"api/categories/html.json"}],"tags":[{"name":"HTML","path":"api/tags/HTML.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列","slug":"读书笔记系列","date":"2017-04-06T07:39:34.000Z","updated":"2019-06-03T04:46:43.383Z","comments":true,"path":"api/articles/读书笔记系列.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>“书中自有黄金屋”，这里汇集了我所读过的书的笔记，在闲下来的时候与其打游戏还不如看会书：</p>\n<ul>\n<li><a href=\"/20170406/html5-mobile-web-development-guide.html\">HTML5移动Web开发指南</a></li>\n<li><a href=\"/20170406/object-oriented-analysis-and-design.html\">面向对象的分析与设计</a></li>\n<li><a href=\"/20170406/excellent-css.html\">精彩绝伦的CSS</a></li>\n<li><a href=\"/20170406/the-way-to-practice-web-front-end-development.html\">编写高质量代码-Web前端开发修炼之道</a></li>\n<li><a href=\"/20170406/html5-and-css3-actual-warfare.html\">响应式Web设计-HTML5和CSS3实战</a></li>\n<li><a href=\"/20170408/dahua-data-structure.html\">大话数据结构</a></li>\n<li><a href=\"/20170706/css-secrets.html\">CSS Secrets</a></li>\n<li><a href=\"/20171010/you-dont-know-js-volume1.html\">你不知道的JavaScript（上卷）</a></li>\n</ul>\n","raw":null,"categories":[{"name":"series","path":"api/categories/series.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"前端面试系列（10）——JS中的闭包","slug":"前端面试系列（10）——JS中的闭包","date":"2017-04-05T13:12:15.000Z","updated":"2019-06-03T04:46:43.379Z","comments":true,"path":"api/articles/前端面试系列（10）——JS中的闭包.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>闭包这个概念其实并不是 JS 中独有的，很多开发者将其理解为 JS 的特有产物，其实是大错特错的；只不过 JS 中的闭包有着其他语言没有的特性和产生机理，所以对于闭包的理解成为了很多面试官垂青的问题，而真正理解闭包并且知道在什么时候用闭包、在什么时候避免闭包对于前端码农来说是一个不小的挑战，本篇文章就将深入剖析闭包的工作原理，以及如何使用和避免使用闭包</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>要理解闭包，首先必须理解 Javascript 特殊的变量作用域；在 JS 中，变量的作用域无非就是两种：全局变量和局部变量：</p>\n<ul>\n<li>全局变量，顾名思义，在函数内部也可以直接读取全局变量</li>\n<li>局部变量，在函数外部是无法读取函数内的局部变量的（<strong>函数内声明变量的时候，一定要使用 var / let 命令，否则相当于声明了一个全局变量</strong>）</li>\n</ul>\n<p>我们有时候需要得到函数内的局部变量，但是从上面的讲解可以看到，正常情况下是办不到的，所以只能变通：<strong>在函数的内部，再定义一个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(n);  <span class=\"comment\">//999</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就引出了另外一个概念，就是 Javascript 语言特有的“<strong>链式作用域</strong>”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量；援引<a href=\"http://www.yanshiba.com/\" target=\"_blank\" rel=\"noopener\">燕十八</a>老师的话，只要在一对大括号之内声明的变量，在这个大括号里面的任何地方都可以访问到该变量。<br>根据上面的代码，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们就可以在 f1 外部读取它的内部变量了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(n); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result=f1();</span><br><span class=\"line\">result(); <span class=\"comment\">// 999</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>上面代码中的 f2 函数，就是闭包。 闭包是 JavaScript（以及其他大多数编程语言）的一个极其强大的属性。正如在 MDN (Mozilla Developer Network) 中定义的那样：</p>\n<blockquote>\n<p>闭包是指能够访问自由变量的函数。换句话说，在闭包中定义的函数可以“记忆”它被创建的环境。</p>\n</blockquote>\n<p>自由变量是既不是在本地声明又不作为参数传递的一类变量。（如果一个作用域中使用的变量并不是在该作用域中声明的，那么这个变量对于该作用域来说就是自由变量），上面例子中的 n 在 f2 中 alert，但是 f2 中并没有声明 n，所以 n 对于 f2 这个大括号形成的作用域来说就是自由变量；更通俗来讲的话，闭包是能够读取其他函数内部变量的函数，所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>\n<h2 id=\"闭包的用途\"><a href=\"#闭包的用途\" class=\"headerlink\" title=\"闭包的用途\"></a>闭包的用途</h2><p>闭包一个非常重要的用途：保留外部作用域对一个变量的私有引用（仅通过唯一途径例如某一个特定函数来访问一个变量），来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 5, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 5, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 5, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 5, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 5, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>这里之所以会打印 5 个 “5”，是因为这五个函数的作用域全部相同（var i = 0 这一句可以提到 for 循环外面，对于 5 个函数来说，只有一个 i，就是循环结束时的那个 i）；也就是说，每次变量 i 增加时，作用域都会更新–这个作用域被所有函数共享。一个解决办法就是为每个函数创建一个额外的封闭环境，使得它们各自都有自己的执行上下文 / 作用域：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// additional enclosing context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 0, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 1, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 2, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 3, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 4, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>另外，因为 ES6 的缘故，所以我们可以使用 let 来代替 var，因为 let 声明的是块级作用域（在 ES5 中，是没有块级作用域的），因此每次迭代都会创建一个新的标示符绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 0, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 1, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 2, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 3, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 4, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>再来看一个例子（MDN 给出的一个闭包的例子）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>));  <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>我们定义了一个方法 makeAdder(x)，这个方法只有一个变量 x，然后返回了一个新的方法；返回的方法呢只有一个变量 y，然后 return 的结果是 x + y；所以，makeAdder(x) 就被我们打造成了一个“方法工厂”，在上面的例子中我们利用这个“工厂”生产了两个新的方法，一个返回的结果是 5 加上变量，另外一个返回 10 加上传进来的变量；不出所料，add5 和 add10 这两个方法都是闭包，他们共享同样的方法体定义，但是存储了不同的词法环境（关于词法环境，本文将不详细探讨，感兴趣的可以自行查阅资料，暂时可以简单的理解为变量所在的环境）；在 add5 的词法环境，x 是 5；而在 add10 的词法环境中，x 是 10；通过这个例子，我们可以看到闭包可以用来打造“方法工厂”，而这个特性也成为了我们避免使用闭包的理由</p>\n<h2 id=\"避免使用闭包\"><a href=\"#避免使用闭包\" class=\"headerlink\" title=\"避免使用闭包\"></a>避免使用闭包</h2><p>曾经我被闭包强大的特性所吸引，直到我看到一些关于“避免使用闭包”的博客，才知道闭包带来的麻烦会比其提供的方便更值得重视；JS 的内存释放和 Java 类似，有一个内存回收机制，没有被引用的对象都会被自动释放，而出现闭包的时候会导致变量无法被释放，下面看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> closure1 = closure();</span><br></pre></td></tr></table></figure>\n<p>closure 方法返回的这个方法，在 closure1 方法每次调用的时候，都可以访问 data 对象，所以由此可见，data 对象的引用没有被释放，否则的话 closure1 方法将无法访问到data对象。这里可以明显的看出来闭包是会把局部变量引用起来导致无法释放的“副作用”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> closure2 = closure();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(closure1 === closure2); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(closure1() === closure2()); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出来，closure 方法执行两次得到两个方法，这两个方法不是一个方法，两个方法可以访问的 data 对象也不是同一个对象。也就是说 closure 执行一次，就有一个新对象 data 产生，同时生成一个新的方法，返回出去。每次 closure 方法的执行就导致内存中多了一个 data 对象，多了一个 function(return data)，很明显<strong>这会导致内存的膨胀。使用不当就会导致内存的泄露</strong>。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><p>关于闭包就介绍到这里了，但是为了更容易让初学者理解，本文省略掉了很多相关概念的介绍（执行上下文、词法环境、静态作用域），感兴趣的话可以查阅相关资料，如果有机会的话，我会再查阅更多资料，详细的介绍一下和闭包有关的其他概念，下面是我推荐的一些关于闭包讲解的链接：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener\">MDN-Lexical scoping</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\" target=\"_blank\" rel=\"noopener\">学习Javascript闭包（Closure）</a></li>\n<li><a href=\"http://web.jobbole.com/88167/\" target=\"_blank\" rel=\"noopener\">让我们一起学习JavaScript闭包吧</a></li>\n<li><a href=\"http://www.jb51.net/article/83524.htm\" target=\"_blank\" rel=\"noopener\">一分钟理解js闭包</a></li>\n<li><a href=\"http://rainfall.blog.51cto.com/8402174/1344225\" target=\"_blank\" rel=\"noopener\">理解js闭包是为了避免使用闭包</a></li>\n<li><a href=\"https://stackoverflow.com/questions/111102/how-do-javascript-closures-work\" target=\"_blank\" rel=\"noopener\">Stackoverflow-How do JavaScript closures work?</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（9）——JS实现继承","slug":"前端面试系列（9）——JS实现继承","date":"2017-04-05T13:11:07.000Z","updated":"2019-06-03T04:46:43.379Z","comments":true,"path":"api/articles/前端面试系列（9）——JS实现继承.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_316.jpg","content":"<p>JS 虽然声称面向对象，但是其很多特性与真正的“面向对象”仍有一定差距；面向对象的一大特性就是可以继承，所以如何在 JS 这种弱类型语言中实现继承就成为了前端面试中的常见问题，下面我就总结一下在 JS 中实现继承的几种方式：</p>\n<h2 id=\"定义父类\"><a href=\"#定义父类\" class=\"headerlink\" title=\"定义父类\"></a>定义父类</h2><p>既然要实现继承，首先得有一个父类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1、原型链继承\"><a href=\"#1、原型链继承\" class=\"headerlink\" title=\"1、原型链继承\"></a>1、原型链继承</h2><p><strong>核心</strong>：将父类的实例作为子类的原型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>\n<li>父类新增原型方法 / 原型属性，子类都能访问到</li>\n<li>简单，易于实现</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>要想为子类新增属性和方法，必须要在 <code>new Animal()</code> 这样的语句之后执行，不能放到构造器中</li>\n<li>无法实现多继承</li>\n<li>来自原型对象的引用属性是所有实例共享的</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n</ol>\n<p><strong>推荐指数</strong>：★★（3、4 两大致命缺陷）</p>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p><strong>核心</strong>：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 除了 call 方法，也可以用 apply()，由于篇幅原因，就不再详细介绍这两种方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>解决了 1 中，子类实例共享父类引用属性的问题</li>\n<li>创建子类实例时，可以向父类传递参数</li>\n<li>可以实现多继承（call 多个父类对象）</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实例并不是父类的实例，只是子类的实例</li>\n<li>只能继承父类的实例属性和方法，不能继承原型属性 / 方法</li>\n<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>\n</ol>\n<p><strong>推荐指数</strong>：★★（缺点3）</p>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p><strong>核心：</strong>：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>不限制调用方式，不管是 <code>new 子类()</code>还是<code>子类()</code>，返回的对象具有相同的效果</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实例是父类的实例，不是子类的实例</li>\n<li>不支持多继承</li>\n</ol>\n<p><strong>推荐指数</strong>：★★</p>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><p><strong>特点</strong>：使用 for in 将父类实例中的方法赋给子类实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>\n<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）</li>\n</ol>\n<p><strong>推荐指数</strong>：★（缺点 1）</p>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p><strong>核</strong>：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>弥补了方式 2 的缺陷，可以继承实例属性 / 方法，也可以继承原型属性 / 方法</li>\n<li>既是子类的实例，也是父类的实例</li>\n<li>不存在引用属性共享问题</li>\n<li>可传参</li>\n<li>函数可复用</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<p><strong>推荐指数</strong>：★★★★（仅仅多消耗了一点内存，也是最常用的一种继承方式）</p>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p><strong>核心</strong>：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法 / 属性，避免的组合继承的缺点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>堪称完美</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实现较为复杂</li>\n</ol>\n<p><strong>推荐指数</strong>：★★★★（实现复杂，扣掉一颗星）</p>\n<h2 id=\"7、六种继承方式的联系\"><a href=\"#7、六种继承方式的联系\" class=\"headerlink\" title=\"7、六种继承方式的联系\"></a>7、六种继承方式的联系</h2><div align=\"center\"><img src=\"/images/hexo_post_316.jpg\" alt=\"\" width=\"300\"></div>\n\n<p>PS：虚线表示辅助作用，实现表示决定性作用</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/humin/p/4556820.html\" target=\"_blank\" rel=\"noopener\">JS继承的实现方式</a></li>\n<li><a href=\"http://www.cnblogs.com/ayqy/p/4471638.html\" target=\"_blank\" rel=\"noopener\">重新理解JS的6种继承方式</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（8）——TCP的三次握手与四次分手","slug":"前端面试系列（8）——TCP的三次握手与四次分手","date":"2017-04-05T08:07:21.000Z","updated":"2019-06-03T04:46:43.379Z","comments":true,"path":"api/articles/前端面试系列（8）——TCP的三次握手与四次分手.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_123.jpg","content":"<h2 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h2><h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><p><a href=\"http://baike.baidu.com/link?url=eNyUOgDeOV5z-03dVd8M1Y2jazNBA9n_eeqpsGs6DROKf_Eezztf31POgn2yMVtzxhX1BIcma9hIT2lzwaeswKAUZHNBSzFasHHI6SsZKnGJJVu2fKrPkMh3byyFTt1j4VqBV4re8SYTBTMDXY_L7clee5XEglKSOAWJqr5E_QRD6INjs03VMQNOUstxguVR-oOfOPGi4cah5m0VFukOkpT6STLUEGHWUIUUYFv0aAgMRFovp5EWN7V3iMdEZQ0a6ikGU90BRIYMLLIKsVNjP8Szj4c6SexwpfRM6D5CjjG\" target=\"_blank\" rel=\"noopener\">开放系统互连参考模型</a> (Open System Interconnect 简称 OSI）是国际标准化组织（ISO）和国际电报电话咨询委员会（CCITT）联合制定的开放系统互连参考模型，为开放式互连信息系统提供了一种功能结构的框架。它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每一层的功能是独立的。它利用其下一层提供的服务并为其上一层提供服务，而与其他层的具体实现无关。这里所谓的“服务”就是下一层向上一层提供的通信功能和层之间的会话规定，一般用通信原语实现。两个开放系统中的同等层之间的通信规则和约定称之为协议。通常把1～4层协议称为下层协议，5～7 层协议称为上层协议。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_123.jpg\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP / IP\"></a>TCP / IP</h3><p>TCP 工作在网络 OSI 的七层模型中的第四层——Transport 层，IP 在第三层——Network 层，ARP 在第二层——Data Link 层；在第二层上的数据，我们把它叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。在 OSI 七层模型中，每一层的作用和对应的协议如下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_58.jpeg\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h2><p>TCP 是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记 TCP 协议中每个字段的含义。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_223.jpg\" alt=\"\" width=\"700\"></div>\n\n<p>上面就是 TCP 协议头部的格式，下面就将每个字段的信息都详细的说明一下。</p>\n<ul>\n<li><strong>Source Port</strong>和<strong>Destination Port</strong>：分别占用 16 位，表示源端口号和目的端口号；用于区别主机中的不同进程，而 IP 地址是用来区分不同的主机的，源端口号和目的端口号配合上 IP 首部中的源 IP 地址和目的 IP 地址就能唯一的确定一个 TCP 连接；</li>\n<li><strong>Sequence Number</strong>：用来标识从 TCP 发端向 TCP 收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</li>\n<li><strong>Acknowledgment Number</strong>：32 位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加 1。不过，只有当标志位中的 ACK 标志（下面介绍）为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题；</li>\n<li><strong>Offset</strong>：给出首部中 32 bit 字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占 4bit（最多能表示 15 个 32bit 的的字，即 4*15=60 个字节的首部长度），因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节；</li>\n<li><strong>TCP Flags</strong>：TCP 首部中有 6 个标志比特，它们中的多个可同时被设置为 1，主要是用于操控 TCP 的状态机的，依次为 <code>URG</code>，<code>ACK</code>，<code>PSH</code>，<code>RST</code>，<code>SYN</code>，<code>FIN</code>。每个标志位的意思如下：<ul>\n<li>URG：此标志表示 TCP 包的紧急指针域（后面马上就要说到）有效，用来保证 TCP 连接不被中断，并且督促中间层设备要尽快处理这些数据；</li>\n<li><strong>ACK</strong>：此标志表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0；</li>\n<li>PSH：这个标志位表示 Push 操作。所谓 Push 操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li>\n<li>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li>\n<li><strong>SYN</strong>：表示同步序号，用来建立连接。<code>SYN</code> 标志位和 <code>ACK</code> 标志位搭配使用，当连接请求的时候，<code>SYN</code> = 1，<code>ACK</code> = 0；连接被响应的时候，<code>SYN</code> = 1，<code>ACK</code> = 1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 <code>SYN</code> 的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行 TCP 三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行 TCP 的三次握手；</li>\n<li>FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送 <code>FIN</code> 标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li>\n</ul>\n</li>\n<li><strong>Window</strong>：窗口大小，也就是有名的滑动窗口，用来进行流量控制；这是一个复杂的问题，这篇博文中并不会进行总结的；</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p>TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP / IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。这就是面试中经常会被问到的 <strong>TCP 三次握手</strong>。\b下图很形象的展示了三次握手和四次分手的数据交换：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_74.jpg\" alt=\"\" width=\"400\"></div>\n\n<ol>\n<li>第一次握手：建立连接。客户端发送连接请求报文段，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为 x；然后，客户端进入 <code>SYN_SEND</code> 状态，等待服务器的确认；</li>\n<li>第二次握手：服务器收到 <code>SYN</code> 报文段。服务器收到客户端的 <code>SYN</code> 报文段，需要对这个 <code>SYN</code> 报文段进行确认，设置 <code>Acknowledgment Number</code> 为 x+1(<code>Sequence Number</code> + 1)；同时，自己自己还要发送 <code>SYN</code> 请求信息，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为 y；服务器端将上述所有信息放到一个报文段（即 <code>SYN + ACK</code> 报文段）中，一并发送给客户端，此时服务器进入 <code>SYN_RECV</code> 状态；</li>\n<li>第三次握手：客户端收到服务器的<code>SYN + ACK</code> 报文段。然后将 <code>Acknowledgment Number</code> 设置为 y+1，向服务器发送 <code>ACK</code> 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <code>ESTABLISHED</code> 状态，完成 TCP 三次握手。</li>\n</ol>\n<p>完成了三次握手，客户端和服务器端就可以开始传送数据。</p>\n<h2 id=\"四次分手\"><a href=\"#四次分手\" class=\"headerlink\" title=\"四次分手\"></a>四次分手</h2><p>当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的啊。那对于 TCP 的断开连接，这里就有了神秘的“四次分手”。</p>\n<ol>\n<li>第一次分手：主机 1（可以是客户端，也可以是服务器端），设置 <code>Sequence Number</code> 和 <code>Acknowledgment Number</code>，向主机 2 发送一个 <code>FIN</code> 报文段；此时，主机 1 进入 <code>FIN_WAIT_1</code> 状态；这表示主机1没有数据要发送给主机 2 了；</li>\n<li>第二次分手：主机 2 收到了主机1发送的 <code>FIN</code> 报文段，向主机 1 回一个 <code>ACK</code> 报文段，<code>Acknowledgment Number</code> 为 <code>Sequence Number</code> 加 1；主机 1 进入 <code>FIN_WAIT_2</code> 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；</li>\n<li>第三次分手：主机 2 向主机 1 发送 <code>FIN</code> 报文段，请求关闭连接，同时主机 2 进入 <code>LAST_ACK</code> 状态；</li>\n<li>第四次分手：主机 1 收到主机 2 发送的 <code>FIN</code> 报文段，向主机 2 发送 <code>ACK</code> 报文段，然后主机 1 进入 <code>TIME_WAIT</code> 状态；主机 2 收到主机 1 的 <code>ACK</code> 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。</li>\n</ol>\n<p>至此，TCP 的四次分手就这么愉快的完成了。</p>\n<h3 id=\"为什么要握手三次\"><a href=\"#为什么要握手三次\" class=\"headerlink\" title=\"为什么要握手三次\"></a>为什么要握手三次</h3><p>既然总结了 TCP 的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那 TCP 为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p>\n<blockquote>\n<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>\n</blockquote>\n<p>在书中同时举了一个例子：</p>\n<blockquote>\n<p>“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p>\n</blockquote>\n<p>总结一下就是为了<strong>防止服务器端一直等待而浪费资源。</strong></p>\n<h2 id=\"为什么要分手四次\"><a href=\"#为什么要分手四次\" class=\"headerlink\" title=\"为什么要分手四次\"></a>为什么要分手四次</h2><p>那四次分手又是为何呢？TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 <code>FIN</code> 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 <code>ACK</code> 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 <code>FIN</code> 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>\n<ul>\n<li><code>FIN_WAIT_1</code>：这个状态要好好解释一下，其实 <code>FIN_WAIT_1</code> 和 <code>FIN_WAIT_2</code> 状态的真正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是：<code>FIN_WAIT_1</code> 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 <code>FIN</code> 报文，此时该 SOCKET 即进入到 <code>FIN_WAIT_1</code> 状态。而当对方回应 ACK 报文后，则进入到 <code>FIN_WAIT_2</code> 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 <code>FIN_WAIT_1</code> 状态一般是比较难见到的，而 <code>FIN_WAIT_2</code> 状态还有时常常可以用 netstat 看到。（主动方）</li>\n<li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上 <code>FIN_WAIT_2</code> 状态下的 SOCKET，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK 信息)，稍后再关闭连接。（主动方）</li>\n<li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 <code>FIN</code> 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 <code>CLOSE_WAIT</code> 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 <code>FIN</code> 报文给对方，也即关闭连接。所以你在 <code>CLOSE_WAIT</code> 状态下，需要完成的事情是等待你去关闭连接。（被动方）</li>\n<li><code>LAST_ACK</code>：这个状态还是比较容易好理解的，它是被动关闭一方在发送 <code>FIN</code> 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 CLOSED 可用状态了。（被动方）</li>\n<li><code>TIME_WAIT</code>：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 <code>TIME_WAIT</code> 状态，而无须经过 <code>FIN_WAIT_2</code> 状态。（主动方）</li>\n<li><code>CLOSED</code>：表示连接中断。</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h3 id=\"1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\"><a href=\"#1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\" class=\"headerlink\" title=\"1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\"></a>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h3><p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p>\n<h3 id=\"2．为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态？\"><a href=\"#2．为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态？\" class=\"headerlink\" title=\"2．为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？\"></a>2．为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？</h3><p>这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/20879359\" target=\"_blank\" rel=\"noopener\">怎样生动描述TCP的「三次握手」？</a></li>\n</ul>\n","raw":null,"categories":[{"name":"computer-base","path":"api/categories/computer-base.json"}],"tags":[{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（7）——session&cookie","slug":"前端面试系列（7）——session&cookie","date":"2017-04-04T14:05:42.000Z","updated":"2019-06-03T04:46:43.379Z","comments":true,"path":"api/articles/前端面试系列（7）——session&cookie.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>本篇文章参考了一些开发者对于 session 和 cookie 的讲解，对这些内容进行了筛选和合并，同时加入了我的理解，争取用最短的篇幅给大家讲清楚这两个概念，因为在前端面试或笔试中会经常碰到这两个问题，同时在很多项目中也会用到</p>\n<h2 id=\"session-的概念\"><a href=\"#session-的概念\" class=\"headerlink\" title=\"session 的概念\"></a>session 的概念</h2><p>Web 应用程序是使用 HTTP 协议传输数据的。<strong>HTTP 协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</strong>。即用户 A 购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户 A 的会话还是用户 B 的会话了。要跟踪该会话，必须引入一种机制。<br>当浏览器第一次发送请求时，服务器自动生成了一个 Session 和一个 Session ID 用来唯一标识这个 Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的 Session ID 放在请求中一并发送到服务器上，服务器从请求中提取出 Session ID，并和保存的所有 Session ID 进行对比，找到这个用户对应的 Session。一般情况下，服务器会在一定时间内（默认 30 分钟）保存这个 Session，过了时间限制，就会销毁这个 Session。在销毁之前，程序员可以将用户的一些数据以 Key 和 Value 的形式暂时存放在这个 Session 中。当然，也有使用数据库将这个 Session 序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。</p>\n<h2 id=\"session-的客户端实现形式\"><a href=\"#session-的客户端实现形式\" class=\"headerlink\" title=\"session 的客户端实现形式\"></a>session 的客户端实现形式</h2><p>即 session ID 的保存方法，一般浏览器提供了两种方式来保存，还有一种是程序员使用 html 隐藏域的方式自定义实现：</p>\n<h3 id=\"使用-Cookie-来保存\"><a href=\"#使用-Cookie-来保存\" class=\"headerlink\" title=\"使用 Cookie 来保存\"></a>使用 Cookie 来保存</h3><p>这是最常见的方法，\b比如“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置 Cookie 的方式将 Session ID 发送到浏览器。如果我们不设置这个过期时间，那么这个 Cookie 将不存放在硬盘上，当浏览器关闭的时候，Cookie 就消失了，这个 Session ID 就丢失了。如果我们设置这个时间为若干天之后，那么这个 Cookie 会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同样会发送到服务器上。</p>\n<h3 id=\"使用-URL-附加信息的方式\"><a href=\"#使用-URL-附加信息的方式\" class=\"headerlink\" title=\"使用 URL 附加信息的方式\"></a>使用 URL 附加信息的方式</h3><p>也就是像我们经常看到 JSP 网站会有 aaa.jsp?JSESSIONID=* 一样的。这种方式和第一种方式里面不设置 Cookie 过期时间是一样的。</p>\n<h3 id=\"第三种方式是在页面表单里面增加隐藏域\"><a href=\"#第三种方式是在页面表单里面增加隐藏域\" class=\"headerlink\" title=\"第三种方式是在页面表单里面增加隐藏域\"></a>第三种方式是在页面表单里面增加隐藏域</h3><p>这种方式实际上和第二种方式一样，只不过前者通过 GET 方式发送数据，后者使用 POST 方式发送数据。但是明显后者比较麻烦。</p>\n<h2 id=\"cookie-的局限性\"><a href=\"#cookie-的局限性\" class=\"headerlink\" title=\"cookie 的局限性\"></a>cookie 的局限性</h2><p>Session 是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的 SessionID，用该 SessionID 为标识符来存取服务器端的 Session 存储空间。而 SessionID 这一数据则是保存到客户端，用 Cookie 保存的，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 Session 数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用 Cookie，那么 Session 也会失效。服务器也可以通过 URL 重写的方式来传递 SessionID 的值，因此不是完全依赖 Cookie。如果客户端 Cookie 禁用，则服务器可以自动通过重写URL的方式来保存 Session 的值，并且这个过程对程序员透明。可以试一下，即使不写 Cookie，在使用 request.getCookies(); 时取出的 Cookie 数组的长度也是 1，而这个 Cookie 的名字就是 JSESSIONID，还有一个很长的二进制的字符串，是 SessionID 的值。</p>\n<h2 id=\"cookie-的性质\"><a href=\"#cookie-的性质\" class=\"headerlink\" title=\"cookie 的性质\"></a>cookie 的性质</h2><ul>\n<li>不可跨域</li>\n<li>保存中文只能编码（UTF-8）</li>\n</ul>\n<h2 id=\"cookie-的应用\"><a href=\"#cookie-的应用\" class=\"headerlink\" title=\"cookie 的应用\"></a>cookie 的应用</h2><ol>\n<li>判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除 cookie，则每次登录必须从新填写登录的相关信息。</li>\n<li>另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入 cookie，在最后付款时从 cookie 中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。</li>\n<li>记录用户访问次数，服务器可以通过操作 Cookie 类对象对客户端 Cookie 进行操作</li>\n</ol>\n<h2 id=\"cookie-和-session-的区别和联系\"><a href=\"#cookie-和-session-的区别和联系\" class=\"headerlink\" title=\"cookie 和 session 的区别和联系\"></a>cookie 和 session 的区别和联系</h2><ol>\n<li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li>\n<li>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗；考虑到安全应当使用session。</li>\n<li>session 会在一定时间内保存在服务器的一个文件里（不是内存）。当访问增多，会比较占用你服务器的性能；考虑到减轻服务器性能方面，应当使用 COOKIE。</li>\n<li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</li>\n<li>session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）</li>\n<li>Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。</li>\n<li>如果说 <strong>Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</strong></li>\n</ol>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html\" target=\"_blank\" rel=\"noopener\">cookie 和session 的区别详解</a></li>\n<li><a href=\"https://www.zhihu.com/question/19786827\" target=\"_blank\" rel=\"noopener\">COOKIE和SESSION有什么区别</a></li>\n<li><a href=\"http://blog.csdn.net/duan1078774504/article/details/51912868\" target=\"_blank\" rel=\"noopener\">浅谈Session与Cookie的区别与联系</a></li>\n<li><a href=\"http://blog.csdn.net/fangaoxin/article/details/6952954\" target=\"_blank\" rel=\"noopener\">Cookie/Session机制详解</a></li>\n</ul>\n","raw":null,"categories":[{"name":"HTTP","path":"api/categories/HTTP.json"}],"tags":[{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（6）——HTTP请求的状态码","slug":"前端面试系列（6）——HTTP请求的状态码","date":"2017-04-04T13:38:16.000Z","updated":"2019-06-03T04:46:43.379Z","comments":true,"path":"api/articles/前端面试系列（6）——HTTP请求的状态码.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>首先说一下 HTTP，超文本传输协议（HTTP）是一种通信协议，它允许将超文本标记语言（HTML）文档从 Web 服务器传送到客户端的浏览器；而状态码在 Response 消息中的第一行（状态行），用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p>HTTP/1.1 中定义了 5 类状态码，状态码由三位数字组成，第一个数字定义了响应的类别</p>\n<ul>\n<li>1XX  提示信息 - 表示请求已被成功接收，继续处理</li>\n<li>2XX  成功 - 表示请求已被成功接收，理解，接受</li>\n<li>3XX  重定向 - 要完成请求必须进行更进一步的处理</li>\n<li>4XX  客户端错误 - 请求有语法错误或请求无法实现</li>\n<li>5XX  服务器端错误 - 服务器未能实现合法的请求</li>\n</ul>\n<h2 id=\"状态码含义\"><a href=\"#状态码含义\" class=\"headerlink\" title=\"状态码含义\"></a>状态码含义</h2><p><strong>粗体为常见状态码，需要多留意</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">状态码</th>\n<th style=\"text-align:center\">英文解释</th>\n<th style=\"text-align:left\">中文解释</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">Continue</td>\n<td style=\"text-align:left\">初始的请求已经接受，客户应当继续发送请求的其余部分</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">101</td>\n<td style=\"text-align:center\">Switching Protocols</td>\n<td style=\"text-align:left\">服务器将遵从客户的请求转换到另外一种协议</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>200</strong></td>\n<td style=\"text-align:center\"><strong>OK</strong></td>\n<td style=\"text-align:left\"><strong>一切正常，对GET和POST请求的应答文档跟在后面</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">201</td>\n<td style=\"text-align:center\">Created</td>\n<td style=\"text-align:left\">服务器已经创建了文档，Location头给出了它的URL</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">202</td>\n<td style=\"text-align:center\">Accepted</td>\n<td style=\"text-align:left\">已经接受请求，但处理尚未完成</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">203</td>\n<td style=\"text-align:center\">Non-Authoritative Information</td>\n<td style=\"text-align:left\">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">204</td>\n<td style=\"text-align:center\">No Content</td>\n<td style=\"text-align:left\">没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而 Servlet 可以确定用户文档足够新，这个状态代码是很有用的</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">205</td>\n<td style=\"text-align:center\">Reset Content</td>\n<td style=\"text-align:left\">没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">206</td>\n<td style=\"text-align:center\">Partial Content</td>\n<td style=\"text-align:left\">客户发送了一个带有Range头的GET请求，服务器完成了它</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">300</td>\n<td style=\"text-align:center\">Multiple Choices</td>\n<td style=\"text-align:left\">客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>301</strong></td>\n<td style=\"text-align:center\"><strong>Moved Permanently</strong></td>\n<td style=\"text-align:left\"><strong>客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>302</strong></td>\n<td style=\"text-align:center\"><strong>Found</strong></td>\n<td style=\"text-align:left\"><strong>类似于 301，但新的URL应该被视为临时性的替代，而不是永久性的</strong></td>\n<td style=\"text-align:left\"><strong>在 HTTP1.0 中对应的状态信息是 “Moved Temporatily”</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">303</td>\n<td style=\"text-align:center\">See Other</td>\n<td style=\"text-align:left\">类似于301/302，不同之处在于，如果原来的请求是 POST，Location 头指定的重定向目标文档应该通过 GET 提取</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>304</strong></td>\n<td style=\"text-align:center\"><strong>Not Modified</strong></td>\n<td style=\"text-align:left\"><strong>客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">305</td>\n<td style=\"text-align:center\">Use Proxy</td>\n<td style=\"text-align:left\">客户请求的文档应该通过 Location 头所指明的代理服务器提取</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">307</td>\n<td style=\"text-align:center\">Temporary Redirect</td>\n<td style=\"text-align:left\">和 302 相同。许多浏览器会错误地响应 302 应答进行重定向，即使原来的请求是 POST，即使它实际上只能在 POST 请求的应答是 303 时才能重定向。由于这个原因，HTTP 1.1 新增了 307，以便更加清除地区分几个状态代码：当出现 303 应答时，浏览器可以跟随重定向的 GET 和 POST 请求；如果是 307 应答，则浏览器只能跟随对 GET 请求的重定向</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">400</td>\n<td style=\"text-align:center\">Bad Request</td>\n<td style=\"text-align:left\">请求出现语法错误</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">401</td>\n<td style=\"text-align:center\">Unauthorized</td>\n<td style=\"text-align:left\">客户试图未经授权访问受密码保护的页面。应答中会包含一个 WWW-Authenticate 头，浏览器据此显示用户名字/密码对话框，然后在填写合适的 Authorization 头后再次发出请求</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>403</strong></td>\n<td style=\"text-align:center\"><strong>Forbidden</strong></td>\n<td style=\"text-align:left\"><strong>资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>404</strong></td>\n<td style=\"text-align:center\"><strong>Not Found</strong></td>\n<td style=\"text-align:left\"><strong>无法找到指定位置的资源。这也是一个常用的应答</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">405</td>\n<td style=\"text-align:center\">Method Not Allowed</td>\n<td style=\"text-align:left\">请求方法（GET、POST、HEAD、Delete、PUT、TRACE 等）对指定的资源不适用。</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">406</td>\n<td style=\"text-align:center\">Not Acceptable</td>\n<td style=\"text-align:left\">指定的资源已经找到，但它的 MIME 类型和客户在 Accpet 头中所指定的不兼容</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">407</td>\n<td style=\"text-align:center\">Proxy Authentication Required</td>\n<td style=\"text-align:left\">类似于 401，表示客户必须先经过代理服务器的授权</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">408</td>\n<td style=\"text-align:center\">Request Timeout</td>\n<td style=\"text-align:left\">在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">409</td>\n<td style=\"text-align:center\">Conflict</td>\n<td style=\"text-align:left\">通常和 PUT 请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">410</td>\n<td style=\"text-align:center\">Gone</td>\n<td style=\"text-align:left\">所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">411</td>\n<td style=\"text-align:center\">Length Required</td>\n<td style=\"text-align:left\">服务器不能处理请求，除非客户发送一个 Content-Length 头</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">412</td>\n<td style=\"text-align:center\">Precondition Failed</td>\n<td style=\"text-align:left\">请求头中指定的一些前提条件失败</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">413</td>\n<td style=\"text-align:center\">Request Entity Too Large</td>\n<td style=\"text-align:left\">目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个 Retry-After 头</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">414</td>\n<td style=\"text-align:center\">Request URI Too Long</td>\n<td style=\"text-align:left\">URI 太长</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">Internal Server Error</td>\n<td style=\"text-align:left\">服务器遇到了意料不到的情况，不能完成客户的请求</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">501</td>\n<td style=\"text-align:center\">Not Implemented</td>\n<td style=\"text-align:left\">服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>502</strong></td>\n<td style=\"text-align:center\"><strong>Bad Gateway</strong></td>\n<td style=\"text-align:left\"><strong>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>503</strong></td>\n<td style=\"text-align:center\"><strong>Service Unavailable</strong></td>\n<td style=\"text-align:left\"><strong>服务器由于维护或者负载过重未能应答。例如，Servlet 可能在数据库连接池已满的情况下返回503。服务器返回 503 时可以提供一个 Retry-After 头</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>504</strong></td>\n<td style=\"text-align:center\"><strong>Gateway Timeout</strong></td>\n<td style=\"text-align:left\"><strong>由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答</strong></td>\n<td style=\"text-align:left\"><strong>HTTP 1.1 新</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">505</td>\n<td style=\"text-align:center\">HTTP Version Not Supported</td>\n<td style=\"text-align:left\">服务器不支持请求中所指明的 HTTP 版本</td>\n<td style=\"text-align:left\">HTTP 1.1 新</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li>[一篇学习HTTP状态码的神文]（<a href=\"http://www.codeceo.com/article/http-code.html）\" target=\"_blank\" rel=\"noopener\">http://www.codeceo.com/article/http-code.html）</a></li>\n</ul>\n","raw":null,"categories":[{"name":"HTTP","path":"api/categories/HTTP.json"}],"tags":[{"name":"面试","path":"api/tags/面试.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"CSS书写规范","slug":"CSS书写规范","date":"2017-04-04T13:12:45.000Z","updated":"2019-06-03T04:46:43.371Z","comments":true,"path":"api/articles/CSS书写规范.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_97.png","content":"<p>本篇文章转载自 cnblogs，我在看了原文章之后又搜了一些其他相关资料，就有了下面这些对于 CSS 书写规范的总结。CSS 作为前端语言中最好学的一种，很容易造成“不需要规范”的错觉，但其实 CSS 的书写也有很多规范，顺序、命名以及缩写等等，知道并且遵循这些规范不仅可以更容易让别人读懂你的代码，还能方便自己。</p>\n<h2 id=\"CSS-书写顺序\"><a href=\"#CSS-书写顺序\" class=\"headerlink\" title=\"CSS 书写顺序\"></a>CSS 书写顺序</h2><ol>\n<li>位置属性（position, top, right, z-index, display, float 等）</li>\n<li>大小（width, height, padding, margin）</li>\n<li>文字系列（font, line-height, letter-spacing, color- text-align 等）</li>\n<li>背景（background, border 等）</li>\n<li>其他（animation, transition 等）</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_97.png\" alt=\"\" width=\"500\"></div>\n\n<h2 id=\"CSS-书写规范\"><a href=\"#CSS-书写规范\" class=\"headerlink\" title=\"CSS 书写规范\"></a>CSS 书写规范</h2><h3 id=\"使用-CSS-缩写属性\"><a href=\"#使用-CSS-缩写属性\" class=\"headerlink\" title=\"使用 CSS 缩写属性\"></a>使用 CSS 缩写属性</h3><p>CSS 有些属性是可以缩写的，比如 padding, margin, font 等等，这样精简代码同时又能提高用户的阅读体验。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_87.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"去掉小数点前的-“0”\"><a href=\"#去掉小数点前的-“0”\" class=\"headerlink\" title=\"去掉小数点前的 “0”\"></a>去掉小数点前的 “0”</h3><div align=\"center\"><img src=\"/images/hexo_post_98.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"简写命名\"><a href=\"#简写命名\" class=\"headerlink\" title=\"简写命名\"></a>简写命名</h3><p>很多用户都喜欢简写类名，但前提是要让人看懂你的命名才能简写哦！</p>\n<div align=\"center\"><img src=\"/images/hexo_post_121.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"16-进制颜色代码缩写\"><a href=\"#16-进制颜色代码缩写\" class=\"headerlink\" title=\"16 进制颜色代码缩写\"></a>16 进制颜色代码缩写</h3><p>有些颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_94.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"连字符-CSS-选择器命名规范\"><a href=\"#连字符-CSS-选择器命名规范\" class=\"headerlink\" title=\"连字符 CSS 选择器命名规范\"></a>连字符 CSS 选择器命名规范</h3><ol>\n<li>长名称或词组可以使用中横线来为选择器命名。</li>\n<li>不建议使用 “_” 下划线来命名 CSS 选择器，为什么呢？</li>\n</ol>\n<ul>\n<li>输入的时候少按一个 <code>shift</code> 键；</li>\n<li>浏览器兼容问题 （比如使用 _tips 的选择器命名，在 IE6 是无效的）</li>\n<li>能良好区分 JavaScript 变量命名（JS 变量命名是用 “_”）</li>\n</ul>\n<p>这里有一篇破折号与下划线的详细讨论，英文：<a href=\"http://stackoverflow.com/questions/7560813/why-are-dashes-preferred-for-css-selectors-html-attributes\" target=\"_blank\" rel=\"noopener\">点击查看</a> 中文篇：<a href=\"http://www.cnblogs.com/kaiye/archive/2011/06/13/3039046.html\" target=\"_blank\" rel=\"noopener\">点击查看</a> <a href=\"https://book.douban.com/subject/26295140/\" target=\"_blank\" rel=\"noopener\">《CSS Secrets》</a>的译者张鹏对于使用 “_” 还是 “-“ 也阐述了自己的观点，比较了两者的优缺点，可以<a href=\"https://github.com/cssmagic/blog/issues/42\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看</p>\n<div align=\"center\"><img src=\"/images/hexo_post_317.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"不要随意使用-Id\"><a href=\"#不要随意使用-Id\" class=\"headerlink\" title=\"不要随意使用 Id\"></a>不要随意使用 Id</h3><p>id 在 JS 是唯一的，不能多次使用，而使用 class 类选择器却可以重复使用，另外 id 的优先级优先与 class，所以 id 应该按需使用，而不能滥用。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_96.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"为浏览器添加状态前缀\"><a href=\"#为浏览器添加状态前缀\" class=\"headerlink\" title=\"为浏览器添加状态前缀\"></a>为浏览器添加状态前缀</h3><p>有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下图是添加了 “.is-” 前缀。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_221.png\" alt=\"\" width=\"500\"></div>\n\n<h2 id=\"CSS-命名规则\"><a href=\"#CSS-命名规则\" class=\"headerlink\" title=\"CSS 命名规则\"></a>CSS 命名规则</h2><p>可以按照功能、位置、结构进行命名，因为命名的出发点就是为了让自己和其他人都能看懂，所以越明白越好：</p>\n<ul>\n<li>一律小写;</li>\n<li>尽量用英文;</li>\n<li>不加中槓和下划线;</li>\n<li>尽量不缩写，除非一看就明白的单词。</li>\n</ul>\n<p>在译文<a href=\"http://jiongks.name/blog/naming-css-stuff-is-really-hard/?utm_source=tuicool\" target=\"_blank\" rel=\"noopener\">《CSS命名神马的真心难》</a>中，作者指出可以根据三类情况给定一个 class 名：</p>\n<ul>\n<li>功能性（positive-button、important-text、selected-tab）</li>\n<li>内容性（submit-button、intro-text、profile-photo）</li>\n<li>展示性（green-button、bit-text、sqiggle-border）</li>\n</ul>\n<p>其实，在我看来，命名的首要目的就是“语义化”，而“语义化”有两个方面：方便自己和方便别人，所以不一定所有的语义化都需要按照内容进行命名，class 名的语义化不同于 HTML，可以按照其背后的意义和开发者的意图进行命名</p>\n<p><strong>最常用主要命名</strong>：wrap（外套、最外层）、header（页眉、头部）、nav(导航条)、menu(菜单)、title(栏目标题、一般配合h1\\h2\\h3\\h4标签使用)、content (内容区)、footer(页脚、底部)、logo（标志、可以配合h1标签使用）、banner（广告条，一般在顶部）、copyRight（版权）</p>\n<h2 id=\"CSS-样式表文件命名\"><a href=\"#CSS-样式表文件命名\" class=\"headerlink\" title=\"CSS 样式表文件命名\"></a>CSS 样式表文件命名</h2><ul>\n<li>主要的 master.css</li>\n<li>模块 module.css</li>\n<li>基本共用 base.css</li>\n<li>布局、版面 layout.css</li>\n<li>主题 themes.css</li>\n<li>专栏 columns.css</li>\n<li>文字 font.css</li>\n<li>表单 forms.css</li>\n<li>补丁 mend.css</li>\n<li>打印 print.css</li>\n</ul>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/AllenChou/p/5911834.html\" target=\"_blank\" rel=\"noopener\">推荐大家使用的CSS书写规范、顺序</a></li>\n<li><a href=\"http://jiongks.name/blog/naming-css-stuff-is-really-hard/\" target=\"_blank\" rel=\"noopener\">CSS命名神马的真心难</a></li>\n<li><a href=\"http://nec.netease.com/standard/css-name.html\" target=\"_blank\" rel=\"noopener\">css命名方式</a></li>\n<li><a href=\"http://getbem.com/\" target=\"_blank\" rel=\"noopener\">BEM——一种css命名解决方案</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000391762\" target=\"_blank\" rel=\"noopener\">BEM —— 源自Yandex的CSS 命名方法论</a></li>\n<li><a href=\"http://blog.jobbole.com/76030/\" target=\"_blank\" rel=\"noopener\">CSS设计模式：OOCSS 和 SMACSS</a></li>\n</ul>\n","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]}]}