{"total":115,"pageSize":10,"pageCount":12,"data":[{"title":"JS宽高的理解和应用","slug":"JS宽高的理解和应用","date":"2017-05-01T14:49:51.000Z","updated":"2019-02-04T06:11:30.226Z","comments":true,"path":"api/articles/JS宽高的理解和应用.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_31.png","content":"<h2 id=\"window-和-document\"><a href=\"#window-和-document\" class=\"headerlink\" title=\"window 和 document\"></a>window 和 document</h2><p><strong>document 是 window 对象的一部分</strong>：document.body -&gt; window.document.body，浏览器的 HTML 文档称为 document 对象<br><strong>window.location === document.location</strong>：window 对象的 location 属性引用的是 location 对象，表示该窗口中当前显示文档的 URL，document 对象的 location 属性也是引用了 location 对象</p>\n<h2 id=\"window-screen\"><a href=\"#window-screen\" class=\"headerlink\" title=\"window.screen\"></a>window.screen</h2><p>window.screen 包含有关用户屏幕的信息，它包括：</p>\n<ul>\n<li><code>window.screen.width</code></li>\n<li><code>window.screen.height</code></li>\n<li><code>window.screen.availHeight</code></li>\n<li><code>window.screen.availWidth</code></li>\n<li><code>window.screenTop</code></li>\n<li><code>window.screenLeft</code></li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_31.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"与-window-相关的宽高\"><a href=\"#与-window-相关的宽高\" class=\"headerlink\" title=\"与 window 相关的宽高\"></a>与 window 相关的宽高</h2><ul>\n<li><code>window.innerWidth</code> 内部的宽度</li>\n<li><code>window.innerHeight</code> 内部的高度</li>\n<li><code>window.outWidth</code> 外部的宽度</li>\n<li><code>window.outHeight</code> 外部的高度</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_24.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"与-document-相关的宽高\"><a href=\"#与-document-相关的宽高\" class=\"headerlink\" title=\"与 document 相关的宽高\"></a>与 document 相关的宽高</h2><h3 id=\"与-client-相关的宽高\"><a href=\"#与-client-相关的宽高\" class=\"headerlink\" title=\"与 client 相关的宽高\"></a>与 client 相关的宽高</h3><ul>\n<li><code>document.body.clientWidth</code> 元素宽度（可视内容区+内边距）</li>\n<li><code>document.body.clientHeight</code> 元素高度（可视内容区+内边距）</li>\n</ul>\n<p>该属性指的是元素的可视部分宽度和高度，即 <code>padding+content</code></p>\n<ul>\n<li>如果没有滚动条，即为元素设定的宽度和高度</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientWidth);  <span class=\"comment\">// 350+padding(80) = 430</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientHeight);  <span class=\"comment\">// 500 + padding(80) = 580</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#exp2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"exp2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.clientHeight); <span class=\"comment\">// 200</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.clientWidth); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>document.body.clientLeft</code></li>\n<li><code>document.body.clientTop</code></li>\n</ul>\n<p>这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是 0</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientLeft);  <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientTop);  <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>无 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code></li>\n<li>有 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code> + 盒子的 <code>padding * 2</code></li>\n<li>有 <code>padding</code> 有滚动 ：<code>clientWidth</code> = 盒子和 <code>width</code> + 盒子的 <code>padding * 2</code> - 滚动轴宽度</li>\n<li><code>clientTop = border-top</code></li>\n<li><code>clientLeft = border-left</code></li>\n</ul>\n<h3 id=\"与-offset-相关的宽高\"><a href=\"#与-offset-相关的宽高\" class=\"headerlink\" title=\"与 offset 相关的宽高\"></a>与 offset 相关的宽高</h3><ul>\n<li><strong>document.body.offsetWidth（元素的border + padding + content的宽度）</strong></li>\n<li><strong>document.body.offsetHeight（元素的border + padding + content的高度）</strong></li>\n</ul>\n<p>该属性和其内部的内容是否超出元素大小无关，只和本来设定的 border 以及 width 和 height 有关</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.offsetWidth);  <span class=\"comment\">// 470 = padding\\*2 + 350 + border\\*2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.offsetHeight);  <span class=\"comment\">// 620 = padding\\*2 + 500 + border\\*2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>document.offsetLeft</strong></li>\n<li><strong>document.offsetTop</strong></li>\n</ul>\n<p>了解这两个属性我们必须先了解它，什么是 <code>offsetParent</code></p>\n<ul>\n<li>如果当前元素的父级元素没有进行 <code>CSS</code> 定位（<code>position</code> 为 <code>absolute</code> 或 <code>relative</code>）,<code>offsetParent</code> 为 <code>body.</code></li>\n<li>假如当前元素的父级元素中有 <code>CSS</code> 定位，<code>offsetParent</code> 取最近的那个父级元素</li>\n</ul>\n<h3 id=\"offsetLeft-的兼容性问题\"><a href=\"#offsetLeft-的兼容性问题\" class=\"headerlink\" title=\"offsetLeft 的兼容性问题\"></a>offsetLeft 的兼容性问题</h3><ul>\n<li>在 <code>IE6/7</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 padding-left + 当前元素的 margin-left</li>\n</ul>\n</li>\n<li>在 <code>IE8/9/10</code> 以及 <code>chrome</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 margin-left + offsetParent 的 border 宽度 + offsetParent 的 padding-left + 当前元素的 margin-left</li>\n</ul>\n</li>\n<li>在 <code>FireFox</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 margin-left + 当前元素的 margin-left + offsetParent 的padding-left</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-id\">#exp</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">20px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 IE8 / 9 / 10 以及 chrome 中：<ul>\n<li>div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 + margin10 + border20 = 80</li>\n<li>div.offsetTop = 本身的 margin10 + 父级元素的 padding40 + margin10 + border20 = 80</li>\n</ul>\n</li>\n<li>在 FireFox：（相比 chrome 中少了 border）<ul>\n<li>div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 + margin10 = 60</li>\n<li>div.offsetTop = 本身的 margin10 + 父级元素的 padding40 + margin10 = 60</li>\n</ul>\n</li>\n<li>在 IE6/7 中：（相比在 FireFox，不但少了 border 还少了父级元素的 margin）<ul>\n<li><code>div.offsetLeft</code> = 本身的 <code>margin10</code> + 父级元素的 <code>padding40</code> = 50</li>\n<li><code>div.offsetTop</code> = 本身的 <code>margin10</code> + 父级元素的 <code>padding40</code> = 50</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>无 <code>padding</code> 无滚动无 <code>border</code><ul>\n<li>offsetWidth = clientWidth = 盒子的宽度</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 无滚动有 <code>border</code><ul>\n<li>offsetWidth = 盒子的宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 边框宽度 * 2</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 有滚动，且滚动是显示的，有 <code>border</code><ul>\n<li>offsetWidth = 盒子宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"与-scroll-相关的宽高\"><a href=\"#与-scroll-相关的宽高\" class=\"headerlink\" title=\"与 scroll 相关的宽高\"></a>与 scroll 相关的宽高</h2><ul>\n<li><strong>document.body.scrollWidth</strong></li>\n<li><strong>document.body.scrollHeight</strong></li>\n</ul>\n<p>document.body 的 scrollWidth 和 scrollHeight 与 div 的 scrollWidth 和 scrollHeight 是有区别的</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.scrollHeight; <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.scrollWidth; <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>当给定宽高小于浏览器窗口的宽高<ul>\n<li>scrollWidth = 通常是浏览器窗口的宽度</li>\n<li>scrollHeight = 通常是浏览器窗口的高度</li>\n</ul>\n</li>\n<li>当给定宽高大于浏览器窗口的宽高，且内容小于给定宽高的时候<ul>\n<li>scrollWidth = 给定宽度 + 其所有的 padding + margin + border</li>\n<li>scrollHeight = 给定高度 + 其所有的 padding + margin + border</li>\n</ul>\n</li>\n<li>当给定宽高大于浏览器窗口宽高，且内容大于给定宽高<ul>\n<li>scrollWidth = 内容宽度 + 其所有的 padding + margin + border</li>\n<li>scrollHeight = 内容高度 + 其所有的 padding + margin + border</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在某-div-中的-scrollWidth-和-scrollHeight\"><a href=\"#在某-div-中的-scrollWidth-和-scrollHeight\" class=\"headerlink\" title=\"在某 div 中的 scrollWidth 和 scrollHeight\"></a><strong>在某 div 中的 scrollWidth 和 scrollHeight</strong></h3><p>无滚动轴时：</p>\n<ul>\n<li>scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_28.png\" alt=\"\" width=\"450\"></div>\n\n<p>有滚动轴时：</p>\n<ul>\n<li>scrollWidth = 实际内容的宽度 + padding * 2</li>\n<li>scrollHeight = 实际内容的高度 + padding * 2</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_32.png\" alt=\"\" width=\"450\"></div>\n\n<ul>\n<li><strong>document.body.scrollLeft</strong></li>\n<li><strong>document.body.scrollTop</strong></li>\n</ul>\n<p>与前面不同的是，这对属性是<strong>可读写</strong>的，指的是当元素其中的超出其宽高的时候，元素被卷起来的高度和宽度</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#exp</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">20px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>:scroll;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"exp\"</span>);</span><br><span class=\"line\">mydiv.scrollTop ;  <span class=\"comment\">// 默认情况下是0 </span></span><br><span class=\"line\">mydiv.scrollLeft ; <span class=\"comment\">// 默认情况下是0 </span></span><br><span class=\"line\"><span class=\"comment\">// 可以改写它</span></span><br><span class=\"line\">mydiv.scrollTop = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mydiv.scrollTop)</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_25.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"obj-style-width-和-obj-style-height\"><a href=\"#obj-style-width-和-obj-style-height\" class=\"headerlink\" title=\"obj.style.width 和 obj.style.height\"></a><strong>obj.style.width 和 obj.style.height</strong></h3><p>对于一个 <code>DOM</code> 元素，它的 <code>style</code> 属性返回的是一个对象，这个对象的任意一个属性是可读写的，<code>style.width</code> 等于 <code>css</code> 属性中的宽度。<code>style.height</code> 等于 <code>css</code> 属性中的高度</p>\n<h2 id=\"documentElement-和-body-的关系\"><a href=\"#documentElement-和-body-的关系\" class=\"headerlink\" title=\"documentElement 和 body 的关系\"></a>documentElement 和 body 的关系</h2><p>是父子级的关系</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>); <span class=\"comment\">//document</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.documentElement); <span class=\"comment\">//html</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body); <span class=\"comment\">//body</span></span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_29.png\" alt=\"\" width=\"600\"></div>\n\n<ul>\n<li>兼容问题推荐使用，获取浏览器窗口可视区域大小：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.clientWidth || <span class=\"built_in\">document</span>.documentElement.clientWidth;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.clientHeight || <span class=\"built_in\">document</span>.documentElement.clientHeight;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-对象的-5-种坐标\"><a href=\"#Event-对象的-5-种坐标\" class=\"headerlink\" title=\"Event 对象的 5 种坐标\"></a>Event 对象的 5 种坐标</h2><ul>\n<li>clientX 和 clientY：相对于浏览器（可视区左上角0,0）的坐标</li>\n<li>screenX 和 screenY：相对于设备屏幕左上角（0,0）的坐标</li>\n<li>offsetX 和 offsetY：相对于事件源左上角（0,0）的坐标</li>\n<li>pageX 和 pageY：相对于整个网页左上角（0,0）的坐标</li>\n<li>X 和 Y：本来是 IE 属性，相对于用CSS动态定位的最内层包容元素</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_27.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"JS各种宽高的应用\"><a href=\"#JS各种宽高的应用\" class=\"headerlink\" title=\"JS各种宽高的应用\"></a>JS各种宽高的应用</h2><ul>\n<li><a href=\"http://codepen.io/poetries/pen/RoeJgG\" target=\"_blank\" rel=\"noopener\">可视区域加载</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/WoayJy\" target=\"_blank\" rel=\"noopener\">判断网页滚动到顶部或者底部</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/vyVrvm\" target=\"_blank\" rel=\"noopener\">DIV滚动到底部时加载剩余内容</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/RoeBbL\" target=\"_blank\" rel=\"noopener\">计算滚动轴的宽高</a></li>\n</ul>\n<h2 id=\"JS中的宽高属性总结\"><a href=\"#JS中的宽高属性总结\" class=\"headerlink\" title=\"JS中的宽高属性总结\"></a>JS中的宽高属性总结</h2><div align=\"center\"><img src=\"/images/hexo_post_26.png\" alt=\"\" width=\"700\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_23.png\" alt=\"\" width=\"700\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_30.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://blog.poetries.top/2016/12/13/js-props/\" target=\"_blank\" rel=\"noopener\">JavaScript及jQuery中的各种宽高属性图解</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"}]},{"title":"读书笔记系列（7）——JavaScript半知半解","slug":"读书笔记系列（7）——JavaScript半知半解","date":"2017-04-25T15:33:09.000Z","updated":"2019-02-04T06:11:30.238Z","comments":true,"path":"api/articles/读书笔记系列（7）——JavaScript半知半解.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这本书是我无意中看到的一本电子版书籍，但是第一章就吸引到了我，然后就对作者展开了深入“挖掘”，通过作者的<a href=\"http://ghmagical.com/\" target=\"_blank\" rel=\"noopener\">个人博客</a>发现作者是一个很厉害的技术开发人员，不管是前端还是后台都有所涉猎，所以推荐大家去他的个人博客逛逛，同时推荐他的两本书籍：《JavaScript半知半解》和《Web实战》，一定会有所收获</p>\n<h2 id=\"1-完整的-JavaScript\"><a href=\"#1-完整的-JavaScript\" class=\"headerlink\" title=\"1. 完整的 JavaScript\"></a>1. 完整的 JavaScript</h2><p>完整的 JavaScript 实现由下列三个不同的部分组成：</p>\n<ul>\n<li>核心（<strong>ECMAScript</strong>）</li>\n<li>文档对象模型（<strong>DOM</strong>）</li>\n<li>浏览器对象模型（<strong>BOM</strong>）</li>\n</ul>\n<h2 id=\"2-lt-script-gt-元素\"><a href=\"#2-lt-script-gt-元素\" class=\"headerlink\" title=\"2. &lt;script&gt; 元素\"></a>2. <code>&lt;script&gt;</code> 元素</h2><p>向 HTML 页面中插入 JavaScript 的主要方法，就是使用 <code>&lt;script&gt;</code> 元素。<code>&lt;script&gt;</code> 中定义了下列 6 个属性：</p>\n<ul>\n<li><strong><code>async</code></strong>：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效</li>\n<li><strong><code>charset</code></strong>：可选，表示通过 src 属性指定的代码的字符集，比较少用。</li>\n<li><strong><code>defer</code></strong>：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li>\n<li><strong><code>language</code></strong>：已废弃</li>\n<li><strong><code>src</code></strong>：可选，表示包含要执行代码的外部文件</li>\n<li><strong><code>type</code></strong>：可选，表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。在 HTML5 中，默认是 text/javascript，所以不需要设置。</li>\n</ul>\n<h2 id=\"3-在使用-lt-script-gt-嵌入-JavaScript-代码时，切记不要在代码中的任何地方出现-lt-script-gt\"><a href=\"#3-在使用-lt-script-gt-嵌入-JavaScript-代码时，切记不要在代码中的任何地方出现-lt-script-gt\" class=\"headerlink\" title=\"3. 在使用 &lt;script&gt; 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 &lt;/script&gt;\"></a>3. 在使用 <code>&lt;script&gt;</code> 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 <code>&lt;/script&gt;</code></h2><p>执行下面的代码时，会产生一个错误：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  alert('</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-JavaScript-代码的执行顺序\"><a href=\"#4-JavaScript-代码的执行顺序\" class=\"headerlink\" title=\"4. JavaScript 代码的执行顺序\"></a>4. JavaScript 代码的执行顺序</h2><p>只要不存在 defer 和 async 属性，JavaScript 代码就会从上至下依次解析。带有 src 属性的 <code>&lt;script&gt;</code> 元素不应该在其 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签之间再包含额外的 JavaScript 代码，嵌入代码会被忽略。<strong>只要不存在 defer 和 async 属性，浏览器都会按照 <code>&lt;script&gt;</code> 出现的先后顺序对它们依次进行解析。</strong> 一般将全部 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中页面的内容后面。</p>\n<h2 id=\"5-延迟脚本\"><a href=\"#5-延迟脚本\" class=\"headerlink\" title=\"5. 延迟脚本\"></a>5. 延迟脚本</h2><p>当给 <code>&lt;script&gt;</code> 元素添加了 <code>defer</code> 属性时，src 指向的外部文件会立即下载，但包含的脚本会延迟到浏览器遇到 <code>&lt;/html&gt;</code> 标签（整个页面解析完毕）后再执行（按添加顺序执行），会先于 DOMContentLoaded 事件执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span>=<span class=\"string\">\"defer\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>会先执行 example.js，然后执行 example2.js。</p>\n<blockquote>\n<p>注意：defer 只适合外部脚本文件。</p>\n</blockquote>\n<h2 id=\"6-异步脚本\"><a href=\"#6-异步脚本\" class=\"headerlink\" title=\"6. 异步脚本\"></a>6. 异步脚本</h2><p><code>async</code> 与 <code>defer</code> 属性类似，都用于改变处理脚本的行为，适用于外部脚本文件，并告诉浏览器立即下载，但标记为 <code>async</code> 的脚本并不保证按照指定它们的先后顺序执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>两个执行顺序不定</strong>。指定 <code>async</code> 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p>\n<blockquote>\n<p>注意：异步脚本不要在加载期间修改 DOM。 <strong>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行</strong>。</p>\n</blockquote>\n<h2 id=\"7-元素\"><a href=\"#7-元素\" class=\"headerlink\" title=\"7. 元素\"></a>7. <noscript>元素</noscript></h2><p>当浏览器不支持 JavaScript 或被禁用时，显示里面的内容。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\"> 本页面需要浏览器支持（启用）JavaScript</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"8-关键字和保留字\"><a href=\"#8-关键字和保留字\" class=\"headerlink\" title=\"8. 关键字和保留字\"></a>8. 关键字和保留字</h2><p>ECMA-262 描述了一组具有特定用途的<strong>关键字</strong>，这些关键字可用于控制语句的开始或结束，或者用于执行特定操作等，不能用作标识符。</p>\n<blockquote>\n<p>break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try</p>\n</blockquote>\n<p>ECMA-262 还描述了一组不能用作标识符的<strong>保留字</strong>：</p>\n<blockquote>\n<p>abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public</p>\n</blockquote>\n<p>如果使用关键字作标识符，会导致 “Identifier Expected” 错误。 有些时候，我们不得不用到保留字货关键字的，比如 CSS 样式中的 float，这时就需要这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style.cssFloat</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-隐式全局变量\"><a href=\"#9-隐式全局变量\" class=\"headerlink\" title=\"9. 隐式全局变量\"></a>9. 隐式全局变量</h2><p>在下面的代码中，由于从右至左的操作符优先级，所以表达式 “b=0” 是先执行的，而此时b未经过声明，所以它会成为全局变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>\n<p>关于全局变量：</p>\n<ul>\n<li>使用 var 创建的全局变量不能删除。</li>\n<li>不是 var 创建的隐含全局变量可以使用 delete 删除（因为它并不是真正的变量，而是全局对象 window 的属性）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> b;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">//  0</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// ReferenceError: b is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-变量提升\"><a href=\"#10-变量提升\" class=\"headerlink\" title=\"10. 变量提升\"></a>10. 变量提升</h2><p><strong>变量提升</strong>是指所有变量的声明语句，都会被提升到代码的头部。 在函数内也一样，函数中的所有变量声明会在函数执行时被“提升”至函数体顶端：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>结果是不是有点出乎你的意料。其实 JavaScript 的执行环境分为<strong>声明阶段</strong>和<strong>执行阶段</strong>，因此对于上面的代码，JavaScript 会这样解释代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-typeof-操作符\"><a href=\"#11-typeof-操作符\" class=\"headerlink\" title=\"11. typeof 操作符\"></a>11. typeof 操作符</h2><p><strong><code>typeof</code></strong>操作符用来检测给定变量的数据类型，可能的返回值：</p>\n<ul>\n<li>“undefined” –&gt; 这个值未定义</li>\n<li>“boolean” –&gt; 这个值是布尔值</li>\n<li>“string” –&gt; 这个值是字符串</li>\n<li>“number” –&gt; 这个值是数值</li>\n<li>“object” –&gt; 这个值是对象或 <strong>null</strong></li>\n<li>“function” –&gt; 这个值是函数</li>\n</ul>\n<h2 id=\"12-undefined-和-null-类型\"><a href=\"#12-undefined-和-null-类型\" class=\"headerlink\" title=\"12. undefined 和 null 类型\"></a>12. undefined 和 null 类型</h2><p><code>Undefined</code> 类型只有一个值，即特殊的 <code>undefined</code>；<code>Null</code> 类型也是只有一个值的数据类型，这个特殊值就是 <code>null</code>；null 和 undefined 没有属性，甚至连 toString() 这种标准方法都没有；undefined 其实是派生自 null 值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"13-Boolean\"><a href=\"#13-Boolean\" class=\"headerlink\" title=\"13. Boolean()\"></a>13. Boolean()</h2><p>要将一个值转换为其对应的 Boolean 值，可以使用转型函数 Boolean()；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'tg'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Boolean</span>(name);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>可以对任何类型的值调用 Boolean 函数，而且总会返回一个 Boolean 值（true 或 false）<strong>转换规则</strong>：</p>\n<ul>\n<li>对于 true 或 false，返回原值（true 或 false）</li>\n<li>对于 String 类型的值，任何非空字符串返回 true，空字符串（””）返回 false</li>\n<li>对于 Number 类型的值，任何非零数字值（包括无穷大），返回 true；0 和 NaN 返回 false</li>\n<li>对于 Object 类型的值，任何对象返回 true，null 返回 false</li>\n<li>对于 Undefined 类型，undefined 返回 false（只有一个值）</li>\n</ul>\n<h2 id=\"14-浮点数值\"><a href=\"#14-浮点数值\" class=\"headerlink\" title=\"14. 浮点数值\"></a>14. 浮点数值</h2><p>保存浮点数值需要的内存空间是保存整数值的两倍。 默认情况下，ECMAScript 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示的数值。 浮点数的最高精度是 17 位小数（所以浮点数的比较比较麻烦）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> = <span class=\"number\">0.3000000000000004</span>; <span class=\"comment\">// 不是等于0.3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"15-数值范围\"><a href=\"#15-数值范围\" class=\"headerlink\" title=\"15. 数值范围\"></a>15. 数值范围</h2><p>ECMAScript 能够表示的最小数值保存在 <code>Number.MIN_VALUE</code>（最小值）中，这个值是 5e-324；能够表示的最大数值保存在 <code>Number.MAX_VALUE</code>（最大值）中，这个值是 1.7976931348623157e+308</p>\n<blockquote>\n<p>注意：Infinity 是不能参与计算的数值。用 <code>isFinite()</code> 来判断这个值是否无穷，该函数接受一个参数。如果参数位于最小与最大数值之间，返回 true。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isFinite</span>(<span class=\"number\">1</span>));  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isFinite</span>(<span class=\"literal\">Infinity</span>));  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"16-NaN\"><a href=\"#16-NaN\" class=\"headerlink\" title=\"16. NaN\"></a>16. NaN</h2><p>NaN（Not a Number）表示非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 注意点：</p>\n<ul>\n<li>任何涉及 NaN 的操作都会返回 NaN。</li>\n<li>NaN 与任何值都不相等，包括 NaN 本身。</li>\n<li>任何操作数与 NaN 比较，都会返回 false</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>);  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>我们可以用 <code>isNaN()</code> 函数来判断是否非数值，该函数接受一个参数，可以是任何类型。<code>isNaN()</code> 在接收到\b这个参数之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，比如：字符串 “10” 或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"number\">10</span>));  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"string\">'blue'</span>));  <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"17-Number\"><a href=\"#17-Number\" class=\"headerlink\" title=\"17. Number()\"></a>17. Number()</h2><p><strong>Number() 函数的转换规则</strong>：</p>\n<ul>\n<li>如果是 Boolean 值，true 和 false 将分别转换为 1 和 0</li>\n<li>如果是数字值，只是简单的传入和返回</li>\n<li>如果是 null 值，返回 0</li>\n<li>如果是 undefined，返回 NaN</li>\n<li>如果是字符串，遵循下列规则： （<ul>\n<li>如果是字符串中只包含数字（包括前面带正负号），则将其转换为十进制数值（前导的零会被忽略）</li>\n<li>如果字符串中包含有效的浮点格式，如 1.1，则将其转换为对应的浮点数值</li>\n<li>如果字符串中包含有效的十六进制，如 0xf，则将其转换为相同大小的十进制数值</li>\n<li>如果字符串是空的，返回0</li>\n<li>如果字符串中包含上述格式以外的字符，返回 NaN ）</li>\n</ul>\n</li>\n<li>如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回字符串值</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">'tg'</span>));   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">''</span>));   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">'0011'</span>));  <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"literal\">true</span>));   <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>一元加操作符的操作与 Number 函数规则相同</p>\n<h2 id=\"18-parseInt-和-parseFloat\"><a href=\"#18-parseInt-和-parseFloat\" class=\"headerlink\" title=\"18. parseInt() 和 parseFloat()\"></a>18. parseInt() 和 parseFloat()</h2><p><code>parseInt()</code> 会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回 NaN。如果第一个字符是数字字符，就会继续解析，直到解析完所有后续字符或者遇到了一个非数字字符。 <code>parseInt()</code> 也能识别八进制（在 ECMAScript 5 中无法识别，将开头的 0 当作 0）和十六进制，最后会转换成十进制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'123tg'</span>));  <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">''</span>));   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'070'</span>));  <span class=\"comment\">// 70</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'0xf'</span>));  <span class=\"comment\">//15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"number\">22.5</span>));  <span class=\"comment\">// 22</span></span><br></pre></td></tr></table></figure>\n<p>我们还可以为 <code>parseInt()</code> 提供第二个参数，指定需要转换的进制（刷算法题的时候经常用到）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'0xAF'</span>,<span class=\"number\">16</span>));  <span class=\"comment\">// 175</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'AF'</span>,<span class=\"number\">16</span>));  <span class=\"comment\">// 175</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'AF'</span>));  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'070'</span>,<span class=\"number\">8</span>));  <span class=\"comment\">// 56</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'70'</span>,<span class=\"number\">8</span>));  <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n<p><code>parseFloat()</code> 和 <code>parseInt()</code> 类似，也是从第一个字符（位置 0）开始解析每个字符，而且一直解析到字符串末尾，或者解析到遇到一个无效的浮点数字字符为止，换句话说，字符串中的第一个小数点是有效的，后面的小数点是无效的，它还会忽略前导的零，只会解析十进制值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'123tg'</span>));  <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'22.12.4'</span>));   <span class=\"comment\">// 22.12</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'070'</span>));  <span class=\"comment\">// 70</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'0xf'</span>));  <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"number\">22.5</span>));  <span class=\"comment\">// 22.5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"19-Object-类型\"><a href=\"#19-Object-类型\" class=\"headerlink\" title=\"19. Object 类型\"></a>19. Object 类型</h2><p>在 ECMAScript 中，<code>Object</code> 类型是所有对象的基础。<code>Object</code> 的每个实例都具有下列属性和方法：</p>\n<ul>\n<li><strong><code>Constructor</code></strong>：保存着用于创建当前对象的函数，比如上面的例子，构造函数就是 Object()</li>\n<li><strong><code>hasOwnProperty(propertyName)</code></strong>：用于检查给定的属性在当前对象实例中是否存在（而不是在实例的原型中），参数必须是字符串形式</li>\n<li><strong><code>isPrototypeOf(object)</code></strong>：用于检查传入的对象是否是另一个对象的原型</li>\n<li><strong><code>propertyIsEnumerable(propertyName)</code></strong>：用于检查给定的属性是否能够使用 for-in 语句来枚举，参数必须是字符串形式</li>\n<li><strong><code>toLocaleString()</code></strong>：返回对象的字符串表示，该字符串与执行环境的地区对应</li>\n<li><strong><code>toString()</code></strong>：返回对象的字符串表</li>\n<li><strong><code>valueOf()</code></strong>：返回对象的字符串、数值或布尔值表示，通常和 toString() 返回的值相同</li>\n</ul>\n<h2 id=\"20-递增和递减\"><a href=\"#20-递增和递减\" class=\"headerlink\" title=\"20. 递增和递减\"></a>20. 递增和递减</h2><p>递减和递增操作符会遵循下列规则：</p>\n<ul>\n<li>当操作数是一个包含有效数字字符的字符串，系统会将其转换为数字值，再执行递减或递增。</li>\n<li>当操作数是一个不包含有效数字字符的字符串，系统将变量的值设置为 NaN</li>\n<li>当操作数是布尔值，会将其转为数值（true 转为 1，false 转为 0）再操作。</li>\n<li>当操作数是浮点数值，直接执行递减或递增</li>\n<li>当操作数是对象，先调用对象的 valueOf() 方法取得一个可供操作的值，然后再遵循上面的三条规则。如果结果是 NaN，则在调用 toString() 方法后再遵循上面的规则转换。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'2'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  valueOf: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a++;  <span class=\"comment\">// 3</span></span><br><span class=\"line\">b++;  <span class=\"comment\">// NaN</span></span><br><span class=\"line\">c--;  <span class=\"comment\">// -1</span></span><br><span class=\"line\">d--;  <span class=\"comment\">// 0.10000000000000009 （浮点数操作结果，类似0.1+0.2 != 0.3）</span></span><br><span class=\"line\">o--;  <span class=\"number\">-2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"21-按位非（NOT）\"><a href=\"#21-按位非（NOT）\" class=\"headerlink\" title=\"21. 按位非（NOT）\"></a>21. 按位非（NOT）</h2><p>位运算符并不直接操作 64 位的值，而是先将 64 位的值转换为 32 位，然后执行操作，最后将结果转换回 64 位。按位非（否运算）就是<strong>一个数与自身的取反值相加，等于 -1</strong>。</p>\n<p>~3 + 3 = -1 =&gt; -1 - 3 = -4 == ~3</p>\n<h2 id=\"22-位运算符\"><a href=\"#22-位运算符\" class=\"headerlink\" title=\"22. 位运算符\"></a>22. 位运算符</h2><p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。</p>\n<p>##23. 逻辑与（&amp;&amp;）</p>\n<p>逻辑与（&amp;&amp;）有两个操作数，如果是布尔值，只有两个都是 true 时，才会返回 true，否则返回 false；逻辑与操作属于短路操作，也就是说如果第一个操作数能够决定结果（等于 false 时），就不会再对第二个操作数求值，如果不是布尔值，它遵循下面的规则：</p>\n<ul>\n<li>如果第一个操作数是对象，则返回第二个操作数</li>\n<li>如果第二个操作数是对象，则只有在第一个操作数的求值为 true 时才会返回第二个操作数</li>\n<li>如果有一个操作数是 null，则返回 null</li>\n<li>如果有一个操作数是 NaN，则返回 NaN</li>\n<li>如果有一个操作数是 undefined，则返回 undefined</li>\n</ul>\n<p>逻辑与操作符也就是先将第一个操作数转换为 Boolean 类型判断是 true 或 false，再根据结果决定是否执行第二个操作数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> &amp;&amp; <span class=\"string\">'tg'</span> ;  <span class=\"comment\">//  0</span></span><br><span class=\"line\">&#123;&#125; &amp;&amp; <span class=\"string\">'tg'</span>;  <span class=\"comment\">// \"tg\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"24-乘法运算符\"><a href=\"#24-乘法运算符\" class=\"headerlink\" title=\"24. 乘法运算符\"></a>24. 乘法运算符</h2><p>乘法运算符(<code>*</code>)，用于计算两个数值的乘积。 处理特殊值时，乘法运算符会遵循下列规则：</p>\n<ul>\n<li>如果操作数都是数值，但乘积超过了 ECMAScript 数值范围，则返回 Infinity 或 -Infinity</li>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果是 Infinity 乘以 0，结果是 NaN</li>\n<li>如果是 Infinity 与非 0 数值相乘，结果是 Infinity 或 -Infinity，取决于非0数值的符号</li>\n<li>如果是 Infinity 与 Infinity 相乘，结果是 Infinity</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> * <span class=\"literal\">NaN</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"literal\">Infinity</span> * <span class=\"number\">2</span>);  <span class=\"comment\">// Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> * <span class=\"number\">0</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> * <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"24-除法运算符\"><a href=\"#24-除法运算符\" class=\"headerlink\" title=\"24. 除法运算符\"></a>24. 除法运算符</h2><p>除法运算符（/），执行第二个操作数除第一个操作数计算。 处理特殊值，规则如下：</p>\n<ul>\n<li>如果操作数都是数值，但商超过了 ECMAScript 的表示范围，则返回 Infinity 或 -Infinity</li>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果是 Infinity 被 Infinity 除，结果是 NaN</li>\n<li>如果是零被零除，结果是 NaN</li>\n<li>如果是非零的有限数被零除，结果是 Infinity 或 -Infinity，取决于有符号的操作数</li>\n<li>如果是 Infinity 被任何非零数值除，结果是 Infinity 或 -Infinity</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> / <span class=\"number\">1</span>); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0</span> / <span class=\"number\">0</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> / <span class=\"number\">0</span>);  <span class=\"comment\">//  Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> / <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> / <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> / <span class=\"number\">2</span>);   <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"25-求模\"><a href=\"#25-求模\" class=\"headerlink\" title=\"25. 求模\"></a>25. 求模</h2><p>求模（余数）运算符（%） 处理特殊值，规则如下：</p>\n<ul>\n<li>如果被除数是无穷大值而除数是有限大的数值，结果是 NaN</li>\n<li>如果被除数是有限大的数值而除数是零，结果是 NaN</li>\n<li>如果是 Infinity 被 Infinity 除，结果是 NaN</li>\n<li>如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数</li>\n<li>如果被除数是零，结果是零</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">5</span> % <span class=\"number\">3</span>);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"26-减法\"><a href=\"#26-减法\" class=\"headerlink\" title=\"26. 减法\"></a>26. 减法</h2><p>减法运算符（-） 对于特殊值，减法操作会遵循下列规则：</p>\n<ul>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果 Infinity 减 Infinity，结果是 NaN</li>\n<li>如果是 -Infinity 减 -Infinity，结果是 NaN</li>\n<li>如果是 Infinity 减 -Infinity，结果是 Infinity</li>\n<li>如果是 -Infinity 减 Infinity，结果是 -Infinity</li>\n<li>如果是 +0 减 +0，结果是 +0</li>\n<li>如果是 -0 加 -0，结果是 +0</li>\n<li>如果是 +0 减 -0，结果是 -0</li>\n<li>如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 将其转换为数值，然后遵循上面的规则进行计算。</li>\n<li>如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值；如果该对象没有 valueOf() 方法，则调用其 toString() 方法将得到的字符串转换为数值，然后遵循上面的规则进行计算。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> - <span class=\"literal\">true</span>;  <span class=\"comment\">// 4 （true转换成1）</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"string\">'2'</span>    <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"literal\">null</span>;  <span class=\"comment\">// 5（null转换成0）</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"27-逗号运算符\"><a href=\"#27-逗号运算符\" class=\"headerlink\" title=\"27. 逗号运算符\"></a>27. 逗号运算符</h2><p>逗号运算符多用于声明多个变量。逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = (<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>);  <span class=\"comment\">// num的值为3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"28-标签语句\"><a href=\"#28-标签语句\" class=\"headerlink\" title=\"28. 标签语句\"></a>28. 标签语句</h2><p>语句是可以添加标签的，标签是由语句前的标识符和冒号组成：</p>\n<blockquote>\n<p><strong>label</strong> : statement</p>\n</blockquote>\n<p>label 语句定义的标签一般由 break 或 continue 语句引用。加标签的语句一般要与 for 等循环语句配合使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">tip : <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">  num += i;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);  <span class=\"comment\">//  轮流输出：0、1、2、3、4、5</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i ==<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span> tip;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num);  <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>当执行到 i = 5 时，会跳出循环，也就是 tip 对应的层，然后执行其下方的代码。</p>\n<h2 id=\"29-with-语句\"><a href=\"#29-with-语句\" class=\"headerlink\" title=\"29. with 语句\"></a>29. with 语句</h2><p><code>with</code> 语句用于临时扩展作用域链，也就是将代码的作用域设置到一个特定的对象中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span>(object)&#123;   </span><br><span class=\"line\">  statement  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将 object 添加到作用域链的头部，然后执行 statement，最后把作用域链恢复到原生状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'tg'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">24</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span>(o)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'name：'</span> + name);  <span class=\"comment\">// name：tg</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'age：'</span> + age);  <span class=\"comment\">// age：24</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>with 里面的 name 相当于 o.name。</p>\n<blockquote>\n<p>注意：在严格模式中是禁止使用 with 语句的，因为 with 语句性能非常差，不推荐使用。</p>\n</blockquote>\n<h2 id=\"30-debugger-语句\"><a href=\"#30-debugger-语句\" class=\"headerlink\" title=\"30. debugger 语句\"></a>30. debugger 语句</h2><p>debugger 语句用来产生一个断点（breakpoint），JavaScript 代码的执行会停止在断点的位置。一般用来调试代码。</p>\n<h2 id=\"31-对象\"><a href=\"#31-对象\" class=\"headerlink\" title=\"31. 对象\"></a>31. 对象</h2><p><strong>键名</strong>：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  <span class=\"string\">'1a'</span> : <span class=\"string\">'a'</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，如果键名 ‘1a’ 不用引号引起来，就会报错。注意：为了避免这种歧义，JavaScript 规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。</p>\n<h2 id=\"32-创建对象\"><a href=\"#32-创建对象\" class=\"headerlink\" title=\"32. 创建对象\"></a>32. 创建对象</h2><p>在 JavaScript 中，有三种方法创建对象</p>\n<ul>\n<li>对象直接量： var o={};</li>\n<li>关键字new： var o=new Object();</li>\n<li>Object.create() 函数： var o=Object.create(null)</li>\n</ul>\n<h3 id=\"提取方法\"><a href=\"#提取方法\" class=\"headerlink\" title=\"提取方法\"></a>提取方法</h3><p>如果对对象中的方法进行提取，则会失去与对象的连接。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.get());  <span class=\"comment\">//  \"a\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = obj.get;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func());  <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，object 对象中有一个方法 get()，用来获取 obj 对象中的 name，而当 get() 方法赋值给一个变量 func，再调用 func() 函数时，此时的 this 是指向 window 的，而非 obj 的。注意：如果在严格模式下，this 会是 undefined。</p>\n<h3 id=\"属性特性\"><a href=\"#属性特性\" class=\"headerlink\" title=\"属性特性\"></a>属性特性</h3><ul>\n<li>可写（writable attribute）：可设置该属性的值。</li>\n<li>可枚举（enumerable attribute）：可通过 for / in 循环返回该属性。</li>\n<li>可配置（configurable attribute）：可删除或修改属性。</li>\n</ul>\n<h3 id=\"查看所有属性\"><a href=\"#查看所有属性\" class=\"headerlink\" title=\"查看所有属性\"></a>查看所有属性</h3><p>查看一个对象本身的所有属性，可以使用 Object.keys 方法，返回一个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  age : <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(o)  <span class=\"comment\">// ['name','age']</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h3><p>delete 运算符可以删除对象的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.name  <span class=\"comment\">//true</span></span><br><span class=\"line\">o.name  <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：delete 运算符只能删除自有属性，不能删除继承属性。 删除一个不存在的属性，delete 不报错，而且返回 true。只有一种情况，delete 命令会返回 false，那就是该属性存在，且不得删除。</p>\n</blockquote>\n<h2 id=\"33-序列化对象\"><a href=\"#33-序列化对象\" class=\"headerlink\" title=\"33. 序列化对象\"></a>33. 序列化对象</h2><p>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 在 JavaScript 中，提供了内置函数 <strong>JSON.stringify()</strong> 和 <strong>JSON.parse()</strong> 用来序列化和还原 JavaScript 对象。NaN、Infinity 和 -Infinity 序列化的结果是 null</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  age : <span class=\"number\">12</span>,</span><br><span class=\"line\">  intro : \\[<span class=\"literal\">false</span>,<span class=\"literal\">null</span>,<span class=\"string\">''</span>\\]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s= <span class=\"built_in\">JSON</span>.stringify(o)  <span class=\"comment\">// s &#123;\"name\":\"a\",\"age\":12,\"intro\":[false,null,\"\"]&#125;</span></span><br><span class=\"line\">p=<span class=\"built_in\">JSON</span>.parse(s)  <span class=\"comment\">// p是o的深拷贝</span></span><br></pre></td></tr></table></figure>\n<p>注意：JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。</p>\n<h2 id=\"34-原型\"><a href=\"#34-原型\" class=\"headerlink\" title=\"34. 原型\"></a>34. 原型</h2><p>每一个 JavaScript 对象（null 除外）都和另一个对象相关联，也可以说，继承另一个对象。另一个对象就是我们熟知的“原型”（prototype），每一个对象都从原型继承属性。只有 null 除外，它没有自己的原型对象。所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。比如：通过 new Object() 创建的对象继承自 Object.prototype；通过 new Array() 创建的对象的原型就是 Array.prototype。没有原型的对象为数不多，Object.prototype 就是其中之一，它不继承任何属性。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。</p>\n<h2 id=\"35-空位\"><a href=\"#35-空位\" class=\"headerlink\" title=\"35. 空位\"></a>35. 空位</h2><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在<strong>空位</strong>（hole）。如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [,,];</span><br><span class=\"line\">arr.length  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"36-类数组对象\"><a href=\"#36-类数组对象\" class=\"headerlink\" title=\"36. 类数组对象\"></a>36. 类数组对象</h2><p>在 JavaScript 中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用 length 属性，但是它们并不是数组，无法使用一些数组的方法。<code>类数组对象</code>有一个特征，就是具有 length 属性。换句话说，只要有 length 属性，就可以认为这个对象类似于数组。但是，对象的 length 属性不是动态值，不会随着成员的变化而变化。典型的类似数组的对象是函数的 <strong>arguments 对象</strong>，以及<strong>大多数 DOM 元素集</strong>，还有<strong>字符串</strong>。</p>\n<h2 id=\"37-函数表达式\"><a href=\"#37-函数表达式\" class=\"headerlink\" title=\"37. 函数表达式\"></a>37. 函数表达式</h2><p>采用函数表达式声明函数时，function 命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"38-函数被提前\"><a href=\"#38-函数被提前\" class=\"headerlink\" title=\"38. 函数被提前\"></a>38. 函数被提前</h2><p>就像变量的“被提前”一样，函数声明语句也会“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。在函数提升中，函数体也会跟着提升（不像变量一样，只会提升变量声明），这也是我们可以引用后面声明的函数的原因。 此外，<strong>以表达式定义的函数并没有“被提前”，而是以变量的形式“被提前”</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f();  </span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>\n<p>变量其实是分为声明，赋值两部分的，上面的代码等同于下面的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f;</span><br><span class=\"line\">f();</span><br><span class=\"line\">f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"39-实参对象\"><a href=\"#39-实参对象\" class=\"headerlink\" title=\"39. 实参对象\"></a>39. 实参对象</h2><p><code>arguments</code> 类数组中每一个元素的值会与对应的命名参数的值保持同步，这种影响是单向的，也可以这样说，<strong>如果是修改 <code>arguments</code> 中的值，会影响到命名参数的值，但是修改命名参数的值，并不会改变 <code>arguments</code> 中对应的值</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);    <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] = <span class=\"literal\">null</span>;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);    <span class=\"comment\">// null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p><code>arguments</code> 并不是真正的数组，它只是类数组对象（有 length 属性且可使用索引来访问子项）。但我们可以借助 Array 类的原型对象的 slice 方法，将其转为真正的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 更简洁的写法</span></span><br><span class=\"line\">[].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"40-函数的属性、方法\"><a href=\"#40-函数的属性、方法\" class=\"headerlink\" title=\"40. 函数的属性、方法\"></a>40. 函数的属性、方法</h2><h3 id=\"name-属性\"><a href=\"#name-属性\" class=\"headerlink\" title=\"name 属性\"></a>name 属性</h3><p>name 属性返回紧跟在 function 关键字之后的那个函数名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">f.name   <span class=\"comment\">// f</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"length-属性\"><a href=\"#length-属性\" class=\"headerlink\" title=\"length 属性\"></a>length 属性</h3><p>函数的 length 属性是只读属性，代表函数形参的数量，也就是在函数定义时给出的形参个数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x,y</span>)</span>&#123;&#125;</span><br><span class=\"line\">f.length  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"41-立即调用的函数表达式（IIFE）\"><a href=\"#41-立即调用的函数表达式（IIFE）\" class=\"headerlink\" title=\"41. 立即调用的函数表达式（IIFE）\"></a>41. 立即调用的函数表达式（IIFE）</h2><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：</p>\n<ul>\n<li>一是不必为函数命名，避免了污染全局变量；</li>\n<li>二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li>\n</ul>\n<h2 id=\"42-Object-对象的静态方法\"><a href=\"#42-Object-对象的静态方法\" class=\"headerlink\" title=\"42. Object 对象的静态方法\"></a>42. Object 对象的静态方法</h2><p><code>Object.keys()</code> 方法和 <code>Object.getOwnPropertyNames()</code> 方法一般用来遍历对象的属性，它们的参数都是一个对象，返回一个数组，该数组的项都是对象自身的（不是继续原型的）的所有属性名。两者的区别在于， <code>Object.keys()</code> 只返回可枚举的属性，<code>Object.getOwnPropertyNames()</code> 方法还返回不可枚举的属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(arr));  <span class=\"comment\">// [\"0\", \"1\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(arr)); <span class=\"comment\">// [\"0\", \"1\", \"length\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"43-splice\"><a href=\"#43-splice\" class=\"headerlink\" title=\"43. splice()\"></a>43. splice()</h2><p><code>splice()</code> 用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素，该方法会改变原数组。第一个参数是删除的起始位置，如果是负数，就表示从倒数位置开始删除 第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如只是单纯地插入元素，splice 方法的第二个参数可以设为 0。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>));  <span class=\"comment\">// [\"b\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"c\", \"d\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'f'</span>));   <span class=\"comment\">// [\"b\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"f\", \"c\", \"d\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"string\">'h'</span>));  <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"h\", \"b\", \"c\", \"d\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"44-some-、every\"><a href=\"#44-some-、every\" class=\"headerlink\" title=\"44. some()、every()\"></a>44. some()、every()</h2><p><code>some()</code> 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是 true，则整个 some 方法的返回值就是 true，否则 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v == <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>every()</code> 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是 true，才返回 true，否则 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v == <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool);  <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bool2 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool2);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>some 和 every 方法还可以接受第二个参数，用来绑定函数中的 this 关键字。</p>\n<h2 id=\"45-基本包装类型\"><a href=\"#45-基本包装类型\" class=\"headerlink\" title=\"45. 基本包装类型\"></a>45. 基本包装类型</h2><p>ECMAScript 提供了三个基本包装类型：<code>Boolean</code>、<code>Number</code>、<code>String</code>。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能过调用一些方法来操作这些数据。执行步骤如下：</p>\n<ol>\n<li>创建那个类型的一个实例</li>\n<li>在实例上调用指定的方法</li>\n<li>销毁这个实例</li>\n</ol>\n<p>引用类型与基本包装类型的区别在于对象的生存期：使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁，这也是我们不能再运行时为基本类型值添加属性和方法的原因。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'tg'</span>;</span><br><span class=\"line\">s.age =<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.age);  <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码执行输出的是 undefined，这是音乐第二行创建的 String 对象在执行第三行代码时已经被销毁了，第三行又创建自己的 String 对象，而该对象没有 age 属性。</p>\n<h2 id=\"46-Boolean-类型\"><a href=\"#46-Boolean-类型\" class=\"headerlink\" title=\"46. Boolean 类型\"></a>46. Boolean 类型</h2><p>即使你使用 false 创建一个 Boolean 实例对象，当进行逻辑运算时，它会被转为 true，因为它是一个对象，而所有对象在逻辑运算中都会返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(bool)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"47-document-referrer\"><a href=\"#47-document-referrer\" class=\"headerlink\" title=\"47. document.referrer\"></a>47. document.referrer</h2><p>document.referrer 属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。 注：HTTPS 默认会关闭 referrer，需要通过 meta 来设置，设置方法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"referrer\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"always\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"48-数据集（dataset）属性\"><a href=\"#48-数据集（dataset）属性\" class=\"headerlink\" title=\"48. 数据集（dataset）属性\"></a>48. 数据集（dataset）属性</h2><p>在 HTML5 文档中，任意以 “data-” 为前缀的小写的属性名字都是合法的。 HTML5 还在 Element 对象上定义了 dataset 属性。该属性指代一个对象，它的各个属性对应于去掉前缀的 data-属性。因此 dataset.x 应该保存 data-x 属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test 属性就变成 dataset.jqueryTest 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"top\"</span> <span class=\"attr\">data-tip</span>=<span class=\"string\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'top'</span>);</span><br><span class=\"line\">t.dataset.tip  <span class=\"comment\">//title</span></span><br><span class=\"line\">t.dataset.tip = <span class=\"string\">'title2'</span></span><br></pre></td></tr></table></figure>\n<p>注意：dataset 属性是元素的 data-属性 的实时、双向接口。设置或删除 dataset 的一个属性就等同于设置或移除对应元素的 data-属性。</p>\n<h2 id=\"49-addEventListener\"><a href=\"#49-addEventListener\" class=\"headerlink\" title=\"49. addEventListener()\"></a>49. addEventListener()</h2><p>调用 addEventListener() 并不会影响 onclick 属性的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mybutton\"</span>&gt;</span>点击<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mybutton'</span>);</span><br><span class=\"line\">v.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;alert(<span class=\"string\">'1'</span>);&#125;</span><br><span class=\"line\">v.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'2'</span>);&#125;,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，单击按钮会产生两个 alert() 对话框。 能通过多次调用 addEventListener() 方法为同一个对象注册同一事件类型的多个处理程序函数。</p>\n<h2 id=\"50-调用顺序\"><a href=\"#50-调用顺序\" class=\"headerlink\" title=\"50. 调用顺序\"></a>50. 调用顺序</h2><p>文档元素或其他对象可以指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照下面的规则调用所有的事件处理程序：</p>\n<ul>\n<li>通过设置对象属性或 HTML 属性注册的处理程序一直优先调用。</li>\n<li>使用 addEventListener() 注册的处理程序按照它们的注册顺序调用。</li>\n<li>使用 attachEvent() 注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。</li>\n</ul>\n<h2 id=\"51-进度事件\"><a href=\"#51-进度事件\" class=\"headerlink\" title=\"51. 进度事件\"></a>51. 进度事件</h2><p>进度事件用来描述一个事件进展的过程。比如 XMLHttpRequest 对象发出的 HTTP 请求的过程，<code>&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;</code> 加载外部资源的过程。下载和上传都会发生进度事件。进度事件有以下几种：</p>\n<ul>\n<li>abort 事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。</li>\n<li>error 事件：由于错误导致资源无法加载时触发。</li>\n<li>load 事件：进度成功结束时触发。</li>\n<li>loadstart 事件：进度开始时触发。</li>\n<li>loaden d事件：进度停止时触发，发生顺序排在 error 事件 / abort 事件 / load 事件后面。</li>\n<li>progress 事件：当操作处于进度之中，由传输的数据块不断触发。</li>\n<li>timeout 事件：进度超过限时触发。</li>\n</ul>\n<h2 id=\"52-JSON-语法\"><a href=\"#52-JSON-语法\" class=\"headerlink\" title=\"52. JSON 语法\"></a>52. JSON 语法</h2><p>JSON 对值的类型和格式有严格的规定：</p>\n<ul>\n<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li>\n<li>简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和 null（不能使用 NaN, Infinity, -Infinity 和 undefined）。</li>\n<li>字符串必须使用双引号表示，不能使用单引号。</li>\n<li>对象的键名必须放在双引号里面。</li>\n<li>数组或对象最后一个成员的后面，不能加逗号。</li>\n</ul>\n<h2 id=\"53-上传文件\"><a href=\"#53-上传文件\" class=\"headerlink\" title=\"53. 上传文件\"></a>53. 上传文件</h2><p>如果要允许选择多个文件，可设置 file 控件的 multiple 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">multiple</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"54-同源策略\"><a href=\"#54-同源策略\" class=\"headerlink\" title=\"54. 同源策略\"></a>54. 同源策略</h2><p>同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 <code>&lt;iframe&gt;</code> 元素或打开其他浏览器窗口的时候，这一策略通常就会发挥作用。所谓“同源”指的是”三个相同“。</p>\n<ul>\n<li><strong>协议</strong>相同</li>\n<li><strong>域名</strong>相同</li>\n<li><strong>端口</strong>相同</li>\n</ul>\n<p>从不同 Web 服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用 http:协议 载入的文档和使用 https:协议 载入的文档具有不同的来源，即使它们来自同一个服务器。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<h2 id=\"55-获取表单元素\"><a href=\"#55-获取表单元素\" class=\"headerlink\" title=\"55. 获取表单元素\"></a>55. 获取表单元素</h2><p>获取表单元素一般有两种方式：</p>\n<ul>\n<li>通过 id 来获取，比如获取一个 id 名为 form1 的表单元素：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'form1'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 docuemnt.forms 获取 name 名为 form1 的表单元素：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.forms[<span class=\"string\">\"form1\"</span>]</span><br></pre></td></tr></table></figure>\n<p><code>document.forms</code> 可以获取到当前页面中所有的表单元素，我们又可以通过方括号表示法获取某个属性，传入数值索引或 <code>name</code> 值。</p>\n<h2 id=\"56-重置表单\"><a href=\"#56-重置表单\" class=\"headerlink\" title=\"56. 重置表单\"></a>56. 重置表单</h2><p>重置表单也有两种方式：</p>\n<h3 id=\"重置按钮\"><a href=\"#重置按钮\" class=\"headerlink\" title=\"重置按钮\"></a>重置按钮</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"reset\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"reset\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当点击重置按钮时，会触发 reset 事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form1.onreset = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过-reset-方法\"><a href=\"#通过-reset-方法\" class=\"headerlink\" title=\"通过 reset() 方法\"></a>通过 reset() 方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form1.reset();</span><br></pre></td></tr></table></figure>\n<p>与调用 submit() 不同，调用 reset() 方法时也会触发 reset 事件。</p>\n<h2 id=\"57-离线检测\"><a href=\"#57-离线检测\" class=\"headerlink\" title=\"57. 离线检测\"></a>57. 离线检测</h2><p>HTML5 定义了一个 <code>navigator.onLine</code> 属性，用来检测设备是在线还是离线，为 true 时表示设备能上网，否则表示设备离线。 检测代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.onLine)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正常工作</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设备已离线</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了 <code>navigator.onLine</code> 属性，HTML5 还为检测网络是否可用提供了两个事件：<code>online</code> 和 <code>offline</code>。</p>\n<ul>\n<li><code>online</code>：当网络从离线变为在线时触发</li>\n<li><code>offline</code>：当网络从在线变为离线时触发</li>\n</ul>\n<h2 id=\"58-应用缓存\"><a href=\"#58-应用缓存\" class=\"headerlink\" title=\"58. 应用缓存\"></a>58. 应用缓存</h2><p>HTML5 的应用缓存（application cache），简称：appcache，是专门为开发离线 Web 应用而设计的。 Appcache 就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。<code>manifest</code> 文件可分为三个部分：</p>\n<ul>\n<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>\n<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>\n<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"># 需要缓存的列表</span><br><span class=\"line\">test.css</span><br><span class=\"line\">test.jpg</span><br><span class=\"line\">test.js</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\"># 不需要缓存的</span><br><span class=\"line\">test2.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\"># 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件 *.html /offline.html</span><br><span class=\"line\">2.jpg/3.jpg</span><br></pre></td></tr></table></figure>\n<p>注意：manifest 文件的 <code>MIME</code> 类型必须是 “text/cache-manifest”。</p>\n<blockquote>\n<p>描述文件的扩展名以前推荐用 manifest，现在推荐用 appcache</p>\n</blockquote>\n<h2 id=\"59-localStorage-和-sessionStorage\"><a href=\"#59-localStorage-和-sessionStorage\" class=\"headerlink\" title=\"59. localStorage 和 sessionStorage\"></a>59. localStorage 和 sessionStorage</h2><p><code>localStorage</code> 和 <code>sessionStorage</code>这两个属性都代表同一个 Storage 对象（一个持久化关联数组，数组使用字符串来索引，存储的值都是字符串形式的）。</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>通过 <code>localStorage</code> 存储的数据是永久性的，除非Web应用刻意删除存储的数据或用户通过设置浏览器设置来删除，否则数据将一直保留在用户的电脑里，永不过期。<code>localStorage</code> 的作用域是限定在文档源（document origin）级别。 同源的文档间共享同样的 <code>localStorage</code> 数据。</p>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p><code>sessionStorage</code> 的作用域同样是限定在文档源中，不过它被限定在窗口中。也就是说，如果同源的文档在不同的浏览器标签页中，那它们互相之间拥有的是各自的 <code>sessionStorage</code> 数据，无法共享。</p>\n<p>注意：基于窗口作用域的 <code>sessionStorage</code> 指的窗口只是顶级窗口。如果一个浏览器标签页包含多个 <code>&lt;iframe&gt;</code> 元素，它们包含的文档是同源的，两者之间的 sessionStorage 是可共享的。</p>\n<h2 id=\"60-finally-子句\"><a href=\"#60-finally-子句\" class=\"headerlink\" title=\"60. finally 子句\"></a>60. finally 子句</h2><p>当使用 <code>finally</code> 子句时，其代码无论如何都会执行，也就是说，不管是正常执行还是出错了，<code>finally</code> 子句都会执行。甚至 <code>return</code> 语句，也不会阻止 <code>finally</code> 子句的执行。看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(error)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test()); </span><br><span class=\"line\"><span class=\"comment\">//结果</span></span><br><span class=\"line\">a</span><br><span class=\"line\">c</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>从运行结果，我们可以看到，<code>return</code> 语句并没有阻止 <code>finally</code> 子句的执行，而且是在 <code>finally</code> 子句执行后才会返回 <code>return</code> 语句的值。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"JS中的传值与传址","slug":"JS中的传值与传址","date":"2017-04-25T12:36:04.000Z","updated":"2019-02-04T06:11:30.226Z","comments":true,"path":"api/articles/JS中的传值与传址.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_21.jpg","content":"<p>在 JS 中，有两种不同的方式可以操作数据的值，这两种技术分别叫做<strong>传值</strong>和<strong>传址</strong>。</p>\n<h2 id=\"数据值的操作\"><a href=\"#数据值的操作\" class=\"headerlink\" title=\"数据值的操作\"></a>数据值的操作</h2><p>要知道传址跟传址，首先我们先了解下数据值的操作。</p>\n<ol>\n<li><strong>复制</strong>：可以把它赋值给一个新的变量</li>\n<li><strong>传递</strong>：可以将他传递给一个函数或者方法</li>\n<li><strong>比较</strong>：可以与另外一个值比较，判断是否相等</li>\n</ol>\n<h2 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h2><p><strong>传值</strong>：在赋值过程中，首先对值进行了一份拷贝，而后将这份拷贝存储到一个变量、对象属性或数组元素中。拷贝的值和原始的值是完全独立、互不影响的。当一份数据通过值传递给一个函数，实际上被传递的不是数据本身，而是数据的一份拷贝。因此，如果函数修改了这个值，影响到的只是数据的那份拷贝，而并不影响数据本身。</p>\n<p><strong>传址</strong>：在赋值过程中，变量实际上存储的是数据的地址（对数据的引用），而不是原始数据或者是数据的拷贝。如果值通过一个地址发生了改变，这个改变也会通过原始地址表现出来。</p>\n<h2 id=\"参阅对比表\"><a href=\"#参阅对比表\" class=\"headerlink\" title=\"参阅对比表\"></a>参阅对比表</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>传值</th>\n<th>传址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复制</td>\n<td>实际复制的是值，存在于两个不同的独立拷贝</td>\n<td>复制的只是对数值的引用，即地址，如果通过这个新的引用修改了数值，这个改变对最初的引用也是可见的</td>\n</tr>\n<tr>\n<td>传递</td>\n<td>传递给函数的值是一个独立的拷贝，对它的改变函数外没有影响</td>\n<td>传递给函数的是对数值的一个引用。如果通过这个新的引用修改了数值，这个改变对最初的引用也是可见的</td>\n</tr>\n<tr>\n<td>比较</td>\n<td>比较两个独立的值，判断是否相同</td>\n<td>比较的是两个的引用，判断引用是否是同一个数值。对两个不同数值的引用不相等，即使这两个数值相等</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>根据操作数据方式的不同，我们可以把数据类型分为两类：<strong>基础类型</strong>和<strong>引用类型</strong>。</p>\n<ul>\n<li>基础类型主要有：数字(Number)、布尔类型(Boolean)；其操作方式为传值。</li>\n<li>引用类型主要有：对象(Object) —— 数组(Array)、函数(Function)；其操作方式为传址。</li>\n</ul>\n<p>数字和布尔类型是基础类型，它们是由很小的，固定数目字节组成，所以可以通过传值来操作；而数组和函数，是对象的特殊类型，也是引用类型。由于对象没有固定大小，所以无法通过传值进行操作。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"传值（赋值操作）\"><a href=\"#传值（赋值操作）\" class=\"headerlink\" title=\"传值（赋值操作）\"></a>传值（赋值操作）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>, b = a, a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"a=\"</span> + a + <span class=\"string\">\",b=\"</span> + b);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_21.jpg\" alt=\"\" width=\"400\"></div>\n\n<p>a 先是被赋值为 1，接着把 a 的值赋给 b，这时会进行值的拷贝，因此b = 1；然后又把 a 赋值为 2。在没有执行 a = 2 之前，我们试试下列代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b);  <span class=\"comment\">// 输出为true. 可见它们在内存中是指向同一个位置的。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"传值（基础类型）\"><a href=\"#传值（基础类型）\" class=\"headerlink\" title=\"传值（基础类型）\"></a>传值（基础类型）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;            <span class=\"comment\">// 将a复制给b</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add1</span>(<span class=\"params\">x,y</span>) </span>&#123;     <span class=\"comment\">// 函数修改参数的值</span></span><br><span class=\"line\">  x = x + y;              <span class=\"comment\">// 虽然这个里面将值进行相加，但是仅仅是值的独立拷贝，进行相加，在函数外面没有影响</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add1(a,b);                <span class=\"comment\">// 数字类型为传值</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\"n\"</span> + <span class=\"string\">\"b:\"</span> + b);      <span class=\"comment\">// a为1，b为1  </span></span><br><span class=\"line\">(a == b) ? c = <span class=\"string\">\"true\"</span> : c = <span class=\"string\">\"false\"</span>;  </span><br><span class=\"line\">alert(c);         <span class=\"comment\">// c = \"true\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"传址（引用类型）\"><a href=\"#传址（引用类型）\" class=\"headerlink\" title=\"传址（引用类型）\"></a>传址（引用类型）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];      <span class=\"comment\">// 定义数组，引用类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;                           <span class=\"comment\">// 将a复制给b</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123;           <span class=\"comment\">// 函数修改参数的值</span></span><br><span class=\"line\">  x[<span class=\"number\">0</span>] = <span class=\"string\">\"tt\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(b);             <span class=\"comment\">// 数组对象为传址  </span></span><br><span class=\"line\">alert(<span class=\"string\">\"a:\"</span> + a[<span class=\"number\">0</span>] + a[<span class=\"number\">1</span>] + a[<span class=\"number\">2</span>] + a[<span class=\"number\">3</span>] + <span class=\"string\">\"n\"</span> + <span class=\"string\">\"b:\"</span> + b[<span class=\"number\">0</span>] + b[<span class=\"number\">1</span>] + b[<span class=\"number\">2</span>] + b[<span class=\"number\">3</span>]);  <span class=\"comment\">// b对象修改，则a也会修改，传址</span></span><br><span class=\"line\">(a == b) ? q = <span class=\"string\">\"true\"</span> : q = <span class=\"string\">\"false\"</span>;    <span class=\"comment\">// 判断 a=b  ，返回true</span></span><br><span class=\"line\">alert(q);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];</span><br><span class=\"line\">(a == b) ? q = <span class=\"string\">\"true\"</span> : q = <span class=\"string\">\"false\"</span>;     <span class=\"comment\">// 这里定义了两个对象，虽然值一样，但是不是同样的地址，所以为false</span></span><br><span class=\"line\">alert(q);    <span class=\"comment\">// 输出\"false\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数内的特殊引用\"><a href=\"#函数内的特殊引用\" class=\"headerlink\" title=\"函数内的特殊引用\"></a>函数内的特殊引用</h3><p>按值传递一个参数给函数就是制作该参数的一个独立复本，即一个只存在于该函数内的复本。即使按引用传递对象和数组时，如果直接在函数中用新值覆盖原先的值，在函数外并不反映新值。只有在对象的属性或者数组的元素改变时，在函数外才可以看出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newa = <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  newa[<span class=\"number\">0</span>] = a[<span class=\"number\">0</span>] + b;</span><br><span class=\"line\">  newa[<span class=\"number\">1</span>] = a[<span class=\"number\">1</span>] + b;</span><br><span class=\"line\">  newa[<span class=\"number\">2</span>] = a[<span class=\"number\">2</span>] + b;</span><br><span class=\"line\">  a = newa;     <span class=\"comment\">// 重新覆盖了引用，所以外部是不可见的</span></span><br><span class=\"line\">  alert(a[<span class=\"number\">0</span>]);  <span class=\"comment\">// 11</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(a1, <span class=\"number\">10</span>);   </span><br><span class=\"line\">alert(a1[<span class=\"number\">0</span>]);     <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h2><p>前面看了这么多类型，一直都没有介绍字符串类型，它不好直接分为基础类型和引用类型，因为字符串\b可以是任意的长度，看上去应该是引用类型，可是他却不是对象，所以也不可作为引用类型；总结一下，<strong>字符串是按引用(即地址)复制和传递的，但是是按值来比较的。</strong></p>\n<p>请注意，假如有两个 String 对象（用 new String(“something”) 创建的），按引用比较它们，但是，如果其中一个或者两者都是字符串值的话，按值比较它们</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>复制</th>\n<th>传递</th>\n<th>比较</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数字</td>\n<td>传值</td>\n<td>传值</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>布尔</td>\n<td>传值</td>\n<td>传值</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>不可变</td>\n<td>不可变</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>对象</td>\n<td>传址</td>\n<td>传址</td>\n<td>传址</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/joe2014/archive/2014/06/28/3813919.html\" target=\"_blank\" rel=\"noopener\">JS 基础知识2 传值和传址</a></li>\n<li><a href=\"http://www.cnblogs.com/idayln/p/3346242.html\" target=\"_blank\" rel=\"noopener\">图解JS的传值与传址</a></li>\n<li><a href=\"http://lxneliu.iteye.com/blog/1567205\" target=\"_blank\" rel=\"noopener\">JS 传值与传址</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"浏览器中输入url后发生了什么","slug":"浏览器中输入url后发生了什么","date":"2017-04-24T13:18:56.000Z","updated":"2019-02-04T06:11:30.234Z","comments":true,"path":"api/articles/浏览器中输入url后发生了什么.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_34.png","content":"<p>本文转载自<a href=\"http://www.jianshu.com/p/c1dfc6caa520\" target=\"_blank\" rel=\"noopener\">简书-浏览器中输入url后发生了什么</a>，其实这个问题在前端面试中经常遇到，所以网上有很多关于这个问题的文章，但是我感觉这篇文章是表达的最清晰的，感兴趣的童鞋可以点击上面的链接查看原文，不过在本文中，我又补充了一些其他文章中的相关内容，同时加入了一些我自己的理解，争取让初学者更容易看懂 先上一张思维导图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_34.png\" alt=\"\" width=\"900\"></div>\n\n<p>上面这张图用非常简练的语言总结了浏览器中输入 url 后发生的事情以及顺序，下面按照执行顺序分为六步进行描述：</p>\n<h2 id=\"1-DNS-域名解析\"><a href=\"#1-DNS-域名解析\" class=\"headerlink\" title=\"1. DNS 域名解析\"></a>1. DNS 域名解析</h2><ul>\n<li>在浏览器 DNS 缓存中搜索</li>\n<li>在操作系统 DNS 缓存中搜索</li>\n<li>读取系统 hosts 文件，查找其中是否有对应的 ip</li>\n<li>向本地配置的首选 DNS 服务器发起域名解析请求</li>\n</ul>\n<p>以上四个步骤其实都是 DNS 的解析过程，总结一下就是先看有没有缓存，如果没有就发起DNS域名解析请求，具体过程其实比较复杂，可以查看<a href=\"http://www.cnblogs.com/vincently/p/4670597.html\" target=\"_blank\" rel=\"noopener\">DNS原理及解析过程</a>进行更深入的了解</p>\n<h2 id=\"2-建立-TCP-连接\"><a href=\"#2-建立-TCP-连接\" class=\"headerlink\" title=\"2.建立 TCP 连接\"></a>2.建立 TCP 连接</h2><p>为了准确地传输数据，TCP 协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有 SYN/ACK(acknowledegment) 标志的数据包以示传达确认信息。最后发送方再回传一个带 ACK 标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP 会再次发送相同的数据包。TCP 是一个端到端的可靠的面向连接的协议，所以 HTTP 基于传输层 TCP 协议不用担心数据的传输的各种问题。当然，TCP 三次握手也是一个可以展开的问题，而且为什么使用三次握手也是大有学问，可以去我的另外一篇文章：<a href=\"/20170405/tcp-three-handshakes-and-four-breakups.html\">前端面试系列（8）——TCP的三次握手与四次分手</a>中寻找答案</p>\n<h2 id=\"3-发起-HTTP-请求\"><a href=\"#3-发起-HTTP-请求\" class=\"headerlink\" title=\"3. 发起 HTTP 请求\"></a>3. 发起 HTTP 请求</h2><p>HTTP 的请求方法（method）有以下几种：</p>\n<ul>\n<li>GET: 获取资源</li>\n<li>POST: 传输实体主体</li>\n<li>HEAD: 获取报文首部</li>\n<li>PUT: 传输文件</li>\n<li>DELETE: 删除文件</li>\n<li>OPTIONS: 询问支持的方法</li>\n<li>TRACE: 追踪路径</li>\n</ul>\n<p>其中最常用的就是 GET 和 POST 了，请求报文格式如下所示（HTTP/1.1）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_33.png\" alt=\"\" width=\"900\"></div>\n\n<h2 id=\"4-接受响应结果\"><a href=\"#4-接受响应结果\" class=\"headerlink\" title=\"4. 接受响应结果\"></a>4. 接受响应结果</h2><p>客户端在发出请求之后，服务器会在接收到请求之后返回客户端响应结果，该结果就是服务器告知客户端的当前状态，下面是状态码的分类，更多关于状态码的详细内容请移步<a href=\"/20170404/status-code-of-http-request.html\">前端面试系列（6）——HTTP请求的状态码</a>：</p>\n<ul>\n<li>1**：信息性状态码</li>\n<li>2**：成功状态码</li>\n<li>3**：重定向状态码</li>\n<li>4**：客户端错误状态码</li>\n<li>5**：服务器错误状态码</li>\n</ul>\n<p>响应报文：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_35.png\" alt=\"\" width=\"900\"></div>\n\n<h2 id=\"5-浏览器解析-html\"><a href=\"#5-浏览器解析-html\" class=\"headerlink\" title=\"5. 浏览器解析 html\"></a>5. 浏览器解析 html</h2><p>浏览器按顺序解析 html 文件，构建 DOM 树，在解析到外部的 css 和 js 文件时，向服务器发起请求下载资源，若是下载 css 文件，则解析器会在下载的同时继续解析后面的 html 来构建 DOM 树，但是在下载 js 文件和执行它时，解析器会停止对 html 的解析。这便出现了 js 阻塞问题。</p>\n<h3 id=\"预加载器：\"><a href=\"#预加载器：\" class=\"headerlink\" title=\"预加载器：\"></a>预加载器：</h3><p>当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的 html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索 HTML 标签中的 URL，无法检测到使用脚本添加的 URL，这些资源要等脚本代码执行时才会获取。（注: 预解析并不改变 Dom 树，它将这个工作留给主解析过程），浏览器解析 css，形成 CSSOM 树，当 DOM 树构建完成后，浏览器引擎通过 DOM 树和 CSSOM 树构造出渲染树（Render 树）。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head 元素和 display 值为 none 的元素）</p>\n<blockquote>\n<p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n</blockquote>\n<h2 id=\"6-浏览器布局渲染\"><a href=\"#6-浏览器布局渲染\" class=\"headerlink\" title=\"6. 浏览器布局渲染\"></a>6. 浏览器布局渲染</h2><ul>\n<li>布局（Layout）：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。</li>\n<li>绘制（Paint）：将计算好的每个像素点信息绘制在屏幕上</li>\n</ul>\n<p>在页面显示的过程中会多次进行 Reflow 和 Repaint 操作，而 Reflow 的成本比 Repaint 的成本高得多的多。因为 Repaint 只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的 display 属性由 block 改为 none 则需要 Reflow。如何减少 rpaint 和 reflow 也是<a href=\"/20170416/front-end-performance-optimization.html\">前端优化</a>需要考虑的问题：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_36.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/c1dfc6caa520\" target=\"_blank\" rel=\"noopener\">浏览器中输入url后发生了什么</a></li>\n<li><a href=\"http://coolshell.cn/articles/9666.html\" target=\"_blank\" rel=\"noopener\">浏览器的渲染原理简介</a></li>\n<li><a href=\"http://www.cnblogs.com/yuezk/archive/2013/01/11/2855698.html\" target=\"_blank\" rel=\"noopener\">了解html页面的渲染过程</a></li>\n<li><a href=\"https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/\" target=\"_blank\" rel=\"noopener\">老生常谈-从输入url到页面展示到底发生了什么</a></li>\n<li><a href=\"http://harttle.com/2016/05/18/async-javascript-loading.html\" target=\"_blank\" rel=\"noopener\">异步脚本载入提高页面性能</a></li>\n</ul>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://blog.codingplayboy.com/2017/03/29/webpage_render/\" target=\"_blank\" rel=\"noopener\">浅谈前端页面渲染机制</a></li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"CSS深入理解之border","slug":"CSS深入理解之border","date":"2017-04-23T14:39:19.000Z","updated":"2019-02-04T06:11:30.222Z","comments":true,"path":"api/articles/CSS深入理解之border.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_205.png","content":"<h2 id=\"1-不支持百分比单位的属性\"><a href=\"#1-不支持百分比单位的属性\" class=\"headerlink\" title=\"1. 不支持百分比单位的属性\"></a>1. 不支持百分比单位的属性</h2><ul>\n<li>border-width</li>\n<li>outline</li>\n<li>box-shadow</li>\n<li>text-shadow</li>\n</ul>\n<h2 id=\"2-border-width-支持关键字\"><a href=\"#2-border-width-支持关键字\" class=\"headerlink\" title=\"2. border-width 支持关键字\"></a>2. border-width 支持关键字</h2><ul>\n<li>thin –&gt; 1px</li>\n<li>medium（默认值）–&gt; 3px</li>\n<li>thick –&gt; 5px</li>\n</ul>\n<h2 id=\"3-border-style\"><a href=\"#3-border-style\" class=\"headerlink\" title=\"3. border-style\"></a>3. border-style</h2><ul>\n<li>solid：实线</li>\n<li>dashed：虚线，但是 IE 和 Chrome / FireFox 的虚线比例不同，IE 会更密一些</li>\n<li>dotted：点线，Chrome / FireFox 下点线是方形，IE 下是圆形</li>\n<li>double：双线，宽度实现规律为双线宽度永远相等，而中间间隔 ±1</li>\n<li>inset：内凹，在 css 里很少用，基本上被淘汰了</li>\n<li>groove：沟槽</li>\n<li>ridge：山脊</li>\n</ul>\n<p>inset、groove、ridge 风格过时 + 兼容性差，所以基本上处于被淘汰的状态</p>\n<h2 id=\"4-利用-IE7-中的-border-style-dotted-实现圆角效果\"><a href=\"#4-利用-IE7-中的-border-style-dotted-实现圆角效果\" class=\"headerlink\" title=\"4. 利用 IE7 中的 border-style:dotted 实现圆角效果\"></a>4. 利用 IE7 中的 border-style:dotted 实现圆角效果</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dotted</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">149px</span> dotted <span class=\"number\">#cd0000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-利用-border-style-double-实现三道杠\"><a href=\"#5-利用-border-style-double-实现三道杠\" class=\"headerlink\" title=\"5. 利用 border-style:double 实现三道杠\"></a>5. 利用 border-style:double 实现三道杠</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.three</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">120px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>:<span class=\"number\">60px</span> double;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>:<span class=\"number\">20px</span> solid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-border-color-与-color\"><a href=\"#6-border-color-与-color\" class=\"headerlink\" title=\"6. border-color 与 color\"></a>6. border-color 与 color</h2><p>当没有指定 border-color 的时候，会使用 color 作为边框色，类似的还有 box-shadow、text-shadow 和 outline，都是默认使用 color 的颜色</p>\n<h2 id=\"7-border-与-background-position-定位\"><a href=\"#7-border-与-background-position-定位\" class=\"headerlink\" title=\"7. border 与 background-position 定位\"></a>7. border 与 background-position 定位</h2><p>background-position 默认相对于左上进行定位，所以如果想相对于右边进行定位的话，其中一个方法就是借助于 border（设置为 100% 默认不计算 border 区域）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border-right</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 100% 40<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-border-color-的分配\"><a href=\"#8-border-color-的分配\" class=\"headerlink\" title=\"8. border-color 的分配\"></a>8. border-color 的分配</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.triangle</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">100px</span> solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red green blue orange;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果展示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_205.png\" alt=\"\" width=\"150\"></div>\n\n<h2 id=\"9-border-的应用\"><a href=\"#9-border-的应用\" class=\"headerlink\" title=\"9. border 的应用\"></a>9. border 的应用</h2><h3 id=\"透明边框优雅增加响应区域大小（复选框）\"><a href=\"#透明边框优雅增加响应区域大小（复选框）\" class=\"headerlink\" title=\"透明边框优雅增加响应区域大小（复选框）\"></a>透明边框优雅增加响应区域大小（复选框）</h3><p>原来视觉区域大小（不含边框）是 16px * 16px，经过使用透明边框，可以使复选框点击区域扩大到 20px * 20px 甚至更大</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.checkbox</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: inset <span class=\"number\">0</span> <span class=\"number\">1px</span>, inset <span class=\"number\">1px</span> <span class=\"number\">0</span>, inset -<span class=\"number\">1px</span> <span class=\"number\">0</span>, inset <span class=\"number\">0</span> -<span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-clip</span>: content-box;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#d0d0d5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现两栏等高布局\"><a href=\"#实现两栏等高布局\" class=\"headerlink\" title=\"实现两栏等高布局\"></a>实现两栏等高布局</h3><p>利用很长的 border 构造另外一个盒子，然后利用 margin 负值进行定位，但是不支持百分比宽度（margin 和 padding实现支持百分比宽度）</p>\n<p>html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>导航1<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"module\"</span>&gt;</span>模块1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">300px</span> solid <span class=\"number\">#222</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_206.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"绘制三角形\"><a href=\"#绘制三角形\" class=\"headerlink\" title=\"绘制三角形\"></a>绘制三角形</h3><p>根据上面 border-color 的分配，实现方案为将 border 的其中一个方向的颜色设置为预期颜色，将其余三个方向设置为透明，然后 border-width 就是三角形的大小</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.triangle</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">100px</span> solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red transparent transparent transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"CSS深入理解系列","slug":"CSS深入理解系列","date":"2017-04-21T13:52:56.000Z","updated":"2019-02-04T06:11:30.226Z","comments":true,"path":"api/articles/CSS深入理解系列.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>此系列的文章是我对张鑫旭的讲解的总结，张鑫旭作为很早入行前端的代表人物，其对 html 以及 css 的理解很深刻，所以他的系列文章“<a href=\"http://www.imooc.com/search/course?words=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css\" target=\"_blank\" rel=\"noopener\">深入理解 CSS</a>”是一个不错的前端基础教材，虽然我将其讲解进行了总结，但是还是希望你有时间能够看一下他的视频，风趣幽默又不失教学性，一定会有所收获。</p>\n<ul>\n<li><a href=\"/20170421/line-height-of-css.html\">CSS深入理解之line-height</a></li>\n<li><a href=\"/20170420/margin-of-css.html\">CSS深入理解之margin</a></li>\n<li><a href=\"/20170420/padding-of-css.html\">CSS深入理解之padding</a></li>\n<li><a href=\"/20170420/z-index-of-css.html\">CSS深入理解之z-index</a></li>\n<li><a href=\"/20170421/relative-of-css.html\">CSS深入理解之relative</a></li>\n<li><a href=\"/20170421/vertical-align-of-css.html\">CSS深入理解之vertical-align</a></li>\n<li><a href=\"/20170421/absolute-of-css.html\">CSS深入理解之absolute</a></li>\n<li><a href=\"/20170421/overflow-of-css.html\">CSS深入理解之overflow</a></li>\n<li><a href=\"/20170421/float-of-css.html\">CSS深入理解之float</a></li>\n<li><a href=\"/20170423/border-of-css.html\">CSS深入理解之border</a></li>\n</ul>\n","raw":null,"categories":[{"name":"series","path":"api/categories/series.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"CSS深入理解之float","slug":"CSS深入理解之float","date":"2017-04-21T13:41:31.000Z","updated":"2019-02-04T06:11:30.222Z","comments":true,"path":"api/articles/CSS深入理解之float.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"1-float-的历史\"><a href=\"#1-float-的历史\" class=\"headerlink\" title=\"1. float 的历史\"></a>1. float 的历史</h2><p>浮动设计的初衷: 实现文字环绕</p>\n<h2 id=\"2-float-感性认知\"><a href=\"#2-float-感性认知\" class=\"headerlink\" title=\"2. float 感性认知\"></a>2. float 感性认知</h2><p>float 具有<strong>包裹性</strong>和<strong>破坏性</strong></p>\n<h3 id=\"具有包裹性的小伙伴\"><a href=\"#具有包裹性的小伙伴\" class=\"headerlink\" title=\"具有包裹性的小伙伴:\"></a>具有包裹性的小伙伴:</h3><ul>\n<li>display: inline-block / table-cell / …</li>\n<li>position: absolute(近亲) / fixed / sticky</li>\n<li>overflow: hidden / scroll</li>\n</ul>\n<h3 id=\"具有破坏性的小伙伴-父级元素容器塌陷，高度变为-0\"><a href=\"#具有破坏性的小伙伴-父级元素容器塌陷，高度变为-0\" class=\"headerlink\" title=\"具有破坏性的小伙伴: (父级元素容器塌陷，高度变为 0)\"></a>具有破坏性的小伙伴: (父级元素容器塌陷，高度变为 0)</h3><ul>\n<li>display: none</li>\n<li>position: absolute(近亲) / fixed / sticky</li>\n</ul>\n<h2 id=\"3-如何解决浮动让父元素高度塌陷的问题\"><a href=\"#3-如何解决浮动让父元素高度塌陷的问题\" class=\"headerlink\" title=\"3. 如何解决浮动让父元素高度塌陷的问题\"></a>3. 如何解决浮动让父元素高度塌陷的问题</h2><p>浮动的破坏性只是单纯为了实现文字环绕效果而已<br>关于<strong>浮动塌陷</strong>：给父元素设置了宽高，那么父元素不会塌陷；如果设置了宽度没有设置高度，会塌陷，宽度值还是设定的值，高度为0；如果没有设置宽高，发生塌陷，宽度为页面宽度，高度为0。</p>\n<h2 id=\"4-清除浮动\"><a href=\"#4-清除浮动\" class=\"headerlink\" title=\"4. 清除浮动\"></a>4. 清除浮动</h2><h3 id=\"底部插入-clear-both\"><a href=\"#底部插入-clear-both\" class=\"headerlink\" title=\"底部插入 clear:both\"></a>底部插入 <code>clear:both</code></h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</span><br><span class=\"line\">  *zoom: 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更好的方法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</span><br><span class=\"line\">  *zoom: 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-BFC\"><a href=\"#5-BFC\" class=\"headerlink\" title=\"5. BFC\"></a>5. BFC</h2><p>BFC：Block Formatting Context，<strong>块级格式化上下文</strong>，一个独立的块级渲染区域，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关</p>\n<h3 id=\"产生条件：\"><a href=\"#产生条件：\" class=\"headerlink\" title=\"产生条件：\"></a>产生条件：</h3><p>满足其一即可：</p>\n<ol>\n<li>html 根元素</li>\n<li>float 的值不为 none</li>\n<li>display 的值为 inline-block、table-cell、table-caption</li>\n<li>position 的值为 absolute 或 fix</li>\n</ol>\n<h3 id=\"约束规则：\"><a href=\"#约束规则：\" class=\"headerlink\" title=\"约束规则：\"></a>约束规则：</h3><ol>\n<li>生成 BFC 元素的子元素会一个接着一个防止垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的 margin 特性。在 BFC 中相邻的块级元素外边距会折叠，同属一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li>\n<li>生成 BFC 元素的子元素中，每一个子元素左外边距与包含块的左边界接触，即使浮动元素也是如此（除非这个子元素自身也是一个浮动元素）。</li>\n<li>BFC 的区域不会与 float 的元素区域重叠。</li>\n<li>计算 BFC 高度时，浮动元素也参与计算。</li>\n<li>BFC 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。</li>\n</ol>\n<h2 id=\"6-浮动的优劣\"><a href=\"#6-浮动的优劣\" class=\"headerlink\" title=\"6. 浮动的优劣\"></a>6. 浮动的优劣</h2><h3 id=\"浮动的影响\"><a href=\"#浮动的影响\" class=\"headerlink\" title=\"浮动的影响\"></a>浮动的影响</h3><ul>\n<li>元素 block 块状化(砖头化)</li>\n<li>破坏性造成的紧密排列特性(去空格化，和 inline-block 不同)</li>\n</ul>\n<h3 id=\"浮动存在的问题\"><a href=\"#浮动存在的问题\" class=\"headerlink\" title=\"浮动存在的问题:\"></a>浮动存在的问题:</h3><ul>\n<li>容错性比较糟糕，容易出问题</li>\n<li>全部用固定尺寸，代码不易重用</li>\n<li>与 IE7 及以下版本不兼容</li>\n</ul>\n<h2 id=\"7-两侧自适应布局\"><a href=\"#7-两侧自适应布局\" class=\"headerlink\" title=\"7.两侧自适应布局\"></a>7.两侧自适应布局</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.left&#123;  // 左侧</span><br><span class=\"line\">  <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right&#123;  // 右侧</span><br><span class=\"line\">  <span class=\"selector-tag\">width</span>: <span class=\"selector-tag\">max-width</span>;</span><br><span class=\"line\">  *<span class=\"selector-tag\">width</span>: <span class=\"selector-tag\">auto</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">table-cell</span>;</span><br><span class=\"line\">  *<span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">inline-block</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"CSS深入理解之overflow","slug":"CSS深入理解之overflow","date":"2017-04-21T13:29:13.000Z","updated":"2019-02-04T06:11:30.222Z","comments":true,"path":"api/articles/CSS深入理解之overflow.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_124.png","content":"<h2 id=\"1-overflow-起作用的前提\"><a href=\"#1-overflow-起作用的前提\" class=\"headerlink\" title=\"1. overflow 起作用的前提\"></a>1. overflow 起作用的前提</h2><ol>\n<li>非 display:inline水 平</li>\n<li>对应方位的尺寸限制 .width / height / max-width / max-height / absolute 拉伸</li>\n<li>对于单元格 td 等，还需要 table 为 table-layout:fixed 状态才行</li>\n</ol>\n<p><strong>Tips</strong>: 如果 overflow-x，overflow-y 相同，则等同于 overflow；如果不同，其中一个为 visible，另外一个为 auto / hidden / scroll，则 visible 会重置为 auto</p>\n<h2 id=\"2-JS-与滚动高度\"><a href=\"#2-JS-与滚动高度\" class=\"headerlink\" title=\"2. JS 与滚动高度\"></a>2. JS 与滚动高度</h2><p>无论什么浏览器，默认滚动条均来自 <code>&lt;html&gt;</code>，而不是 <code>&lt;body&gt;</code> 标签.所以，如果想要去除页面默认滚动条，只需要 <strong>html{ overflow: hidden }</strong>，而没必要把 <code>&lt;body&gt;</code> 也拉下水。</p>\n<h3 id=\"关于scrollTop\"><a href=\"#关于scrollTop\" class=\"headerlink\" title=\"关于scrollTop\"></a>关于scrollTop</h3><p>Chrome 浏览器: document.body.scrollTop<br>其他浏览器: document.documentElement.scrollTop</p>\n<p>目前，两者不会同时存在，建议使用: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"built_in\">document</span>.body.scrollTop || <span class=\"built_in\">document</span>.documentElement.scrollTop</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-水平居中跳动问题的修复\"><a href=\"#3-水平居中跳动问题的修复\" class=\"headerlink\" title=\"3. 水平居中跳动问题的修复\"></a>3. 水平居中跳动问题的修复</h2><p>由于滚动条会使网页可用内容宽度变小，所以水平居中的页面出现滚动条时会有跳动的问题，解决方案： </p>\n<ol>\n<li>html{ overflow-y: scroll } // 滚动栏一直存在</li>\n<li>container{ padding-left: calc(100vw - 100%) } // <strong>100vw-浏览器宽度;100%-可用内容宽度</strong></li>\n</ol>\n<h2 id=\"4-iOS-原生滚动回调效果\"><a href=\"#4-iOS-原生滚动回调效果\" class=\"headerlink\" title=\"4. iOS 原生滚动回调效果:\"></a>4. iOS 原生滚动回调效果:</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-webkit-overflow-scrolling</span><span class=\"selector-pseudo\">:touch</span>;</span><br></pre></td></tr></table></figure>\n<p>会使滚动出现缓冲效果</p>\n<h2 id=\"5-overflow-与块状格式上下文\"><a href=\"#5-overflow-与块状格式上下文\" class=\"headerlink\" title=\"5. overflow 与块状格式上下文\"></a>5. overflow 与块状格式上下文</h2><h3 id=\"两栏自适应布局\"><a href=\"#两栏自适应布局\" class=\"headerlink\" title=\"两栏自适应布局\"></a>两栏自适应布局</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.cell</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">  width: 2000px; // IE8+ BFC特性</span><br><span class=\"line\">  <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">inline-block</span>;</span><br><span class=\"line\">  width: auto; // IE7- 伪BFC特性</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只适用于 block 属性的元素，之间的空隙推荐使用浮动元素的 margin 来实现</p>\n<h3 id=\"父元素设置-overflow-scroll-overflow-auto-overflow-hidden，可以解决父元素因内部浮动塌陷问题。\"><a href=\"#父元素设置-overflow-scroll-overflow-auto-overflow-hidden，可以解决父元素因内部浮动塌陷问题。\" class=\"headerlink\" title=\"父元素设置 overflow: scroll; overflow: auto; overflow:hidden，可以解决父元素因内部浮动塌陷问题。\"></a>父元素设置 overflow: scroll; overflow: auto; overflow:hidden，可以解决父元素因内部浮动塌陷问题。</h3><p>更多请参见：<a href=\"http://harttle.com/2016/05/11/block-formatting-context.html\" target=\"_blank\" rel=\"noopener\">overflow 与布局上下文（BFC）</a></p>\n<h2 id=\"6-overflow-与-absolute-绝对定位\"><a href=\"#6-overflow-与-absolute-绝对定位\" class=\"headerlink\" title=\"6. overflow 与 absolute 绝对定位\"></a>6. overflow 与 absolute 绝对定位</h2><p>overflow: hidden 在子元素绝对定位失效，可以理解成，父元素与子元素所在的层级不一样了，子元素完全脱离文档流了，因而无法被剪裁。而给父元素加上除 static 以外的定位属性（使之成为包含块），只不过是提高了父元素的层级，从而约束绝对定位的表现。使之可以被溢出隐藏</p>\n<h3 id=\"如何避免-overflow-失效\"><a href=\"#如何避免-overflow-失效\" class=\"headerlink\" title=\"如何避免 overflow 失效?\"></a>如何避免 overflow 失效?</h3><ol>\n<li>overflow 元素自身为包含块;</li>\n<li>overflow 元素的子元素为包含块;</li>\n<li>任意合法 transform 声明当作包含块;</li>\n</ol>\n<h4 id=\"overflow-元素自身-transform\"><a href=\"#overflow-元素自身-transform\" class=\"headerlink\" title=\"overflow 元素自身 transform:\"></a>overflow 元素自身 transform:</h4><ul>\n<li>IE9+/Firefox √</li>\n<li>Chrome/Safari(win)/Opera ×</li>\n</ul>\n<h4 id=\"overflow-子元素-transform\"><a href=\"#overflow-子元素-transform\" class=\"headerlink\" title=\"overflow 子元素 transform\"></a>overflow 子元素 transform</h4><ul>\n<li>IE9+/Firefox √</li>\n<li>Chrome/Safari(win)/Opera √</li>\n</ul>\n<p>动态渲染异常: Chrome 包含块重定位 / Opera 同，但点击重绘自修正 / Safari 非定位 overflow 元素左上角</p>\n<h3 id=\"overflow-失效妙用\"><a href=\"#overflow-失效妙用\" class=\"headerlink\" title=\"overflow 失效妙用\"></a>overflow 失效妙用</h3><p>右侧图片会紧挨左侧内容，并实现自适应跟随，<code>&amp;nbsp</code> 可以辅助将图片设置在右方；将 <code>&amp;nbsp</code> 的高度设置为 0 以及 overflow: hidden 可以让 <code>&amp;nbsp</code> 不影响布局，但图片是绝对定位，不会受 overflow: hidden 影响：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_124.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"7-依赖-overflow-的样式表现\"><a href=\"#7-依赖-overflow-的样式表现\" class=\"headerlink\" title=\"7. 依赖 overflow 的样式表现\"></a>7. 依赖 overflow 的样式表现</h2><h3 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize\"></a>resize</h3><p>可以拉伸元素尺寸，但是，此声明要想起作用，元素的 overflow 属性值不能是 visible</p>\n<h3 id=\"text-overflow-ellipsis\"><a href=\"#text-overflow-ellipsis\" class=\"headerlink\" title=\"text-overflow:ellipsis\"></a>text-overflow:ellipsis</h3><p>文本溢出时用 … 代替，经常与 white-space: nowrap 一起使用，但是，<strong>不设置 overflow: hidden 属性，无法实现效果</strong></p>\n<h2 id=\"8-overflow-与锚点技术\"><a href=\"#8-overflow-与锚点技术\" class=\"headerlink\" title=\"8. overflow 与锚点技术\"></a>8. overflow 与锚点技术</h2><h3 id=\"锚点定位\"><a href=\"#锚点定位\" class=\"headerlink\" title=\"锚点定位:\"></a>锚点定位:</h3><p>寻找妹子5: <code>&lt;a href=&quot;#mm5&quot;&gt;</code></p>\n<h3 id=\"锚点定位实现的前提\"><a href=\"#锚点定位实现的前提\" class=\"headerlink\" title=\"锚点定位实现的前提:\"></a>锚点定位实现的前提:</h3><ul>\n<li>容器可滚动;</li>\n<li>锚点元素在容器内;</li>\n</ul>\n<h3 id=\"锚点定位的本质\"><a href=\"#锚点定位的本质\" class=\"headerlink\" title=\"锚点定位的本质\"></a>锚点定位的本质</h3><ol>\n<li>触发锚点定位;</li>\n<li>锚点元素通过 scrollTop 值改变向上偏移定位;</li>\n<li>锚元素的上边缘和可滚动容器上边缘对齐</li>\n</ol>\n<h3 id=\"锚点定位的触发\"><a href=\"#锚点定位的触发\" class=\"headerlink\" title=\"锚点定位的触发\"></a>锚点定位的触发</h3><ul>\n<li>url 地址中的锚链与锚点元素;</li>\n<li>可 focus 的锚点元素处于 focus 态</li>\n</ul>\n<h3 id=\"锚点定位的作用\"><a href=\"#锚点定位的作用\" class=\"headerlink\" title=\"锚点定位的作用\"></a>锚点定位的作用</h3><ul>\n<li>快速定位</li>\n<li>选项卡技术(有严重的不足)</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_68.png\" alt=\"\" width=\"400\"></div>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"CSS深入理解之absolute","slug":"CSS深入理解之absolute","date":"2017-04-21T13:11:24.000Z","updated":"2019-02-04T06:11:30.222Z","comments":true,"path":"api/articles/CSS深入理解之absolute.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_64.png","content":"<h2 id=\"1-超越-overflow\"><a href=\"#1-超越-overflow\" class=\"headerlink\" title=\"1. 超越 overflow\"></a>1. 超越 overflow</h2><p>独立的 absolute 可以摆脱 overflow 的限制，无论是滚动还是隐藏</p>\n<h2 id=\"2-无依赖的-absolute\"><a href=\"#2-无依赖的-absolute\" class=\"headerlink\" title=\"2. 无依赖的 absolute\"></a>2. 无依赖的 absolute</h2><p>不受 relative 限制的 absolute 定位，行为表现上是不使用 top / right / bottom / left 任何一个属性或使用 auto 作为值</p>\n<h2 id=\"3-定位的行为表现\"><a href=\"#3-定位的行为表现\" class=\"headerlink\" title=\"3. 定位的行为表现\"></a>3. 定位的行为表现</h2><ul>\n<li>脱离文档流</li>\n<li>去浮动：absolute 生效的时候，float 是失效的</li>\n<li>位置跟随：原来是什么位置，绝对定位后依然是什么位置(元素是 block，absolute 之后依然是 block，inline 时 absolute 后依然是 inline)</li>\n<li>可以配合 margin 来精确定位</li>\n<li>注释 <code>&lt;!\\-\\- --&gt;</code> 可以消除换行后的空白，同时保持代码可读性</li>\n</ul>\n<h2 id=\"4-居中以及边缘对齐定位\"><a href=\"#4-居中以及边缘对齐定位\" class=\"headerlink\" title=\"4. 居中以及边缘对齐定位\"></a>4. 居中以及边缘对齐定位</h2><h3 id=\"居中\"><a href=\"#居中\" class=\"headerlink\" title=\"居中\"></a>居中</h3><p>采用 <code>text-align:center</code> 使 div 中的空格居中，利用 <code>absolute 的跟随性</code> 配合 <code>margin 负值自身宽度 50%</code> 实现居中。</p>\n<p>html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"course-loading-x\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://img.mukewang.com/5453077400015bba00010001.gif\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"course-loading\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"加载中...\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.course-loading-x</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">20px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center; </span><br><span class=\"line\">  <span class=\"attribute\">letter-spacing</span>: -.<span class=\"number\">25em</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.course-loading</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">26px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_64.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"边缘定位\"><a href=\"#边缘定位\" class=\"headerlink\" title=\"边缘定位\"></a>边缘定位</h3><p>采用 <code>text-align:right</code> 使 div 中的空格居右(fixed 是直接相对于窗口定位，而直接用 absolute 和 right，bottom 是会受到父级 relative 限制的。所以为了避免受到父级影响，使用fixed) </p>\n<p>html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"course-fixed-x\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"course-fixed\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://www.imooc.com/activity/diaocha\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"goto_top_diaocha\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://www.imooc.com/user/feedback\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"goto_top_feed\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.course-fixed-x</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: right; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.course-fixed</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline; </span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed; </span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">20px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">100px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_53.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"5-处理对齐、溢出技巧\"><a href=\"#5-处理对齐、溢出技巧\" class=\"headerlink\" title=\"5. 处理对齐、溢出技巧\"></a>5. 处理对齐、溢出技巧</h2><h3 id=\"处理文字前的星号\"><a href=\"#处理文字前的星号\" class=\"headerlink\" title=\"处理文字前的星号\"></a>处理文字前的星号</h3><p>将星号绝对定位后其不占据任何空间，方便后面的文字左对齐</p>\n<p>html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">class</span>=<span class=\"string\">\"regist-label\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"regist-star\"</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>登录密码</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.regist-star</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">1em</span>; </span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: simsun; </span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#f30</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"图片与文字垂直对齐\"><a href=\"#图片与文字垂直对齐\" class=\"headerlink\" title=\"图片与文字垂直对齐\"></a>图片与文字垂直对齐</h3><p>对图标设置绝对定位，并设置 margin 为负值</p>\n<p>html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"regist-remark regist-warn\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-warn\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span>邮箱格式不准确（演示）</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.regist-warn</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">padding-left</span>: <span class=\"number\">20px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#be3948</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.regist-warn</span> &gt; <span class=\"selector-class\">.icon-warn</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">20px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理文字溢出\"><a href=\"#处理文字溢出\" class=\"headerlink\" title=\"处理文字溢出\"></a>处理文字溢出</h3><p>利用 absolute 绝对定位使 span 不占据任何空间，从而使其不换行（注 <code>&lt;span&gt;</code> 必须紧跟前一个标签，不能有空格）</p>\n<p>html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"regist-remark\"</span>&gt;</span>请输入6-16位密码，区分大小写，不能使用空格<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.regist-remark</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">21px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">9px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#666</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-脱离文档流\"><a href=\"#6-脱离文档流\" class=\"headerlink\" title=\"6. 脱离文档流\"></a>6. 脱离文档流</h2><h3 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h3><p>由于回流与重绘的缘故，动画尽量作用在绝对定位元素上</p>\n<h3 id=\"垂直空间的等级\"><a href=\"#垂直空间的等级\" class=\"headerlink\" title=\"垂直空间的等级\"></a>垂直空间的等级</h3><p>z-index 潜在『误区』:绝对定位元素都需要 z-index 控制等级以确定其显示的位置</p>\n<h4 id=\"absolute-是-z-index-无依赖的：\"><a href=\"#absolute-是-z-index-无依赖的：\" class=\"headerlink\" title=\"absolute 是 z-index 无依赖的：\"></a>absolute 是 z-index 无依赖的：</h4><ol>\n<li>如果只有一个绝对定位元素，则会自动<strong>覆盖普通元素</strong></li>\n<li>如果有两个绝对定位，可以控制 DOM 流的前后顺序达到覆盖效果(<strong>后来居上</strong>)</li>\n<li>如果多个绝对定位交错（非常少见），则用 <strong>z-index：1 控制</strong></li>\n<li>如果非弹框类的绝对定位元素 <strong>z-index &gt; 2，必定 z-index 冗余</strong>，需要优化</li>\n</ol>\n<h2 id=\"7-absolute-的-top-right-bottom-left-和-width-height\"><a href=\"#7-absolute-的-top-right-bottom-left-和-width-height\" class=\"headerlink\" title=\"7. absolute 的 top / right / bottom / left 和 width / height\"></a>7. absolute 的 top / right / bottom / left 和 width / height</h2><h3 id=\"absolute-元素使用-top-right-bottom-left-可以让元素在容器内自由定位\"><a href=\"#absolute-元素使用-top-right-bottom-left-可以让元素在容器内自由定位\" class=\"headerlink\" title=\"absolute 元素使用 top / right / bottom / left 可以让元素在容器内自由定位\"></a>absolute 元素使用 top / right / bottom / left 可以让元素在容器内自由定位</h3><p>但是遇到属性为 <strong>position: relative / absolute / fixed / sticky</strong> 的 <code>&lt;div&gt;</code> 时，则只能到这一层为止，无法突破这一层。</p>\n<h3 id=\"使用-top-right-bottom-left-实现『拉伸』\"><a href=\"#使用-top-right-bottom-left-实现『拉伸』\" class=\"headerlink\" title=\"使用 top / right / bottom / left 实现『拉伸』\"></a>使用 top / right / bottom / left 实现『拉伸』</h3><p>当绝对定位的方向是『对立』的(如 left 和 right)，则不是瞬间位移，而是『拉伸』效果 『position: absolute;left: 0;top: 0;width: 50%』等价于『position: absolute;left: 0;top: 0;right: 50%』</p>\n<h4 id=\"没有宽度和高度声明实现的全屏自适应效果：\"><a href=\"#没有宽度和高度声明实现的全屏自适应效果：\" class=\"headerlink\" title=\"没有宽度和高度声明实现的全屏自适应效果：\"></a>没有宽度和高度声明实现的全屏自适应效果：</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.overlay</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: .<span class=\"number\">5</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"高度自适应的九宫格效果\"><a href=\"#高度自适应的九宫格效果\" class=\"headerlink\" title=\"高度自适应的九宫格效果\"></a>高度自适应的九宫格效果</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.page</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.list</span> &#123;\t</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">33.3%</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33.3%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"left-right-和-width-同时存在\"><a href=\"#left-right-和-width-同时存在\" class=\"headerlink\" title=\"left / right 和 width 同时存在\"></a>left / right 和 width 同时存在</h3><p>相互支持性：</p>\n<ul>\n<li>容器无需固定 width / height 值，内部元素亦可拉伸(可实现图片上一张 / 下一张的遮盖层效果)</li>\n<li>容器拉伸，内部元素支持百分比 width / height 值</li>\n</ul>\n<p><strong>优先级：width / height &gt; left / right</strong></p>\n","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"CSS深入理解之line-height","slug":"CSS深入理解之line-height","date":"2017-04-21T08:56:36.000Z","updated":"2019-02-04T06:11:30.222Z","comments":true,"path":"api/articles/CSS深入理解之line-height.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_89.png","content":"<h2 id=\"1-baseline-与-line-height\"><a href=\"#1-baseline-与-line-height\" class=\"headerlink\" title=\"1. baseline 与 line-height\"></a>1. baseline 与 line-height</h2><p>两条 baseline 之间的距离即为行高(不同的字体所在位置不同，可能偏离基线)</p>\n<div align=\"center\"><img src=\"/images/hexo_post_89.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"2-行内框盒子模型\"><a href=\"#2-行内框盒子模型\" class=\"headerlink\" title=\"2. 行内框盒子模型\"></a>2. 行内框盒子模型</h2><p>一共有 4 种模型：</p>\n<ol>\n<li><strong>内容区域</strong>(content area)，是一种围绕文字看不见的盒子。”内容区域”(content area)的大小与 font-size 的大小相关；</li>\n<li><strong>内联盒子</strong>(inline boxes)，内联盒子不会让内容成块显示，而是排成一行。如果外部含 inline 水平的标签(span，a，em等)，则属于内联盒子。如果是个光秃秃的文字，则属于匿名内联盒子；</li>\n<li><strong>行框盒子</strong>(line boxes)，每一行就是一个行框盒子，每个行框盒子又是由一个一个内联盒子组成；</li>\n<li><code>&lt;p&gt;</code> 标签所在的<strong>包含盒子</strong>(containing box)，此盒子由一行一行的行框盒子组成；</li>\n</ol>\n<h2 id=\"3-line-height-与内联元素的高度机制\"><a href=\"#3-line-height-与内联元素的高度机制\" class=\"headerlink\" title=\"3. line-height 与内联元素的高度机制\"></a>3. line-height 与内联元素的高度机制</h2><ul>\n<li><strong>内联元素的高度是由 line-height 决定的；</strong></li>\n<li>行高由于其继承性，影响无处不在，即使单行文本也不例外；</li>\n<li>行高只是幕后黑手，高度的表现不是行高，而是内容区域和行间距；</li>\n<li><strong>内容区域高度(content area) + 行间距(vertical spacing) = 行高(line-height)；</strong></li>\n<li>内容区域高度只与字号以及字体有关，与 line-height 没有任何关系；在 simsun 字体下，内容区域高度等于文字大小值；</li>\n<li>行间距上下拆分，就有了”半行间距”；</li>\n<li><strong>行高决定内联盒子高度;行间距墙头草，可大可小(甚至负值)，保证高度正好等同于行高；</strong></li>\n<li>含多个行框盒子的包含容器–多行文本的高度就是单行文本高度累加。</li>\n</ul>\n<h2 id=\"4-line-height-各类属性值\"><a href=\"#4-line-height-各类属性值\" class=\"headerlink\" title=\"4. line-height 各类属性值\"></a>4. line-height 各类属性值</h2><h3 id=\"normal\"><a href=\"#normal\" class=\"headerlink\" title=\"normal\"></a>normal</h3><p>默认属性值.跟着用户的浏览器走，且与元素字体关联</p>\n<h3 id=\"lt-number-gt\"><a href=\"#lt-number-gt\" class=\"headerlink\" title=\"&lt;number&gt;\"></a><code>&lt;number&gt;</code></h3><p>使用数值作为行高值，根据当前元素的 font-size 大小计算</p>\n<h3 id=\"lt-length-gt\"><a href=\"#lt-length-gt\" class=\"headerlink\" title=\"&lt;length&gt;\"></a><code>&lt;length&gt;</code></h3><p>使用具体长度值作为行高值，如 1.5em; 1.5rem; 20px; 20pt</p>\n<h3 id=\"lt-percent-gt\"><a href=\"#lt-percent-gt\" class=\"headerlink\" title=\"&lt;percent&gt;\"></a><code>&lt;percent&gt;</code></h3><p>相对于设置了该 line-height 属性的元素的 font-size 大小计算</p>\n<h3 id=\"inherit\"><a href=\"#inherit\" class=\"headerlink\" title=\"inherit\"></a>inherit</h3><p>继承，input 框等元素默认行高是 normal，使用 inherit 可以让文本框样式可控性更强</p>\n<h2 id=\"5-line-height-设置为-1-5-150-1-5em-有何区别\"><a href=\"#5-line-height-设置为-1-5-150-1-5em-有何区别\" class=\"headerlink\" title=\"5. line-height 设置为 1.5 / 150% / 1.5em 有何区别\"></a>5. line-height 设置为 1.5 / 150% / 1.5em 有何区别</h2><p>计算上无差别，但是 <strong>150% / 1.5em 是根据父元素的 font-size 计算的，1.5 是根据自身的 font-size 计算；也就是 150% / 1.5em 是会将行高继承给后代元素的，而 1.5 只会将比例继承给后代元素，后代元素会根据自己的 font-size 重新计算行高</strong></p>\n<div align=\"center\"><img src=\"/images/hexo_post_83.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"6-body-全局数值行高使用经验\"><a href=\"#6-body-全局数值行高使用经验\" class=\"headerlink\" title=\"6. body 全局数值行高使用经验\"></a>6. body 全局数值行高使用经验</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">14px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: ?;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了方便心算，所以我们<strong>将行高设置为 20px</strong>，此时的 line-height 为：line-height = 20px / 14px ≈ 1.4287 -&gt; <strong>line-height: 1.4286</strong></p>\n<h2 id=\"7-line-height-与图片的表现\"><a href=\"#7-line-height-与图片的表现\" class=\"headerlink\" title=\"7. line-height 与图片的表现\"></a>7. line-height 与图片的表现</h2><h3 id=\"行高不会影响图片实际占据的高度\"><a href=\"#行高不会影响图片实际占据的高度\" class=\"headerlink\" title=\"行高不会影响图片实际占据的高度\"></a>行高不会影响图片实际占据的高度</h3><p>图片外面有隐藏的“幽灵”文本节点，所以 text-align: center 会使图片在p标签中居中</p>\n<div align=\"center\"><img src=\"/images/hexo_post_82.png\" alt=\"\" width=\"400\"></div>\n\n<p>内联元素的 vertical-align 默认为 baseline，所以文字的基线与图片的最下方对齐，但由于文字有行高，所以图片下方会有空隙：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_76.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"如何消除图片底部间隙\"><a href=\"#如何消除图片底部间隙\" class=\"headerlink\" title=\"如何消除图片底部间隙\"></a>如何消除图片底部间隙</h3><h4 id=\"图片块状化-无基线对齐\"><a href=\"#图片块状化-无基线对齐\" class=\"headerlink\" title=\"图片块状化-无基线对齐\"></a>图片块状化-无基线对齐</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span>&#123; <span class=\"attribute\">display</span>: block; &#125;</span><br></pre></td></tr></table></figure>\n<p>块状化的元素没有 vertical-align 属性</p>\n<h4 id=\"图片底线对齐\"><a href=\"#图片底线对齐\" class=\"headerlink\" title=\"图片底线对齐\"></a>图片底线对齐</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">img</span>&#123;<span class=\"attribute\">vertical-align</span>: bottom&#125;</span><br></pre></td></tr></table></figure>\n<p>vertical-align 不再是 baseline，文本的最下方与图片的最下方对齐</p>\n<h4 id=\"行高足够小-基线位置上移\"><a href=\"#行高足够小-基线位置上移\" class=\"headerlink\" title=\"行高足够小-基线位置上移\"></a>行高足够小-基线位置上移</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123; <span class=\"attribute\">line-height</span>: <span class=\"number\">0</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>基线位置上移到图片的最下方</p>\n<h3 id=\"小图片和大文字\"><a href=\"#小图片和大文字\" class=\"headerlink\" title=\"小图片和大文字\"></a>小图片和大文字</h3><p>基本上高度受行高控制</p>\n<h2 id=\"8-line-height-的实际应用\"><a href=\"#8-line-height-的实际应用\" class=\"headerlink\" title=\"8. line-height 的实际应用\"></a>8. line-height 的实际应用</h2><h3 id=\"图片水平垂直居中\"><a href=\"#图片水平垂直居中\" class=\"headerlink\" title=\"图片水平垂直居中\"></a>图片水平垂直居中</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span>&gt;<span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多行文本水平垂直居中\"><a href=\"#多行文本水平垂直居中\" class=\"headerlink\" title=\"多行文本水平垂直居中\"></a>多行文本水平垂直居中</h3><p>多行文字水平垂直居中实现的原理跟上一页图片的实现是一样的，区别在于要把多行文本所在的容器的 display 水平转换成和图片一样的，也就是 inline-block，以及重置外部继承的 text-align 和 line-height 属性值</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">250px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span>&gt;<span class=\"selector-class\">.text</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: normal;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]}]}