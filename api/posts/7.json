{"total":119,"pageSize":10,"pageCount":12,"data":[{"title":"今日头条前端散招内推面试经验总结","slug":"今日头条前端散招内推面试经验总结","date":"2017-05-17T07:33:40.000Z","updated":"2019-02-07T13:01:36.415Z","comments":true,"path":"api/articles/今日头条前端散招内推面试经验总结.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"笔试题\"><a href=\"#笔试题\" class=\"headerlink\" title=\"笔试题\"></a>笔试题</h2><p>可能是内推的缘故，在面试之前前台工作人员给了一套前端的笔试题，然后就分配了一个小房间开始做题，虽然没有指明不可以手机搜索，但是为了保证最起码的诚信，我全程都没有看手机，完全凭自己的水平答题，虽然最后面试官把原题拿走了，但是我还是能靠记忆回想起一些题目，总结如下：</p>\n<h3 id=\"1-替换元素和非替换元素有哪些，它们的差异是什么？\"><a href=\"#1-替换元素和非替换元素有哪些，它们的差异是什么？\" class=\"headerlink\" title=\"1. 替换元素和非替换元素有哪些，它们的差异是什么？\"></a>1. 替换元素和非替换元素有哪些，它们的差异是什么？</h3><h4 id=\"替换元素\"><a href=\"#替换元素\" class=\"headerlink\" title=\"替换元素\"></a>替换元素</h4><p>替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。 比如：<code>&lt;input type=&quot;text&quot;/&gt;</code>，这是一个文本输入框，换一个其他 type 的时候，浏览器显示就不一样，HTML 中的 <code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;object&gt;</code> 都是替换元素，这些元素都没有实际的内容。</p>\n<h4 id=\"非替换元素\"><a href=\"#非替换元素\" class=\"headerlink\" title=\"非替换元素\"></a>非替换元素</h4><p>HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。 比如 <code>&lt;p&gt;merrier.wang&lt;/p&gt;</code>、<code>&lt;label&gt;Merrier&lt;/label&gt;</code> 浏览器将把这段内容直接显示出来。</p>\n<h3 id=\"2-offsetWidth、clientWidth、scrollWidth-如何计算？\"><a href=\"#2-offsetWidth、clientWidth、scrollWidth-如何计算？\" class=\"headerlink\" title=\"2. offsetWidth、clientWidth、scrollWidth 如何计算？\"></a>2. offsetWidth、clientWidth、scrollWidth 如何计算？</h3><h4 id=\"offsetWidth\"><a href=\"#offsetWidth\" class=\"headerlink\" title=\"offsetWidth\"></a>offsetWidth</h4><ul>\n<li>无 <code>padding</code> 无滚动无 <code>border</code><ul>\n<li>offsetWidth = clientWidth = 盒子的宽度</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 无滚动有 <code>border</code><ul>\n<li>offsetWidth = 盒子的宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 边框宽度*2</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 有滚动，且滚动是显示的，有 <code>border</code><ul>\n<li>offsetWidth = 盒子宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"clientWidth\"><a href=\"#clientWidth\" class=\"headerlink\" title=\"clientWidth\"></a>clientWidth</h4><ul>\n<li>无 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code></li>\n<li>有 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code> + 盒子的 <code>padding * 2</code></li>\n<li>有 <code>padding</code> 有滚动 ：<code>clientWidth</code> = 盒子和 <code>width</code> + 盒子的 <code>padding * 2</code> - 滚动轴宽度</li>\n</ul>\n<h4 id=\"scrollWidth\"><a href=\"#scrollWidth\" class=\"headerlink\" title=\"scrollWidth\"></a>scrollWidth</h4><p>无滚动轴时：</p>\n<ul>\n<li>scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2</li>\n</ul>\n<p>有滚动轴时：</p>\n<ul>\n<li>scrollWidth = 实际内容的宽度 + padding * 2</li>\n<li>scrollHeight = 实际内容的高度 + padding * 2</li>\n</ul>\n<p>更多关于 JS 中的宽高可以狠狠的点击这里：<a href=\"/20170501/js-width-and-height.html\">JS 宽高的理解和应用</a></p>\n<h3 id=\"3-JS-中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\"><a href=\"#3-JS-中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\" class=\"headerlink\" title=\"3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\"></a>3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例</h3><p>DOM2 标准事件模型：每一个 DOM 元素所触发的事件都要经历三个阶段：</p>\n<ol>\n<li>捕获阶段</li>\n<li>目标对象本身的事件处理程序调用阶段</li>\n<li>冒泡阶段</li>\n</ol>\n<p>在 IE8 以上的版本以及其他的浏览器中通过 e.stopPropagation() 方式阻止事件的冒泡；在 IE8  以下的浏览器中通过 e.cancleBubble = true 阻止事件冒泡；jQ 中的 mouseenter 和 mouseleave 也是默认不冒泡</p>\n<h3 id=\"4-CSS-选择器的优先级是什么？\"><a href=\"#4-CSS-选择器的优先级是什么？\" class=\"headerlink\" title=\"4. CSS 选择器的优先级是什么？\"></a>4. CSS 选择器的优先级是什么？</h3><p>!important &gt; 内联 &gt; id &gt; class &gt; 标签(p、a、div) &gt; 通配符(*) &gt; 浏览器自定义</p>\n<p>更多关于 CSS 选择器的的内容：<a href=\"/20170403/css-selector.html\">前端面试系列（4）——CSS选择器</a></p>\n<h3 id=\"5-IFC-是什么？它的作用是什么？\"><a href=\"#5-IFC-是什么？它的作用是什么？\" class=\"headerlink\" title=\"5. IFC 是什么？它的作用是什么？\"></a>5. IFC 是什么？它的作用是什么？</h3><h4 id=\"What’s-FC？\"><a href=\"#What’s-FC？\" class=\"headerlink\" title=\"What’s FC？\"></a>What’s FC？</h4><p>FC 的全称是：Formatting Contexts，是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<h4 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a>IFC</h4><p>IFC(Inline Formatting Contexts) 直译为”内联格式化上下文”，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding / margin 影响)，IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。IFC 中是不可能有块级元素的，当插入块级元素时（如 p 中插入 div），会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。</p>\n<p><strong>那么IFC一般有什么用呢？</strong></p>\n<ul>\n<li>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</li>\n<li>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>\n</ul>\n<h4 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h4><p>BFC(Block Formatting Contexts) 直译为”块级格式化上下文”。Block Formatting Contexts 就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。 </p>\n<p><strong>如何产生 BFC？</strong></p>\n<ol>\n<li>float 的值不为 none。</li>\n<li>overflow 的值不为 visible。</li>\n<li>position 的值不为 relative 和 static。</li>\n<li>display 的值为 table-cell, table-caption, inline-block 中的任何一个。</li>\n</ol>\n<p><strong>那BFC 一般有什么用呢？</strong> </p>\n<p>比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 CSS2.1 中只有 BFC 和 IFC，CSS3 中才有 GFC 和 FFC，更多关于这些 FC 的内容可以查看：<a href=\"http://www.jshacker.com/note/3608\" target=\"_blank\" rel=\"noopener\">小科普：到底什么是BFC、IFC、GFC和FFC，次奥？</a></p>\n<h3 id=\"6-如何实现一个自适应正方形\"><a href=\"#6-如何实现一个自适应正方形\" class=\"headerlink\" title=\"6. 如何实现一个自适应正方形\"></a>6. 如何实现一个自适应正方形</h3><p>这个问题在我前不久的一篇文章里有总结过，可以<a href=\"/20170516/realization-of-adaptive-square-in-pure-css.html\">点击这里</a>查看</p>\n<h3 id=\"7-http-mp-toutiao-com-向-http-toutiao-com-发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\"><a href=\"#7-http-mp-toutiao-com-向-http-toutiao-com-发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\" class=\"headerlink\" title=\"7. http://mp.toutiao.com 向 http://toutiao.com 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\"></a>7. <a href=\"http://mp.toutiao.com\" target=\"_blank\" rel=\"noopener\">http://mp.toutiao.com</a> 向 <a href=\"http://toutiao.com\" target=\"_blank\" rel=\"noopener\">http://toutiao.com</a> 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？</h3><p>判断跨域的指标：域名、协议、端口，只要有其中一项不一致就会发生跨域</p>\n<h3 id=\"8-请介绍一下-XSS-和-CSRF-的区别，如何防御？\"><a href=\"#8-请介绍一下-XSS-和-CSRF-的区别，如何防御？\" class=\"headerlink\" title=\"8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？\"></a>8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？</h3><h4 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h4><p>XSS 全称“跨站脚本”（Cross-site scripting），是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>\n<h4 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h4><p>CSRF 的全称是“跨站请求伪造”（Cross-site request forgery），而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。 严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。</p>\n<h4 id=\"防御-XSS-攻击可以通过以下两方面操作：\"><a href=\"#防御-XSS-攻击可以通过以下两方面操作：\" class=\"headerlink\" title=\"防御 XSS 攻击可以通过以下两方面操作：\"></a>防御 XSS 攻击可以通过以下两方面操作：</h4><ol>\n<li>对用户表单输入的数据进行过滤，对 javascript 代码进行转义，然后再存入数据库；</li>\n<li>在信息的展示页面，也要进行转义，防止 javascript 在页面上执行。</li>\n</ol>\n<h4 id=\"CSRF-攻击的防御可以通过以下两方面操作：\"><a href=\"#CSRF-攻击的防御可以通过以下两方面操作：\" class=\"headerlink\" title=\"CSRF 攻击的防御可以通过以下两方面操作：\"></a>CSRF 攻击的防御可以通过以下两方面操作：</h4><ol>\n<li>所有需要用户登录之后才能执行的操作属于重要操作，这些操作传递参数应该使用 post 方式，更加安全；</li>\n<li>为防止跨站请求伪造，我们在某次请求的时候都要带上一个 csrf_token 参数，用于标识请求来源是否合法，csrf_token 参数由系统生成，存储在 SESSION 中。</li>\n</ol>\n<h4 id=\"更多关于-XSS-和-CSRF-的解释：\"><a href=\"#更多关于-XSS-和-CSRF-的解释：\" class=\"headerlink\" title=\"更多关于 XSS 和 CSRF 的解释：\"></a>更多关于 XSS 和 CSRF 的解释：</h4><ul>\n<li><a href=\"http://blog.csdn.net/koastal/article/details/52905358\" target=\"_blank\" rel=\"noopener\">浅析XSS和CSRF攻击及防御</a></li>\n<li><a href=\"https://www.zhihu.com/question/34445731?sort=created\" target=\"_blank\" rel=\"noopener\">如何用简洁生动的语言理清XSS和CSRF的区别？</a></li>\n</ul>\n<h3 id=\"9-JSBridge-是什么，它的作用是什么？\"><a href=\"#9-JSBridge-是什么，它的作用是什么？\" class=\"headerlink\" title=\"9. JSBridge 是什么，它的作用是什么？\"></a>9. JSBridge 是什么，它的作用是什么？</h3><p>在开发中我们经常需要 web 和 native 进行交互，也就是要用到经常听到的 “JSBridge”。由于我对这个东西也是停留在概念层面，所以推荐其他人的一篇文章吧：<a href=\"http://blog.csdn.net/jjx0224/article/details/52788922\" target=\"_blank\" rel=\"noopener\">理解JSBridge</a></p>\n<h3 id=\"10-TCP-和-UDP-的区别，以及如何进行拥塞控制？\"><a href=\"#10-TCP-和-UDP-的区别，以及如何进行拥塞控制？\" class=\"headerlink\" title=\"10. TCP 和 UDP 的区别，以及如何进行拥塞控制？\"></a>10. TCP 和 UDP 的区别，以及如何进行拥塞控制？</h3><ol>\n<li>TCP 面向连接（如打电话要先拨号建立连接）；UDP 是无连接的，即发送数据之前不需要建立连接</li>\n<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li>\n<li>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>\n<li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li>\n<li>TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节</li>\n<li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li>\n</ol>\n<p>更多关于 TCP 和 UDP 的区别：<a href=\"http://blog.csdn.net/li_ning_/article/details/52117463\" target=\"_blank\" rel=\"noopener\">TCP和UDP的最完整的区别</a></p>\n<h4 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h4><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br><strong>几种拥塞控制方法</strong>：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 更多关于拥塞控制：<a href=\"http://blog.csdn.net/kinger0/article/details/48206999\" target=\"_blank\" rel=\"noopener\">TCP/IP详解–拥塞控制 &amp; 慢启动 快恢复 拥塞避免</a></p>\n<h3 id=\"11-有一无序数组，数组个数为-m，如何从这-m-个数里面找到-N-个数，使这-N-个数的和为-M；并阐述时间复杂度和空间复杂度\"><a href=\"#11-有一无序数组，数组个数为-m，如何从这-m-个数里面找到-N-个数，使这-N-个数的和为-M；并阐述时间复杂度和空间复杂度\" class=\"headerlink\" title=\"11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度\"></a>11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度</h3><p>这个属于比较经典的 <a href=\"http://baike.baidu.com/item/01%E8%83%8C%E5%8C%85\" target=\"_blank\" rel=\"noopener\">01背包问题</a>，网上有很多关于这种问题的求解方式，基本上包括递归、动态规划、无脑循环等方法，推荐以下比较靠谱的解法：<a href=\"http://www.cnblogs.com/iyangyuan/p/3908498.html\" target=\"_blank\" rel=\"noopener\">动态规划（JS）</a>、<a href=\"http://blog.csdn.net/min_jie/article/details/3966867\" target=\"_blank\" rel=\"noopener\">无脑循环</a></p>\n<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><p>一面的时间很长，大概有将近一个小时的感觉，所以问的问题涉及的领域和方面也比较多，所以我就想到什么写下什么了，另外也不赋答案了，实在有点多。。</p>\n<ol>\n<li>__proto__ 是什么意思</li>\n<li>JS 实现继承的方式</li>\n<li>object.defineproprety() 方法的参数和含义</li>\n<li>setTimeout(func,0) 中设置延时为 “0” 的目的</li>\n<li>jQuery 中对 Promise() 的 when() 方法的实现原理</li>\n<li>HTTP 和 TCP 的关系</li>\n<li>TCP 三次握手</li>\n<li>HTTP 如何达到在下一次连接时不用再 TCP 三次握手的</li>\n<li>如何实现一个自适应正方形</li>\n<li>浏览器渲染的过程</li>\n<li>重排和重绘的触发时机和区别</li>\n<li>层叠上下文起作用的前提</li>\n<li>前端路由和后端路由的区别</li>\n<li>首屏加载完毕之后 <code>&lt;script&gt;&lt;/script&gt;</code> 代码的加载顺序</li>\n<li>vue.js 的设计思想</li>\n<li>如果用 jQuery 实现双向数据绑定，应该如何实现</li>\n<li>当 content-length 过长时，应该如何传输数据</li>\n<li>JS 文件中的代码执行顺序</li>\n<li>详细讲解一下 JS 中宏任务和微任务的判断机制</li>\n<li>如果有别的库中也用到了 “$”，如何解决和 jQuery 的冲突</li>\n</ol>\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><p>二面相对于一面来说，就简单随意了很多，问了一些项目的事情，还问了技术选型方面的问题，最后出了一道算法题让我做，我思考了大概 15 分钟，感觉真心写不出代码，就和面试官简单的讲了一下思路，面试官思考了一段时间之后就告诉我二面结束了，可以 hr 面了；至此，技术面就全部结束了。</p>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"纯CSS实现自适应正方形","slug":"纯CSS实现自适应正方形","date":"2017-05-16T09:00:27.000Z","updated":"2019-02-07T13:01:36.423Z","comments":true,"path":"api/articles/纯CSS实现自适应正方形.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_231.png","content":"<p>首先，自适应正方形是指宽度和高度随着屏幕宽度（不管是移动端还是 PC 端）进行等比例变化的正方形，在处理移动端页面时，我们有时会需要将 banner 图做成与屏幕等宽的正方形以获得最佳的体验效果，如 <a href=\"http://flipboard.com/@news/\" target=\"_blank\" rel=\"noopener\">Flipbord的移动页面</a>，而在 PC 端，我们也可能需要实现一个随屏幕宽度变化的正方形，从而达到某些效果；那么应该怎么使用纯 CSS 制作出能够自适应大小的正方形呢？</p>\n<h2 id=\"方案一：CSS3-vw-单位\"><a href=\"#方案一：CSS3-vw-单位\" class=\"headerlink\" title=\"方案一：CSS3 vw 单位\"></a>方案一：CSS3 vw 单位</h2><p>CSS3 中新增了一组相对于可视区域百分比的长度单位 vw, vh, vmin, vmax。其中vw是相对于视口宽度百分比的单位，1vw = 1% viewport width，vh是相对于视口高度百分比的单位，1vh = 1% viewport height；vmin 是相对当前视口宽高中较小的一个的百分比单位，同理 vmax 是相对当前视口宽高中较大的一个的百分比单位。<a href=\"http://caniuse.com/#search=vw\" target=\"_blank\" rel=\"noopener\">该单位浏览器兼容性</a>如下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_231.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"placeholder\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.placeholder</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50vw</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50vw</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优点：简洁方便 缺点：浏览器兼容不好</p>\n<h3 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a><a href=\"https://idiotwu.me/study/responsive-square/#viewwidth\" target=\"_blank\" rel=\"noopener\">实现效果</a></h3><h2 id=\"方法二：设置垂直方向的-padding-撑开容器\"><a href=\"#方法二：设置垂直方向的-padding-撑开容器\" class=\"headerlink\" title=\"方法二：设置垂直方向的 padding 撑开容器\"></a>方法二：设置垂直方向的 padding 撑开容器</h2><p>在 CSS 盒模型中，一个比较容易被忽略的就是 margin, padding 的百分比数值计算。按照规定，<strong>margin, padding 的百分比数值是相对父元素宽度的宽度计算的</strong>。由此可以发现只需将元素垂直方向的一个 padding 值设定为与 width 相同的百分比就可以制作出自适应正方形了：</p>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.placeholder</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: bottom:<span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果正方形中没有内容（相当于只是一个几何里面的正方形，并没有展示其他任何内容），一切看起来都很正常；但是，如果正方形中有其他内容（这种情况会更常见一些，比如说有一些文本和图片），此时容器的高度就会被拉伸，因为<a href=\"/20170403/css-box-model.html\">盒子模型</a>中的 padding 是不包含在 content 中的，所以我们可以通过 height:0 解决这个问题；这种方案简洁明了，且兼容性好；但是除了填充内容后会出现问题以外，还有可能碰上<a href=\"https://idiotwu.me/study/responsive-square/#maxheight\" target=\"_blank\" rel=\"noopener\">max-height不收缩</a>，于是第三种方案来了：</p>\n<h2 id=\"方案三：利用伪元素的-margin-padding-top-撑开容器\"><a href=\"#方案三：利用伪元素的-margin-padding-top-撑开容器\" class=\"headerlink\" title=\"方案三：利用伪元素的 margin(padding)-top 撑开容器\"></a>方案三：利用伪元素的 margin(padding)-top 撑开容器</h2><p>在方案二中，我们利用百分比数值的 padding-bottom 属性撑开容器内部空间，但是这样做会导致在元素上设置的 max-height 属性失效；而失效的原因是 <a href=\"http://stackoverflow.com/questions/21750091/max-height-on-border-boxed-div-with-padding-is-not-set\" target=\"_blank\" rel=\"noopener\">max-height 属性只限制于 height</a>，也就是只会对元素的 content height 起作用。那么我们是不是能用一个子元素撑开 content 部分的高度，从而使 max-height 属性生效呢？我们来试试：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.placeholder</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.placeholder</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">100%</span>; <span class=\"comment\">/* margin 百分比相对父元素宽度计算 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一刷新页面，啊嘞？怎么什么也没有？ 这里就涉及到 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/margin_collapsing\" target=\"_blank\" rel=\"noopener\">margin collapse</a> 的概念了，由于容器与伪元素在垂直方向发生了外边距折叠，所以我们想象中的撑开父元素高度并没有出现。而应对的方法是在父元素上触发 BFC：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.placeholder</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现效果-1\"><a href=\"#实现效果-1\" class=\"headerlink\" title=\"实现效果\"></a><a href=\"https://idiotwu.me/study/responsive-square/#margin\" target=\"_blank\" rel=\"noopener\">实现效果</a></h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就是三种制作自适应正方形的方案，除去 CSS3 中的视口相对单位，主要利用到 margin, padding 的百分比数值相对父元素宽度的宽度计算得出来制作宽高相等、且相对视口宽度自适应的正方形。如果需求是制作相对视口高度自适应的正方形，估计就只能使用 vh 单位了吧~</p>\n","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"Sublime Text插件推荐","slug":"Sublime Text插件推荐","date":"2017-05-14T12:44:19.000Z","updated":"2019-02-07T13:01:36.415Z","comments":true,"path":"api/articles/Sublime Text插件推荐.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_7.gif","content":"<h2 id=\"安装sublime-text2-插件的方法\"><a href=\"#安装sublime-text2-插件的方法\" class=\"headerlink\" title=\"安装sublime text2 插件的方法\"></a>安装sublime text2 插件的方法</h2><h3 id=\"直接安装\"><a href=\"#直接安装\" class=\"headerlink\" title=\"直接安装\"></a>直接安装</h3><p>安装 Sublime text 2 插件很方便，可以直接下载安装包解压缩到 Packages 目录（菜单 -&gt; preferences -&gt; packages）。</p>\n<h3 id=\"使用-Package-Control-组件安装\"><a href=\"#使用-Package-Control-组件安装\" class=\"headerlink\" title=\"使用 Package Control 组件安装\"></a>使用 Package Control 组件安装</h3><p>也可以安装 package control 组件，然后直接在线安装：</p>\n<ol>\n<li>按 Ctrl+` 调出 console（注：安装有 QQ 输入法的话这个快捷键会有冲突，输入法属性设置-输入法管理-取消热键切换至 QQ 拼音）</li>\n<li>粘贴以下代码到底部命令行并回车：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib2,os;pf=<span class=\"string\">'Package Control.sublime-package'</span>;ipp=sublime.installed\\_packages\\_path();os.makedirs(ipp) <span class=\"keyword\">if</span> not os.path.exists(ipp) <span class=\"keyword\">else</span> None;open(os.path.join(ipp,pf),<span class=\"string\">'wb'</span>).write(urllib2.urlopen(<span class=\"string\">'http://sublime.wbond.net/'</span>+pf.replace(<span class=\"string\">' '</span>,<span class=\"string\">'%20'</span>)).<span class=\"built_in\">read</span>())</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>重启 Sublime Text 2。</li>\n<li>如果在 Perferences -&gt; package settings 中看到 package control 这一项，则安装成功。</li>\n</ol>\n<h2 id=\"用-Package-Control-安装插件的方法\"><a href=\"#用-Package-Control-安装插件的方法\" class=\"headerlink\" title=\"用 Package Control 安装插件的方法\"></a>用 Package Control 安装插件的方法</h2><ol>\n<li>按下 Ctrl + Shift + P 调出命令面板</li>\n<li>输入 install，调出 Install Package 选项并回车，然后在列表中选中要安装的插件。</li>\n</ol>\n<p>不爽的是，有的网络环境可能会不允许访问陌生的网络环境从而设置一道防火墙，而 Sublime Text 2 貌似无法设置代理，可能就获取不到安装包列表了。好，方法介绍完了，下面是本文正题，推荐一些 Sublime Text 2 插件：</p>\n<h2 id=\"插件推荐\"><a href=\"#插件推荐\" class=\"headerlink\" title=\"插件推荐\"></a>插件推荐</h2><h3 id=\"Emmet\"><a href=\"#Emmet\" class=\"headerlink\" title=\"Emmet\"></a>Emmet</h3><p>HTML / CSS 代码快速编写神器，Emmet 的前身是大名鼎鼎的 Zen coding，如果你从事 Web 前端开发的话，对该插件一定不会陌生。它使用仿 CSS 选择器的语法来生成代码，大大提高了 HTML / CSS代码编写的速度，比如下面的演示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_7.gif\" alt=\"\" width=\"400\"></div>\n\n<p>关于这一插件的牛逼之处就不再多言，这里有一篇讲解 Emmet 的文章讲的很详细：<a href=\"http://www.iteye.com/news/27580\" target=\"_blank\" rel=\"noopener\">Emmet：HTML/CSS代码快速编写神器</a></p>\n<h3 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h3><p>git 应该是必备的插件之一，而 sublime 对于 git 的支持也是很好的，关于如何在 sublime 中使用 git，可以查看下面这篇文章：<a href=\"http://www.jianshu.com/p/c3fabbeebbeb\" target=\"_blank\" rel=\"noopener\">sublime中git的使用</a>，我就不再过多描述了</p>\n<h3 id=\"Vue-Syntax-Highlight\"><a href=\"#Vue-Syntax-Highlight\" class=\"headerlink\" title=\"Vue Syntax Highlight\"></a>Vue Syntax Highlight</h3><p>这是一款可以让你的 .vue 文件也可以高亮的插件，鉴于最近在自学 vue，所以还是推荐一下这款插件吧，在 Package 里面搜索 vue 即可</p>\n","raw":null,"categories":[{"name":"tool","path":"api/categories/tool.json"}],"tags":[{"name":"推荐","path":"api/tags/推荐.json"},{"name":"sublime","path":"api/tags/sublime.json"}]},{"title":"与MySQL的零距离接触","slug":"与MySQL的零距离接触","date":"2017-05-09T02:02:40.000Z","updated":"2019-02-07T13:01:36.415Z","comments":true,"path":"api/articles/与MySQL的零距离接触.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_207.png","content":"<h2 id=\"MySQL-基础\"><a href=\"#MySQL-基础\" class=\"headerlink\" title=\"MySQL 基础\"></a>MySQL 基础</h2><p>由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司，MySQL 是一个开源的<strong>关系型</strong>数据库管理系统，分为社区版和企业版</p>\n<h2 id=\"MySQL-一些常用参数\"><a href=\"#MySQL-一些常用参数\" class=\"headerlink\" title=\"MySQL 一些常用参数\"></a>MySQL 一些常用参数</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-D，–database=name</td>\n<td>打开指定数据库</td>\n</tr>\n<tr>\n<td>–delimiter=name</td>\n<td>指定分隔符</td>\n</tr>\n<tr>\n<td>-h，–host=name</td>\n<td>服务器名称</td>\n</tr>\n<tr>\n<td>-p，–password[=name]</td>\n<td>密码</td>\n</tr>\n<tr>\n<td>-P，–port=#</td>\n<td>端口号</td>\n</tr>\n<tr>\n<td>–prompt=name</td>\n<td>设置提示符</td>\n</tr>\n<tr>\n<td>-u，–user=name</td>\n<td>用户名</td>\n</tr>\n<tr>\n<td>-V，–version</td>\n<td>输出版本信息并且退出</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"MySQL退出\"><a href=\"#MySQL退出\" class=\"headerlink\" title=\"MySQL退出\"></a>MySQL退出</h3><ul>\n<li>mysql &gt; exit;</li>\n<li>mysql &gt; quit;</li>\n<li>mysql &gt; \\q;</li>\n</ul>\n<h3 id=\"修改-MySQL-提示符\"><a href=\"#修改-MySQL-提示符\" class=\"headerlink\" title=\"修改 MySQL 提示符\"></a>修改 MySQL 提示符</h3><p>连接客户端时通过参数指定提示符：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell&gt;mysql -uroot -proot --prompt</span><br></pre></td></tr></table></figure>\n<p>连接上客户端后，通过 prompt 命令修改提示符：mysql&gt;prompt，MySQL 提示符修改时可以用到的一些参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\D</td>\n<td>完整的日期</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>当前数据库</td>\n</tr>\n<tr>\n<td>\\h</td>\n<td>服务器名称</td>\n</tr>\n<tr>\n<td>\\u</td>\n<td>当前用户</td>\n</tr>\n</tbody>\n</table>\n<div align=\"center\"><img src=\"/images/hexo_post_207.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"修改数据表的默认存储引擎\"><a href=\"#修改数据表的默认存储引擎\" class=\"headerlink\" title=\"修改数据表的默认存储引擎\"></a>修改数据表的默认存储引擎</h3><p>找到 MySQL 配置文件：default-storage-engine=INNODB，修改完之后需要重启 MySQL</p>\n<h2 id=\"MySQL-语句的规范\"><a href=\"#MySQL-语句的规范\" class=\"headerlink\" title=\"MySQL 语句的规范\"></a>MySQL 语句的规范</h2><ul>\n<li>关键字与函数名称全部大写</li>\n<li>数据库名称、表名称、字段名称全部小写</li>\n<li>SQL 语句必须以分号结尾</li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ol>\n<li>字符型</li>\n<li>整型</li>\n<li>浮点型</li>\n<li>日期时间型</li>\n</ol>\n<h2 id=\"MySQL-常用命令\"><a href=\"#MySQL-常用命令\" class=\"headerlink\" title=\"MySQL 常用命令\"></a>MySQL 常用命令</h2><ul>\n<li>显示当前服务器版本：SELECT VERSION();</li>\n<li>显示当前日期时间：SELECT NOW();</li>\n<li>显示当前用户：SELECT USER();</li>\n</ul>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><ul>\n<li>|：表示可以互换的两项</li>\n<li>[]：表示可选项</li>\n<li>{}：表示必选项</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE &#123;DATABASE | SCHEMA&#125; \\[IF NOT EXISTS\\] db\\_name \\[DEFAULT\\] CHARACTER SET \\[=\\] charset\\_name</span><br></pre></td></tr></table></figure>\n<p>DATABASE | SCHEMA：这两个完全相同，任选其一即可<br>IF NOT EXISTS：可选项，如果存在就不创建，不存在才会创建<br>CHARACTER：设置编码格式，例如 utf-8，gbk</p>\n<h3 id=\"查看当前服务器下的数据表列表\"><a href=\"#查看当前服务器下的数据表列表\" class=\"headerlink\" title=\"查看当前服务器下的数据表列表\"></a>查看当前服务器下的数据表列表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHOW &#123;DATABASES | SCHEMAS&#125; \\[LIKE <span class=\"string\">'pattern'</span> | WHERE expr\\]</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改数据库\"><a href=\"#修改数据库\" class=\"headerlink\" title=\"修改数据库\"></a>修改数据库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER &#123;DATABASE | SCHEMA&#125; \\[db\\_name\\] \\[DEFAULT\\] CHARACTER SET \\[=\\] charset\\_name</span><br></pre></td></tr></table></figure>\n<p>通过以上语句可以修改某个数据库的编码格式</p>\n<h3 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP &#123;DATABASE | SCHEMA&#125; \\[IF EXISTS\\] db_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"打开数据库\"><a href=\"#打开数据库\" class=\"headerlink\" title=\"打开数据库\"></a>打开数据库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">USE db_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建数据表\"><a href=\"#创建数据表\" class=\"headerlink\" title=\"创建数据表\"></a>创建数据表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE \\[IF NOT EXISTS\\] table\\_name( column\\_name data_type, .... )</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看数据表列表\"><a href=\"#查看数据表列表\" class=\"headerlink\" title=\"查看数据表列表\"></a>查看数据表列表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHOW TABLES \\[FROM db_name\\] \\[LIKE <span class=\"string\">'pattern'</span> | WHERE expr\\]</span><br></pre></td></tr></table></figure>\n<p>FROM db_name：不仅可以查看当前数据库中的数据表，还可以查看其他数据库中的数据表</p>\n<h3 id=\"查看数据表结构\"><a href=\"#查看数据表结构\" class=\"headerlink\" title=\"查看数据表结构\"></a>查看数据表结构</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHOW COLUMNS FROM tbl_name</span><br></pre></td></tr></table></figure>\n<p>tbl_name：数据表的名称</p>\n<h3 id=\"插入记录\"><a href=\"#插入记录\" class=\"headerlink\" title=\"插入记录\"></a>插入记录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT \\[INFO\\] tbl\\_name \\[(col\\_name,...)\\] VALUES(val,...)</span><br></pre></td></tr></table></figure>\n<p>如果省略 col_name (列名称)，就必须为所有字段都赋值</p>\n<h3 id=\"记录查找\"><a href=\"#记录查找\" class=\"headerlink\" title=\"记录查找\"></a>记录查找</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT expr,... FROM tbl_name</span><br></pre></td></tr></table></figure>\n<p>expr：表达式</p>\n<h2 id=\"字段属性设置\"><a href=\"#字段属性设置\" class=\"headerlink\" title=\"字段属性设置\"></a>字段属性设置</h2><h3 id=\"空值与非空\"><a href=\"#空值与非空\" class=\"headerlink\" title=\"空值与非空\"></a>空值与非空</h3><ul>\n<li>NULL：字段值可以为空（默认值）</li>\n<li>NOT NULL：字段值禁止为空</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE tbl_name(username VARCHAR(20) NOT NULL,age TINYINT UNSIGNED NULL);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_208.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"表级约束与列级约束\"><a href=\"#表级约束与列级约束\" class=\"headerlink\" title=\"表级约束与列级约束\"></a>表级约束与列级约束</h2><p>对一个数据列建立的约束，称为列级约束 对多个数据列建立的约束，称为表级约束 列级约束既可以在列定义时声明，也可以在列定义后声明 表级约束只能在列定义后声明</p>\n<h3 id=\"主键约束\"><a href=\"#主键约束\" class=\"headerlink\" title=\"主键约束\"></a>主键约束</h3><p>PRIMARY KEY：每张数据表只能存在一个主键，主键保证记录的唯一性，主键自动为 NOT NULL，主键不一定和下面的自动编号一起使用，但是不能赋相同的值</p>\n<h3 id=\"自动编号\"><a href=\"#自动编号\" class=\"headerlink\" title=\"自动编号\"></a>自动编号</h3><p>AUTO_INCREMENT：必须与主键组合使用，默认情况下，起始值为 1，每次的增量为 1，该字段的数据类型必须为数字，如果是浮点数必须小数位数为 0</p>\n<h3 id=\"唯一约束\"><a href=\"#唯一约束\" class=\"headerlink\" title=\"唯一约束\"></a>唯一约束</h3><p>UNIQUE KEY：可以保证记录的唯一性，字段可以为空值（NULL），每张数据表可以存在多个唯一约束</p>\n<h3 id=\"默认约束\"><a href=\"#默认约束\" class=\"headerlink\" title=\"默认约束\"></a>默认约束</h3><p>DEFAULT：当插入记录时，如果没有明确为字段赋值，则自动赋予默认值</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sex enum(<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>) DEFAULT <span class=\"string\">'3'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"外键约束\"><a href=\"#外键约束\" class=\"headerlink\" title=\"外键约束\"></a>外键约束</h3><p>FOREIGN KEY：保持数据一致性和完整性，实现一对一或一对多关系</p>\n<h4 id=\"外键约束的要求\"><a href=\"#外键约束的要求\" class=\"headerlink\" title=\"外键约束的要求\"></a>外键约束的要求</h4><ol>\n<li>父表和子表必须使用相同的存储引擎，而且禁止使用临时表</li>\n<li>数据表的存储引擎只能为 InnoDB</li>\n<li>外键列和参照列必须具有相似的数据类型，其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同</li>\n<li>外键列和参照列必须创建索引，如果外键列不存在索引的话，MySQL 将自动创建索引</li>\n</ol>\n<h4 id=\"外键约束的参照操作\"><a href=\"#外键约束的参照操作\" class=\"headerlink\" title=\"外键约束的参照操作\"></a>外键约束的参照操作</h4><ol>\n<li>CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行</li>\n<li>SET NULL：从父表删除或更新行，并设置子表中的外键列为 NULL。如果使用该选项，必须保证子表列没有指定NOT NULL</li>\n<li>RESTRICT：拒绝对父表的删除或更新操作</li>\n<li>NO ACTION：标准 SQL 的关键字，在 MySQL 中与 RESTRICT 相同</li>\n</ol>\n<p>pid INT,FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE =&gt; pid 为外键约束，参照数据表 provinces 中的 id 字段；并且删除时的参照操作为 CASCADE</p>\n<h2 id=\"修改数据表\"><a href=\"#修改数据表\" class=\"headerlink\" title=\"修改数据表\"></a>修改数据表</h2><h3 id=\"添加单列\"><a href=\"#添加单列\" class=\"headerlink\" title=\"添加单列\"></a>添加单列</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name ADD \\[COLUMN\\] col\\_name column\\_definition \\[FIRST | AFTER col\\_name\\]</span><br></pre></td></tr></table></figure>\n<p>FIRST：新添加的列将置于最前面<br>AFTER col_name：新添加的列将置于某一列后面<br>如果省略以上两项，新添加的列将位于所有列最后面</p>\n<h3 id=\"添加多列\"><a href=\"#添加多列\" class=\"headerlink\" title=\"添加多列\"></a>添加多列</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name ADD \\[COLUMN\\] (col\\_name column_definition,...)</span><br></pre></td></tr></table></figure>\n<p>添加多列时无法指定位置，只能位于最后面</p>\n<h3 id=\"删除列\"><a href=\"#删除列\" class=\"headerlink\" title=\"删除列\"></a>删除列</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name DROP \\[COLUMN\\] col\\_name</span><br></pre></td></tr></table></figure>\n<p>ALTER TABLE tbl_name DROP age,DROP password =&gt; 可以同时删除 age 列和 password 列</p>\n<h3 id=\"添加约束\"><a href=\"#添加约束\" class=\"headerlink\" title=\"添加约束\"></a>添加约束</h3><h4 id=\"添加主键约束\"><a href=\"#添加主键约束\" class=\"headerlink\" title=\"添加主键约束\"></a>添加主键约束</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name ADD \\[CONSTRAINT \\[symbol\\] \\] PRIMARY KEY \\[index\\_type\\] (index\\_col\\_name,...)</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加唯一约束\"><a href=\"#添加唯一约束\" class=\"headerlink\" title=\"添加唯一约束\"></a>添加唯一约束</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name ADD \\[CONSTRAINT \\[symbol\\] \\] UNIQUE \\[INDEX | KEY\\] \\[index\\_name\\] \\[index\\_type\\] (index\\_col_name,...)</span><br></pre></td></tr></table></figure>\n<p>唯一约束可以给多列添加</p>\n<h4 id=\"添加外键约束\"><a href=\"#添加外键约束\" class=\"headerlink\" title=\"添加外键约束\"></a>添加外键约束</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name ADD \\[CONSTRAINT \\[symbol\\] \\] FOREIGN KEY \\[index\\_name\\] (index\\_col\\_name,...) reference_definition</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加-删除默认约束\"><a href=\"#添加-删除默认约束\" class=\"headerlink\" title=\"添加/删除默认约束\"></a>添加/删除默认约束</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name ALTER \\[COLUMN\\] col\\_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;</span><br></pre></td></tr></table></figure>\n<p>SET DEFAULT literal：添加默认约束<br>DROP DEFAULT：删除默认约束</p>\n<h3 id=\"删除约束\"><a href=\"#删除约束\" class=\"headerlink\" title=\"删除约束\"></a>删除约束</h3><h4 id=\"删除主键约束\"><a href=\"#删除主键约束\" class=\"headerlink\" title=\"删除主键约束\"></a>删除主键约束</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl_name DROP PRIMARY KEY</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除唯一约束\"><a href=\"#删除唯一约束\" class=\"headerlink\" title=\"删除唯一约束\"></a>删除唯一约束</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name DROP &#123;INDEX | KEY&#125; index\\_name</span><br></pre></td></tr></table></figure>\n<p>一张表可以有多个唯一约束，所以需要查看约束的名字 =&gt; SHOW INDEXES FROM tbl_name [\\G];</p>\n<h4 id=\"删除外键约束\"><a href=\"#删除外键约束\" class=\"headerlink\" title=\"删除外键约束\"></a>删除外键约束</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name DROP FOREIGN KEY fk\\_symbol</span><br></pre></td></tr></table></figure>\n<p>fk_symbol：约束的名字，需要提前查看 =&gt; SHOW CREATE tbl_name</p>\n<h3 id=\"修改列定义\"><a href=\"#修改列定义\" class=\"headerlink\" title=\"修改列定义\"></a>修改列定义</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name MODIFY \\[COLUMN\\] col\\_name column\\_definition \\[FIRST | AFTER col\\_name\\]</span><br></pre></td></tr></table></figure>\n<p>可以修改数据类型以及数据列的位置</p>\n<h3 id=\"修改列名称\"><a href=\"#修改列名称\" class=\"headerlink\" title=\"修改列名称\"></a>修改列名称</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name CHANGE \\[COLUMN\\] old\\_col\\_name new\\_col\\_name column\\_definition \\[FIRST | AFTER col_name\\]</span><br></pre></td></tr></table></figure>\n<p>修改列名称的同时也可以修改列类型和位置，所以其功能要强大于修改列定义</p>\n<h3 id=\"数据表更名\"><a href=\"#数据表更名\" class=\"headerlink\" title=\"数据表更名\"></a>数据表更名</h3><p>尽量少更改数据表和数据列名字，因为如果创建过索引和约束，会影响到正常使用</p>\n<h4 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl\\_name RENAME \\[TO | AS\\] new\\_tbl_name</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RENAME TABLE tbl\\_name TO new\\_tbl\\_name \\[,tbl\\_name2 TO new\\_tbl\\_name2\\] ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><div align=\"center\"><img src=\"/images/hexo_post_209.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"记录操作\"><a href=\"#记录操作\" class=\"headerlink\" title=\"记录操作\"></a>记录操作</h2><h3 id=\"插入记录-1\"><a href=\"#插入记录-1\" class=\"headerlink\" title=\"插入记录\"></a>插入记录</h3><h4 id=\"第一种\"><a href=\"#第一种\" class=\"headerlink\" title=\"第一种\"></a>第一种</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT \\[INTO\\] tbl\\_name \\[(col\\_name,...)\\] &#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,...&#125;,(...),...</span><br></pre></td></tr></table></figure>\n<p>可以插入一条记录，也可以插入多条记录 INSERT users VALUES(NULL,’John’,’456’,25,1); =&gt; NULL 为空值，也可以为自增字段赋值（DEFAULT也可以）</p>\n<p>INSERT users VALUES(\bDEFAULT,’Tom’,’123’,3*7-5,1),(NULL,’Rose’,md5(‘123’),DEFAULT,0); =&gt; 插入多条记录，可以用表达式，也可以用函数、NULL、DEFAULT</p>\n<h4 id=\"第二种\"><a href=\"#第二种\" class=\"headerlink\" title=\"第二种\"></a>第二种</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT \\[INTO\\] tbl\\_name SET col\\_name=&#123;expr | DEFAULT&#125;,...</span><br></pre></td></tr></table></figure>\n<p>与第一种方式的区别在于，此方法可以使用子查询(SubQuery)，但是此方法只能插入一条记录<br>INSERT users SET username=’Ben’,password=’456’; =&gt; 将这两条数据列插入users，其他数据列为默认值<br>INSERT test(username) SELECT username FROM users WHERE age&gt;=30; =&gt; 将 users 数据表中的 age &gt;= 30 的记录中的 username 数据列插入到 test 的 username 数据列中</p>\n<h3 id=\"第三种\"><a href=\"#第三种\" class=\"headerlink\" title=\"第三种\"></a>第三种</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT \\[INTO\\] tbl\\_name \\[(col\\_name,...)\\] SELECT ...</span><br></pre></td></tr></table></figure>\n<p>此方法可以将查询结果插入到指定数据表</p>\n<h3 id=\"更新记录（单表更新）\"><a href=\"#更新记录（单表更新）\" class=\"headerlink\" title=\"更新记录（单表更新）\"></a>更新记录（单表更新）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE \\[LOW\\_PRIORITY\\] \\[IGNORE\\] table\\_reference SET col\\_name1=&#123;expr1 | DEFAULT&#125; \\[,col\\_name2=&#123;expr2 | DEFAULT&#125;\\] ... \\[WHERE where_condition\\]</span><br></pre></td></tr></table></figure>\n<p>UPDATE users SET age=age-id,sex=0 WHERE id%2=0; =&gt; 将 id 为偶数的记录的 age 设置为 age-id，sex 设置为 0</p>\n<h3 id=\"删除记录（单表删除）\"><a href=\"#删除记录（单表删除）\" class=\"headerlink\" title=\"删除记录（单表删除）\"></a>删除记录（单表删除）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE FROM tbl\\_name \\[WHERE <span class=\"built_in\">where</span>\\_condition\\]</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找记录\"><a href=\"#查找记录\" class=\"headerlink\" title=\"查找记录\"></a>查找记录</h3><p>查找记录占据了 MySQL 语句的 80% 频率</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT select\\_expr \\[,select\\_expr ...\\] \\[ FROM table\\_references \\[WHERE <span class=\"built_in\">where</span>\\_condition\\] \\[GROUP BY &#123;col\\_name | position&#125; \\[ASC | DESC\\],...\\] \\[HAVING <span class=\"built_in\">where</span>\\_condition\\] \\[ORDER BY &#123;col\\_name | expr | position&#125; \\[ASC | DESC\\],...\\] \\[LIMIT &#123;\\[offset,\\] row\\_count | row_count OFFSET offset&#125;\\] \\]</span><br></pre></td></tr></table></figure>\n<h4 id=\"select-expr\"><a href=\"#select-expr\" class=\"headerlink\" title=\"select_expr\"></a>select_expr</h4><p>查询表达式</p>\n<ul>\n<li>每一个表达式表示想要的一列，必须有至少一个</li>\n<li>多个列之间以英文逗号分隔</li>\n<li>星号(<em>)表示所有列；tbl_name.</em> 可以表示命名表的所有列</li>\n<li>查询表达式可以使用 [AS] alias_name 为其赋予别名</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT username AS uname FROM users;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>别名可用于 GROUP BY,ORDRE BY 或 HAVING 子句</li>\n</ul>\n<h4 id=\"WHERE\"><a href=\"#WHERE\" class=\"headerlink\" title=\"WHERE\"></a>WHERE</h4><p>条件表达式 对记录进行过滤，如果没有指定WHERE子句，则显示所有记录 在 WHERE 表达式中，可以使用 MySQL 支持的函数或运算符</p>\n<h4 id=\"GROUP-BY\"><a href=\"#GROUP-BY\" class=\"headerlink\" title=\"GROUP BY\"></a>GROUP BY</h4><p>查询结果分组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[GROUP BY &#123;col_name | position&#125; \\[ASC | DESC\\], ...\\]</span><br></pre></td></tr></table></figure>\n<p>既可以指定列名，也可以指定列的位置 ASC 为升序（默认），DESC 为降序</p>\n<h4 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h4><p>分组条件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[HAVING where_condition\\]</span><br></pre></td></tr></table></figure>\n<h4 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a>ORDER BY</h4><p>对查询结果进行排序</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[ORDER BY &#123;col_name | expr | position&#125; \\[ASC | DESC\\],...\\]</span><br></pre></td></tr></table></figure>\n<p>可以指定多个数据列进行排序，当第一个数据列的值相同时，按照第二个数据列进行排序，以此类推……</p>\n<h4 id=\"LIMIT\"><a href=\"#LIMIT\" class=\"headerlink\" title=\"LIMIT\"></a>LIMIT</h4><p>限制查询结果返回的数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[LIMIT &#123;\\[offset,\\] row\\_count | row\\_count OFFSET offset&#125;\\]</span><br></pre></td></tr></table></figure>\n<p>SELECT * FROM users LIMIT 3,2; =&gt; 从索引值为 3（第四条记录）的记录开始返回两条记录</p>\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><p>子查询(Subquery)是指出现在其他 SQL 语句内的 SELECT 子句<br>SELECT <em> FROM t1 WHERE col1 = (SELECT col2 FROM t2); =&gt; 其中SELECT </em> FROM t1 称为 Outer Query/Outer Statement,SELECT col2 FROM t2 称为 SubQuery</p>\n<ul>\n<li>子查询指嵌套在查询内部，且必须始终出现在圆括号内</li>\n<li>子查询可以包含多个关键字或条件，如 DISTINCT、GROUP BY、ORDER BY、LIMIT 函数等</li>\n<li>子查询的外层查询可以是：SELECT，INSERT，UPDATE，SET 或 DO</li>\n</ul>\n<h3 id=\"子查询返回值\"><a href=\"#子查询返回值\" class=\"headerlink\" title=\"子查询返回值\"></a>子查询返回值</h3><p>子查询可以返回标量、一行、一列或子查询</p>\n<h3 id=\"使用比较运算法的子查询\"><a href=\"#使用比较运算法的子查询\" class=\"headerlink\" title=\"使用比较运算法的子查询\"></a>使用比较运算法的子查询</h3><p>=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt;</p>\n<h3 id=\"语法结构\"><a href=\"#语法结构\" class=\"headerlink\" title=\"语法结构\"></a>语法结构</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">operand comparison_operator subquery</span><br></pre></td></tr></table></figure>\n<h3 id=\"用-ANY、SOME-或-ALL-修饰的比较运算符\"><a href=\"#用-ANY、SOME-或-ALL-修饰的比较运算符\" class=\"headerlink\" title=\"用 ANY、SOME 或 ALL 修饰的比较运算符\"></a>用 ANY、SOME 或 ALL 修饰的比较运算符</h3><ol>\n<li>operand comparison_operator ANY (subquery)</li>\n<li>operand comparison_operator SOME (subquery)</li>\n<li>operand comparison_operator ALL (subquery)</li>\n</ol>\n<p>运算符和关键字相结合之后的结果类型：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_210.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"使用-NOT-IN-的子查询\"><a href=\"#使用-NOT-IN-的子查询\" class=\"headerlink\" title=\"使用 [NOT] IN 的子查询\"></a>使用 [NOT] IN 的子查询</h3><h4 id=\"语法结构-1\"><a href=\"#语法结构-1\" class=\"headerlink\" title=\"语法结构\"></a>语法结构</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">operand comparison_operator \\[NOT\\] IN (subquery)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>=ANY 运算符与 IN 等效</li>\n<li>!=ALL 或 &lt;&gt;ALL 运算符与 NOT IN 等效</li>\n</ul>\n<h3 id=\"使用-NOT-EXISTS-的子查询\"><a href=\"#使用-NOT-EXISTS-的子查询\" class=\"headerlink\" title=\"使用 [NOT] EXISTS 的子查询\"></a>使用 [NOT] EXISTS 的子查询</h3><p>如果子查询返回任何行，EXISTS 将返回 TRUE，否则为 FALSE</p>\n<h2 id=\"多表操作\"><a href=\"#多表操作\" class=\"headerlink\" title=\"多表操作\"></a>多表操作</h2><h3 id=\"多表更新\"><a href=\"#多表更新\" class=\"headerlink\" title=\"多表更新\"></a>多表更新</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE table\\_references SET col\\_name1 = &#123;expr1 | DEFAULT&#125; \\[,col\\_name2= &#123;expr2 | DEFAULT&#125;\\] ...\\[WHERE <span class=\"built_in\">where</span>\\_condition\\]</span><br></pre></td></tr></table></figure>\n<h3 id=\"CREATE…SELECT\"><a href=\"#CREATE…SELECT\" class=\"headerlink\" title=\"CREATE…SELECT\"></a>CREATE…SELECT</h3><p>创建数据表同时将查询结果写入到数据表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE \\[IF NOT EXISTS\\] tbl\\_name \\[(create\\_definition,...)\\] select_statement</span><br></pre></td></tr></table></figure>\n<p>CREATE TABLE tdb_goods_brands(brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name; =&gt; 创建表 tdb_goods_brands 的同时将 tdb_goods 中的 brand_name 数据列的值赋给新表 tdb_goods_brands 中的 brand_name 数据列</p>\n<h3 id=\"表的连接\"><a href=\"#表的连接\" class=\"headerlink\" title=\"表的连接\"></a>表的连接</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">table\\_reference &#123;\\[INNER | CROSS\\] JOIN | &#123;LEFT | RIGHT&#125; \\[OUTER\\] JOIN&#125; table\\_reference ON conditional_expr</span><br></pre></td></tr></table></figure>\n<p>table_reference：连接的两张表的名字<br>conditional_expr：连接条件，使用 ON 关键字来设定连接条件，也可以使用 WHERE 来代替：通常使用 ON 关键字来设定连接条件，使用 WHERE 关键字进行结果集记录的过滤</p>\n<h4 id=\"连接类型\"><a href=\"#连接类型\" class=\"headerlink\" title=\"连接类型\"></a>连接类型</h4><ol>\n<li>INNER JOIN，内连接，在 MySQL 中，JOIN，CROSS JOIN 和 INNER JOIN 是等价的</li>\n<li>LEFT [OUTER] JOIN，左外连接</li>\n<li>RIGHT [OUTER] JOIN，右外连接</li>\n</ol>\n<p>UPDATE tdb_goods AS g INNER JOIN tdb_goods_brands AS b ON g.brand_name=b.brand_name SET g.brand_name=b.brand_id; =&gt; 按照 tdb_goods_brands (设置别名为 b)表更新 tdb_goods (设置别名为 g)表，连接条件为表 g 的brand_name 和表 b 的 brand_name 字段值相等，更新操作为将 g 中的 brand_name 更改为 b 中的 brand_id</p>\n<h4 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h4><p>仅显示左表及右表符合连接条件的记录（交集、公共部分）</p>\n<h4 id=\"左（右）外连接\"><a href=\"#左（右）外连接\" class=\"headerlink\" title=\"左（右）外连接\"></a>左（右）外连接</h4><p>显示左（右）表的全部记录及右（左）表符合连接条件的记录 A LEFT JOIN B join_condition 如果数据表 A 的某条记录符合 WHERE 条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行</p>\n<h3 id=\"多表删除\"><a href=\"#多表删除\" class=\"headerlink\" title=\"多表删除\"></a>多表删除</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE tbl\\_name\\[.*\\] \\[,tbl\\_name\\[.*\\]\\] ... FROM table\\_references \\[WHERE <span class=\"built_in\">where</span>\\_condition\\]</span><br></pre></td></tr></table></figure>\n<h2 id=\"系统内置函数\"><a href=\"#系统内置函数\" class=\"headerlink\" title=\"系统内置函数\"></a>系统内置函数</h2><h3 id=\"字符函数\"><a href=\"#字符函数\" class=\"headerlink\" title=\"字符函数\"></a>字符函数</h3><table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CONCAT()</td>\n<td>字符连接</td>\n</tr>\n<tr>\n<td>CONCAT_WS()</td>\n<td>使用指定的分隔符进行字符连接</td>\n</tr>\n<tr>\n<td>FORMAT()</td>\n<td>数字格式化</td>\n</tr>\n<tr>\n<td>LOWER()</td>\n<td>转换成小写字母</td>\n</tr>\n<tr>\n<td>UPPER()</td>\n<td>转换成大写字母</td>\n</tr>\n<tr>\n<td>LEFT()</td>\n<td>获取左侧字符</td>\n</tr>\n<tr>\n<td>RIGHT()</td>\n<td>获取右侧字符</td>\n</tr>\n<tr>\n<td>LENGTH()</td>\n<td>获取字符串长度</td>\n</tr>\n<tr>\n<td>LTRIM()</td>\n<td>删除前导空格</td>\n</tr>\n<tr>\n<td>RTRIM()</td>\n<td>删除后续空格</td>\n</tr>\n<tr>\n<td>TRIM()</td>\n<td>删除前导和后续空格</td>\n</tr>\n<tr>\n<td>SUBSTRING()</td>\n<td>字符串截取</td>\n</tr>\n<tr>\n<td>[NOT] LIKE</td>\n<td>模式匹配</td>\n</tr>\n<tr>\n<td>REPLACE()</td>\n<td>字符串替换</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"CONCAT\"><a href=\"#CONCAT\" class=\"headerlink\" title=\"CONCAT()\"></a>CONCAT()</h3><p>SELECT CONCAT(first_name,last_name) AS fullname FROM test; =&gt; 将数据表 test 中的 first_name 和 last_name 中的数据连接到一起进行输出，并命名为 fullname</p>\n<h3 id=\"FORMAT\"><a href=\"#FORMAT\" class=\"headerlink\" title=\"FORMAT()\"></a>FORMAT()</h3><p>SELECT FORMAT(12560.75,2); =&gt; 转换成 12,560.75（千分位）<br>SELECT FORMAT(12560.75,1); =&gt; 转换成 12,560.8（四舍五入）<br>SELECT FORMAT(12560.75,0); =&gt; 转换成 12,561（取整）</p>\n<h3 id=\"TRIM\"><a href=\"#TRIM\" class=\"headerlink\" title=\"TRIM()\"></a>TRIM()</h3><p>除了删除首尾空格，还可以删除指定其他字符 SELECT TRIM(LEADING ‘?’ FROM ‘??MySQL???’); =&gt; MySQL???，LEADING 关键字代表前导，所以这句话的含义是删除字符串前面的’?’字符；将 LEADING 换为 TRAILING 表示去掉尾部相应字符，换为 BOTH 表示去掉首尾相应字符</p>\n<h3 id=\"NOT-LIKE\"><a href=\"#NOT-LIKE\" class=\"headerlink\" title=\"[NOT] LIKE\"></a>[NOT] LIKE</h3><p>SELECT <em> FROM test WHERE first_name LIKE ‘%o%’; => tom%，%相当于</em>，所以 LIKE 有点类似于正则匹配</p>\n<h3 id=\"数值运算符与函数\"><a href=\"#数值运算符与函数\" class=\"headerlink\" title=\"数值运算符与函数\"></a>数值运算符与函数</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CEIL()</td>\n<td>进一取整</td>\n</tr>\n<tr>\n<td>DIV</td>\n<td>整数除法</td>\n</tr>\n<tr>\n<td>FLOOR()</td>\n<td>舍一取整</td>\n</tr>\n<tr>\n<td>MOD</td>\n<td>取余数（取模）</td>\n</tr>\n<tr>\n<td>POWER()</td>\n<td>幂运算</td>\n</tr>\n<tr>\n<td>ROUND()</td>\n<td>四舍五入</td>\n</tr>\n<tr>\n<td>TRUNCATE()</td>\n<td>数字截取</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"TRUNCATE\"><a href=\"#TRUNCATE\" class=\"headerlink\" title=\"TRUNCATE()\"></a>TRUNCATE()</h3><p>数字截取，不会进行运算，TRUNCATE(125.89,0); => 125，TRUNCATE(125.89,-1); => 120</p>\n<h3 id=\"比较运算符与函数\"><a href=\"#比较运算符与函数\" class=\"headerlink\" title=\"比较运算符与函数\"></a>比较运算符与函数</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[NOT] BETWEEN…AND…</td>\n<td>[不]在范围之内</td>\n</tr>\n<tr>\n<td>[NOT] IN()</td>\n<td>[不]在列出值范围内</td>\n</tr>\n<tr>\n<td>IS [NOT] NULL</td>\n<td>[不]为空</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"日期时间函数\"><a href=\"#日期时间函数\" class=\"headerlink\" title=\"日期时间函数\"></a>日期时间函数</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NOW()</td>\n<td>当前日期和时间</td>\n</tr>\n<tr>\n<td>CURDATE()</td>\n<td>当前日期</td>\n</tr>\n<tr>\n<td>CURTIME()</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>DATE_ADD()</td>\n<td>日期变化</td>\n</tr>\n<tr>\n<td>DATEDIFF()</td>\n<td>日期差值</td>\n</tr>\n<tr>\n<td>DATE_FORMAT()</td>\n<td>日期格式化</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"DATE-ADD\"><a href=\"#DATE-ADD\" class=\"headerlink\" title=\"DATE_ADD()\"></a>DATE_ADD()</h3><p>DATE_ADD(‘2014-3-12’,INTERVAL 3 \bWEEK); =&gt; 2014-04-02<br>DATE_ADD(‘2014-3-12’,INTERVAL -365 DAY); =&gt; 2013-3-12</p>\n<h3 id=\"DATEDIFF\"><a href=\"#DATEDIFF\" class=\"headerlink\" title=\"DATEDIFF()\"></a>DATEDIFF()</h3><p>DATEDIFF(‘2013-3-12’,’2014-3-12’); =&gt;-365</p>\n<h3 id=\"DATE-FORMAT\"><a href=\"#DATE-FORMAT\" class=\"headerlink\" title=\"DATE_FORMAT()\"></a>DATE_FORMAT()</h3><p>DATE_FORMAT(‘2014-3-2’,’%m/%d/%Y’); =&gt;03/02/2014</p>\n<h3 id=\"信息函数\"><a href=\"#信息函数\" class=\"headerlink\" title=\"信息函数\"></a>信息函数</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CONNECTION_ID()</td>\n<td>连接ID</td>\n</tr>\n<tr>\n<td>DATABASE()</td>\n<td>当前数据库</td>\n</tr>\n<tr>\n<td>LAST_INSERT_ID()</td>\n<td>最后插入记录的ID号</td>\n</tr>\n<tr>\n<td>USER()</td>\n<td>当前用户</td>\n</tr>\n<tr>\n<td>VERSION()</td>\n<td>版本信息</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"LAST-INSERT-ID\"><a href=\"#LAST-INSERT-ID\" class=\"headerlink\" title=\"LAST_INSERT_ID()\"></a>LAST_INSERT_ID()</h3><p>当使用该函数时，当前数据表中必须存在一个自增的字段，字段名可以不为 id，当同时写入多条记录时，只返回插入的第一条记录的 ID 值</p>\n<h3 id=\"聚合函数\"><a href=\"#聚合函数\" class=\"headerlink\" title=\"聚合函数\"></a>聚合函数</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVG()</td>\n<td>平均值</td>\n</tr>\n<tr>\n<td>COUNT()</td>\n<td>计数</td>\n</tr>\n<tr>\n<td>MAX()</td>\n<td>最大值</td>\n</tr>\n<tr>\n<td>MIN()</td>\n<td>最小值</td>\n</tr>\n<tr>\n<td>SUM()</td>\n<td>求和</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"AVG\"><a href=\"#AVG\" class=\"headerlink\" title=\"AVG()\"></a>AVG()</h4><p>SELECT AVG(age) FROM test; =&gt; 返回 test 数据表中的 age 平均值</p>\n<h2 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h2><p>用户自定义函数（user-defined function,UDF）是一种对 MySQL 扩展的途径，其用法与内置函数相同</p>\n<h3 id=\"必要条件\"><a href=\"#必要条件\" class=\"headerlink\" title=\"必要条件\"></a>必要条件</h3><ol>\n<li>参数（理论上不超过 1024 个参数）</li>\n<li>返回值</li>\n</ol>\n<p>函数可以返回任意类型的值，同样可以接收这些类型的参数</p>\n<h3 id=\"创建自定义函数\"><a href=\"#创建自定义函数\" class=\"headerlink\" title=\"创建自定义函数\"></a>创建自定义函数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE FUNCTION <span class=\"keyword\">function</span>\\_name RETURNS &#123;STRING | INTERGER | REAL | DECIMAL&#125; routine\\_body</span><br></pre></td></tr></table></figure>\n<p>CREATE FUNCTION f1() RETURNS VARCHAR(30) RETURN DATE_FORMAT(NOW(),’%Y年%m月%d日 %H点:%i分:%s秒’); =&gt; 不带有参数的函数，返回格式为 ‘2017年05月09日 21点:26分:15秒’</p>\n<h3 id=\"关于函数体\"><a href=\"#关于函数体\" class=\"headerlink\" title=\"关于函数体\"></a>关于函数体</h3><ol>\n<li>函数体由合法的 SQL 语句构成</li>\n<li>函数体可以是简单的 SELECT 或 INSERT 语句</li>\n<li>函数体如果为复合结构，则使用 BEGIN…END 语句</li>\n<li>复合结构可以包含声明，循环，控制结构</li>\n</ol>\n<h3 id=\"删除函数\"><a href=\"#删除函数\" class=\"headerlink\" title=\"删除函数\"></a>删除函数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP FUNCTION \\[IF EXISTS\\] function_name</span><br></pre></td></tr></table></figure>\n<h2 id=\"MySQL命令执行过程\"><a href=\"#MySQL命令执行过程\" class=\"headerlink\" title=\"MySQL命令执行过程\"></a>MySQL命令执行过程</h2><div align=\"center\"><img src=\"/images/hexo_post_211.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h2><p>存储过程是 SQL 语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理</p>\n<h3 id=\"存储过程的优点\"><a href=\"#存储过程的优点\" class=\"headerlink\" title=\"存储过程的优点\"></a>存储过程的优点</h3><ol>\n<li>增强 SQL 语句的功能和灵活性</li>\n<li>实现较快的执行速度</li>\n<li>减少网络流量</li>\n</ol>\n<h3 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE \\[DEFINER = &#123;user | CURRENT\\_USER&#125;\\] PROCEDURE sp\\_name (\\[proc\\_parameter\\[,...\\]\\]) \\[characteristic ...\\] routine\\_body</span><br></pre></td></tr></table></figure>\n<p>和创建自定义函数类似，最大的不同就是参数部分不同</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proc\\_parameter:\\[IN | OUT | INOUT\\] param\\_name <span class=\"built_in\">type</span></span><br></pre></td></tr></table></figure>\n<p>IN -&gt; 表示该参数的值必须在调用存储过程时指定<br>OUT -&gt; 表示该参数的值可以被存储过程改变，并且可以返回<br>INOUT -&gt; 表示该参数的调用时指定，并且可以被改变和返回</p>\n<h3 id=\"过程体\"><a href=\"#过程体\" class=\"headerlink\" title=\"过程体\"></a>过程体</h3><ol>\n<li>过程体由合法的 SQL 语句构成</li>\n<li>过程体可以是任意 SQL 语句</li>\n<li>过程体如果为复合结构则使用 BEGIN…END 语句</li>\n<li>复合结构可以包含声明，循环，控制结构</li>\n</ol>\n<h3 id=\"调用存储过程\"><a href=\"#调用存储过程\" class=\"headerlink\" title=\"调用存储过程\"></a>调用存储过程</h3><ul>\n<li>CALL sp_name([parameter[,…]])</li>\n<li>CALL sp_name[()]</li>\n</ul>\n<h3 id=\"修改存储过程\"><a href=\"#修改存储过程\" class=\"headerlink\" title=\"修改存储过程\"></a>修改存储过程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER PROCEDURE sp_name \\[characteristic ...\\] COMMENT <span class=\"string\">'string'</span> | &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除存储过程\"><a href=\"#删除存储过程\" class=\"headerlink\" title=\"删除存储过程\"></a>删除存储过程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP PROCEDURE \\[IF EXISTS\\] sp_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>CREATE PROCEDURE sp1() SELECTION VERSION(); -&gt; 创建存储体<br>CALL sp1; -&gt; 调用存储体</p>\n","raw":null,"categories":[{"name":"慕课网","path":"api/categories/慕课网.json"}],"tags":[{"name":"mysql","path":"api/tags/mysql.json"},{"name":"数据库","path":"api/tags/数据库.json"}]},{"title":"JS宽高的理解和应用","slug":"JS宽高的理解和应用","date":"2017-05-01T14:49:51.000Z","updated":"2019-02-07T13:01:36.415Z","comments":true,"path":"api/articles/JS宽高的理解和应用.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_31.png","content":"<h2 id=\"window-和-document\"><a href=\"#window-和-document\" class=\"headerlink\" title=\"window 和 document\"></a>window 和 document</h2><p><strong>document 是 window 对象的一部分</strong>：document.body -&gt; window.document.body，浏览器的 HTML 文档称为 document 对象<br><strong>window.location === document.location</strong>：window 对象的 location 属性引用的是 location 对象，表示该窗口中当前显示文档的 URL，document 对象的 location 属性也是引用了 location 对象</p>\n<h2 id=\"window-screen\"><a href=\"#window-screen\" class=\"headerlink\" title=\"window.screen\"></a>window.screen</h2><p>window.screen 包含有关用户屏幕的信息，它包括：</p>\n<ul>\n<li><code>window.screen.width</code></li>\n<li><code>window.screen.height</code></li>\n<li><code>window.screen.availHeight</code></li>\n<li><code>window.screen.availWidth</code></li>\n<li><code>window.screenTop</code></li>\n<li><code>window.screenLeft</code></li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_31.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"与-window-相关的宽高\"><a href=\"#与-window-相关的宽高\" class=\"headerlink\" title=\"与 window 相关的宽高\"></a>与 window 相关的宽高</h2><ul>\n<li><code>window.innerWidth</code> 内部的宽度</li>\n<li><code>window.innerHeight</code> 内部的高度</li>\n<li><code>window.outWidth</code> 外部的宽度</li>\n<li><code>window.outHeight</code> 外部的高度</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_24.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"与-document-相关的宽高\"><a href=\"#与-document-相关的宽高\" class=\"headerlink\" title=\"与 document 相关的宽高\"></a>与 document 相关的宽高</h2><h3 id=\"与-client-相关的宽高\"><a href=\"#与-client-相关的宽高\" class=\"headerlink\" title=\"与 client 相关的宽高\"></a>与 client 相关的宽高</h3><ul>\n<li><code>document.body.clientWidth</code> 元素宽度（可视内容区+内边距）</li>\n<li><code>document.body.clientHeight</code> 元素高度（可视内容区+内边距）</li>\n</ul>\n<p>该属性指的是元素的可视部分宽度和高度，即 <code>padding+content</code></p>\n<ul>\n<li>如果没有滚动条，即为元素设定的宽度和高度</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientWidth);  <span class=\"comment\">// 350+padding(80) = 430</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientHeight);  <span class=\"comment\">// 500 + padding(80) = 580</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#exp2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"exp2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.clientHeight); <span class=\"comment\">// 200</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.clientWidth); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>document.body.clientLeft</code></li>\n<li><code>document.body.clientTop</code></li>\n</ul>\n<p>这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是 0</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientLeft);  <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientTop);  <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>无 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code></li>\n<li>有 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code> + 盒子的 <code>padding * 2</code></li>\n<li>有 <code>padding</code> 有滚动 ：<code>clientWidth</code> = 盒子和 <code>width</code> + 盒子的 <code>padding * 2</code> - 滚动轴宽度</li>\n<li><code>clientTop = border-top</code></li>\n<li><code>clientLeft = border-left</code></li>\n</ul>\n<h3 id=\"与-offset-相关的宽高\"><a href=\"#与-offset-相关的宽高\" class=\"headerlink\" title=\"与 offset 相关的宽高\"></a>与 offset 相关的宽高</h3><ul>\n<li><strong>document.body.offsetWidth（元素的border + padding + content的宽度）</strong></li>\n<li><strong>document.body.offsetHeight（元素的border + padding + content的高度）</strong></li>\n</ul>\n<p>该属性和其内部的内容是否超出元素大小无关，只和本来设定的 border 以及 width 和 height 有关</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.offsetWidth);  <span class=\"comment\">// 470 = padding\\*2 + 350 + border\\*2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.offsetHeight);  <span class=\"comment\">// 620 = padding\\*2 + 500 + border\\*2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>document.offsetLeft</strong></li>\n<li><strong>document.offsetTop</strong></li>\n</ul>\n<p>了解这两个属性我们必须先了解它，什么是 <code>offsetParent</code></p>\n<ul>\n<li>如果当前元素的父级元素没有进行 <code>CSS</code> 定位（<code>position</code> 为 <code>absolute</code> 或 <code>relative</code>）,<code>offsetParent</code> 为 <code>body.</code></li>\n<li>假如当前元素的父级元素中有 <code>CSS</code> 定位，<code>offsetParent</code> 取最近的那个父级元素</li>\n</ul>\n<h3 id=\"offsetLeft-的兼容性问题\"><a href=\"#offsetLeft-的兼容性问题\" class=\"headerlink\" title=\"offsetLeft 的兼容性问题\"></a>offsetLeft 的兼容性问题</h3><ul>\n<li>在 <code>IE6/7</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 padding-left + 当前元素的 margin-left</li>\n</ul>\n</li>\n<li>在 <code>IE8/9/10</code> 以及 <code>chrome</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 margin-left + offsetParent 的 border 宽度 + offsetParent 的 padding-left + 当前元素的 margin-left</li>\n</ul>\n</li>\n<li>在 <code>FireFox</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 margin-left + 当前元素的 margin-left + offsetParent 的padding-left</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-id\">#exp</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">20px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 IE8 / 9 / 10 以及 chrome 中：<ul>\n<li>div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 + margin10 + border20 = 80</li>\n<li>div.offsetTop = 本身的 margin10 + 父级元素的 padding40 + margin10 + border20 = 80</li>\n</ul>\n</li>\n<li>在 FireFox：（相比 chrome 中少了 border）<ul>\n<li>div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 + margin10 = 60</li>\n<li>div.offsetTop = 本身的 margin10 + 父级元素的 padding40 + margin10 = 60</li>\n</ul>\n</li>\n<li>在 IE6/7 中：（相比在 FireFox，不但少了 border 还少了父级元素的 margin）<ul>\n<li><code>div.offsetLeft</code> = 本身的 <code>margin10</code> + 父级元素的 <code>padding40</code> = 50</li>\n<li><code>div.offsetTop</code> = 本身的 <code>margin10</code> + 父级元素的 <code>padding40</code> = 50</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>无 <code>padding</code> 无滚动无 <code>border</code><ul>\n<li>offsetWidth = clientWidth = 盒子的宽度</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 无滚动有 <code>border</code><ul>\n<li>offsetWidth = 盒子的宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 边框宽度 * 2</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 有滚动，且滚动是显示的，有 <code>border</code><ul>\n<li>offsetWidth = 盒子宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"与-scroll-相关的宽高\"><a href=\"#与-scroll-相关的宽高\" class=\"headerlink\" title=\"与 scroll 相关的宽高\"></a>与 scroll 相关的宽高</h2><ul>\n<li><strong>document.body.scrollWidth</strong></li>\n<li><strong>document.body.scrollHeight</strong></li>\n</ul>\n<p>document.body 的 scrollWidth 和 scrollHeight 与 div 的 scrollWidth 和 scrollHeight 是有区别的</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.scrollHeight; <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.scrollWidth; <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>当给定宽高小于浏览器窗口的宽高<ul>\n<li>scrollWidth = 通常是浏览器窗口的宽度</li>\n<li>scrollHeight = 通常是浏览器窗口的高度</li>\n</ul>\n</li>\n<li>当给定宽高大于浏览器窗口的宽高，且内容小于给定宽高的时候<ul>\n<li>scrollWidth = 给定宽度 + 其所有的 padding + margin + border</li>\n<li>scrollHeight = 给定高度 + 其所有的 padding + margin + border</li>\n</ul>\n</li>\n<li>当给定宽高大于浏览器窗口宽高，且内容大于给定宽高<ul>\n<li>scrollWidth = 内容宽度 + 其所有的 padding + margin + border</li>\n<li>scrollHeight = 内容高度 + 其所有的 padding + margin + border</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在某-div-中的-scrollWidth-和-scrollHeight\"><a href=\"#在某-div-中的-scrollWidth-和-scrollHeight\" class=\"headerlink\" title=\"在某 div 中的 scrollWidth 和 scrollHeight\"></a><strong>在某 div 中的 scrollWidth 和 scrollHeight</strong></h3><p>无滚动轴时：</p>\n<ul>\n<li>scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_28.png\" alt=\"\" width=\"450\"></div>\n\n<p>有滚动轴时：</p>\n<ul>\n<li>scrollWidth = 实际内容的宽度 + padding * 2</li>\n<li>scrollHeight = 实际内容的高度 + padding * 2</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_32.png\" alt=\"\" width=\"450\"></div>\n\n<ul>\n<li><strong>document.body.scrollLeft</strong></li>\n<li><strong>document.body.scrollTop</strong></li>\n</ul>\n<p>与前面不同的是，这对属性是<strong>可读写</strong>的，指的是当元素其中的超出其宽高的时候，元素被卷起来的高度和宽度</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#exp</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">20px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>:scroll;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"exp\"</span>);</span><br><span class=\"line\">mydiv.scrollTop ;  <span class=\"comment\">// 默认情况下是0 </span></span><br><span class=\"line\">mydiv.scrollLeft ; <span class=\"comment\">// 默认情况下是0 </span></span><br><span class=\"line\"><span class=\"comment\">// 可以改写它</span></span><br><span class=\"line\">mydiv.scrollTop = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mydiv.scrollTop)</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_25.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"obj-style-width-和-obj-style-height\"><a href=\"#obj-style-width-和-obj-style-height\" class=\"headerlink\" title=\"obj.style.width 和 obj.style.height\"></a><strong>obj.style.width 和 obj.style.height</strong></h3><p>对于一个 <code>DOM</code> 元素，它的 <code>style</code> 属性返回的是一个对象，这个对象的任意一个属性是可读写的，<code>style.width</code> 等于 <code>css</code> 属性中的宽度。<code>style.height</code> 等于 <code>css</code> 属性中的高度</p>\n<h2 id=\"documentElement-和-body-的关系\"><a href=\"#documentElement-和-body-的关系\" class=\"headerlink\" title=\"documentElement 和 body 的关系\"></a>documentElement 和 body 的关系</h2><p>是父子级的关系</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>); <span class=\"comment\">//document</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.documentElement); <span class=\"comment\">//html</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body); <span class=\"comment\">//body</span></span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_29.png\" alt=\"\" width=\"600\"></div>\n\n<ul>\n<li>兼容问题推荐使用，获取浏览器窗口可视区域大小：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.clientWidth || <span class=\"built_in\">document</span>.documentElement.clientWidth;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.clientHeight || <span class=\"built_in\">document</span>.documentElement.clientHeight;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-对象的-5-种坐标\"><a href=\"#Event-对象的-5-种坐标\" class=\"headerlink\" title=\"Event 对象的 5 种坐标\"></a>Event 对象的 5 种坐标</h2><ul>\n<li>clientX 和 clientY：相对于浏览器（可视区左上角0,0）的坐标</li>\n<li>screenX 和 screenY：相对于设备屏幕左上角（0,0）的坐标</li>\n<li>offsetX 和 offsetY：相对于事件源左上角（0,0）的坐标</li>\n<li>pageX 和 pageY：相对于整个网页左上角（0,0）的坐标</li>\n<li>X 和 Y：本来是 IE 属性，相对于用CSS动态定位的最内层包容元素</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_27.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"JS各种宽高的应用\"><a href=\"#JS各种宽高的应用\" class=\"headerlink\" title=\"JS各种宽高的应用\"></a>JS各种宽高的应用</h2><ul>\n<li><a href=\"http://codepen.io/poetries/pen/RoeJgG\" target=\"_blank\" rel=\"noopener\">可视区域加载</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/WoayJy\" target=\"_blank\" rel=\"noopener\">判断网页滚动到顶部或者底部</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/vyVrvm\" target=\"_blank\" rel=\"noopener\">DIV滚动到底部时加载剩余内容</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/RoeBbL\" target=\"_blank\" rel=\"noopener\">计算滚动轴的宽高</a></li>\n</ul>\n<h2 id=\"JS中的宽高属性总结\"><a href=\"#JS中的宽高属性总结\" class=\"headerlink\" title=\"JS中的宽高属性总结\"></a>JS中的宽高属性总结</h2><div align=\"center\"><img src=\"/images/hexo_post_26.png\" alt=\"\" width=\"700\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_23.png\" alt=\"\" width=\"700\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_30.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://blog.poetries.top/2016/12/13/js-props/\" target=\"_blank\" rel=\"noopener\">JavaScript及jQuery中的各种宽高属性图解</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"}]},{"title":"读书笔记系列（7）——JavaScript半知半解","slug":"读书笔记系列（7）——JavaScript半知半解","date":"2017-04-25T15:33:09.000Z","updated":"2019-02-07T13:01:36.423Z","comments":true,"path":"api/articles/读书笔记系列（7）——JavaScript半知半解.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这本书是我无意中看到的一本电子版书籍，但是第一章就吸引到了我，然后就对作者展开了深入“挖掘”，通过作者的<a href=\"http://ghmagical.com/\" target=\"_blank\" rel=\"noopener\">个人博客</a>发现作者是一个很厉害的技术开发人员，不管是前端还是后台都有所涉猎，所以推荐大家去他的个人博客逛逛，同时推荐他的两本书籍：《JavaScript半知半解》和《Web实战》，一定会有所收获</p>\n<h2 id=\"1-完整的-JavaScript\"><a href=\"#1-完整的-JavaScript\" class=\"headerlink\" title=\"1. 完整的 JavaScript\"></a>1. 完整的 JavaScript</h2><p>完整的 JavaScript 实现由下列三个不同的部分组成：</p>\n<ul>\n<li>核心（<strong>ECMAScript</strong>）</li>\n<li>文档对象模型（<strong>DOM</strong>）</li>\n<li>浏览器对象模型（<strong>BOM</strong>）</li>\n</ul>\n<h2 id=\"2-lt-script-gt-元素\"><a href=\"#2-lt-script-gt-元素\" class=\"headerlink\" title=\"2. &lt;script&gt; 元素\"></a>2. <code>&lt;script&gt;</code> 元素</h2><p>向 HTML 页面中插入 JavaScript 的主要方法，就是使用 <code>&lt;script&gt;</code> 元素。<code>&lt;script&gt;</code> 中定义了下列 6 个属性：</p>\n<ul>\n<li><strong><code>async</code></strong>：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效</li>\n<li><strong><code>charset</code></strong>：可选，表示通过 src 属性指定的代码的字符集，比较少用。</li>\n<li><strong><code>defer</code></strong>：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li>\n<li><strong><code>language</code></strong>：已废弃</li>\n<li><strong><code>src</code></strong>：可选，表示包含要执行代码的外部文件</li>\n<li><strong><code>type</code></strong>：可选，表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。在 HTML5 中，默认是 text/javascript，所以不需要设置。</li>\n</ul>\n<h2 id=\"3-在使用-lt-script-gt-嵌入-JavaScript-代码时，切记不要在代码中的任何地方出现-lt-script-gt\"><a href=\"#3-在使用-lt-script-gt-嵌入-JavaScript-代码时，切记不要在代码中的任何地方出现-lt-script-gt\" class=\"headerlink\" title=\"3. 在使用 &lt;script&gt; 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 &lt;/script&gt;\"></a>3. 在使用 <code>&lt;script&gt;</code> 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 <code>&lt;/script&gt;</code></h2><p>执行下面的代码时，会产生一个错误：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  alert('</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-JavaScript-代码的执行顺序\"><a href=\"#4-JavaScript-代码的执行顺序\" class=\"headerlink\" title=\"4. JavaScript 代码的执行顺序\"></a>4. JavaScript 代码的执行顺序</h2><p>只要不存在 defer 和 async 属性，JavaScript 代码就会从上至下依次解析。带有 src 属性的 <code>&lt;script&gt;</code> 元素不应该在其 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签之间再包含额外的 JavaScript 代码，嵌入代码会被忽略。<strong>只要不存在 defer 和 async 属性，浏览器都会按照 <code>&lt;script&gt;</code> 出现的先后顺序对它们依次进行解析。</strong> 一般将全部 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中页面的内容后面。</p>\n<h2 id=\"5-延迟脚本\"><a href=\"#5-延迟脚本\" class=\"headerlink\" title=\"5. 延迟脚本\"></a>5. 延迟脚本</h2><p>当给 <code>&lt;script&gt;</code> 元素添加了 <code>defer</code> 属性时，src 指向的外部文件会立即下载，但包含的脚本会延迟到浏览器遇到 <code>&lt;/html&gt;</code> 标签（整个页面解析完毕）后再执行（按添加顺序执行），会先于 DOMContentLoaded 事件执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span>=<span class=\"string\">\"defer\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>会先执行 example.js，然后执行 example2.js。</p>\n<blockquote>\n<p>注意：defer 只适合外部脚本文件。</p>\n</blockquote>\n<h2 id=\"6-异步脚本\"><a href=\"#6-异步脚本\" class=\"headerlink\" title=\"6. 异步脚本\"></a>6. 异步脚本</h2><p><code>async</code> 与 <code>defer</code> 属性类似，都用于改变处理脚本的行为，适用于外部脚本文件，并告诉浏览器立即下载，但标记为 <code>async</code> 的脚本并不保证按照指定它们的先后顺序执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>两个执行顺序不定</strong>。指定 <code>async</code> 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p>\n<blockquote>\n<p>注意：异步脚本不要在加载期间修改 DOM。 <strong>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行</strong>。</p>\n</blockquote>\n<h2 id=\"7-元素\"><a href=\"#7-元素\" class=\"headerlink\" title=\"7. 元素\"></a>7. <noscript>元素</noscript></h2><p>当浏览器不支持 JavaScript 或被禁用时，显示里面的内容。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\"> 本页面需要浏览器支持（启用）JavaScript</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"8-关键字和保留字\"><a href=\"#8-关键字和保留字\" class=\"headerlink\" title=\"8. 关键字和保留字\"></a>8. 关键字和保留字</h2><p>ECMA-262 描述了一组具有特定用途的<strong>关键字</strong>，这些关键字可用于控制语句的开始或结束，或者用于执行特定操作等，不能用作标识符。</p>\n<blockquote>\n<p>break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try</p>\n</blockquote>\n<p>ECMA-262 还描述了一组不能用作标识符的<strong>保留字</strong>：</p>\n<blockquote>\n<p>abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public</p>\n</blockquote>\n<p>如果使用关键字作标识符，会导致 “Identifier Expected” 错误。 有些时候，我们不得不用到保留字货关键字的，比如 CSS 样式中的 float，这时就需要这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style.cssFloat</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-隐式全局变量\"><a href=\"#9-隐式全局变量\" class=\"headerlink\" title=\"9. 隐式全局变量\"></a>9. 隐式全局变量</h2><p>在下面的代码中，由于从右至左的操作符优先级，所以表达式 “b=0” 是先执行的，而此时b未经过声明，所以它会成为全局变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>\n<p>关于全局变量：</p>\n<ul>\n<li>使用 var 创建的全局变量不能删除。</li>\n<li>不是 var 创建的隐含全局变量可以使用 delete 删除（因为它并不是真正的变量，而是全局对象 window 的属性）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> b;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">//  0</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// ReferenceError: b is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-变量提升\"><a href=\"#10-变量提升\" class=\"headerlink\" title=\"10. 变量提升\"></a>10. 变量提升</h2><p><strong>变量提升</strong>是指所有变量的声明语句，都会被提升到代码的头部。 在函数内也一样，函数中的所有变量声明会在函数执行时被“提升”至函数体顶端：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>结果是不是有点出乎你的意料。其实 JavaScript 的执行环境分为<strong>声明阶段</strong>和<strong>执行阶段</strong>，因此对于上面的代码，JavaScript 会这样解释代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-typeof-操作符\"><a href=\"#11-typeof-操作符\" class=\"headerlink\" title=\"11. typeof 操作符\"></a>11. typeof 操作符</h2><p><strong><code>typeof</code></strong>操作符用来检测给定变量的数据类型，可能的返回值：</p>\n<ul>\n<li>“undefined” –&gt; 这个值未定义</li>\n<li>“boolean” –&gt; 这个值是布尔值</li>\n<li>“string” –&gt; 这个值是字符串</li>\n<li>“number” –&gt; 这个值是数值</li>\n<li>“object” –&gt; 这个值是对象或 <strong>null</strong></li>\n<li>“function” –&gt; 这个值是函数</li>\n</ul>\n<h2 id=\"12-undefined-和-null-类型\"><a href=\"#12-undefined-和-null-类型\" class=\"headerlink\" title=\"12. undefined 和 null 类型\"></a>12. undefined 和 null 类型</h2><p><code>Undefined</code> 类型只有一个值，即特殊的 <code>undefined</code>；<code>Null</code> 类型也是只有一个值的数据类型，这个特殊值就是 <code>null</code>；null 和 undefined 没有属性，甚至连 toString() 这种标准方法都没有；undefined 其实是派生自 null 值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"13-Boolean\"><a href=\"#13-Boolean\" class=\"headerlink\" title=\"13. Boolean()\"></a>13. Boolean()</h2><p>要将一个值转换为其对应的 Boolean 值，可以使用转型函数 Boolean()；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'tg'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Boolean</span>(name);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>可以对任何类型的值调用 Boolean 函数，而且总会返回一个 Boolean 值（true 或 false）<strong>转换规则</strong>：</p>\n<ul>\n<li>对于 true 或 false，返回原值（true 或 false）</li>\n<li>对于 String 类型的值，任何非空字符串返回 true，空字符串（””）返回 false</li>\n<li>对于 Number 类型的值，任何非零数字值（包括无穷大），返回 true；0 和 NaN 返回 false</li>\n<li>对于 Object 类型的值，任何对象返回 true，null 返回 false</li>\n<li>对于 Undefined 类型，undefined 返回 false（只有一个值）</li>\n</ul>\n<h2 id=\"14-浮点数值\"><a href=\"#14-浮点数值\" class=\"headerlink\" title=\"14. 浮点数值\"></a>14. 浮点数值</h2><p>保存浮点数值需要的内存空间是保存整数值的两倍。 默认情况下，ECMAScript 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示的数值。 浮点数的最高精度是 17 位小数（所以浮点数的比较比较麻烦）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> = <span class=\"number\">0.3000000000000004</span>; <span class=\"comment\">// 不是等于0.3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"15-数值范围\"><a href=\"#15-数值范围\" class=\"headerlink\" title=\"15. 数值范围\"></a>15. 数值范围</h2><p>ECMAScript 能够表示的最小数值保存在 <code>Number.MIN_VALUE</code>（最小值）中，这个值是 5e-324；能够表示的最大数值保存在 <code>Number.MAX_VALUE</code>（最大值）中，这个值是 1.7976931348623157e+308</p>\n<blockquote>\n<p>注意：Infinity 是不能参与计算的数值。用 <code>isFinite()</code> 来判断这个值是否无穷，该函数接受一个参数。如果参数位于最小与最大数值之间，返回 true。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isFinite</span>(<span class=\"number\">1</span>));  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isFinite</span>(<span class=\"literal\">Infinity</span>));  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"16-NaN\"><a href=\"#16-NaN\" class=\"headerlink\" title=\"16. NaN\"></a>16. NaN</h2><p>NaN（Not a Number）表示非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 注意点：</p>\n<ul>\n<li>任何涉及 NaN 的操作都会返回 NaN。</li>\n<li>NaN 与任何值都不相等，包括 NaN 本身。</li>\n<li>任何操作数与 NaN 比较，都会返回 false</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>);  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>我们可以用 <code>isNaN()</code> 函数来判断是否非数值，该函数接受一个参数，可以是任何类型。<code>isNaN()</code> 在接收到\b这个参数之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，比如：字符串 “10” 或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"number\">10</span>));  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"string\">'blue'</span>));  <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"17-Number\"><a href=\"#17-Number\" class=\"headerlink\" title=\"17. Number()\"></a>17. Number()</h2><p><strong>Number() 函数的转换规则</strong>：</p>\n<ul>\n<li>如果是 Boolean 值，true 和 false 将分别转换为 1 和 0</li>\n<li>如果是数字值，只是简单的传入和返回</li>\n<li>如果是 null 值，返回 0</li>\n<li>如果是 undefined，返回 NaN</li>\n<li>如果是字符串，遵循下列规则： （<ul>\n<li>如果是字符串中只包含数字（包括前面带正负号），则将其转换为十进制数值（前导的零会被忽略）</li>\n<li>如果字符串中包含有效的浮点格式，如 1.1，则将其转换为对应的浮点数值</li>\n<li>如果字符串中包含有效的十六进制，如 0xf，则将其转换为相同大小的十进制数值</li>\n<li>如果字符串是空的，返回0</li>\n<li>如果字符串中包含上述格式以外的字符，返回 NaN ）</li>\n</ul>\n</li>\n<li>如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回字符串值</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">'tg'</span>));   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">''</span>));   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">'0011'</span>));  <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"literal\">true</span>));   <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>一元加操作符的操作与 Number 函数规则相同</p>\n<h2 id=\"18-parseInt-和-parseFloat\"><a href=\"#18-parseInt-和-parseFloat\" class=\"headerlink\" title=\"18. parseInt() 和 parseFloat()\"></a>18. parseInt() 和 parseFloat()</h2><p><code>parseInt()</code> 会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回 NaN。如果第一个字符是数字字符，就会继续解析，直到解析完所有后续字符或者遇到了一个非数字字符。 <code>parseInt()</code> 也能识别八进制（在 ECMAScript 5 中无法识别，将开头的 0 当作 0）和十六进制，最后会转换成十进制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'123tg'</span>));  <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">''</span>));   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'070'</span>));  <span class=\"comment\">// 70</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'0xf'</span>));  <span class=\"comment\">//15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"number\">22.5</span>));  <span class=\"comment\">// 22</span></span><br></pre></td></tr></table></figure>\n<p>我们还可以为 <code>parseInt()</code> 提供第二个参数，指定需要转换的进制（刷算法题的时候经常用到）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'0xAF'</span>,<span class=\"number\">16</span>));  <span class=\"comment\">// 175</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'AF'</span>,<span class=\"number\">16</span>));  <span class=\"comment\">// 175</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'AF'</span>));  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'070'</span>,<span class=\"number\">8</span>));  <span class=\"comment\">// 56</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'70'</span>,<span class=\"number\">8</span>));  <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n<p><code>parseFloat()</code> 和 <code>parseInt()</code> 类似，也是从第一个字符（位置 0）开始解析每个字符，而且一直解析到字符串末尾，或者解析到遇到一个无效的浮点数字字符为止，换句话说，字符串中的第一个小数点是有效的，后面的小数点是无效的，它还会忽略前导的零，只会解析十进制值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'123tg'</span>));  <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'22.12.4'</span>));   <span class=\"comment\">// 22.12</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'070'</span>));  <span class=\"comment\">// 70</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'0xf'</span>));  <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"number\">22.5</span>));  <span class=\"comment\">// 22.5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"19-Object-类型\"><a href=\"#19-Object-类型\" class=\"headerlink\" title=\"19. Object 类型\"></a>19. Object 类型</h2><p>在 ECMAScript 中，<code>Object</code> 类型是所有对象的基础。<code>Object</code> 的每个实例都具有下列属性和方法：</p>\n<ul>\n<li><strong><code>Constructor</code></strong>：保存着用于创建当前对象的函数，比如上面的例子，构造函数就是 Object()</li>\n<li><strong><code>hasOwnProperty(propertyName)</code></strong>：用于检查给定的属性在当前对象实例中是否存在（而不是在实例的原型中），参数必须是字符串形式</li>\n<li><strong><code>isPrototypeOf(object)</code></strong>：用于检查传入的对象是否是另一个对象的原型</li>\n<li><strong><code>propertyIsEnumerable(propertyName)</code></strong>：用于检查给定的属性是否能够使用 for-in 语句来枚举，参数必须是字符串形式</li>\n<li><strong><code>toLocaleString()</code></strong>：返回对象的字符串表示，该字符串与执行环境的地区对应</li>\n<li><strong><code>toString()</code></strong>：返回对象的字符串表</li>\n<li><strong><code>valueOf()</code></strong>：返回对象的字符串、数值或布尔值表示，通常和 toString() 返回的值相同</li>\n</ul>\n<h2 id=\"20-递增和递减\"><a href=\"#20-递增和递减\" class=\"headerlink\" title=\"20. 递增和递减\"></a>20. 递增和递减</h2><p>递减和递增操作符会遵循下列规则：</p>\n<ul>\n<li>当操作数是一个包含有效数字字符的字符串，系统会将其转换为数字值，再执行递减或递增。</li>\n<li>当操作数是一个不包含有效数字字符的字符串，系统将变量的值设置为 NaN</li>\n<li>当操作数是布尔值，会将其转为数值（true 转为 1，false 转为 0）再操作。</li>\n<li>当操作数是浮点数值，直接执行递减或递增</li>\n<li>当操作数是对象，先调用对象的 valueOf() 方法取得一个可供操作的值，然后再遵循上面的三条规则。如果结果是 NaN，则在调用 toString() 方法后再遵循上面的规则转换。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'2'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  valueOf: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a++;  <span class=\"comment\">// 3</span></span><br><span class=\"line\">b++;  <span class=\"comment\">// NaN</span></span><br><span class=\"line\">c--;  <span class=\"comment\">// -1</span></span><br><span class=\"line\">d--;  <span class=\"comment\">// 0.10000000000000009 （浮点数操作结果，类似0.1+0.2 != 0.3）</span></span><br><span class=\"line\">o--;  <span class=\"number\">-2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"21-按位非（NOT）\"><a href=\"#21-按位非（NOT）\" class=\"headerlink\" title=\"21. 按位非（NOT）\"></a>21. 按位非（NOT）</h2><p>位运算符并不直接操作 64 位的值，而是先将 64 位的值转换为 32 位，然后执行操作，最后将结果转换回 64 位。按位非（否运算）就是<strong>一个数与自身的取反值相加，等于 -1</strong>。</p>\n<p>~3 + 3 = -1 =&gt; -1 - 3 = -4 == ~3</p>\n<h2 id=\"22-位运算符\"><a href=\"#22-位运算符\" class=\"headerlink\" title=\"22. 位运算符\"></a>22. 位运算符</h2><p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。</p>\n<p>##23. 逻辑与（&amp;&amp;）</p>\n<p>逻辑与（&amp;&amp;）有两个操作数，如果是布尔值，只有两个都是 true 时，才会返回 true，否则返回 false；逻辑与操作属于短路操作，也就是说如果第一个操作数能够决定结果（等于 false 时），就不会再对第二个操作数求值，如果不是布尔值，它遵循下面的规则：</p>\n<ul>\n<li>如果第一个操作数是对象，则返回第二个操作数</li>\n<li>如果第二个操作数是对象，则只有在第一个操作数的求值为 true 时才会返回第二个操作数</li>\n<li>如果有一个操作数是 null，则返回 null</li>\n<li>如果有一个操作数是 NaN，则返回 NaN</li>\n<li>如果有一个操作数是 undefined，则返回 undefined</li>\n</ul>\n<p>逻辑与操作符也就是先将第一个操作数转换为 Boolean 类型判断是 true 或 false，再根据结果决定是否执行第二个操作数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> &amp;&amp; <span class=\"string\">'tg'</span> ;  <span class=\"comment\">//  0</span></span><br><span class=\"line\">&#123;&#125; &amp;&amp; <span class=\"string\">'tg'</span>;  <span class=\"comment\">// \"tg\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"24-乘法运算符\"><a href=\"#24-乘法运算符\" class=\"headerlink\" title=\"24. 乘法运算符\"></a>24. 乘法运算符</h2><p>乘法运算符(<code>*</code>)，用于计算两个数值的乘积。 处理特殊值时，乘法运算符会遵循下列规则：</p>\n<ul>\n<li>如果操作数都是数值，但乘积超过了 ECMAScript 数值范围，则返回 Infinity 或 -Infinity</li>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果是 Infinity 乘以 0，结果是 NaN</li>\n<li>如果是 Infinity 与非 0 数值相乘，结果是 Infinity 或 -Infinity，取决于非0数值的符号</li>\n<li>如果是 Infinity 与 Infinity 相乘，结果是 Infinity</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> * <span class=\"literal\">NaN</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"literal\">Infinity</span> * <span class=\"number\">2</span>);  <span class=\"comment\">// Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> * <span class=\"number\">0</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> * <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"24-除法运算符\"><a href=\"#24-除法运算符\" class=\"headerlink\" title=\"24. 除法运算符\"></a>24. 除法运算符</h2><p>除法运算符（/），执行第二个操作数除第一个操作数计算。 处理特殊值，规则如下：</p>\n<ul>\n<li>如果操作数都是数值，但商超过了 ECMAScript 的表示范围，则返回 Infinity 或 -Infinity</li>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果是 Infinity 被 Infinity 除，结果是 NaN</li>\n<li>如果是零被零除，结果是 NaN</li>\n<li>如果是非零的有限数被零除，结果是 Infinity 或 -Infinity，取决于有符号的操作数</li>\n<li>如果是 Infinity 被任何非零数值除，结果是 Infinity 或 -Infinity</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> / <span class=\"number\">1</span>); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0</span> / <span class=\"number\">0</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> / <span class=\"number\">0</span>);  <span class=\"comment\">//  Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> / <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> / <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> / <span class=\"number\">2</span>);   <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"25-求模\"><a href=\"#25-求模\" class=\"headerlink\" title=\"25. 求模\"></a>25. 求模</h2><p>求模（余数）运算符（%） 处理特殊值，规则如下：</p>\n<ul>\n<li>如果被除数是无穷大值而除数是有限大的数值，结果是 NaN</li>\n<li>如果被除数是有限大的数值而除数是零，结果是 NaN</li>\n<li>如果是 Infinity 被 Infinity 除，结果是 NaN</li>\n<li>如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数</li>\n<li>如果被除数是零，结果是零</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">5</span> % <span class=\"number\">3</span>);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"26-减法\"><a href=\"#26-减法\" class=\"headerlink\" title=\"26. 减法\"></a>26. 减法</h2><p>减法运算符（-） 对于特殊值，减法操作会遵循下列规则：</p>\n<ul>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果 Infinity 减 Infinity，结果是 NaN</li>\n<li>如果是 -Infinity 减 -Infinity，结果是 NaN</li>\n<li>如果是 Infinity 减 -Infinity，结果是 Infinity</li>\n<li>如果是 -Infinity 减 Infinity，结果是 -Infinity</li>\n<li>如果是 +0 减 +0，结果是 +0</li>\n<li>如果是 -0 加 -0，结果是 +0</li>\n<li>如果是 +0 减 -0，结果是 -0</li>\n<li>如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 将其转换为数值，然后遵循上面的规则进行计算。</li>\n<li>如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值；如果该对象没有 valueOf() 方法，则调用其 toString() 方法将得到的字符串转换为数值，然后遵循上面的规则进行计算。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> - <span class=\"literal\">true</span>;  <span class=\"comment\">// 4 （true转换成1）</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"string\">'2'</span>    <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"literal\">null</span>;  <span class=\"comment\">// 5（null转换成0）</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"27-逗号运算符\"><a href=\"#27-逗号运算符\" class=\"headerlink\" title=\"27. 逗号运算符\"></a>27. 逗号运算符</h2><p>逗号运算符多用于声明多个变量。逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = (<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>);  <span class=\"comment\">// num的值为3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"28-标签语句\"><a href=\"#28-标签语句\" class=\"headerlink\" title=\"28. 标签语句\"></a>28. 标签语句</h2><p>语句是可以添加标签的，标签是由语句前的标识符和冒号组成：</p>\n<blockquote>\n<p><strong>label</strong> : statement</p>\n</blockquote>\n<p>label 语句定义的标签一般由 break 或 continue 语句引用。加标签的语句一般要与 for 等循环语句配合使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">tip : <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">  num += i;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);  <span class=\"comment\">//  轮流输出：0、1、2、3、4、5</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i ==<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span> tip;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num);  <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>当执行到 i = 5 时，会跳出循环，也就是 tip 对应的层，然后执行其下方的代码。</p>\n<h2 id=\"29-with-语句\"><a href=\"#29-with-语句\" class=\"headerlink\" title=\"29. with 语句\"></a>29. with 语句</h2><p><code>with</code> 语句用于临时扩展作用域链，也就是将代码的作用域设置到一个特定的对象中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span>(object)&#123;   </span><br><span class=\"line\">  statement  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将 object 添加到作用域链的头部，然后执行 statement，最后把作用域链恢复到原生状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'tg'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">24</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span>(o)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'name：'</span> + name);  <span class=\"comment\">// name：tg</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'age：'</span> + age);  <span class=\"comment\">// age：24</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>with 里面的 name 相当于 o.name。</p>\n<blockquote>\n<p>注意：在严格模式中是禁止使用 with 语句的，因为 with 语句性能非常差，不推荐使用。</p>\n</blockquote>\n<h2 id=\"30-debugger-语句\"><a href=\"#30-debugger-语句\" class=\"headerlink\" title=\"30. debugger 语句\"></a>30. debugger 语句</h2><p>debugger 语句用来产生一个断点（breakpoint），JavaScript 代码的执行会停止在断点的位置。一般用来调试代码。</p>\n<h2 id=\"31-对象\"><a href=\"#31-对象\" class=\"headerlink\" title=\"31. 对象\"></a>31. 对象</h2><p><strong>键名</strong>：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  <span class=\"string\">'1a'</span> : <span class=\"string\">'a'</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，如果键名 ‘1a’ 不用引号引起来，就会报错。注意：为了避免这种歧义，JavaScript 规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。</p>\n<h2 id=\"32-创建对象\"><a href=\"#32-创建对象\" class=\"headerlink\" title=\"32. 创建对象\"></a>32. 创建对象</h2><p>在 JavaScript 中，有三种方法创建对象</p>\n<ul>\n<li>对象直接量： var o={};</li>\n<li>关键字new： var o=new Object();</li>\n<li>Object.create() 函数： var o=Object.create(null)</li>\n</ul>\n<h3 id=\"提取方法\"><a href=\"#提取方法\" class=\"headerlink\" title=\"提取方法\"></a>提取方法</h3><p>如果对对象中的方法进行提取，则会失去与对象的连接。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.get());  <span class=\"comment\">//  \"a\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = obj.get;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func());  <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，object 对象中有一个方法 get()，用来获取 obj 对象中的 name，而当 get() 方法赋值给一个变量 func，再调用 func() 函数时，此时的 this 是指向 window 的，而非 obj 的。注意：如果在严格模式下，this 会是 undefined。</p>\n<h3 id=\"属性特性\"><a href=\"#属性特性\" class=\"headerlink\" title=\"属性特性\"></a>属性特性</h3><ul>\n<li>可写（writable attribute）：可设置该属性的值。</li>\n<li>可枚举（enumerable attribute）：可通过 for / in 循环返回该属性。</li>\n<li>可配置（configurable attribute）：可删除或修改属性。</li>\n</ul>\n<h3 id=\"查看所有属性\"><a href=\"#查看所有属性\" class=\"headerlink\" title=\"查看所有属性\"></a>查看所有属性</h3><p>查看一个对象本身的所有属性，可以使用 Object.keys 方法，返回一个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  age : <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(o)  <span class=\"comment\">// ['name','age']</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h3><p>delete 运算符可以删除对象的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.name  <span class=\"comment\">//true</span></span><br><span class=\"line\">o.name  <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：delete 运算符只能删除自有属性，不能删除继承属性。 删除一个不存在的属性，delete 不报错，而且返回 true。只有一种情况，delete 命令会返回 false，那就是该属性存在，且不得删除。</p>\n</blockquote>\n<h2 id=\"33-序列化对象\"><a href=\"#33-序列化对象\" class=\"headerlink\" title=\"33. 序列化对象\"></a>33. 序列化对象</h2><p>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 在 JavaScript 中，提供了内置函数 <strong>JSON.stringify()</strong> 和 <strong>JSON.parse()</strong> 用来序列化和还原 JavaScript 对象。NaN、Infinity 和 -Infinity 序列化的结果是 null</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  age : <span class=\"number\">12</span>,</span><br><span class=\"line\">  intro : \\[<span class=\"literal\">false</span>,<span class=\"literal\">null</span>,<span class=\"string\">''</span>\\]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s= <span class=\"built_in\">JSON</span>.stringify(o)  <span class=\"comment\">// s &#123;\"name\":\"a\",\"age\":12,\"intro\":[false,null,\"\"]&#125;</span></span><br><span class=\"line\">p=<span class=\"built_in\">JSON</span>.parse(s)  <span class=\"comment\">// p是o的深拷贝</span></span><br></pre></td></tr></table></figure>\n<p>注意：JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。</p>\n<h2 id=\"34-原型\"><a href=\"#34-原型\" class=\"headerlink\" title=\"34. 原型\"></a>34. 原型</h2><p>每一个 JavaScript 对象（null 除外）都和另一个对象相关联，也可以说，继承另一个对象。另一个对象就是我们熟知的“原型”（prototype），每一个对象都从原型继承属性。只有 null 除外，它没有自己的原型对象。所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。比如：通过 new Object() 创建的对象继承自 Object.prototype；通过 new Array() 创建的对象的原型就是 Array.prototype。没有原型的对象为数不多，Object.prototype 就是其中之一，它不继承任何属性。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。</p>\n<h2 id=\"35-空位\"><a href=\"#35-空位\" class=\"headerlink\" title=\"35. 空位\"></a>35. 空位</h2><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在<strong>空位</strong>（hole）。如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [,,];</span><br><span class=\"line\">arr.length  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"36-类数组对象\"><a href=\"#36-类数组对象\" class=\"headerlink\" title=\"36. 类数组对象\"></a>36. 类数组对象</h2><p>在 JavaScript 中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用 length 属性，但是它们并不是数组，无法使用一些数组的方法。<code>类数组对象</code>有一个特征，就是具有 length 属性。换句话说，只要有 length 属性，就可以认为这个对象类似于数组。但是，对象的 length 属性不是动态值，不会随着成员的变化而变化。典型的类似数组的对象是函数的 <strong>arguments 对象</strong>，以及<strong>大多数 DOM 元素集</strong>，还有<strong>字符串</strong>。</p>\n<h2 id=\"37-函数表达式\"><a href=\"#37-函数表达式\" class=\"headerlink\" title=\"37. 函数表达式\"></a>37. 函数表达式</h2><p>采用函数表达式声明函数时，function 命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"38-函数被提前\"><a href=\"#38-函数被提前\" class=\"headerlink\" title=\"38. 函数被提前\"></a>38. 函数被提前</h2><p>就像变量的“被提前”一样，函数声明语句也会“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。在函数提升中，函数体也会跟着提升（不像变量一样，只会提升变量声明），这也是我们可以引用后面声明的函数的原因。 此外，<strong>以表达式定义的函数并没有“被提前”，而是以变量的形式“被提前”</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f();  </span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>\n<p>变量其实是分为声明，赋值两部分的，上面的代码等同于下面的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f;</span><br><span class=\"line\">f();</span><br><span class=\"line\">f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"39-实参对象\"><a href=\"#39-实参对象\" class=\"headerlink\" title=\"39. 实参对象\"></a>39. 实参对象</h2><p><code>arguments</code> 类数组中每一个元素的值会与对应的命名参数的值保持同步，这种影响是单向的，也可以这样说，<strong>如果是修改 <code>arguments</code> 中的值，会影响到命名参数的值，但是修改命名参数的值，并不会改变 <code>arguments</code> 中对应的值</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);    <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] = <span class=\"literal\">null</span>;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);    <span class=\"comment\">// null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p><code>arguments</code> 并不是真正的数组，它只是类数组对象（有 length 属性且可使用索引来访问子项）。但我们可以借助 Array 类的原型对象的 slice 方法，将其转为真正的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 更简洁的写法</span></span><br><span class=\"line\">[].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"40-函数的属性、方法\"><a href=\"#40-函数的属性、方法\" class=\"headerlink\" title=\"40. 函数的属性、方法\"></a>40. 函数的属性、方法</h2><h3 id=\"name-属性\"><a href=\"#name-属性\" class=\"headerlink\" title=\"name 属性\"></a>name 属性</h3><p>name 属性返回紧跟在 function 关键字之后的那个函数名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">f.name   <span class=\"comment\">// f</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"length-属性\"><a href=\"#length-属性\" class=\"headerlink\" title=\"length 属性\"></a>length 属性</h3><p>函数的 length 属性是只读属性，代表函数形参的数量，也就是在函数定义时给出的形参个数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x,y</span>)</span>&#123;&#125;</span><br><span class=\"line\">f.length  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"41-立即调用的函数表达式（IIFE）\"><a href=\"#41-立即调用的函数表达式（IIFE）\" class=\"headerlink\" title=\"41. 立即调用的函数表达式（IIFE）\"></a>41. 立即调用的函数表达式（IIFE）</h2><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：</p>\n<ul>\n<li>一是不必为函数命名，避免了污染全局变量；</li>\n<li>二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li>\n</ul>\n<h2 id=\"42-Object-对象的静态方法\"><a href=\"#42-Object-对象的静态方法\" class=\"headerlink\" title=\"42. Object 对象的静态方法\"></a>42. Object 对象的静态方法</h2><p><code>Object.keys()</code> 方法和 <code>Object.getOwnPropertyNames()</code> 方法一般用来遍历对象的属性，它们的参数都是一个对象，返回一个数组，该数组的项都是对象自身的（不是继续原型的）的所有属性名。两者的区别在于， <code>Object.keys()</code> 只返回可枚举的属性，<code>Object.getOwnPropertyNames()</code> 方法还返回不可枚举的属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(arr));  <span class=\"comment\">// [\"0\", \"1\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(arr)); <span class=\"comment\">// [\"0\", \"1\", \"length\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"43-splice\"><a href=\"#43-splice\" class=\"headerlink\" title=\"43. splice()\"></a>43. splice()</h2><p><code>splice()</code> 用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素，该方法会改变原数组。第一个参数是删除的起始位置，如果是负数，就表示从倒数位置开始删除 第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如只是单纯地插入元素，splice 方法的第二个参数可以设为 0。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>));  <span class=\"comment\">// [\"b\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"c\", \"d\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'f'</span>));   <span class=\"comment\">// [\"b\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"f\", \"c\", \"d\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"string\">'h'</span>));  <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"h\", \"b\", \"c\", \"d\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"44-some-、every\"><a href=\"#44-some-、every\" class=\"headerlink\" title=\"44. some()、every()\"></a>44. some()、every()</h2><p><code>some()</code> 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是 true，则整个 some 方法的返回值就是 true，否则 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v == <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>every()</code> 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是 true，才返回 true，否则 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v == <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool);  <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bool2 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool2);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>some 和 every 方法还可以接受第二个参数，用来绑定函数中的 this 关键字。</p>\n<h2 id=\"45-基本包装类型\"><a href=\"#45-基本包装类型\" class=\"headerlink\" title=\"45. 基本包装类型\"></a>45. 基本包装类型</h2><p>ECMAScript 提供了三个基本包装类型：<code>Boolean</code>、<code>Number</code>、<code>String</code>。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能过调用一些方法来操作这些数据。执行步骤如下：</p>\n<ol>\n<li>创建那个类型的一个实例</li>\n<li>在实例上调用指定的方法</li>\n<li>销毁这个实例</li>\n</ol>\n<p>引用类型与基本包装类型的区别在于对象的生存期：使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁，这也是我们不能再运行时为基本类型值添加属性和方法的原因。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'tg'</span>;</span><br><span class=\"line\">s.age =<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.age);  <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码执行输出的是 undefined，这是音乐第二行创建的 String 对象在执行第三行代码时已经被销毁了，第三行又创建自己的 String 对象，而该对象没有 age 属性。</p>\n<h2 id=\"46-Boolean-类型\"><a href=\"#46-Boolean-类型\" class=\"headerlink\" title=\"46. Boolean 类型\"></a>46. Boolean 类型</h2><p>即使你使用 false 创建一个 Boolean 实例对象，当进行逻辑运算时，它会被转为 true，因为它是一个对象，而所有对象在逻辑运算中都会返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(bool)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"47-document-referrer\"><a href=\"#47-document-referrer\" class=\"headerlink\" title=\"47. document.referrer\"></a>47. document.referrer</h2><p>document.referrer 属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。 注：HTTPS 默认会关闭 referrer，需要通过 meta 来设置，设置方法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"referrer\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"always\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"48-数据集（dataset）属性\"><a href=\"#48-数据集（dataset）属性\" class=\"headerlink\" title=\"48. 数据集（dataset）属性\"></a>48. 数据集（dataset）属性</h2><p>在 HTML5 文档中，任意以 “data-” 为前缀的小写的属性名字都是合法的。 HTML5 还在 Element 对象上定义了 dataset 属性。该属性指代一个对象，它的各个属性对应于去掉前缀的 data-属性。因此 dataset.x 应该保存 data-x 属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test 属性就变成 dataset.jqueryTest 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"top\"</span> <span class=\"attr\">data-tip</span>=<span class=\"string\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'top'</span>);</span><br><span class=\"line\">t.dataset.tip  <span class=\"comment\">//title</span></span><br><span class=\"line\">t.dataset.tip = <span class=\"string\">'title2'</span></span><br></pre></td></tr></table></figure>\n<p>注意：dataset 属性是元素的 data-属性 的实时、双向接口。设置或删除 dataset 的一个属性就等同于设置或移除对应元素的 data-属性。</p>\n<h2 id=\"49-addEventListener\"><a href=\"#49-addEventListener\" class=\"headerlink\" title=\"49. addEventListener()\"></a>49. addEventListener()</h2><p>调用 addEventListener() 并不会影响 onclick 属性的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mybutton\"</span>&gt;</span>点击<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mybutton'</span>);</span><br><span class=\"line\">v.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;alert(<span class=\"string\">'1'</span>);&#125;</span><br><span class=\"line\">v.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'2'</span>);&#125;,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，单击按钮会产生两个 alert() 对话框。 能通过多次调用 addEventListener() 方法为同一个对象注册同一事件类型的多个处理程序函数。</p>\n<h2 id=\"50-调用顺序\"><a href=\"#50-调用顺序\" class=\"headerlink\" title=\"50. 调用顺序\"></a>50. 调用顺序</h2><p>文档元素或其他对象可以指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照下面的规则调用所有的事件处理程序：</p>\n<ul>\n<li>通过设置对象属性或 HTML 属性注册的处理程序一直优先调用。</li>\n<li>使用 addEventListener() 注册的处理程序按照它们的注册顺序调用。</li>\n<li>使用 attachEvent() 注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。</li>\n</ul>\n<h2 id=\"51-进度事件\"><a href=\"#51-进度事件\" class=\"headerlink\" title=\"51. 进度事件\"></a>51. 进度事件</h2><p>进度事件用来描述一个事件进展的过程。比如 XMLHttpRequest 对象发出的 HTTP 请求的过程，<code>&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;</code> 加载外部资源的过程。下载和上传都会发生进度事件。进度事件有以下几种：</p>\n<ul>\n<li>abort 事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。</li>\n<li>error 事件：由于错误导致资源无法加载时触发。</li>\n<li>load 事件：进度成功结束时触发。</li>\n<li>loadstart 事件：进度开始时触发。</li>\n<li>loaden d事件：进度停止时触发，发生顺序排在 error 事件 / abort 事件 / load 事件后面。</li>\n<li>progress 事件：当操作处于进度之中，由传输的数据块不断触发。</li>\n<li>timeout 事件：进度超过限时触发。</li>\n</ul>\n<h2 id=\"52-JSON-语法\"><a href=\"#52-JSON-语法\" class=\"headerlink\" title=\"52. JSON 语法\"></a>52. JSON 语法</h2><p>JSON 对值的类型和格式有严格的规定：</p>\n<ul>\n<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li>\n<li>简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和 null（不能使用 NaN, Infinity, -Infinity 和 undefined）。</li>\n<li>字符串必须使用双引号表示，不能使用单引号。</li>\n<li>对象的键名必须放在双引号里面。</li>\n<li>数组或对象最后一个成员的后面，不能加逗号。</li>\n</ul>\n<h2 id=\"53-上传文件\"><a href=\"#53-上传文件\" class=\"headerlink\" title=\"53. 上传文件\"></a>53. 上传文件</h2><p>如果要允许选择多个文件，可设置 file 控件的 multiple 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">multiple</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"54-同源策略\"><a href=\"#54-同源策略\" class=\"headerlink\" title=\"54. 同源策略\"></a>54. 同源策略</h2><p>同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 <code>&lt;iframe&gt;</code> 元素或打开其他浏览器窗口的时候，这一策略通常就会发挥作用。所谓“同源”指的是”三个相同“。</p>\n<ul>\n<li><strong>协议</strong>相同</li>\n<li><strong>域名</strong>相同</li>\n<li><strong>端口</strong>相同</li>\n</ul>\n<p>从不同 Web 服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用 http:协议 载入的文档和使用 https:协议 载入的文档具有不同的来源，即使它们来自同一个服务器。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<h2 id=\"55-获取表单元素\"><a href=\"#55-获取表单元素\" class=\"headerlink\" title=\"55. 获取表单元素\"></a>55. 获取表单元素</h2><p>获取表单元素一般有两种方式：</p>\n<ul>\n<li>通过 id 来获取，比如获取一个 id 名为 form1 的表单元素：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'form1'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 docuemnt.forms 获取 name 名为 form1 的表单元素：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.forms[<span class=\"string\">\"form1\"</span>]</span><br></pre></td></tr></table></figure>\n<p><code>document.forms</code> 可以获取到当前页面中所有的表单元素，我们又可以通过方括号表示法获取某个属性，传入数值索引或 <code>name</code> 值。</p>\n<h2 id=\"56-重置表单\"><a href=\"#56-重置表单\" class=\"headerlink\" title=\"56. 重置表单\"></a>56. 重置表单</h2><p>重置表单也有两种方式：</p>\n<h3 id=\"重置按钮\"><a href=\"#重置按钮\" class=\"headerlink\" title=\"重置按钮\"></a>重置按钮</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"reset\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"reset\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当点击重置按钮时，会触发 reset 事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form1.onreset = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过-reset-方法\"><a href=\"#通过-reset-方法\" class=\"headerlink\" title=\"通过 reset() 方法\"></a>通过 reset() 方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form1.reset();</span><br></pre></td></tr></table></figure>\n<p>与调用 submit() 不同，调用 reset() 方法时也会触发 reset 事件。</p>\n<h2 id=\"57-离线检测\"><a href=\"#57-离线检测\" class=\"headerlink\" title=\"57. 离线检测\"></a>57. 离线检测</h2><p>HTML5 定义了一个 <code>navigator.onLine</code> 属性，用来检测设备是在线还是离线，为 true 时表示设备能上网，否则表示设备离线。 检测代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.onLine)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正常工作</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设备已离线</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了 <code>navigator.onLine</code> 属性，HTML5 还为检测网络是否可用提供了两个事件：<code>online</code> 和 <code>offline</code>。</p>\n<ul>\n<li><code>online</code>：当网络从离线变为在线时触发</li>\n<li><code>offline</code>：当网络从在线变为离线时触发</li>\n</ul>\n<h2 id=\"58-应用缓存\"><a href=\"#58-应用缓存\" class=\"headerlink\" title=\"58. 应用缓存\"></a>58. 应用缓存</h2><p>HTML5 的应用缓存（application cache），简称：appcache，是专门为开发离线 Web 应用而设计的。 Appcache 就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。<code>manifest</code> 文件可分为三个部分：</p>\n<ul>\n<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>\n<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>\n<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"># 需要缓存的列表</span><br><span class=\"line\">test.css</span><br><span class=\"line\">test.jpg</span><br><span class=\"line\">test.js</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\"># 不需要缓存的</span><br><span class=\"line\">test2.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\"># 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件 *.html /offline.html</span><br><span class=\"line\">2.jpg/3.jpg</span><br></pre></td></tr></table></figure>\n<p>注意：manifest 文件的 <code>MIME</code> 类型必须是 “text/cache-manifest”。</p>\n<blockquote>\n<p>描述文件的扩展名以前推荐用 manifest，现在推荐用 appcache</p>\n</blockquote>\n<h2 id=\"59-localStorage-和-sessionStorage\"><a href=\"#59-localStorage-和-sessionStorage\" class=\"headerlink\" title=\"59. localStorage 和 sessionStorage\"></a>59. localStorage 和 sessionStorage</h2><p><code>localStorage</code> 和 <code>sessionStorage</code>这两个属性都代表同一个 Storage 对象（一个持久化关联数组，数组使用字符串来索引，存储的值都是字符串形式的）。</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>通过 <code>localStorage</code> 存储的数据是永久性的，除非Web应用刻意删除存储的数据或用户通过设置浏览器设置来删除，否则数据将一直保留在用户的电脑里，永不过期。<code>localStorage</code> 的作用域是限定在文档源（document origin）级别。 同源的文档间共享同样的 <code>localStorage</code> 数据。</p>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p><code>sessionStorage</code> 的作用域同样是限定在文档源中，不过它被限定在窗口中。也就是说，如果同源的文档在不同的浏览器标签页中，那它们互相之间拥有的是各自的 <code>sessionStorage</code> 数据，无法共享。</p>\n<p>注意：基于窗口作用域的 <code>sessionStorage</code> 指的窗口只是顶级窗口。如果一个浏览器标签页包含多个 <code>&lt;iframe&gt;</code> 元素，它们包含的文档是同源的，两者之间的 sessionStorage 是可共享的。</p>\n<h2 id=\"60-finally-子句\"><a href=\"#60-finally-子句\" class=\"headerlink\" title=\"60. finally 子句\"></a>60. finally 子句</h2><p>当使用 <code>finally</code> 子句时，其代码无论如何都会执行，也就是说，不管是正常执行还是出错了，<code>finally</code> 子句都会执行。甚至 <code>return</code> 语句，也不会阻止 <code>finally</code> 子句的执行。看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(error)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test()); </span><br><span class=\"line\"><span class=\"comment\">//结果</span></span><br><span class=\"line\">a</span><br><span class=\"line\">c</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>从运行结果，我们可以看到，<code>return</code> 语句并没有阻止 <code>finally</code> 子句的执行，而且是在 <code>finally</code> 子句执行后才会返回 <code>return</code> 语句的值。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"JS中的传值与传址","slug":"JS中的传值与传址","date":"2017-04-25T12:36:04.000Z","updated":"2019-02-07T13:01:36.415Z","comments":true,"path":"api/articles/JS中的传值与传址.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_21.jpg","content":"<p>在 JS 中，有两种不同的方式可以操作数据的值，这两种技术分别叫做<strong>传值</strong>和<strong>传址</strong>。</p>\n<h2 id=\"数据值的操作\"><a href=\"#数据值的操作\" class=\"headerlink\" title=\"数据值的操作\"></a>数据值的操作</h2><p>要知道传址跟传址，首先我们先了解下数据值的操作。</p>\n<ol>\n<li><strong>复制</strong>：可以把它赋值给一个新的变量</li>\n<li><strong>传递</strong>：可以将他传递给一个函数或者方法</li>\n<li><strong>比较</strong>：可以与另外一个值比较，判断是否相等</li>\n</ol>\n<h2 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h2><p><strong>传值</strong>：在赋值过程中，首先对值进行了一份拷贝，而后将这份拷贝存储到一个变量、对象属性或数组元素中。拷贝的值和原始的值是完全独立、互不影响的。当一份数据通过值传递给一个函数，实际上被传递的不是数据本身，而是数据的一份拷贝。因此，如果函数修改了这个值，影响到的只是数据的那份拷贝，而并不影响数据本身。</p>\n<p><strong>传址</strong>：在赋值过程中，变量实际上存储的是数据的地址（对数据的引用），而不是原始数据或者是数据的拷贝。如果值通过一个地址发生了改变，这个改变也会通过原始地址表现出来。</p>\n<h2 id=\"参阅对比表\"><a href=\"#参阅对比表\" class=\"headerlink\" title=\"参阅对比表\"></a>参阅对比表</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>传值</th>\n<th>传址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复制</td>\n<td>实际复制的是值，存在于两个不同的独立拷贝</td>\n<td>复制的只是对数值的引用，即地址，如果通过这个新的引用修改了数值，这个改变对最初的引用也是可见的</td>\n</tr>\n<tr>\n<td>传递</td>\n<td>传递给函数的值是一个独立的拷贝，对它的改变函数外没有影响</td>\n<td>传递给函数的是对数值的一个引用。如果通过这个新的引用修改了数值，这个改变对最初的引用也是可见的</td>\n</tr>\n<tr>\n<td>比较</td>\n<td>比较两个独立的值，判断是否相同</td>\n<td>比较的是两个的引用，判断引用是否是同一个数值。对两个不同数值的引用不相等，即使这两个数值相等</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>根据操作数据方式的不同，我们可以把数据类型分为两类：<strong>基础类型</strong>和<strong>引用类型</strong>。</p>\n<ul>\n<li>基础类型主要有：数字(Number)、布尔类型(Boolean)；其操作方式为传值。</li>\n<li>引用类型主要有：对象(Object) —— 数组(Array)、函数(Function)；其操作方式为传址。</li>\n</ul>\n<p>数字和布尔类型是基础类型，它们是由很小的，固定数目字节组成，所以可以通过传值来操作；而数组和函数，是对象的特殊类型，也是引用类型。由于对象没有固定大小，所以无法通过传值进行操作。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"传值（赋值操作）\"><a href=\"#传值（赋值操作）\" class=\"headerlink\" title=\"传值（赋值操作）\"></a>传值（赋值操作）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>, b = a, a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"a=\"</span> + a + <span class=\"string\">\",b=\"</span> + b);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_21.jpg\" alt=\"\" width=\"400\"></div>\n\n<p>a 先是被赋值为 1，接着把 a 的值赋给 b，这时会进行值的拷贝，因此b = 1；然后又把 a 赋值为 2。在没有执行 a = 2 之前，我们试试下列代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b);  <span class=\"comment\">// 输出为true. 可见它们在内存中是指向同一个位置的。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"传值（基础类型）\"><a href=\"#传值（基础类型）\" class=\"headerlink\" title=\"传值（基础类型）\"></a>传值（基础类型）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;            <span class=\"comment\">// 将a复制给b</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add1</span>(<span class=\"params\">x,y</span>) </span>&#123;     <span class=\"comment\">// 函数修改参数的值</span></span><br><span class=\"line\">  x = x + y;              <span class=\"comment\">// 虽然这个里面将值进行相加，但是仅仅是值的独立拷贝，进行相加，在函数外面没有影响</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add1(a,b);                <span class=\"comment\">// 数字类型为传值</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\"n\"</span> + <span class=\"string\">\"b:\"</span> + b);      <span class=\"comment\">// a为1，b为1  </span></span><br><span class=\"line\">(a == b) ? c = <span class=\"string\">\"true\"</span> : c = <span class=\"string\">\"false\"</span>;  </span><br><span class=\"line\">alert(c);         <span class=\"comment\">// c = \"true\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"传址（引用类型）\"><a href=\"#传址（引用类型）\" class=\"headerlink\" title=\"传址（引用类型）\"></a>传址（引用类型）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];      <span class=\"comment\">// 定义数组，引用类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;                           <span class=\"comment\">// 将a复制给b</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123;           <span class=\"comment\">// 函数修改参数的值</span></span><br><span class=\"line\">  x[<span class=\"number\">0</span>] = <span class=\"string\">\"tt\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(b);             <span class=\"comment\">// 数组对象为传址  </span></span><br><span class=\"line\">alert(<span class=\"string\">\"a:\"</span> + a[<span class=\"number\">0</span>] + a[<span class=\"number\">1</span>] + a[<span class=\"number\">2</span>] + a[<span class=\"number\">3</span>] + <span class=\"string\">\"n\"</span> + <span class=\"string\">\"b:\"</span> + b[<span class=\"number\">0</span>] + b[<span class=\"number\">1</span>] + b[<span class=\"number\">2</span>] + b[<span class=\"number\">3</span>]);  <span class=\"comment\">// b对象修改，则a也会修改，传址</span></span><br><span class=\"line\">(a == b) ? q = <span class=\"string\">\"true\"</span> : q = <span class=\"string\">\"false\"</span>;    <span class=\"comment\">// 判断 a=b  ，返回true</span></span><br><span class=\"line\">alert(q);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];</span><br><span class=\"line\">(a == b) ? q = <span class=\"string\">\"true\"</span> : q = <span class=\"string\">\"false\"</span>;     <span class=\"comment\">// 这里定义了两个对象，虽然值一样，但是不是同样的地址，所以为false</span></span><br><span class=\"line\">alert(q);    <span class=\"comment\">// 输出\"false\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数内的特殊引用\"><a href=\"#函数内的特殊引用\" class=\"headerlink\" title=\"函数内的特殊引用\"></a>函数内的特殊引用</h3><p>按值传递一个参数给函数就是制作该参数的一个独立复本，即一个只存在于该函数内的复本。即使按引用传递对象和数组时，如果直接在函数中用新值覆盖原先的值，在函数外并不反映新值。只有在对象的属性或者数组的元素改变时，在函数外才可以看出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newa = <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  newa[<span class=\"number\">0</span>] = a[<span class=\"number\">0</span>] + b;</span><br><span class=\"line\">  newa[<span class=\"number\">1</span>] = a[<span class=\"number\">1</span>] + b;</span><br><span class=\"line\">  newa[<span class=\"number\">2</span>] = a[<span class=\"number\">2</span>] + b;</span><br><span class=\"line\">  a = newa;     <span class=\"comment\">// 重新覆盖了引用，所以外部是不可见的</span></span><br><span class=\"line\">  alert(a[<span class=\"number\">0</span>]);  <span class=\"comment\">// 11</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(a1, <span class=\"number\">10</span>);   </span><br><span class=\"line\">alert(a1[<span class=\"number\">0</span>]);     <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h2><p>前面看了这么多类型，一直都没有介绍字符串类型，它不好直接分为基础类型和引用类型，因为字符串\b可以是任意的长度，看上去应该是引用类型，可是他却不是对象，所以也不可作为引用类型；总结一下，<strong>字符串是按引用(即地址)复制和传递的，但是是按值来比较的。</strong></p>\n<p>请注意，假如有两个 String 对象（用 new String(“something”) 创建的），按引用比较它们，但是，如果其中一个或者两者都是字符串值的话，按值比较它们</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>复制</th>\n<th>传递</th>\n<th>比较</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数字</td>\n<td>传值</td>\n<td>传值</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>布尔</td>\n<td>传值</td>\n<td>传值</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>不可变</td>\n<td>不可变</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>对象</td>\n<td>传址</td>\n<td>传址</td>\n<td>传址</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/joe2014/archive/2014/06/28/3813919.html\" target=\"_blank\" rel=\"noopener\">JS 基础知识2 传值和传址</a></li>\n<li><a href=\"http://www.cnblogs.com/idayln/p/3346242.html\" target=\"_blank\" rel=\"noopener\">图解JS的传值与传址</a></li>\n<li><a href=\"http://lxneliu.iteye.com/blog/1567205\" target=\"_blank\" rel=\"noopener\">JS 传值与传址</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"浏览器中输入url后发生了什么","slug":"浏览器中输入url后发生了什么","date":"2017-04-24T13:18:56.000Z","updated":"2019-02-07T13:01:36.423Z","comments":true,"path":"api/articles/浏览器中输入url后发生了什么.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_34.png","content":"<p>本文转载自<a href=\"http://www.jianshu.com/p/c1dfc6caa520\" target=\"_blank\" rel=\"noopener\">简书-浏览器中输入url后发生了什么</a>，其实这个问题在前端面试中经常遇到，所以网上有很多关于这个问题的文章，但是我感觉这篇文章是表达的最清晰的，感兴趣的童鞋可以点击上面的链接查看原文，不过在本文中，我又补充了一些其他文章中的相关内容，同时加入了一些我自己的理解，争取让初学者更容易看懂 先上一张思维导图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_34.png\" alt=\"\" width=\"900\"></div>\n\n<p>上面这张图用非常简练的语言总结了浏览器中输入 url 后发生的事情以及顺序，下面按照执行顺序分为六步进行描述：</p>\n<h2 id=\"1-DNS-域名解析\"><a href=\"#1-DNS-域名解析\" class=\"headerlink\" title=\"1. DNS 域名解析\"></a>1. DNS 域名解析</h2><ul>\n<li>在浏览器 DNS 缓存中搜索</li>\n<li>在操作系统 DNS 缓存中搜索</li>\n<li>读取系统 hosts 文件，查找其中是否有对应的 ip</li>\n<li>向本地配置的首选 DNS 服务器发起域名解析请求</li>\n</ul>\n<p>以上四个步骤其实都是 DNS 的解析过程，总结一下就是先看有没有缓存，如果没有就发起DNS域名解析请求，具体过程其实比较复杂，可以查看<a href=\"http://www.cnblogs.com/vincently/p/4670597.html\" target=\"_blank\" rel=\"noopener\">DNS原理及解析过程</a>进行更深入的了解</p>\n<h2 id=\"2-建立-TCP-连接\"><a href=\"#2-建立-TCP-连接\" class=\"headerlink\" title=\"2.建立 TCP 连接\"></a>2.建立 TCP 连接</h2><p>为了准确地传输数据，TCP 协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有 SYN/ACK(acknowledegment) 标志的数据包以示传达确认信息。最后发送方再回传一个带 ACK 标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP 会再次发送相同的数据包。TCP 是一个端到端的可靠的面向连接的协议，所以 HTTP 基于传输层 TCP 协议不用担心数据的传输的各种问题。当然，TCP 三次握手也是一个可以展开的问题，而且为什么使用三次握手也是大有学问，可以去我的另外一篇文章：<a href=\"/20170405/tcp-three-handshakes-and-four-breakups.html\">前端面试系列（8）——TCP的三次握手与四次分手</a>中寻找答案</p>\n<h2 id=\"3-发起-HTTP-请求\"><a href=\"#3-发起-HTTP-请求\" class=\"headerlink\" title=\"3. 发起 HTTP 请求\"></a>3. 发起 HTTP 请求</h2><p>HTTP 的请求方法（method）有以下几种：</p>\n<ul>\n<li>GET: 获取资源</li>\n<li>POST: 传输实体主体</li>\n<li>HEAD: 获取报文首部</li>\n<li>PUT: 传输文件</li>\n<li>DELETE: 删除文件</li>\n<li>OPTIONS: 询问支持的方法</li>\n<li>TRACE: 追踪路径</li>\n</ul>\n<p>其中最常用的就是 GET 和 POST 了，请求报文格式如下所示（HTTP/1.1）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_33.png\" alt=\"\" width=\"900\"></div>\n\n<h2 id=\"4-接受响应结果\"><a href=\"#4-接受响应结果\" class=\"headerlink\" title=\"4. 接受响应结果\"></a>4. 接受响应结果</h2><p>客户端在发出请求之后，服务器会在接收到请求之后返回客户端响应结果，该结果就是服务器告知客户端的当前状态，下面是状态码的分类，更多关于状态码的详细内容请移步<a href=\"/20170404/status-code-of-http-request.html\">前端面试系列（6）——HTTP请求的状态码</a>：</p>\n<ul>\n<li>1**：信息性状态码</li>\n<li>2**：成功状态码</li>\n<li>3**：重定向状态码</li>\n<li>4**：客户端错误状态码</li>\n<li>5**：服务器错误状态码</li>\n</ul>\n<p>响应报文：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_35.png\" alt=\"\" width=\"900\"></div>\n\n<h2 id=\"5-浏览器解析-html\"><a href=\"#5-浏览器解析-html\" class=\"headerlink\" title=\"5. 浏览器解析 html\"></a>5. 浏览器解析 html</h2><p>浏览器按顺序解析 html 文件，构建 DOM 树，在解析到外部的 css 和 js 文件时，向服务器发起请求下载资源，若是下载 css 文件，则解析器会在下载的同时继续解析后面的 html 来构建 DOM 树，但是在下载 js 文件和执行它时，解析器会停止对 html 的解析。这便出现了 js 阻塞问题。</p>\n<h3 id=\"预加载器：\"><a href=\"#预加载器：\" class=\"headerlink\" title=\"预加载器：\"></a>预加载器：</h3><p>当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的 html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索 HTML 标签中的 URL，无法检测到使用脚本添加的 URL，这些资源要等脚本代码执行时才会获取。（注: 预解析并不改变 Dom 树，它将这个工作留给主解析过程），浏览器解析 css，形成 CSSOM 树，当 DOM 树构建完成后，浏览器引擎通过 DOM 树和 CSSOM 树构造出渲染树（Render 树）。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head 元素和 display 值为 none 的元素）</p>\n<blockquote>\n<p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n</blockquote>\n<h2 id=\"6-浏览器布局渲染\"><a href=\"#6-浏览器布局渲染\" class=\"headerlink\" title=\"6. 浏览器布局渲染\"></a>6. 浏览器布局渲染</h2><ul>\n<li>布局（Layout）：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。</li>\n<li>绘制（Paint）：将计算好的每个像素点信息绘制在屏幕上</li>\n</ul>\n<p>在页面显示的过程中会多次进行 Reflow 和 Repaint 操作，而 Reflow 的成本比 Repaint 的成本高得多的多。因为 Repaint 只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的 display 属性由 block 改为 none 则需要 Reflow。如何减少 rpaint 和 reflow 也是<a href=\"/20170416/front-end-performance-optimization.html\">前端优化</a>需要考虑的问题：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_36.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/c1dfc6caa520\" target=\"_blank\" rel=\"noopener\">浏览器中输入url后发生了什么</a></li>\n<li><a href=\"http://coolshell.cn/articles/9666.html\" target=\"_blank\" rel=\"noopener\">浏览器的渲染原理简介</a></li>\n<li><a href=\"http://www.cnblogs.com/yuezk/archive/2013/01/11/2855698.html\" target=\"_blank\" rel=\"noopener\">了解html页面的渲染过程</a></li>\n<li><a href=\"https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/\" target=\"_blank\" rel=\"noopener\">老生常谈-从输入url到页面展示到底发生了什么</a></li>\n<li><a href=\"http://harttle.com/2016/05/18/async-javascript-loading.html\" target=\"_blank\" rel=\"noopener\">异步脚本载入提高页面性能</a></li>\n</ul>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://blog.codingplayboy.com/2017/03/29/webpage_render/\" target=\"_blank\" rel=\"noopener\">浅谈前端页面渲染机制</a></li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"CSS深入理解之border","slug":"CSS深入理解之border","date":"2017-04-23T14:39:19.000Z","updated":"2019-02-07T13:01:36.411Z","comments":true,"path":"api/articles/CSS深入理解之border.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_205.png","content":"<h2 id=\"1-不支持百分比单位的属性\"><a href=\"#1-不支持百分比单位的属性\" class=\"headerlink\" title=\"1. 不支持百分比单位的属性\"></a>1. 不支持百分比单位的属性</h2><ul>\n<li>border-width</li>\n<li>outline</li>\n<li>box-shadow</li>\n<li>text-shadow</li>\n</ul>\n<h2 id=\"2-border-width-支持关键字\"><a href=\"#2-border-width-支持关键字\" class=\"headerlink\" title=\"2. border-width 支持关键字\"></a>2. border-width 支持关键字</h2><ul>\n<li>thin –&gt; 1px</li>\n<li>medium（默认值）–&gt; 3px</li>\n<li>thick –&gt; 5px</li>\n</ul>\n<h2 id=\"3-border-style\"><a href=\"#3-border-style\" class=\"headerlink\" title=\"3. border-style\"></a>3. border-style</h2><ul>\n<li>solid：实线</li>\n<li>dashed：虚线，但是 IE 和 Chrome / FireFox 的虚线比例不同，IE 会更密一些</li>\n<li>dotted：点线，Chrome / FireFox 下点线是方形，IE 下是圆形</li>\n<li>double：双线，宽度实现规律为双线宽度永远相等，而中间间隔 ±1</li>\n<li>inset：内凹，在 css 里很少用，基本上被淘汰了</li>\n<li>groove：沟槽</li>\n<li>ridge：山脊</li>\n</ul>\n<p>inset、groove、ridge 风格过时 + 兼容性差，所以基本上处于被淘汰的状态</p>\n<h2 id=\"4-利用-IE7-中的-border-style-dotted-实现圆角效果\"><a href=\"#4-利用-IE7-中的-border-style-dotted-实现圆角效果\" class=\"headerlink\" title=\"4. 利用 IE7 中的 border-style:dotted 实现圆角效果\"></a>4. 利用 IE7 中的 border-style:dotted 实现圆角效果</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dotted</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">149px</span> dotted <span class=\"number\">#cd0000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-利用-border-style-double-实现三道杠\"><a href=\"#5-利用-border-style-double-实现三道杠\" class=\"headerlink\" title=\"5. 利用 border-style:double 实现三道杠\"></a>5. 利用 border-style:double 实现三道杠</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.three</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">120px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>:<span class=\"number\">60px</span> double;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>:<span class=\"number\">20px</span> solid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-border-color-与-color\"><a href=\"#6-border-color-与-color\" class=\"headerlink\" title=\"6. border-color 与 color\"></a>6. border-color 与 color</h2><p>当没有指定 border-color 的时候，会使用 color 作为边框色，类似的还有 box-shadow、text-shadow 和 outline，都是默认使用 color 的颜色</p>\n<h2 id=\"7-border-与-background-position-定位\"><a href=\"#7-border-与-background-position-定位\" class=\"headerlink\" title=\"7. border 与 background-position 定位\"></a>7. border 与 background-position 定位</h2><p>background-position 默认相对于左上进行定位，所以如果想相对于右边进行定位的话，其中一个方法就是借助于 border（设置为 100% 默认不计算 border 区域）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border-right</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">background-position</span>: 100% 40<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-border-color-的分配\"><a href=\"#8-border-color-的分配\" class=\"headerlink\" title=\"8. border-color 的分配\"></a>8. border-color 的分配</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.triangle</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">100px</span> solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red green blue orange;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果展示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_205.png\" alt=\"\" width=\"150\"></div>\n\n<h2 id=\"9-border-的应用\"><a href=\"#9-border-的应用\" class=\"headerlink\" title=\"9. border 的应用\"></a>9. border 的应用</h2><h3 id=\"透明边框优雅增加响应区域大小（复选框）\"><a href=\"#透明边框优雅增加响应区域大小（复选框）\" class=\"headerlink\" title=\"透明边框优雅增加响应区域大小（复选框）\"></a>透明边框优雅增加响应区域大小（复选框）</h3><p>原来视觉区域大小（不含边框）是 16px * 16px，经过使用透明边框，可以使复选框点击区域扩大到 20px * 20px 甚至更大</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.checkbox</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: inset <span class=\"number\">0</span> <span class=\"number\">1px</span>, inset <span class=\"number\">1px</span> <span class=\"number\">0</span>, inset -<span class=\"number\">1px</span> <span class=\"number\">0</span>, inset <span class=\"number\">0</span> -<span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-clip</span>: content-box;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#d0d0d5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现两栏等高布局\"><a href=\"#实现两栏等高布局\" class=\"headerlink\" title=\"实现两栏等高布局\"></a>实现两栏等高布局</h3><p>利用很长的 border 构造另外一个盒子，然后利用 margin 负值进行定位，但是不支持百分比宽度（margin 和 padding实现支持百分比宽度）</p>\n<p>html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>导航1<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"module\"</span>&gt;</span>模块1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">300px</span> solid <span class=\"number\">#222</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现效果：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_206.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"绘制三角形\"><a href=\"#绘制三角形\" class=\"headerlink\" title=\"绘制三角形\"></a>绘制三角形</h3><p>根据上面 border-color 的分配，实现方案为将 border 的其中一个方向的颜色设置为预期颜色，将其余三个方向设置为透明，然后 border-width 就是三角形的大小</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.triangle</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">100px</span> solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red transparent transparent transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"css","path":"api/categories/css.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]},{"title":"CSS深入理解系列","slug":"CSS深入理解系列","date":"2017-04-21T13:52:56.000Z","updated":"2019-02-07T13:01:36.411Z","comments":true,"path":"api/articles/CSS深入理解系列.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>此系列的文章是我对张鑫旭的讲解的总结，张鑫旭作为很早入行前端的代表人物，其对 html 以及 css 的理解很深刻，所以他的系列文章“<a href=\"http://www.imooc.com/search/course?words=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css\" target=\"_blank\" rel=\"noopener\">深入理解 CSS</a>”是一个不错的前端基础教材，虽然我将其讲解进行了总结，但是还是希望你有时间能够看一下他的视频，风趣幽默又不失教学性，一定会有所收获。</p>\n<ul>\n<li><a href=\"/20170421/line-height-of-css.html\">CSS深入理解之line-height</a></li>\n<li><a href=\"/20170420/margin-of-css.html\">CSS深入理解之margin</a></li>\n<li><a href=\"/20170420/padding-of-css.html\">CSS深入理解之padding</a></li>\n<li><a href=\"/20170420/z-index-of-css.html\">CSS深入理解之z-index</a></li>\n<li><a href=\"/20170421/relative-of-css.html\">CSS深入理解之relative</a></li>\n<li><a href=\"/20170421/vertical-align-of-css.html\">CSS深入理解之vertical-align</a></li>\n<li><a href=\"/20170421/absolute-of-css.html\">CSS深入理解之absolute</a></li>\n<li><a href=\"/20170421/overflow-of-css.html\">CSS深入理解之overflow</a></li>\n<li><a href=\"/20170421/float-of-css.html\">CSS深入理解之float</a></li>\n<li><a href=\"/20170423/border-of-css.html\">CSS深入理解之border</a></li>\n</ul>\n","raw":null,"categories":[{"name":"series","path":"api/categories/series.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"}]}]}