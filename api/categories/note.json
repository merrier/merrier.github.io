{"name":"note","postlist":[{"title":"机器学习概念入门","slug":"机器学习概念入门","date":"2017-11-02T14:23:08.000Z","updated":"2019-05-05T03:32:55.324Z","comments":true,"path":"api/articles/机器学习概念入门.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_287.png","content":"<p>最近在做毕设，需要用到一些机器学习的内容（不要问我为什么，做前端根本没办法毕业！），这篇文章是我看 bilibili 上<a href=\"https://www.bilibili.com/video/av12556478/\" target=\"_blank\" rel=\"noopener\">莫烦系列教程-Tensorflow教程</a>时候做的笔记，都是一些机器学习入门概念，如果你和我一样都是入门选手，我相信这些概念能够帮助到你~</p>\n<h2 id=\"什么是机器学习\"><a href=\"#什么是机器学习\" class=\"headerlink\" title=\"什么是机器学习\"></a>什么是机器学习</h2><p>机器学习是一帮计算机科学家想让计算机像人一样思考，所研发出来的计算机理论</p>\n<h2 id=\"机器学习分类\"><a href=\"#机器学习分类\" class=\"headerlink\" title=\"机器学习分类\"></a>机器学习分类</h2><h3 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h3><p>有数据和标签</p>\n<h3 id=\"非监督学习\"><a href=\"#非监督学习\" class=\"headerlink\" title=\"非监督学习\"></a>非监督学习</h3><p>只有数据，没有标签</p>\n<h3 id=\"半监督学习\"><a href=\"#半监督学习\" class=\"headerlink\" title=\"半监督学习\"></a>半监督学习</h3><p>结合了监督学习和非监督学习</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>从经验中总结提升</p>\n<h3 id=\"遗传算法\"><a href=\"#遗传算法\" class=\"headerlink\" title=\"遗传算法\"></a>遗传算法</h3><p>和强化学习类似，有着适者生存，不适者淘汰准则</p>\n<h2 id=\"什么是神经网络\"><a href=\"#什么是神经网络\" class=\"headerlink\" title=\"什么是神经网络\"></a>什么是神经网络</h2><p>神经网络是一种数学模型，是存在于计算机的神经系统，由大量的神经元相连接并进行计算，在外界信息的基础上，改变内部的结构，常用来对输入和输出间复杂的关系进行建模。</p>\n<p>神经网络由大量的节点和之间的联系构成，负责传递信息和加工信息，神经元也可以通过训练而被强化。</p>\n<h2 id=\"怎么检验神经网络\"><a href=\"#怎么检验神经网络\" class=\"headerlink\" title=\"怎么检验神经网络\"></a>怎么检验神经网络</h2><p>为了检验、评价神经网络，并努力改善这些问题，我们常会把收集到的数据分为<strong>训练数据</strong>和<strong>测试数据</strong>，一般用于训练的数据可以是全部数据的百分之 70，剩下的百分之 30 可以用来测试学习结果。接着，对于神经网络的评价，基本上基于这百分之 30 的测试结果。</p>\n<ul>\n<li>评价机器学习可以从误差这个值开始，随着训练时间的变长，优秀的神经网络能够预测到更精准的答案，预测的误差也会越小；</li>\n<li>除了误差曲线，我们也可以看它的精确度曲线，最好的精度是趋向于百分之百的精度；</li>\n<li>对于回归问题，我们可以采用 R2 score 作为评分标准；</li>\n<li>还有 F1 score 用来测量不均衡数据的精度。</li>\n</ul>\n<h2 id=\"什么叫过拟合\"><a href=\"#什么叫过拟合\" class=\"headerlink\" title=\"什么叫过拟合\"></a>什么叫过拟合</h2><p>如下图，训练时的误差比测试误差小，神经网络虽然学习到了知识，但是对于训练数据太过依赖，所以测试数据产生的误差会产生波谷，后面会变大。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_287.png\" alt=\"\" width=\"400\"></div>\n\n<p>在机器学习中，解决过拟合的方法也有很多，比如 <strong>L1，L2正规化</strong>和 <strong>Dropout方法</strong></p>\n<h2 id=\"什么是交叉验证\"><a href=\"#什么是交叉验证\" class=\"headerlink\" title=\"什么是交叉验证\"></a>什么是交叉验证</h2><p>交叉验证不仅可以用于神经网络的调参，还可以用于其他机器学习方法的调参，同样是选择你想观看的误差值或者精确度，不过横坐标不再是学习时间，而是你要测试的某一参数，比如说神经网络的层数。。</p>\n<h2 id=\"为什么要特征标准化\"><a href=\"#为什么要特征标准化\" class=\"headerlink\" title=\"为什么要特征标准化\"></a>为什么要特征标准化</h2><p>我们在机器学习训练之前, 先对数据预先处理一下, 取值跨度大的特征数据, 我们浓缩一下, 跨度小的括展一下, 使得他们的跨度尽量统一，这样可以<strong>提升学习效率</strong> 通常用于 特征标准化的途径有两种, 一种叫做 min max normalization, 他会将所有特征数据按比例缩放到 0-1 的这个取值区间. 有时也可以是 -1 到 1 的区间. 还有一种叫做 standard deviation normalization, 他会将所有特征数据缩放成平均值为 0, 方差为 1. 使用这些标准化手段. 我们不仅可以快速推进机器学习的学习速度, 还可以<strong>避免机器学习学得特扭曲</strong>.</p>\n<h2 id=\"区分好用的特征\"><a href=\"#区分好用的特征\" class=\"headerlink\" title=\"区分好用的特征\"></a>区分好用的特征</h2><p>在选择特征的时候,我们得要时刻回想起这三点.：</p>\n<ol>\n<li>避免无意义的信息</li>\n<li>避免重复性的信息</li>\n<li>避免复杂的信息</li>\n</ol>\n<p>这就是我们这次机器学习简介中所聊到的如何区分好用的特征</p>\n<h2 id=\"为什么需要激励函数\"><a href=\"#为什么需要激励函数\" class=\"headerlink\" title=\"为什么需要激励函数\"></a>为什么需要激励函数</h2><p>因为现实中的问题往往不是线性的，所以需要一个激励函数<strong>来扭曲原来的线性结果</strong> 你甚至可以创造自己的激励函数来处理自己的问题, 不过要确保的是这些激励函数必须是可以微分的, 因为在 backpropagation 误差反向传递的时候, 只有这些可微分的激励函数才能把误差传递回去. 在少量层结构中, 我们可以尝试很多种不同的激励函数. 在卷积神经网络 Convolutional neural networks 的卷积层中, 推荐的激励函数是 relu. 在循环神经网络中 recurrent neural networks, 推荐的是 tanh 或者是 relu</p>\n<h2 id=\"如何加速神经网络训练\"><a href=\"#如何加速神经网络训练\" class=\"headerlink\" title=\"如何加速神经网络训练\"></a>如何加速神经网络训练</h2><p>越复杂的神经网络，越多的数据，我们需要在训练神经网络的过程上花费的时间也就越多；原因很简单，就是因为计算量太大了。可是往往有时候为了解决复杂的问题, 复杂的结构和大数据又是不能避免的, 所以我们需要寻找一些方法, 让神经网络聪明起来, 快起来. 包括以下几种模式:</p>\n<ul>\n<li>Stochastic Gradient Descent (SGD)</li>\n<li>Momentum</li>\n<li>AdaGrad</li>\n<li>RMSProp</li>\n<li>Adam</li>\n</ul>\n<p>关于这几种方法的具体原理，可以<a href=\"https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-06-speed-up-learning/\" target=\"_blank\" rel=\"noopener\">点击这里</a>观看莫烦的讲解</p>\n<h2 id=\"如何处理不均衡数据\"><a href=\"#如何处理不均衡数据\" class=\"headerlink\" title=\"如何处理不均衡数据\"></a>如何处理不均衡数据</h2><p>不均衡的数据预测起来很简单. 永远都猜多的那一方面准没错. 没错, 机器也懂这个小伎俩. 所以机器学到最后, 学乖了, 每次都预测多数派. 解决的方法有几种, 我们来谈谈.</p>\n<h3 id=\"方法一：想办法获取更多数据\"><a href=\"#方法一：想办法获取更多数据\" class=\"headerlink\" title=\"方法一：想办法获取更多数据\"></a>方法一：想办法获取更多数据</h3><h3 id=\"方法二：更换评判方式\"><a href=\"#方法二：更换评判方式\" class=\"headerlink\" title=\"方法二：更换评判方式\"></a>方法二：更换评判方式</h3><p>通常, 我们会用到准确率 accuracy, 或者误差 cost 来判断机器学习的成果. 可是这些评判方法在不均衡数据面前, 高的准确率和低的误差变得没那么重要. 所以我们得换一种方式评判. 通过 confusion matrix 来计算 precision 和 recall, 然后通过 precision 和 recall 再计算f1 score.这种方式能成功地区分不均衡数据, 给出更好的评判分数.</p>\n<h3 id=\"方法三：重组数据\"><a href=\"#方法三：重组数据\" class=\"headerlink\" title=\"方法三：重组数据\"></a>方法三：重组数据</h3><p>这是最简单粗暴的方法之一，重新组合不均衡数据，使之均衡。有两种方式：</p>\n<ol>\n<li>复制或者合成少数部分的样本, 使之和多数部分差不多数量</li>\n<li>砍掉一些多数部分, 使两者数量差不多</li>\n</ol>\n<h3 id=\"方法四：使用其他机器学习方法\"><a href=\"#方法四：使用其他机器学习方法\" class=\"headerlink\" title=\"方法四：使用其他机器学习方法\"></a>方法四：使用其他机器学习方法</h3><p>如果使用的机器学习方法像神经网络等, 在面对不均衡数据时, 通常是束手无策. 不过有些机器学习方法, 像决策树, decision trees 就不会受到不均很数据的影响.</p>\n<h3 id=\"方法五：修改算法\"><a href=\"#方法五：修改算法\" class=\"headerlink\" title=\"方法五：修改算法\"></a>方法五：修改算法</h3><p>最后一种方法是让自己变得有创造力, 尝试修改算法. 如果你用的是 Sigmoid 的激励函数, activation function, 他会有一个<strong>预测门槛</strong>, 一般如果输出结果落在门槛的这一段,预测结果为梨, 如果落在这一段, 预测结果为苹果, 不过因为现在的梨是多数派, 我们得<strong>调整一下门槛的位置，</strong>使得门槛偏向苹果这边, 只有很自信的时候, 模型才会预测这是苹果. 让机器学习,学习到更好的效果.</p>\n<h2 id=\"什么是批标准化\"><a href=\"#什么是批标准化\" class=\"headerlink\" title=\"什么是批标准化\"></a>什么是批标准化</h2><p>和普通的数据标准化类似, 是将分散的数据统一的一种做法, 也是优化神经网络的一种方法. Batch normalization 的 batch 是批数据, <strong>把数据分成小批小批进行 stochastic gradient descent. 而且在每批数据进行前向传递 forward propagation 的时候, 对每一层都进行 normalization 的处理</strong> Batch normalization 也可以被看做一个层面. 在一层层的添加神经网络的时候, 我们先有数据 X, 再添加全连接层, 全连接层的计算结果会经过 激励函数 成为下一层的输入, 接着重复之前的操作. Batch Normalization (BN) 就被添加在每一个全连接和激励函数之间。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/e112012a4b2d\" target=\"_blank\" rel=\"noopener\">一文学会用 Tensorflow 搭建神经网络</a></li>\n</ul>\n","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"机器学习","path":"api/tags/机器学习.json"}]},{"title":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","slug":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","date":"2017-04-06T09:17:52.000Z","updated":"2019-05-05T03:32:55.324Z","comments":true,"path":"api/articles/读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_297.png","content":"<h2 id=\"1-一句话概括响应式设计\"><a href=\"#1-一句话概括响应式设计\" class=\"headerlink\" title=\"1. 一句话概括响应式设计\"></a>1. 一句话概括响应式设计</h2><p>如果要用一句话概括响应式网页设计，我觉得它是针对任意设备对网页内容进行完美布局的一种显示机制.相反，如果需要根据不同设备提供特定的内容和功能，那就需要一个真正的“手机版”网站.这种情况下，手机版网站会提供与桌面版网站完全不同的用户体验.</p>\n<h2 id=\"2-CSS-reset-网站\"><a href=\"#2-CSS-reset-网站\" class=\"headerlink\" title=\"2. CSS reset 网站\"></a>2. CSS reset 网站</h2><ul>\n<li><a href=\"http://meyerweb.com/eric/tools/css/reset/\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/css/reset/</a>，Eric Meyer的原版，主要针对HTML4</li>\n<li><a href=\"http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/</a>，针对HTML5</li>\n</ul>\n<h2 id=\"3-CSS-网格系统\"><a href=\"#3-CSS-网格系统\" class=\"headerlink\" title=\"3. CSS 网格系统\"></a>3. CSS 网格系统</h2><div align=\"center\"><img src=\"/images/hexo_post_297.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"4-地标角色属性\"><a href=\"#4-地标角色属性\" class=\"headerlink\" title=\"4. 地标角色属性\"></a>4. 地标角色属性</h2><p>role=”” 针对文档结构的各部分分别有如下的地标角色：</p>\n<ul>\n<li>application：用来定义用作网页应用的区域；</li>\n<li>banner：用来定义一个站点级别(而不是某个特定文档的)的区域.如网站的头部和logo；</li>\n<li>complementary：一个对页面主要区域进行补充说明的区域；</li>\n<li>contentinfo：与页面主要内容相关的信息区域，例如页脚的网站版权信息区域；</li>\n<li>form：定义表单，但是如果表单用于搜索，请使用search来替代；</li>\n<li>main：页面的主体内容；</li>\n<li>navigation：链向当前文档或相关文档的导航链接；</li>\n<li>search：一个用于搜索的区域。</li>\n</ul>\n<h2 id=\"5-导航栏使用-table-显示模式\"><a href=\"#5-导航栏使用-table-显示模式\" class=\"headerlink\" title=\"5. 导航栏使用 table 显示模式\"></a>5. 导航栏使用 table 显示模式</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-row;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做可以保证如果有另外的列表项追加进来，同样会自动地调整它们之间的间距。最后，使用 CSS3 选择器将最后一个列表项的文字置为右对齐，将第一个列表项的文字置为左对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:last-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-在响应式设计中使用自定义-font-face-字体的注意事项\"><a href=\"#6-在响应式设计中使用自定义-font-face-字体的注意事项\" class=\"headerlink\" title=\"6. 在响应式设计中使用自定义 @font-face 字体的注意事项\"></a>6. 在响应式设计中使用自定义 @font-face 字体的注意事项</h2><p>唯一需要注意的，是在响应式设计中使用该技术时要考虑到字体文件大小。有些字体可能会非常庞大，如果你想保持网站的高性能，请注意控制自定义字体的文件尺寸。</p>\n<h2 id=\"7-浮雕文字效果\"><a href=\"#7-浮雕文字效果\" class=\"headerlink\" title=\"7. 浮雕文字效果\"></a>7. 浮雕文字效果</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">text-shadow</span>: 0 1<span class=\"selector-tag\">px</span> 0 <span class=\"selector-tag\">hsla</span>(0， 0%， 100%， 0<span class=\"selector-class\">.75</span>);</span><br></pre></td></tr></table></figure>\n<p>不要模糊，不要水平阴影，仅在垂直方向设置 1 或 2 像素的”白影”即可。</p>\n<h2 id=\"8-让整个屏幕飞舞\"><a href=\"#8-让整个屏幕飞舞\" class=\"headerlink\" title=\"8. 让整个屏幕飞舞\"></a>8. 让整个屏幕飞舞</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123; <span class=\"attribute\">transition</span>: all <span class=\"number\">1s</span>; &#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_298.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"9-CSS3-实现-3D-变形效果\"><a href=\"#9-CSS3-实现-3D-变形效果\" class=\"headerlink\" title=\"9. CSS3 实现 3D 变形效果\"></a>9. CSS3 实现 3D 变形效果</h2><h3 id=\"在父级元素上设置透视，这样就开启了-3D-场景\"><a href=\"#在父级元素上设置透视，这样就开启了-3D-场景\" class=\"headerlink\" title=\"在父级元素上设置透视，这样就开启了 3D 场景\"></a>在父级元素上设置透视，这样就开启了 3D 场景</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123; <span class=\"attribute\">-webkit-perspective</span>: <span class=\"number\">200</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>透视的值越大，就表示你的视点与 3D 场景之间的景深越大。因此，如果想要一点隐约的 3D 效果，就增大透视值；如果想要非常明显的 3D 效果，则减小透视值。</p>\n<h3 id=\"延续父元素的透视\"><a href=\"#延续父元素的透视\" class=\"headerlink\" title=\"延续父元素的透视\"></a>延续父元素的透视</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son</span>&#123; <span class=\"attribute\">-webkit-transform-style</span>: perserve-<span class=\"number\">3</span>d; <span class=\"attribute\">-webkit-transition</span>: <span class=\"number\">1s</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>.father 类中添加的透视声明只会应用到其第一个子元素上。因此，为了延续父元素的透视，我们给 .son 元素设定了 preserve-3d (这样可以设置一个 3D 场景)。</p>\n<h3 id=\"当鼠标悬停在-father-模块上时，我们给-son-这个-div-添加一个翻转效果\"><a href=\"#当鼠标悬停在-father-模块上时，我们给-son-这个-div-添加一个翻转效果\" class=\"headerlink\" title=\"当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果\"></a>当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.son</span>&#123; <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"当海报翻转之后隐藏在其背面内容\"><a href=\"#当海报翻转之后隐藏在其背面内容\" class=\"headerlink\" title=\"当海报翻转之后隐藏在其背面内容\"></a>当海报翻转之后隐藏在其背面内容</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.face</span> &#123; <span class=\"attribute\">position</span>: absolute; <span class=\"attribute\">-webkit-backface-visibility</span>: hidden; &#125;</span><br></pre></td></tr></table></figure>\n<p>.face 必须使用绝对定位，这样海报才能盖在 .back 这个 div 的上面</p>\n<h3 id=\"给-back-加上-rotateY\"><a href=\"#给-back-加上-rotateY\" class=\"headerlink\" title=\"给 .back 加上 rotateY\"></a>给 .back 加上 rotateY</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.back</span> &#123; <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg); &#125;</span><br></pre></td></tr></table></figure>\n<p>不加这句的话，.back 这个 div 就会显示在正面海报之上。最终的 HTML 结构以及 CSS 样式如下:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"Qcontainer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"film\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"face front\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/goonies.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"The Goonies\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"face back\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>HOT!<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.Qcontainer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">28%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-perspective</span>: <span class=\"number\">800</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">2%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.film</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">15em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transition</span>: <span class=\"number\">1s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.Qcontainer</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.film</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.face</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-backface-visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.back</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">66%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">127%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">rotateY</span>(180deg);</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#3b3b3b</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(top，</span><br><span class=\"line\">  rgba(0，0，0，0.65) <span class=\"number\">0%</span>，</span><br><span class=\"line\">  <span class=\"built_in\">rgba</span>(0，0，0，0) <span class=\"number\">100%</span>);</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">15%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-list-及对应的-datalist-元素\"><a href=\"#10-list-及对应的-datalist-元素\" class=\"headerlink\" title=\"10. list(及对应的 datalist 元素)\"></a>10. list(及对应的 datalist 元素)</h2><p>list 属性以及对应的 datalist 元素可以让用户在输入框中开始输入值的时候，显示一组备选值。下面是一个包含在 div 中的使用 list 属性及对应 datalist 元素的代码示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"awardWon\"</span>&gt;</span>Award Won<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"awardWon\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"awardWon\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">list</span>=<span class=\"string\">\"awards\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">datalist</span> <span class=\"attr\">id</span>=<span class=\"string\">\"awards\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Picture\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Director\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Adapted Screenplay\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Best Original Screenplay\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">datalist</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>list 属性中的值（awards）同时也是 datalist 元素的 id。这样就可以让 datalist 与输入项关联起来。虽然将 option 包裹在 select 中不是必需的，但这样做便于为老版本浏览器提供降级方案。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_299.png\" alt=\"\" width=\"550\"></div>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"CSS","path":"api/tags/CSS.json"},{"name":"HTML","path":"api/tags/HTML.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（2）——面向对象的分析与设计","slug":"读书笔记系列（2）——面向对象的分析与设计","date":"2017-04-06T08:09:41.000Z","updated":"2019-05-05T03:32:55.324Z","comments":true,"path":"api/articles/读书笔记系列（2）——面向对象的分析与设计.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>面向对象不仅是一些具体的软件开发技术与策略，而且是一整套关于如何看待软件系统与现实世界的关系，用什么观点来研究问题并进行求解，以及如何进行系统构造的软件方法学。面向对象方法比以往的方法更接近人类的日常思维方式。</p>\n<h2 id=\"2-面向对象方法有如下一些主要特点：\"><a href=\"#2-面向对象方法有如下一些主要特点：\" class=\"headerlink\" title=\"2. 面向对象方法有如下一些主要特点：\"></a>2. 面向对象方法有如下一些主要特点：</h2><ol>\n<li>从问题域中客观存在的事物出发来构造软件系统，用对象作为对这些事物的抽象表示，并以此作为系统的基本构成单位。</li>\n<li>用对象的属性表示事物的静态特征（即可以用一些数据来表达的特征），用对象的操作表示事物的动态特征（即事物的行为）</li>\n<li>对象的属性与操作结合在一起构成一个独立的实体，对外屏蔽其内部细节（封装）。</li>\n<li>对事物进行分类，把具有相同属性和相同操作的对象归为一类，类是这些对象的抽象描述，每个对象是它的类的一个实例。</li>\n<li>通过在不同程度上运用抽象的原则，可以得到较一般的类和较特殊的类。特殊类继承一般类的属性与操作，从而简化了系统的构造过程。</li>\n<li>复杂的对象可以用简单的对象作为其构成部分（聚合）。</li>\n<li>对象之间通过消息进行通信，以实现对象之间的动态联系。</li>\n<li>用关联表达某些类之间对用户业务有特定意义的关系。</li>\n</ol>\n<h2 id=\"3-每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\"><a href=\"#3-每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\" class=\"headerlink\" title=\"3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。\"></a>3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。</h2><h2 id=\"4-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\"><a href=\"#4-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\" class=\"headerlink\" title=\"4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。\"></a>4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。</h2><h2 id=\"5-一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\"><a href=\"#5-一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\" class=\"headerlink\" title=\"5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。\"></a>5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。</h2><h2 id=\"6-一般类和特殊类也常常习惯地称为父类和子类。\"><a href=\"#6-一般类和特殊类也常常习惯地称为父类和子类。\" class=\"headerlink\" title=\"6. 一般类和特殊类也常常习惯地称为父类和子类。\"></a>6. 一般类和特殊类也常常习惯地称为父类和子类。</h2><ul>\n<li>特殊类的每个对象实例也都属于它的一般类，然而一般类含有其特殊类所没有的对象实例。</li>\n<li>特殊类拥有其一般类的全部属性与操作，称为特殊类对一般类的继承。</li>\n</ul>\n<h2 id=\"7-聚合的含义\"><a href=\"#7-聚合的含义\" class=\"headerlink\" title=\"7. 聚合的含义\"></a>7. 聚合的含义</h2><p>聚合的含义：一个复杂的对象以若干比较简单的对象作为其组成部分。另一方面，聚合也是对象之间的一种关系，即整体对象和部分对象之间的关系。聚合是两个类之间的一个二元关系，它表示一个类的对象实例以另一个类的对象实例作为其组成部分。</p>\n<h2 id=\"8-用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\"><a href=\"#8-用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\" class=\"headerlink\" title=\"8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。\"></a>8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。</h2><h2 id=\"9-消息是向对象发出的服务请求。\"><a href=\"#9-消息是向对象发出的服务请求。\" class=\"headerlink\" title=\"9. 消息是向对象发出的服务请求。\"></a>9. 消息是向对象发出的服务请求。</h2><p>消息的实现手段，在顺序程序中主要是函数调用，或者其他类似于函数调用的机制。</p>\n<h2 id=\"10-对象的多态性\"><a href=\"#10-对象的多态性\" class=\"headerlink\" title=\"10. 对象的多态性\"></a>10. 对象的多态性</h2><p>对象的多态性通常是指一般-特殊结构中的对象所体现的多态性，即：在一般类中定义的属性或操作被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。</p>\n<h2 id=\"11-功能分解法\"><a href=\"#11-功能分解法\" class=\"headerlink\" title=\"11. 功能分解法\"></a>11. 功能分解法</h2><p>首先定义各项功能，然后把较大的功能分解为子功能，直到这些功能或子功能的大小比较适当，并能给出明确的定义。</p>\n<h2 id=\"12-结构化方法\"><a href=\"#12-结构化方法\" class=\"headerlink\" title=\"12. 结构化方法\"></a>12. 结构化方法</h2><p>研究问题域中数据如何流动以及在各个环节上如何进行处理，从而发现数据流和加工。最终得到的分析模型是数据流图。</p>\n<h2 id=\"13-数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\"><a href=\"#13-数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\" class=\"headerlink\" title=\"13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。\"></a>13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。</h2><h2 id=\"14-实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\"><a href=\"#14-实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\" class=\"headerlink\" title=\"14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。\"></a>14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。</h2><h2 id=\"15-信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\"><a href=\"#15-信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\" class=\"headerlink\" title=\"15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。\"></a>15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。</h2><h2 id=\"16-先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\"><a href=\"#16-先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\" class=\"headerlink\" title=\"16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。\"></a>16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。</h2><h2 id=\"17-面向对象建模方法具有如下优点：\"><a href=\"#17-面向对象建模方法具有如下优点：\" class=\"headerlink\" title=\"17. 面向对象建模方法具有如下优点：\"></a>17. 面向对象建模方法具有如下优点：</h2><ol>\n<li>对问题域和系统责任的复杂性具有较强的处理能力；</li>\n<li>提供了便于各类相关人员交流的共同语言；</li>\n<li>对需求的变化具有较强的适应性；</li>\n<li>为实现分析与设计级别的软件复用提供了强有力的支持。</li>\n</ol>\n<h2 id=\"18-UML是一种建模语言，而不是一种建模方法。\"><a href=\"#18-UML是一种建模语言，而不是一种建模方法。\" class=\"headerlink\" title=\"18. UML是一种建模语言，而不是一种建模方法。\"></a>18. UML是一种建模语言，而不是一种建模方法。</h2><h2 id=\"19-属性有类属性和实例属性之分，必要时要加以区别。\"><a href=\"#19-属性有类属性和实例属性之分，必要时要加以区别。\" class=\"headerlink\" title=\"19. 属性有类属性和实例属性之分，必要时要加以区别。\"></a>19. 属性有类属性和实例属性之分，必要时要加以区别。</h2><h2 id=\"20-数据抽象是面向对象方法的核心原则。\"><a href=\"#20-数据抽象是面向对象方法的核心原则。\" class=\"headerlink\" title=\"20. 数据抽象是面向对象方法的核心原则。\"></a>20. 数据抽象是面向对象方法的核心原则。</h2><h2 id=\"21-没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\"><a href=\"#21-没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\" class=\"headerlink\" title=\"21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。\"></a>21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。</h2><h2 id=\"22-消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\"><a href=\"#22-消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\" class=\"headerlink\" title=\"22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。\"></a>22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。</h2><h2 id=\"23-在面向对象的软件系统中，所有的对象都是通过类描述的。\"><a href=\"#23-在面向对象的软件系统中，所有的对象都是通过类描述的。\" class=\"headerlink\" title=\"23. 在面向对象的软件系统中，所有的对象都是通过类描述的。\"></a>23. 在面向对象的软件系统中，所有的对象都是通过类描述的。</h2><h2 id=\"24-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\"><a href=\"#24-类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\" class=\"headerlink\" title=\"24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。\"></a>24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。</h2><h2 id=\"25-可用以下-4-句话来概括对象和类这两个概念在面向对象建模中的应用规则：\"><a href=\"#25-可用以下-4-句话来概括对象和类这两个概念在面向对象建模中的应用规则：\" class=\"headerlink\" title=\"25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则：\"></a>25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则：</h2><ol>\n<li>从对象出发认识问题域，将问题域中的事物抽象为对象；</li>\n<li>将具有共同特征的对象抽象为类，用类以及它们之间的关系构成整个系统模型；</li>\n<li>模型中不包含实例级的元素，用类来表示属于该类的任何对象实例；</li>\n<li>在类的规约中说明这个类将创建哪些对象实例。</li>\n</ol>\n<h2 id=\"26-如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\"><a href=\"#26-如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\" class=\"headerlink\" title=\"26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。\"></a>26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。</h2><h2 id=\"27-属性是用来描述对象静态特征的一个数据项-操作是用来描述对象动态特征（行为）的一个动作序列。\"><a href=\"#27-属性是用来描述对象静态特征的一个数据项-操作是用来描述对象动态特征（行为）的一个动作序列。\" class=\"headerlink\" title=\"27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。\"></a>27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。</h2><h2 id=\"28-确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\"><a href=\"#28-确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\" class=\"headerlink\" title=\"28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。\"></a>28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。</h2><h2 id=\"29-一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\"><a href=\"#29-一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\" class=\"headerlink\" title=\"29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。\"></a>29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。</h2><p>通过接口进行衔接，则接口在它的使用者和提供者之间起到了隔离作用，二者可以分别实现，并且可以有多种不同的实现，只要都遵守接口所规定的合约，就可以通过该接口相互衔接。</p>\n<h2 id=\"30-接口由某些类提供，为另外某些类所需要。\"><a href=\"#30-接口由某些类提供，为另外某些类所需要。\" class=\"headerlink\" title=\"30. 接口由某些类提供，为另外某些类所需要。\"></a>30. 接口由某些类提供，为另外某些类所需要。</h2><h2 id=\"31-接口与对象类相比，有以下几点不同：\"><a href=\"#31-接口与对象类相比，有以下几点不同：\" class=\"headerlink\" title=\"31. 接口与对象类相比，有以下几点不同：\"></a>31. 接口与对象类相比，有以下几点不同：</h2><ol>\n<li>类既有属性又有操作；接口只是声明了一组操作，没有属性。</li>\n<li>在一个类中定义了一个操作，就要在这个类中真正地实现它的功能；接口中的操作只是一个声明，不需要在接口中加以实现。</li>\n<li>类可以创建对象实例；接口则没有任何实例。</li>\n</ol>\n<h2 id=\"32-对象之间的-4-种重要关系，即继承、聚合、关联和信息。\"><a href=\"#32-对象之间的-4-种重要关系，即继承、聚合、关联和信息。\" class=\"headerlink\" title=\"32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。\"></a>32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。</h2><h2 id=\"33-系统中的一般类应该符合下述3个条件之一才有存在的价值：\"><a href=\"#33-系统中的一般类应该符合下述3个条件之一才有存在的价值：\" class=\"headerlink\" title=\"33. 系统中的一般类应该符合下述3个条件之一才有存在的价值：\"></a>33. 系统中的一般类应该符合下述3个条件之一才有存在的价值：</h2><ol>\n<li>它有两个或两个以上的特殊类；</li>\n<li>需要用它创建对象实例；</li>\n<li>它的存在有助于软件复用。</li>\n</ol>\n<h2 id=\"34-聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\"><a href=\"#34-聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\" class=\"headerlink\" title=\"34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。\"></a>34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。</h2><h2 id=\"35-如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\"><a href=\"#35-如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\" class=\"headerlink\" title=\"35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。\"></a>35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。</h2><h2 id=\"36-关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\"><a href=\"#36-关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\" class=\"headerlink\" title=\"36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。\"></a>36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。</h2><h2 id=\"37-消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\"><a href=\"#37-消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\" class=\"headerlink\" title=\"37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。\"></a>37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。</h2><h2 id=\"38-在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0-到多个），即接收消息的操作要求的输入参数；返回参数（0-到多个），即接收消息的操作提供的输出参数。\"><a href=\"#38-在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0-到多个），即接收消息的操作要求的输入参数；返回参数（0-到多个），即接收消息的操作提供的输出参数。\" class=\"headerlink\" title=\"38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。\"></a>38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。</h2>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"读书笔记系列（6）——大话数据结构","slug":"读书笔记系列（6）——大话数据结构","date":"2017-04-08T12:50:00.000Z","updated":"2019-05-05T03:32:55.324Z","comments":true,"path":"api/articles/读书笔记系列（6）——大话数据结构.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_147.png","content":"<p>这本书我是在网上下载的电子版，所以可能会有一些错别字，但是无伤大雅；《大话数据结构》被誉为程序员面试必读书籍，我大概用了 3 天的时间详读了一遍，感觉作者的文笔很好，而且很擅长通过生活中的小故事总结相关知识和算法思路，对于计算机初级童鞋来说是一本很好的数据结构入门读物，而且作者对于代码的讲解很详尽，接近逐行解释了，和其他数据结构的书籍形成了鲜明的对比，总体评价五星吧；不过我是在刷完 Leetcode 的 easy 题才看的这本书，感觉先看这本书再刷题的话会好很多</p>\n<h2 id=\"一、数据结构与算法\"><a href=\"#一、数据结构与算法\" class=\"headerlink\" title=\"一、数据结构与算法\"></a>一、数据结构与算法</h2><h3 id=\"1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\"><a href=\"#1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\" class=\"headerlink\" title=\"1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子\"></a>1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子</h3><h3 id=\"2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\"><a href=\"#2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\" class=\"headerlink\" title=\"2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科\"></a>2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科</h3><h3 id=\"3、数据元素的存储结构形式有两种：顺序存储和链式存储\"><a href=\"#3、数据元素的存储结构形式有两种：顺序存储和链式存储\" class=\"headerlink\" title=\"3、数据元素的存储结构形式有两种：顺序存储和链式存储\"></a>3、数据元素的存储结构形式有两种：顺序存储和链式存储</h3><ul>\n<li>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（谁也别插谁的队）</li>\n<li>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的（需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置）</li>\n</ul>\n<h3 id=\"4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\"><a href=\"#4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\" class=\"headerlink\" title=\"4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性\"></a>4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性</h3><h3 id=\"5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\"><a href=\"#5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\" class=\"headerlink\" title=\"5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征\"></a>5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征</h3><h3 id=\"6、推导时间复杂度大-O-阶方法：\"><a href=\"#6、推导时间复杂度大-O-阶方法：\" class=\"headerlink\" title=\"6、推导时间复杂度大 O 阶方法：\"></a>6、推导时间复杂度大 O 阶方法：</h3><ol>\n<li>用常数 1 取代运行时间中的所有加法常数</li>\n<li>在修改后的运行次数函数中，只保留最高阶项</li>\n<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>\n</ol>\n<h3 id=\"7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\"><a href=\"#7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\" class=\"headerlink\" title=\"7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\"></a>7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</h3><h3 id=\"8、常见的时间复杂度所耗费的时间：\"><a href=\"#8、常见的时间复杂度所耗费的时间：\" class=\"headerlink\" title=\"8、常见的时间复杂度所耗费的时间：\"></a>8、常见的时间复杂度所耗费的时间：</h3><div align=\"center\"><img src=\"/images/hexo_post_147.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\"><a href=\"#9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\" class=\"headerlink\" title=\"9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。\"></a>9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。</h3><p>在应用中，这是一种最重要的需求，通常，除非特别制定，我们提到的运行时间都是最坏情况的运行时间 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间</p>\n<h3 id=\"10、算法的空间复杂度\"><a href=\"#10、算法的空间复杂度\" class=\"headerlink\" title=\"10、算法的空间复杂度\"></a>10、算法的空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数</p>\n<h2 id=\"二、线性表\"><a href=\"#二、线性表\" class=\"headerlink\" title=\"二、线性表\"></a>二、线性表</h2><h3 id=\"1、描述顺序存储结构需要三个属性：\"><a href=\"#1、描述顺序存储结构需要三个属性：\" class=\"headerlink\" title=\"1、描述顺序存储结构需要三个属性：\"></a>1、描述顺序存储结构需要三个属性：</h3><ul>\n<li>存储空间的起始位置：数组 data，它的存储位置就是存储空间的存储位置</li>\n<li>线性表的最大存储容量：数组长度 MaxSize</li>\n<li>线性表的当前长度：length</li>\n</ul>\n<h3 id=\"2、插入算法的思路：\"><a href=\"#2、插入算法的思路：\" class=\"headerlink\" title=\"2、插入算法的思路：\"></a>2、插入算法的思路：</h3><ol>\n<li>如果插入位置不合理，抛出异常</li>\n<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li>\n<li>从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置</li>\n<li>将要插入元素填入位置 i 处</li>\n<li>表长加 1</li>\n</ol>\n<h3 id=\"3、删除算法的思路：\"><a href=\"#3、删除算法的思路：\" class=\"headerlink\" title=\"3、删除算法的思路：\"></a>3、删除算法的思路：</h3><ol>\n<li>如果删除位置不合理，抛出异常</li>\n<li>取出删除元素</li>\n<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置</li>\n<li>表长减 1</li>\n</ol>\n<h3 id=\"4、线性表的顺序存储结构的优缺点：\"><a href=\"#4、线性表的顺序存储结构的优缺点：\" class=\"headerlink\" title=\"4、线性表的顺序存储结构的优缺点：\"></a>4、线性表的顺序存储结构的优缺点：</h3><p><strong>优点：</strong></p>\n<ul>\n<li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li>\n<li>可以快速地存取表中任一位置的元素</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>插入和删除操作需要移动大量元素</li>\n<li>当线性表长度变化较大时，难以确定存储空间的容量</li>\n<li>造成存储空间的“碎片”</li>\n</ul>\n<h3 id=\"5、单链表\"><a href=\"#5、单链表\" class=\"headerlink\" title=\"5、单链表\"></a>5、单链表</h3><p>n 个结点（ai 的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起</p>\n<div align=\"center\"><img src=\"/images/hexo_post_148.png\" alt=\"\" width=\"400\"></div>\n\n<p>有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_149.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"6、头指针与头结点的异同\"><a href=\"#6、头指针与头结点的异同\" class=\"headerlink\" title=\"6、头指针与头结点的异同\"></a>6、头指针与头结点的异同</h3><h4 id=\"头指针\"><a href=\"#头指针\" class=\"headerlink\" title=\"头指针\"></a>头指针</h4><ul>\n<li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li>\n<li>头指针具有标识作用，所以常用头指针冠以链表的名字</li>\n<li>无论链表是否为空，头指针均不为空。头指针式链表的必要元素</li>\n</ul>\n<h4 id=\"头结点\"><a href=\"#头结点\" class=\"headerlink\" title=\"头结点\"></a>头结点</h4><ul>\n<li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</li>\n<li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li>\n<li>头结点不一定是链表必须要素</li>\n</ul>\n<h3 id=\"7、获取链表第-i-个数据的算法思路\"><a href=\"#7、获取链表第-i-个数据的算法思路\" class=\"headerlink\" title=\"7、获取链表第 i 个数据的算法思路\"></a>7、获取链表第 i 个数据的算法思路</h3><ol>\n<li>声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，返回结点 p 的数据</li>\n</ol>\n<h3 id=\"8、单链表第-i-个数据插入结点的算法思路\"><a href=\"#8、单链表第-i-个数据插入结点的算法思路\" class=\"headerlink\" title=\"8、单链表第 i 个数据插入结点的算法思路\"></a>8、单链表第 i 个数据插入结点的算法思路</h3><ol>\n<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，在系统中生成一个空结点 s</li>\n<li>将数据元素 e 赋值给 s -&gt; data</li>\n<li>单链表的插入标准语句 s-&gt;next=p-&gt;next;p-&gt;next=s</li>\n<li>返回成功</li>\n</ol>\n<h3 id=\"9、单链表第-i-个数据删除结点的算法思路\"><a href=\"#9、单链表第-i-个数据删除结点的算法思路\" class=\"headerlink\" title=\"9、单链表第 i 个数据删除结点的算法思路\"></a>9、单链表第 i 个数据删除结点的算法思路</h3><ol>\n<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始</li>\n<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1</li>\n<li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li>\n<li>否则查找成功，\b将欲删除的结点 p -&gt; next 赋值给 q</li>\n<li>单链表的删除标准语句 p-&gt;next=q-&gt;next</li>\n<li>将 q 结点中的数据赋值给 e，作为返回</li>\n<li>释放 q 结点</li>\n<li>返回成功</li>\n</ol>\n<h3 id=\"10、单链表整表创建的算法思路\"><a href=\"#10、单链表整表创建的算法思路\" class=\"headerlink\" title=\"10、单链表整表创建的算法思路\"></a>10、单链表整表创建的算法思路</h3><ol>\n<li>声明一结点 p 和计数器变量 i</li>\n<li>初始化一空链表 L</li>\n<li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表</li>\n<li>循环：</li>\n</ol>\n<ul>\n<li>生成一新结点赋值给 p</li>\n<li>随机生成一数字赋值给 p 的数据域 p-&gt;data</li>\n<li>将 p 插入到头结点与前一新节点之间</li>\n</ul>\n<h3 id=\"11、单链表的整表删除\"><a href=\"#11、单链表的整表删除\" class=\"headerlink\" title=\"11、单链表的整表删除\"></a>11、单链表的整表删除</h3><ol>\n<li>声明一结点 p 和 q</li>\n<li>将第一个结点赋值给 p</li>\n<li>循环：</li>\n</ol>\n<ul>\n<li>将下一结点赋值给 q</li>\n<li>释放 p</li>\n<li>将 q 赋值给 p</li>\n</ul>\n<h3 id=\"12、单链表结构和顺序存储结构做对比\"><a href=\"#12、单链表结构和顺序存储结构做对比\" class=\"headerlink\" title=\"12、单链表结构和顺序存储结构做对比\"></a>12、单链表结构和顺序存储结构做对比</h3><div align=\"center\"><img src=\"/images/hexo_post_150.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"13、所谓的成功男人就是-3-岁时不尿裤子，5-岁能自己吃饭……80-岁能自己吃饭，90-岁能不尿裤子\"><a href=\"#13、所谓的成功男人就是-3-岁时不尿裤子，5-岁能自己吃饭……80-岁能自己吃饭，90-岁能不尿裤子\" class=\"headerlink\" title=\"13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子\"></a>13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子</h3><h3 id=\"14、循环链表\"><a href=\"#14、循环链表\" class=\"headerlink\" title=\"14、循环链表\"></a>14、循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）:</p>\n<div align=\"center\"><img src=\"/images/hexo_post_151.png\" alt=\"\" width=\"500\"></div>\n\n<p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断 p-&gt;next 是否为空，现在则是 <strong>p-&gt;next 不等于头结点，则循环未结束</strong></p>\n<h3 id=\"15、合并两个循环链表\"><a href=\"#15、合并两个循环链表\" class=\"headerlink\" title=\"15、合并两个循环链表\"></a>15、合并两个循环链表</h3><div align=\"center\"><img src=\"/images/hexo_post_152.png\" alt=\"\" width=\"500\"></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p=rearA-&gt;next;                   /* 保存A表的头结点，即① */</span><br><span class=\"line\">rearA-&gt;next=rearB-&gt;next-&gt;next;   /* 将本是指向B表的第一个结点（不是头结点） */</span><br><span class=\"line\">                                 /* 赋值给rearA-&gt;next，即 ②*/</span><br><span class=\"line\">rearB-&gt;next=p;                   /* 将原A表的头结点赋值给rearB-&gt;next，即③ */</span><br><span class=\"line\">free(p);                         /* 释放p */</span><br></pre></td></tr></table></figure>\n<h3 id=\"16、双向链表\"><a href=\"#16、双向链表\" class=\"headerlink\" title=\"16、双向链表\"></a>16、双向链表</h3><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域</p>\n<h3 id=\"17、双向链表的插入\"><a href=\"#17、双向链表的插入\" class=\"headerlink\" title=\"17、双向链表的插入\"></a>17、双向链表的插入</h3><p>假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间需要下面几步：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_153.png\" alt=\"\" width=\"400\"></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-&gt;prior=p;           /* 把 p 赋值给 s 的前驱，如图中① */</span><br><span class=\"line\">s-&gt;next=p-&gt;next;      /* 把 p-&gt;next 赋值给 s 的后继，如图中② */</span><br><span class=\"line\">p-&gt;next-&gt;prior=s;     /* 把 s 赋值给 p-&gt;next 的前驱，如图中③ */</span><br><span class=\"line\">p-&gt;next=s;            /* 把 s 赋值给 p 的后继，如图中④ */</span><br></pre></td></tr></table></figure>\n<h3 id=\"18、线性表的总结\"><a href=\"#18、线性表的总结\" class=\"headerlink\" title=\"18、线性表的总结\"></a>18、线性表的总结</h3><div align=\"center\"><img src=\"/images/hexo_post_154.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"三、栈与队列\"><a href=\"#三、栈与队列\" class=\"headerlink\" title=\"三、栈与队列\"></a>三、栈与队列</h2><h3 id=\"1、栈的定义\"><a href=\"#1、栈的定义\" class=\"headerlink\" title=\"1、栈的定义\"></a>1、栈的定义</h3><p>栈（stack）是限定<strong>仅在表尾进行插入和删除操作</strong>的线性表，我们把允许插入和删除的一端称为<strong>栈顶</strong>（top），另一端称为<strong>栈底</strong>（bottom），不含任何数据元素的栈称为<strong>空栈</strong></p>\n<h3 id=\"2、当栈存在一个元素时，top-等于-0，因此通常把空栈的判定条件定位-top-等于-1（索引值从-0-开始）\"><a href=\"#2、当栈存在一个元素时，top-等于-0，因此通常把空栈的判定条件定位-top-等于-1（索引值从-0-开始）\" class=\"headerlink\" title=\"2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）\"></a>2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）</h3><h3 id=\"3、用一个数组来存储两个栈\"><a href=\"#3、用一个数组来存储两个栈\" class=\"headerlink\" title=\"3、用一个数组来存储两个栈\"></a>3、用一个数组来存储两个栈</h3><div align=\"center\"><img src=\"/images/hexo_post_155.png\" alt=\"\" width=\"700\"></div>\n\n<p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 n - 1 处。这样，如果两个栈增加元素，就是两端点向中间延伸</p>\n<p><strong>两个栈见面之时，也就是两个指针之间相差 1 时，即 top1 + 1 == top2为栈满</strong></p>\n<h3 id=\"4、递归定义\"><a href=\"#4、递归定义\" class=\"headerlink\" title=\"4、递归定义\"></a>4、递归定义</h3><p>一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数；每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>\n<h3 id=\"5、队列定义\"><a href=\"#5、队列定义\" class=\"headerlink\" title=\"5、队列定义\"></a>5、队列定义</h3><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表；允许插入的一端称为队尾，允许删除的一端称为队头</p>\n<h3 id=\"6、队列的链式存储结构\"><a href=\"#6、队列的链式存储结构\" class=\"headerlink\" title=\"6、队列的链式存储结构\"></a>6、队列的链式存储结构</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；队头指针指向链队列的头结点，而队尾指针指向终端结点：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_156.png\" alt=\"\" width=\"400\"></div>\n\n<p>空队列时，front 和 rear 都指向头结点</p>\n<h3 id=\"7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\"><a href=\"#7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\" class=\"headerlink\" title=\"7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列\"></a>7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列</h3><h3 id=\"8、栈和队列的存储结构\"><a href=\"#8、栈和队列的存储结构\" class=\"headerlink\" title=\"8、栈和队列的存储结构\"></a>8、栈和队列的存储结构</h3><div align=\"center\"><img src=\"/images/hexo_post_295.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"9、关于栈和队列的人生感悟\"><a href=\"#9、关于栈和队列的人生感悟\" class=\"headerlink\" title=\"9、关于栈和队列的人生感悟\"></a>9、关于栈和队列的人生感悟</h3><p>人生，就像是一个很大的栈演变。出生时你赤条条地来到人世，慢慢地长大，渐渐地变老，最终还得赤条条地离开世间。<br>人生，又仿佛是一天一天小小的栈重现。童年父母每天抱你不断地进出家门，壮年你每天奔波于家与事业之间，老年你每天独自蹒跚于养老院的门里屋前。<br>人生，更需要有进栈出栈精神的体现。在哪里跌倒，就应该在哪里爬起来。无论陷入何等困境，只要抬头能仰望蓝天，就有希望，不断进取，你就可以让出头之日重现。困难不会永远存在，强者才能勇往直前。<br>人生，其实就是一个大大的队列演变。无知童年、快乐少年，稚傲青年，成熟中年，安逸晚年。<br>人生，又是一个又一个小小的队列重现。春夏秋冬轮回年年，早中晚夜循环天天。变化的是时间，不变的是你对未来执着的信念。<br>人生，更需要有队列精神的体现。南极到北极，不过是南纬90度到北纬90度的队列，如果你中途犹豫，临时转向，也许你就只能和企鹅相伴永远。可事实上，无论哪个方向，只要你坚持到底，你都可以到达终点。</p>\n<h2 id=\"四、串（字符串）\"><a href=\"#四、串（字符串）\" class=\"headerlink\" title=\"四、串（字符串）\"></a>四、串（字符串）</h2><h3 id=\"1、一首回文诗（李禺《两相思》）\"><a href=\"#1、一首回文诗（李禺《两相思》）\" class=\"headerlink\" title=\"1、一首回文诗（李禺《两相思》）\"></a>1、一首回文诗（李禺《两相思》）</h3><blockquote>\n<p>枯眼望遥山隔水，<br>往来曾见几心知？<br>壶空怕酌一杯酒，<br>笔下难成和韵诗。<br>途路阻人离别久，<br>讯音无雁寄回迟。<br>孤灯夜守长寥寂，<br>夫忆妻兮父忆儿。</p>\n</blockquote>\n<p>更多回文诗可以<a href=\"http://baike.baidu.com/link?url=VNTgFjBN0q2gekPkKqes9MWMtdOqf8_THZ-MuEh3vJTBKi88oJmvcrHNAkswt_oKY5pR58CL8C0CPKEHFfLFQpb6ZOQPU3W4G-P9z9gv6P2D4cO1CxwgyrBQNUg3fGfu\" target=\"_blank\" rel=\"noopener\">戳我一下</a></p>\n<h3 id=\"2、英语单词中的字符串\"><a href=\"#2、英语单词中的字符串\" class=\"headerlink\" title=\"2、英语单词中的字符串\"></a>2、英语单词中的字符串</h3><p>即使是 lover 也有个 over，即使是 friend 也有个 end，即使是 believe 也有个lie</p>\n<h3 id=\"3、关于字符串的一些概念\"><a href=\"#3、关于字符串的一些概念\" class=\"headerlink\" title=\"3、关于字符串的一些概念\"></a>3、关于字符串的一些概念</h3><p><strong>空格串</strong>：是只包含空格的串，空格串是有内容有长度的，而且可以不止一个空格<br>子串与主串：串中任意个数的连续字符组成的子序列称为该串的<strong>子串</strong>，相应地，包含子串的串称为<strong>主串</strong><br><strong>子串在主串中的位置</strong>：就是子串的第一个字符在主串中的序号</p>\n<h3 id=\"4、Unicode-和-ASCII-编码\"><a href=\"#4、Unicode-和-ASCII-编码\" class=\"headerlink\" title=\"4、Unicode 和 ASCII 编码\"></a>4、Unicode 和 ASCII 编码</h3><p>\b计算机中的常用字符是使用标准的 ASCII 编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展 ASCII 码由 8 位二进制数表示一个字符，总共可以表示 256 个字符；可是换做全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了 Unicode 编码，比较常用的是由 16 位的二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和 ASCII 码兼容，Unicode 的前 256 个字符与 ASCII 码完全相同</p>\n<h3 id=\"5、两个字符串的比较\"><a href=\"#5、两个字符串的比较\" class=\"headerlink\" title=\"5、两个字符串的比较\"></a>5、两个字符串的比较</h3><p>给定两个串：s=”a1a2……an”，t=”b1b2……bm”，当满足以下条件之一时，s &lt; t</p>\n<ul>\n<li>n &lt; m，且 ai=bi（i=1，2，……n），例如当 s=”hap”，t=”happy”，就有 s &lt; t。因为 t 比 s 多出了两个字母</li>\n<li>存在某个 k ≤ min(m,n)，使得 ai = bi（i=1，2，……，,k-1），ak &lt; bk，例如当 s=”happen”，t=”happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母（k 值），字母 e 的 ASCII 码是 101，而字母 y 的 ASCII 码是 121，显然 e &lt; y，所以 s &lt; t</li>\n</ul>\n<h2 id=\"五、树\"><a href=\"#五、树\" class=\"headerlink\" title=\"五、树\"></a>五、树</h2><h3 id=\"1、一些概念\"><a href=\"#1、一些概念\" class=\"headerlink\" title=\"1、一些概念\"></a>1、一些概念</h3><ul>\n<li>结点拥有的子树数称为结点的度（Degree）；</li>\n<li>度为 0 的结点称为叶节点（Leaf）或终端结点；</li>\n<li>度不为 0 的结点称为非终端结点或分支结点；</li>\n<li>除根结点之外，分支结点也成为内部结点树的度是树内各结点的度的最大值</li>\n<li>树中结点的最大层次称为树的深度（Depth）或高度</li>\n</ul>\n<h3 id=\"2、线性表与树的结构\"><a href=\"#2、线性表与树的结构\" class=\"headerlink\" title=\"2、线性表与树的结构\"></a>2、线性表与树的结构</h3><div align=\"center\"><img src=\"/images/hexo_post_158.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"3、双亲表示法\"><a href=\"#3、双亲表示法\" class=\"headerlink\" title=\"3、双亲表示法\"></a>3、双亲表示法</h3><p>以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置；由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_159.png\" alt=\"\" width=\"300\"></div>\n\n<p>这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，知道 parent 为 -1 时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，需要遍历整个结构。</p>\n<h3 id=\"4、多重链表表示法\"><a href=\"#4、多重链表表示法\" class=\"headerlink\" title=\"4、多重链表表示法\"></a>4、多重链表表示法</h3><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法；不过，树的每个结点的度，也就是孩子个数是不同的，所以可以设计两种方案来解决：</p>\n<h4 id=\"方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\"><a href=\"#方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\" class=\"headerlink\" title=\"方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）\"></a>方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值）</h4><div align=\"center\"><img src=\"/images/hexo_post_160.png\" alt=\"\" width=\"500\"></div>\n\n<p>其中 data 是数据域，child1 到 childd 是指针域，用来指向该结点的孩子结点，这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的</p>\n<h4 id=\"方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\"><a href=\"#方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\" class=\"headerlink\" title=\"方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数\"></a>方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数</h4><div align=\"center\"><img src=\"/images/hexo_post_296.png\" alt=\"\" width=\"500\"></div>\n\n<p>这种方法提升了空间利用率，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗</p>\n<h3 id=\"5、孩子表示法\"><a href=\"#5、孩子表示法\" class=\"headerlink\" title=\"5、孩子表示法\"></a>5、孩子表示法</h3><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_162.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"6、双亲孩子表示法\"><a href=\"#6、双亲孩子表示法\" class=\"headerlink\" title=\"6、双亲孩子表示法\"></a>6、双亲孩子表示法</h3><div align=\"center\"><img src=\"/images/hexo_post_163.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"7、孩子兄弟表示法\"><a href=\"#7、孩子兄弟表示法\" class=\"headerlink\" title=\"7、孩子兄弟表示法\"></a>7、孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_164.png\" alt=\"\" width=\"300\"></div>\n\n<p>data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址，这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树</p>\n<h3 id=\"8、二叉树特点\"><a href=\"#8、二叉树特点\" class=\"headerlink\" title=\"8、二叉树特点\"></a>8、二叉树特点</h3><ul>\n<li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点（没有子树或者有一棵子树都是可以的）</li>\n<li>左子树和右子树是有顺序的，次序不能任意颠倒</li>\n<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</li>\n</ul>\n<h3 id=\"9、二叉树五种基本形态\"><a href=\"#9、二叉树五种基本形态\" class=\"headerlink\" title=\"9、二叉树五种基本形态\"></a>9、二叉树五种基本形态</h3><ol>\n<li>空二叉树</li>\n<li>只有一个根结点</li>\n<li>根结点只有左子树</li>\n<li>根结点只有右子树</li>\n<li>根结点既有左子树又有右子树</li>\n</ol>\n<h3 id=\"10、特殊二叉树\"><a href=\"#10、特殊二叉树\" class=\"headerlink\" title=\"10、特殊二叉树\"></a>10、特殊二叉树</h3><h4 id=\"斜树\"><a href=\"#斜树\" class=\"headerlink\" title=\"斜树\"></a>斜树</h4><p>所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树，这两者统称为斜树</p>\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</p>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_165.png\" alt=\"\" width=\"400\"></div>\n\n<p><strong>完全二叉树的特点：</strong></p>\n<ul>\n<li>叶子结点只能出现在最下两层</li>\n<li>最下层的叶子一定集中在左部连续位置</li>\n<li>倒数二层，若有叶子结点，一定都在右部连续位置</li>\n<li>如果结点度为 1，则该节点只有左孩子，即不存在只有右子树的情况</li>\n<li>同样结点数的二叉树，完全二叉树的深度最小</li>\n</ul>\n<h3 id=\"11、二叉树的性质\"><a href=\"#11、二叉树的性质\" class=\"headerlink\" title=\"11、二叉树的性质\"></a>11、二叉树的性质</h3><ol>\n<li>在二叉树的第 i 层上至多有 <strong>2i-1</strong> 个结点（i ≥ 1）</li>\n<li>深度为 k 的二叉树至多有 <strong>2k-1</strong> 个结点（k ≥ 1）</li>\n<li>对任何一棵二叉树 T，如果其终端结点数为 <strong>n0</strong>，度为 2 的节点数为 <strong>n2</strong>，则 <strong>n0 = n2 + 1</strong>（解释见下图）</li>\n<li>具有 n 个结点的完全二叉树的深度为 <strong>⌊log2n⌋ + 1</strong>（⌊x⌋ 表示不大于 x 的最大整数）</li>\n<li>如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log2n⌋+1）的结点按层序编号（从第 1 层到第 ⌊log2n⌋ + 1 层，每层从左到右），对任一结点 i（1≤i≤n）有：</li>\n</ol>\n<ul>\n<li>如果 i = 1，则结点i是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 ⌊i / 2⌋</li>\n<li>如果 2i &gt; n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左结点是结点 2i</li>\n<li>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_166.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"12、二叉链表\"><a href=\"#12、二叉链表\" class=\"headerlink\" title=\"12、二叉链表\"></a>12、二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_167.png\" alt=\"\" width=\"300\"></div>\n\n<p>其中 data 是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针</p>\n<h3 id=\"13、二叉树遍历方法\"><a href=\"#13、二叉树遍历方法\" class=\"headerlink\" title=\"13、二叉树遍历方法\"></a>13、二叉树遍历方法</h3><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树，遍历的顺序为：ABDGHCEIF</p>\n<div align=\"center\"><img src=\"/images/hexo_post_168.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树，遍历的顺序为：GDHBAEICF</p>\n<div align=\"center\"><img src=\"/images/hexo_post_169.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点，遍历的顺序为：GHDBIEFCA</p>\n<div align=\"center\"><img src=\"/images/hexo_post_170.png\" alt=\"\" width=\"300\"></div>\n\n<h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><p>若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序堆结点逐个访问，遍历的顺序为：ABCDEFGHI</p>\n<div align=\"center\"><img src=\"/images/hexo_post_171.png\" alt=\"\" width=\"300\"></div>\n\n<h3 id=\"14、两个二叉树遍历的性质\"><a href=\"#14、两个二叉树遍历的性质\" class=\"headerlink\" title=\"14、两个二叉树遍历的性质\"></a>14、两个二叉树遍历的性质</h3><ul>\n<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>\n<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>\n<li>但是已知前序和后序遍历，是不能确定一棵二叉树的</li>\n</ul>\n<h3 id=\"15、线索二叉树\"><a href=\"#15、线索二叉树\" class=\"headerlink\" title=\"15、线索二叉树\"></a>15、线索二叉树</h3><p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树</p>\n<div align=\"center\"><img src=\"/images/hexo_post_172.png\" alt=\"\" width=\"500\"></div>\n\n<p>通过上图（空心箭头实线为前驱，虚线黑箭头为后继），可以看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表；所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化；但是，我们并不知道某一结点的 lchild 是指向它的左孩子还是指向前驱，所以需要一个区分标致；因此，我们在每个结点再增设两个标志域 ltag 和 rtag，这两个 tag 只是存放 0 或 1 数字的布尔型变量，其占用的内存空间要小于像 lchild 和 rchild 的指针变量，结点结构如下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_173.png\" alt=\"\" width=\"400\"></div>\n\n<ul>\n<li>ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱</li>\n<li>rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_174.png\" alt=\"\" width=\"500\"></div>\n\n<p><strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong></p>\n<h3 id=\"16、树转换为二叉树\"><a href=\"#16、树转换为二叉树\" class=\"headerlink\" title=\"16、树转换为二叉树\"></a>16、树转换为二叉树</h3><ol>\n<li>加线，在所有兄弟结点之间加一条连线</li>\n<li>去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>\n<li>层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_175.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"17、森林转换为二叉树\"><a href=\"#17、森林转换为二叉树\" class=\"headerlink\" title=\"17、森林转换为二叉树\"></a>17、森林转换为二叉树</h3><ol>\n<li>把每个树转换为二叉树</li>\n<li>第一棵二叉树不动，从第二棵二叉树开始，以此把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来，当所有的二叉树连接起来后就得到了由森林转换来的二叉树</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_176.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"18、二叉树转换为树\"><a href=\"#18、二叉树转换为树\" class=\"headerlink\" title=\"18、二叉树转换为树\"></a>18、二叉树转换为树</h3><ol>\n<li>加线，若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接起来</li>\n<li>去线，删除原二叉树中所有结点与其右孩子结点的连线</li>\n<li>层次调整，使之结构层次分明</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_177.png\" alt=\"\" width=\"500\"></div>\n\n<h3 id=\"19、二叉树转换为森林\"><a href=\"#19、二叉树转换为森林\" class=\"headerlink\" title=\"19、二叉树转换为森林\"></a>19、二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树</p>\n<ol>\n<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树</li>\n<li>再将每棵分离后的二叉树转换为树即可</li>\n</ol>\n<div align=\"center\"><img src=\"/images/hexo_post_178.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"20、树的遍历\"><a href=\"#20、树的遍历\" class=\"headerlink\" title=\"20、树的遍历\"></a>20、树的遍历</h3><ol>\n<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树</li>\n<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li>\n</ol>\n<h3 id=\"21、森林的遍历\"><a href=\"#21、森林的遍历\" class=\"headerlink\" title=\"21、森林的遍历\"></a>21、森林的遍历</h3><ol>\n<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先跟遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林</li>\n<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林</li>\n</ol>\n<p><strong>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树中的中序遍历结果相同</strong></p>\n<h3 id=\"22、赫夫曼树算法描述\"><a href=\"#22、赫夫曼树算法描述\" class=\"headerlink\" title=\"22、赫夫曼树算法描述\"></a>22、赫夫曼树算法描述</h3><ol>\n<li>根据给定的n个权值 {w1，w2，···wn} 构成 n 棵二叉树的集合 F={T1，T2，···Tn}，其中每个二叉树 Ti 中只有一个带权为 wi 的根结点，其左右子树均为空。</li>\n<li>在 F 中选择两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。</li>\n<li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li>\n<li>重复 2 和 3，直到 F 只含一棵树为止。这棵树便是赫夫曼树。</li>\n</ol>\n<h3 id=\"23、赫夫曼编码\"><a href=\"#23、赫夫曼编码\" class=\"headerlink\" title=\"23、赫夫曼编码\"></a>23、赫夫曼编码</h3><p>一般地，设需要编码的字符集为 {d1，d2，···dn}，各个字符在电文中出现的次数或频率集合为 {w1，w2，···wn}，以 d1，d2，···dn 作为叶子结点，以 w1，w2，···wn 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码</p>\n<h2 id=\"六、图\"><a href=\"#六、图\" class=\"headerlink\" title=\"六、图\"></a>六、图</h2><h3 id=\"1、图的定义\"><a href=\"#1、图的定义\" class=\"headerlink\" title=\"1、图的定义\"></a>1、图的定义</h3><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合</p>\n<h3 id=\"2、关于图的一些定义\"><a href=\"#2、关于图的一些定义\" class=\"headerlink\" title=\"2、关于图的一些定义\"></a>2、关于图的一些定义</h3><ul>\n<li><strong>无向边</strong>：若顶点 vi 到 vj 之间的边没有方向，则称这条边为无向边（Edge），用无需偶对（vi，vj）来表示</li>\n<li><p><strong>有向边</strong>：若从顶点 vi 到 vj 的边有方向，则称这条边为有向边，也成为弧（Arc）<br><strong>无向边用小括号 “()” 表示，而有向边则是用尖括号 “&lt;&gt;” 表示</strong></p>\n</li>\n<li><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为<strong>简单图</strong></p>\n</li>\n<li>在无向图中，如果任意两个顶点之间都存在边，则称该图为<strong>无向完全图</strong></li>\n<li>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为<strong>有向完全图</strong></li>\n<li>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong></li>\n<li>这里稀疏和稠密是模糊的概念，是相对而言的 有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做<strong>权</strong>（Weight）</li>\n<li>带权的图通常称为<strong>网</strong>（Network）</li>\n<li>假设有两个图 G =（V，{E}）和G’ =（V’，{E’}），如果 V’ ⊆ V 且 E’ ⊆ E，则称 G’ 为 G 的<strong>子图</strong>（Subgraph）</li>\n<li>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。</li>\n<li>若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。</li>\n<li>图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量 无向图中连通且n个顶点n-1条边叫生成树。</li>\n<li>有向图中一顶点入度为0其余顶点入度为1的叫有向树。</li>\n<li>一个有向图由若干棵有向树构成生成森林</li>\n</ul>\n<blockquote>\n<p>由于定义实在太多，就不再叙述了，可以<a href=\"http://blog.csdn.net/luoweifu/article/details/9270439\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看关于图的其他定义</p>\n</blockquote>\n<h3 id=\"3、图的邻接矩阵\"><a href=\"#3、图的邻接矩阵\" class=\"headerlink\" title=\"3、图的邻接矩阵\"></a>3、图的邻接矩阵</h3><p>图的邻接矩阵（Adiacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息 n 个顶点和 e 条边的无向网图的创建，时间复杂度为 O（n+n2+e），其中对邻接矩阵的初始化需要耗费 O（n2）的时间</p>\n<h3 id=\"4、邻接表\"><a href=\"#4、邻接表\" class=\"headerlink\" title=\"4、邻接表\"></a>4、邻接表</h3><p>数组与链表相结合的存储方法称为邻接表 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息 图中每个顶点 vi 的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点 vi 的边表，有向图则称为顶点 vi 作为弧尾的出边表</p>\n<div align=\"center\"><img src=\"/images/hexo_post_179.png\" alt=\"\" width=\"600\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_180.png\" alt=\"\" width=\"600\"></div>\n\n<p>若是有向图，邻接表结构是类似的，但我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度，但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立<strong>一个有向图的逆邻接表，即对每个顶点 vi 都建立一个链接为 vi 为弧头的表</strong> 对于带权值的网图，可以在边表结点定义中再<strong>增加一个 weight 的数据域</strong>，存储权值信息即可</p>\n<h3 id=\"5、图的遍历\"><a href=\"#5、图的遍历\" class=\"headerlink\" title=\"5、图的遍历\"></a>5、图的遍历</h3><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）</p>\n<h3 id=\"6、深度优先遍历（DFS）\"><a href=\"#6、深度优先遍历（DFS）\" class=\"headerlink\" title=\"6、深度优先遍历（DFS）\"></a>6、深度优先遍历（DFS）</h3><p>从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止</p>\n<h3 id=\"7、广度优先遍历（BFS）\"><a href=\"#7、广度优先遍历（BFS）\" class=\"headerlink\" title=\"7、广度优先遍历（BFS）\"></a>7、广度优先遍历（BFS）</h3><p>如果说<strong>图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历</strong>了，如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_181.png\" alt=\"\" width=\"450\"></div>\n\n<h3 id=\"8、图的两种遍历方式的比较\"><a href=\"#8、图的两种遍历方式的比较\" class=\"headerlink\" title=\"8、图的两种遍历方式的比较\"></a>8、图的两种遍历方式的比较</h3><p>两者在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同，可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过，深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>\n<h3 id=\"9、最小生成树\"><a href=\"#9、最小生成树\" class=\"headerlink\" title=\"9、最小生成树\"></a>9、最小生成树</h3><p>我们把构造连通网的最小代价生成树称为<strong>最小生成树</strong>（Minimum Cost Spanning Tree）<br>找连通网的最小生成树，经典的有两种算法，<strong>普利姆算法</strong>和<strong>克鲁斯卡尔算法</strong></p>\n<h3 id=\"10、普利姆（Prim）算法\"><a href=\"#10、普利姆（Prim）算法\" class=\"headerlink\" title=\"10、普利姆（Prim）算法\"></a>10、普利姆（Prim）算法</h3><h4 id=\"算法思路：\"><a href=\"#算法思路：\" class=\"headerlink\" title=\"算法思路：\"></a>算法思路：</h4><p>以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</p>\n<h4 id=\"算法步骤：\"><a href=\"#算法步骤：\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><ol>\n<li>输入：一个加权连通图，其中顶点集合为 V，边集合为 E；</li>\n<li>初始化：Vnew = {x}，其中 x 为集合 V 中的任一节点（起始点），Enew = {}，为空；</li>\n<li>重复下列操作，直到 Vnew = V：</li>\n</ol>\n<ul>\n<li>在集合 E 中选取权值最小的边 <code>&lt;u, v&gt;</code>，其中 u 为集合 Vnew 中的元素，而 v 不在 <code>Vnew</code> 集合当中，并且 v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</li>\n<li>将 v 加入集合 Vnew 中，将 <code>&lt;u, v&gt;</code> 边加入集合 Enew 中；</li>\n</ul>\n<ol start=\"4\">\n<li>输出：使用集合 Vnew 和 Enew 来描述所得到的最小生成树。</li>\n</ol>\n<p>书中有非常详尽的解释，但是感觉解释的比较繁琐，建议去看一下<a href=\"http://baike.baidu.com/link?url=9SZQiA3Zm97fe1rIVtGuUCX0FszUTNnk2Qv5XwbPNZpFvjKgRfCL5PnqfPrEo2RdJQo1Asw2bdQx4RujLJL78X8AbfsvN6TUbVKl7w8a2CNQEADeXcqZydK4wrEmYFXybxEKUnpa83ksvSxsJS-zSbyMgjt-9r5Zx3aMquBsMJ26Qj_m2irhgVvsJsxw0QB8\" target=\"_blank\" rel=\"noopener\">百度百科</a>中的讲解</p>\n<h3 id=\"11、克鲁斯卡尔（Kruskal）算法\"><a href=\"#11、克鲁斯卡尔（Kruskal）算法\" class=\"headerlink\" title=\"11、克鲁斯卡尔（Kruskal）算法\"></a>11、克鲁斯卡尔（Kruskal）算法</h3><h4 id=\"算法思路：-1\"><a href=\"#算法思路：-1\" class=\"headerlink\" title=\"算法思路：\"></a>算法思路：</h4><p>因为权值是在边上，所以直接去找最小权值的边来构建生成树，只不过构建时要考虑是否会形成环路而已</p>\n<h4 id=\"算法步骤：-1\"><a href=\"#算法步骤：-1\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><p>先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。关于这个算法，百度百科上的讲解就不是很清楚了，如果感兴趣的话可以自行查阅其他资料</p>\n<h3 id=\"12、Prim-算法和-Kruskal-算法的对比\"><a href=\"#12、Prim-算法和-Kruskal-算法的对比\" class=\"headerlink\" title=\"12、Prim 算法和 Kruskal 算法的对比\"></a>12、Prim 算法和 Kruskal 算法的对比</h3><p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以堆于稀疏图有很大的优势；而普利姆算法对于稠密图，即边数非常多的情况会更好一些</p>\n<h3 id=\"13、最短路径\"><a href=\"#13、最短路径\" class=\"headerlink\" title=\"13、最短路径\"></a>13、最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点 主要有两种求最短路径的算法：迪杰斯特拉算法和</p>\n<h3 id=\"14、迪杰斯特拉（Dijkstra）算法\"><a href=\"#14、迪杰斯特拉（Dijkstra）算法\" class=\"headerlink\" title=\"14、迪杰斯特拉（Dijkstra）算法\"></a>14、迪杰斯特拉（Dijkstra）算法</h3><h4 id=\"算法步骤：-2\"><a href=\"#算法步骤：-2\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><p>G = {V,E}</p>\n<ol>\n<li>初始时令 S = {V0}, T = V - S = {其余顶点}，T 中顶点对应的距离值</li>\n</ol>\n<p>若存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 &lt;V0,Vi&gt; 弧上的权值</p>\n<p>若不存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 ∞</p>\n<ol start=\"2\">\n<li><p>从 T 中选取一个与 S 中顶点有关联边且权值最小的顶点 W，加入到 S 中</p>\n</li>\n<li><p>对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值</p>\n</li>\n</ol>\n<p>重复上述步骤 2、3，直到 S 中包含所有顶点，即 W = Vi 为止</p>\n<h3 id=\"15、弗洛伊德（Floyd）算法\"><a href=\"#15、弗洛伊德（Floyd）算法\" class=\"headerlink\" title=\"15、弗洛伊德（Floyd）算法\"></a>15、弗洛伊德（Floyd）算法</h3><h4 id=\"算法步骤：-3\"><a href=\"#算法步骤：-3\" class=\"headerlink\" title=\"算法步骤：\"></a>算法步骤：</h4><ol>\n<li><p>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</p>\n</li>\n<li><p>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</p>\n</li>\n</ol>\n<p>把图用邻接矩阵 G 表示出来，如果从 Vi 到 Vj 有路可达，则 G[i][j] = d，d 表示该路的长度；否则 G[i][j] = 无穷大。定义一个矩阵D用来记录所插入点的信息，D[i][j] 表示从 Vi 到 Vj 需要经过的点，初始化 D[i][j] = j。把各个顶点插入图中，比较插点后的距离与原来的距离，G[i][j] = min( G[i][j], G[i][k]+G[k][j])，如果 G[i][j] 的值变小，则 D[i][j] = k。在 G 中包含有两点之间最短道路的信息，而在 D 中则包含了最短通路径的信息。</p>\n<p>比如，要寻找从 V5 到 V1 的路径。根据 D，假如 D(5,1) = 3 则说明从 V5 到 V1 经过 V3，路径为 {V5,V3,V1}，如果 D(5,3)=3，说明 V5 与 V3 直接相连，如果 D(3,1) = 1，说明 V3 与 V1 直接相连。</p>\n<h3 id=\"16、拓扑排序\"><a href=\"#16、拓扑排序\" class=\"headerlink\" title=\"16、拓扑排序\"></a>16、拓扑排序</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 <strong>AOV 网</strong>（Activity On Vertex Network）<br><strong>拓扑序列</strong>：设 G = (V,E)是一个具有 n 个顶点的有向图，V 中的顶点序列 V1，V2，……，Vn，满足若从顶点 Vi 到 Vj 有一条路径，则在顶点序列中顶点 Vi 必在顶点 Vj 之前。则我们称这样的顶点序列为一个<strong>拓扑序列</strong><br><strong>拓扑排序</strong>：其实就是对一个有向图构造拓扑序列的过程；构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的 AOV 网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是 AOV 网。</p>\n<h3 id=\"17、拓扑排序算法\"><a href=\"#17、拓扑排序算法\" class=\"headerlink\" title=\"17、拓扑排序算法\"></a>17、拓扑排序算法</h3><p><strong>对 AOV 网进行拓扑排序的基本思路</strong>是：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止</p>\n<h3 id=\"18、关键路径\"><a href=\"#18、关键路径\" class=\"headerlink\" title=\"18、关键路径\"></a>18、关键路径</h3><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为 <strong>AOE 网</strong>（Activity On Edge Network）；我们把 AOE 网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点；正常情况下，AOE 网只有一个源点一个汇点，我们把路径上各个活动所持续的时间之和称为<strong>路径长度</strong>，从源点到汇点具有最大长度的路径叫<strong>关键路径</strong>，在关键路径上的活动叫<strong>关键活动</strong></p>\n<h3 id=\"19、关键路径算法\"><a href=\"#19、关键路径算法\" class=\"headerlink\" title=\"19、关键路径算法\"></a>19、关键路径算法</h3><p>原理：我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。为此，我们需要定义如下几个参数：</p>\n<ol>\n<li>事件的<strong>最早发生时间etv</strong>（earliest time of vertex）：即顶点 Vk 的最早发生时间</li>\n<li>事件的<strong>最晚发生时间ltv</strong>（latest time of vertex）：即顶点 Vk 的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期</li>\n<li>活动的<strong>最早开工时间ete</strong>（earliest time of edge）：即弧 ak 的最早发生时间</li>\n<li>活动的<strong>最晚开工时间lte</strong>（latest time of edge）：即弧 ak 的最晚发生时间，也就是不推迟工期的最晚开工时间</li>\n</ol>\n<p>我们是由 1 和 2 可以求得 3 和 4，然后再根据 ete[k] 是否与 lte[k] 相等来判断 ak 是否是关键活动</p>\n<h3 id=\"20、世界上最遥远的距离……\"><a href=\"#20、世界上最遥远的距离……\" class=\"headerlink\" title=\"20、世界上最遥远的距离……\"></a>20、世界上最遥远的距离……</h3><blockquote>\n<p>世界上最遥远的距离，不是从南极到北极，而是我在讲解算法为何如此精妙，你却能够安详在课堂上休息。<br>世界上最遥远的距离，不是珠峰与马里亚纳海沟的距离，而是我欲把古人的智慧全盘给你，你却不屑一顾毫不怜惜。<br>世界上最遥远的距离，不是牛 A 与牛 C 之间狭小空隙，而是你们当中，有人在通往牛逼的路上一路狂奔，而有人步入大学校园就学会放弃。</p>\n</blockquote>\n<h3 id=\"七、查找\"><a href=\"#七、查找\" class=\"headerlink\" title=\"七、查找\"></a>七、查找</h3><h4 id=\"1、查找概论\"><a href=\"#1、查找概论\" class=\"headerlink\" title=\"1、查找概论\"></a>1、查找概论</h4><ul>\n<li><strong>查找表</strong>（Search Table）是由同一类型的数据元素（或记录）构成的集合</li>\n<li><strong>关键字</strong>（Key）是数据元素中某个数据项的值，又称为<strong>键值</strong></li>\n<li>若此关键字可以唯一地标识一个记录，则称此关键字为<strong>主关键字</strong>（Primary Key）</li>\n<li>那些可以识别多个数据元素（或记录）的关键字，我们称为<strong>次关键字</strong>（Secondary Key）</li>\n<li><strong>查找</strong>（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值得数据元素（或记录）</li>\n</ul>\n<h4 id=\"2、查找表操作方式\"><a href=\"#2、查找表操作方式\" class=\"headerlink\" title=\"2、查找表操作方式\"></a>2、查找表操作方式</h4><p>分为两大种：静态查找表和动态查找表 <strong>静态查找表</strong>（Static Search Table）：只作查找操作的查找表。它的主要操作有：</p>\n<ul>\n<li>查询某个“特定的”数据元素是否在查找表中</li>\n<li>检索某个“特定的”数据元素和各种属性</li>\n</ul>\n<p><strong>动态查找表</strong>（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：</p>\n<ul>\n<li>查找时插入数据元素</li>\n<li>查找时删除数据元素</li>\n</ul>\n<h4 id=\"3、顺序查找\"><a href=\"#3、顺序查找\" class=\"headerlink\" title=\"3、顺序查找\"></a>3、顺序查找</h4><p>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是： 从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</p>\n<h3 id=\"4、二分查找\"><a href=\"#4、二分查找\" class=\"headerlink\" title=\"4、二分查找\"></a>4、二分查找</h3><p>折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是： 在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</p>\n<h4 id=\"5、插值查找\"><a href=\"#5、插值查找\" class=\"headerlink\" title=\"5、插值查找\"></a>5、插值查找</h4><p>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])，对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多</p>\n<h3 id=\"6、斐波那契查找算法\"><a href=\"#6、斐波那契查找算法\" class=\"headerlink\" title=\"6、斐波那契查找算法\"></a>6、斐波那契查找算法</h3><h4 id=\"算法核心：\"><a href=\"#算法核心：\" class=\"headerlink\" title=\"算法核心：\"></a>算法核心：</h4><ol>\n<li>当 key = a[mid] 时，查找就成功</li>\n<li>当 key &lt; a[mid] 时，新范围是第 low 个到第 mid - 1 个，此时范围个数为 F[k-1] - 1 个</li>\n<li>当 key &gt; a[mid] 时，新范围是第 m + 1 个到第 high 个，此时范围个数为 F[k-2] - 1 个</li>\n</ol>\n<h3 id=\"7、三种查找算法的比较\"><a href=\"#7、三种查找算法的比较\" class=\"headerlink\" title=\"7、三种查找算法的比较\"></a>7、三种查找算法的比较</h3><p>折半查找是进行加法与除法运算 (mid = (low + high) / 2)，插值查找进行复杂的四则运算(mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]))，而斐波那契查找只是最简单加减法运算(mid = low + F[k-1] - 1)，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率</p>\n<h3 id=\"8、线性索引\"><a href=\"#8、线性索引\" class=\"headerlink\" title=\"8、线性索引\"></a>8、线性索引</h3><p><strong>索引</strong>就是把一个关键字与它对应的记录相关联的过程 所谓<strong>线性索引</strong>就是将索引项集合组织为线性结构，也称为<strong>索引表</strong> 三种线性索引：稠密索引、分块索引和倒排索引</p>\n<h3 id=\"9、稠密索引\"><a href=\"#9、稠密索引\" class=\"headerlink\" title=\"9、稠密索引\"></a>9、稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</p>\n<div align=\"center\"><img src=\"/images/hexo_post_182.png\" alt=\"\" width=\"400\"></div>\n\n<p>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列 索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率</p>\n<h3 id=\"10、分块索引\"><a href=\"#10、分块索引\" class=\"headerlink\" title=\"10、分块索引\"></a>10、分块索引</h3><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p>\n<ul>\n<li><strong>块内无序</strong>：当然如果能够让块内有序对查找来说更理想</li>\n<li><strong>块间有序</strong>：只有块间有序，才有可能在查找时带来效率</li>\n</ul>\n<h4 id=\"分块索引的索引项结构分三个数据项：\"><a href=\"#分块索引的索引项结构分三个数据项：\" class=\"headerlink\" title=\"分块索引的索引项结构分三个数据项：\"></a>分块索引的索引项结构分三个数据项：</h4><ul>\n<li><strong>最大关键码</strong>，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>\n<li>存储了<strong>块中的记录个数</strong>，以便于循环时使用</li>\n<li>用于<strong>指向块首数据元素的指针</strong>，便于开始对这一块中记录进行遍历</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_183.png\" alt=\"\" width=\"400\"></div>\n\n<h4 id=\"分块索引表中查找的步骤：\"><a href=\"#分块索引表中查找的步骤：\" class=\"headerlink\" title=\"分块索引表中查找的步骤：\"></a>分块索引表中查找的步骤：</h4><ol>\n<li>在分块索引表中查找要查关键字所在的块，可以利用折半、插值等算法</li>\n<li>根据块首指针找到响应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找</li>\n</ol>\n<h3 id=\"11、倒排索引\"><a href=\"#11、倒排索引\" class=\"headerlink\" title=\"11、倒排索引\"></a>11、倒排索引</h3><p>记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index） 倒排索引的优点就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长</p>\n<h3 id=\"12、二叉排序树\"><a href=\"#12、二叉排序树\" class=\"headerlink\" title=\"12、二叉排序树\"></a>12、二叉排序树</h3><p>二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>\n<li>它的左、右子树也分别为二叉排序树</li>\n</ul>\n<p>如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。</p>\n<h3 id=\"13、平衡二叉树\"><a href=\"#13、平衡二叉树\" class=\"headerlink\" title=\"13、平衡二叉树\"></a>13、平衡二叉树</h3><p>平衡二叉树（Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于 1；我们将二叉树上结点的左子树深度减去右子树深度的值称为<strong>平衡因子</strong>BF（Balance Factor），那么平衡二叉树上所有结点的平衡因子只可能是 -1，0，1</p>\n<h3 id=\"14、最小不平衡子树\"><a href=\"#14、最小不平衡子树\" class=\"headerlink\" title=\"14、最小不平衡子树\"></a>14、最小不平衡子树</h3><p>距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，我们称为<strong>最小不平衡子树</strong></p>\n<div align=\"center\"><img src=\"/images/hexo_post_184.png\" alt=\"\" width=\"400\"></div>\n\n<p>如上图所示，当新插入结点 37 时，距离它最近的平衡因子绝对值超过 1 的结点是 58（即它的左子树高度 2 减去右子树高度 0），所以从 58 开始以下的子树为最小不平衡子树</p>\n<h3 id=\"15、平衡二叉树实现算法\"><a href=\"#15、平衡二叉树实现算法\" class=\"headerlink\" title=\"15、平衡二叉树实现算法\"></a>15、平衡二叉树实现算法</h3><h4 id=\"算法原理：\"><a href=\"#算法原理：\" class=\"headerlink\" title=\"算法原理：\"></a>算法原理：</h4><p>基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应地旋转，使之成为新的平衡子树</p>\n<h4 id=\"右旋操作：\"><a href=\"#右旋操作：\" class=\"headerlink\" title=\"右旋操作：\"></a>右旋操作：</h4><div align=\"center\"><img src=\"/images/hexo_post_185.png\" alt=\"\" width=\"500\"></div>\n\n<p>左旋和右旋代码是对称的</p>\n<h3 id=\"16、多路查找树\"><a href=\"#16、多路查找树\" class=\"headerlink\" title=\"16、多路查找树\"></a>16、多路查找树</h3><p>多路查找树（multi-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</p>\n<h3 id=\"17、2-3-树\"><a href=\"#17、2-3-树\" class=\"headerlink\" title=\"17、2-3 树\"></a>17、2-3 树</h3><p>2-3 树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）。</p>\n<ul>\n<li>一个 2 结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似</li>\n<li>一个 3 结点包含一小一大两个元素和三个孩子（或没有孩子），左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素</li>\n<li>2-3 树中所有的叶子都在同一层次上</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_186.png\" alt=\"\" width=\"600\"></div>\n\n<h3 id=\"18、2-3树的插入实现\"><a href=\"#18、2-3树的插入实现\" class=\"headerlink\" title=\"18、2-3树的插入实现\"></a>18、2-3树的插入实现</h3><p>可分为三种情况：</p>\n<ol>\n<li>对于空树，插入一个 2 结点即可，这很容易理解</li>\n<li>插入结点到一个 2 结点的叶子上。由于其本身就只有一个元素，所以只需要将其升级为 3 结点即可</li>\n<li>要往 3 结点中插入一个新元素。因为 3 结点本身已经是 2-3 树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</li>\n</ol>\n<h3 id=\"19、2-3-4树\"><a href=\"#19、2-3-4树\" class=\"headerlink\" title=\"19、2-3-4树\"></a>19、2-3-4树</h3><p>就是 2-3 树的概念扩展，包括了 4 结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个 4 结点要么没有孩子，要么具有 4 个孩子。如果某个 4 结点有孩子的话，从左到右按照由小到大的顺序排列</p>\n<h3 id=\"20、B树\"><a href=\"#20、B树\" class=\"headerlink\" title=\"20、B树\"></a>20、B树</h3><p>B树（B-tree）是一种平衡的多路查找树，2-3树和 2-3-4树都是 B树的特例。结点最大的孩子数目称为 <strong>B树的阶</strong>（order），因此，2-3树是 3 阶 B树，2-3-4树是 4 阶 B树</p>\n<h4 id=\"一个-m-阶的-B-树具有如下属性：\"><a href=\"#一个-m-阶的-B-树具有如下属性：\" class=\"headerlink\" title=\"一个 m 阶的 B 树具有如下属性：\"></a>一个 m 阶的 B 树具有如下属性：</h4><ul>\n<li>如果根结点不是叶节点，则其至少有两棵子树</li>\n<li>每一个非根的分支结点都有 k-1 个元素和k个孩子，其中 ⌈m/2⌉ ≤ k ≤ m。每一个叶子节点 n 都有 k - 1 个元素，其中 ⌈m/2⌉ ≤ k ≤m</li>\n<li>所有叶子结点都位于同一层次</li>\n<li>所有分支结点包含下列信息数据（n,A0,K1,A1,K2,A2,…,Kn,An），其中：Ki(i=1,2,…,n) 为关键字，且 Ki&lt;Ki+1(i=1,2,…,n-1)；Ai(i=0,2,…,n) 为指向子树根结点的指针，且指针 A(i-1) 所指子树中所有结点的关键字均小于 Ki(i=1,2,…,n),An 所指子树中所有结点的关键字均大于 Kn，n·(⌈m/2⌉-1≤n≤m-1) 为关键字的个数（或 n + 1 为子树的个数）</li>\n</ul>\n<h3 id=\"21、B-树\"><a href=\"#21、B-树\" class=\"headerlink\" title=\"21、B+树\"></a>21、B+树</h3><p>在 B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子节点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针</p>\n<div align=\"center\"><img src=\"/images/hexo_post_187.png\" alt=\"\" width=\"400\"></div>\n\n<p>一棵 m 阶的 B+树和 m 阶的 B树的差异在于：</p>\n<ul>\n<li>有 n 棵子树的结点中包含有 n 个关键字</li>\n<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</li>\n<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字</li>\n</ul>\n<p>如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是沿着指向下一叶子结点的指针就可遍历所有的关键字</p>\n<h3 id=\"22、散列表（哈希表）\"><a href=\"#22、散列表（哈希表）\" class=\"headerlink\" title=\"22、散列表（哈希表）\"></a>22、散列表（哈希表）</h3><p><strong>散列技术</strong>是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)，散列技术既是一种存储方法，也是一种查找方法<br>散列技术最适合的求解问题是查找与给定值相等的记录 f称为散列函数，又称为<strong>哈希（Hash）函数</strong><br>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为<strong>散列表或哈希表</strong>（Hash table）</p>\n<h4 id=\"散列过程有两步：\"><a href=\"#散列过程有两步：\" class=\"headerlink\" title=\"散列过程有两步：\"></a>散列过程有两步：</h4><ol>\n<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录</li>\n<li>当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录</li>\n</ol>\n<h3 id=\"23、散列函数构造方法\"><a href=\"#23、散列函数构造方法\" class=\"headerlink\" title=\"23、散列函数构造方法\"></a>23、散列函数构造方法</h3><h4 id=\"直接定址法\"><a href=\"#直接定址法\" class=\"headerlink\" title=\"直接定址法\"></a>直接定址法</h4><p>取关键字的某个线性函数值为散列地址</p>\n<h4 id=\"数字分析法\"><a href=\"#数字分析法\" class=\"headerlink\" title=\"数字分析法\"></a>数字分析法</h4><p>如果我们的关键字是位数较多的数字，可以对数字进行翻转、右环位移、左环位移、甚至前两数与后两数叠加等方法，合理地将关键字分配到散列表的各位置</p>\n<h4 id=\"平方取中法\"><a href=\"#平方取中法\" class=\"headerlink\" title=\"平方取中法\"></a>平方取中法</h4><p>假设关键字是 1234，那么它的平方就是 1522756，再抽取中间的 3 位就是 227，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况</p>\n<h4 id=\"折叠法\"><a href=\"#折叠法\" class=\"headerlink\" title=\"折叠法\"></a>折叠法</h4><p>将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况 比如我们的关键字是 9876543210，散列表表长为三位，我们将它分为四组，987|654|321|0，然后将它们叠加求和 987 + 654 + 321 + 0 = 1962，再求后 3 位得到散列地址为 962。</p>\n<h4 id=\"除留余数法\"><a href=\"#除留余数法\" class=\"headerlink\" title=\"除留余数法\"></a>除留余数法</h4><p>对关键字直接取模，也可在折叠、平方取中后再取模，对于散列表长为 m 的散列函数公式为：</p>\n<blockquote>\n<p>f(key)=key mod p(p≤m)</p>\n</blockquote>\n<p>根据前辈们的经验，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m）的最小质数或不包含小于 20 质因子的合数</p>\n<h4 id=\"随机数法\"><a href=\"#随机数法\" class=\"headerlink\" title=\"随机数法\"></a>随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址</p>\n<h3 id=\"24、采用不同的散列函数应该考虑的因素\"><a href=\"#24、采用不同的散列函数应该考虑的因素\" class=\"headerlink\" title=\"24、采用不同的散列函数应该考虑的因素\"></a>24、采用不同的散列函数应该考虑的因素</h3><ul>\n<li>计算散列地址所需的时间</li>\n<li>关键字的长度</li>\n<li>散列表的大小</li>\n<li>关键字的分布情况</li>\n<li>记录查找的频率</li>\n</ul>\n<h3 id=\"25、处理散列冲突的方法\"><a href=\"#25、处理散列冲突的方法\" class=\"headerlink\" title=\"25、处理散列冲突的方法\"></a>25、处理散列冲突的方法</h3><h4 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h4><p>一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入，公式是：</p>\n<blockquote>\n<p>fi(key)=（f(key)+di）MOD m(di=1,2,3,……,m-1)</p>\n</blockquote>\n<p>这种解决冲突的开放定址法称为<strong>线性探测法</strong><br>如果 di 改进为正负两类值，等于是可以双向寻找到可能的空位置，可以不让关键字都聚集在某一块区域。我们称这种方法为<strong>二次探测法</strong><br>如果 di 采用随机函数计算得到，我们称之为<strong>随机探测法</strong></p>\n<h4 id=\"再散列函数法\"><a href=\"#再散列函数法\" class=\"headerlink\" title=\"再散列函数法\"></a>再散列函数法</h4><p>我们事先准备多个散列函数，每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉</p>\n<h4 id=\"链地址法\"><a href=\"#链地址法\" class=\"headerlink\" title=\"链地址法\"></a>链地址法</h4><p>将所有关键字为同义词的记录存储在一个单链表红，我们称这种表尾同义词子表，在散列表中只存储所有同义词子表的头指针</p>\n<h4 id=\"公共溢出区法\"><a href=\"#公共溢出区法\" class=\"headerlink\" title=\"公共溢出区法\"></a>公共溢出区法</h4><p>凡是冲突的都将它们存储到溢出表中</p>\n<h2 id=\"八、排序\"><a href=\"#八、排序\" class=\"headerlink\" title=\"八、排序\"></a>八、排序</h2><p>关于排序，推荐我的另一篇文章：<a href=\"/20170318/js-implementation-of-ten-sorting-algorithms.html\">\b十大排序算法的Javascript实现</a>，这篇文章里有一些常见排序算法的实现步骤以及演示，是一个比较好的排序算法讲解</p>\n<h2 id=\"九、总结\"><a href=\"#九、总结\" class=\"headerlink\" title=\"九、总结\"></a>九、总结</h2><h3 id=\"1、数据结构和算法\"><a href=\"#1、数据结构和算法\" class=\"headerlink\" title=\"1、数据结构和算法\"></a>1、数据结构和算法</h3><p>数据结构和算法对于程序员的职业人生来说，那就是两个圆圈的交集部分，用心去掌握它，你的编程之路将会是坦途</p>\n<div align=\"center\"><img src=\"/images/hexo_post_188.png\" alt=\"\" width=\"350\"></div>","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]},{"title":"读书笔记系列（9）——你不知道的JavaScript（上卷）","slug":"读书笔记系列（9）——你不知道的JavaScript（上卷）","date":"2017-10-10T11:42:12.000Z","updated":"2019-05-05T03:32:55.328Z","comments":true,"path":"api/articles/读书笔记系列（9）——你不知道的JavaScript（上卷）.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这本书在 github 上很火，而中文译本迟迟没有发行，最近出了中卷，我很早之前就听说了该大作，然而一直没有时间拜读，现在实习告一段落了，终于可以静下心来品味经典了。</p>\n<h2 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h2><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p>\n<h3 id=\"分词-词法分析\"><a href=\"#分词-词法分析\" class=\"headerlink\" title=\"分词/词法分析\"></a>分词/词法分析</h3><p>将字符串分解成有意义的代码块，这些代码块被称为词法单元（token），例如：<code>var a = 2;</code>，会被分解为下面这些词法单元：var、a、=、2、；</p>\n<h3 id=\"解析-语法分析\"><a href=\"#解析-语法分析\" class=\"headerlink\" title=\"解析/语法分析\"></a>解析/语法分析</h3><p>将语法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，被称为“抽象语法树”（AST）。<code>var a = 2;</code> 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier (它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。</p>\n<h3 id=\"代码生成\"><a href=\"#代码生成\" class=\"headerlink\" title=\"代码生成\"></a>代码生成</h3><p>将 AST 转换为可执行代码。简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。 然而，比起那些编译过程只有三个步骤的语言的编译器，<strong>JavaScript 引擎要复杂得多</strong>。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。</p>\n<p>对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内。</p>\n<h3 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h3><p>首先介绍将要参与到对程序 <code>var a = 2;</code> 进行处理的过程中的演员们。</p>\n<h4 id=\"引擎\"><a href=\"#引擎\" class=\"headerlink\" title=\"引擎\"></a>引擎</h4><p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p>\n<h4 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h4><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>\n<h3 id=\"变量的赋值操作\"><a href=\"#变量的赋值操作\" class=\"headerlink\" title=\"变量的赋值操作\"></a>变量的赋值操作</h3><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。（我们在面试时会经常遇到变量为undefined的问题，其实就是这个道理）</p>\n<h4 id=\"编译器有话说\"><a href=\"#编译器有话说\" class=\"headerlink\" title=\"编译器有话说\"></a>编译器有话说</h4><p>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。</p>\n<p>讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</p>\n<h4 id=\"引擎和作用域的对话\"><a href=\"#引擎和作用域的对话\" class=\"headerlink\" title=\"引擎和作用域的对话\"></a>引擎和作用域的对话</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123; <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">2</span> );</span><br></pre></td></tr></table></figure>\n<p>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。</p>\n<blockquote>\n<p>引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?<br>作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎:哥们太够意思了!好吧，我来执行一下 foo。<br>引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?<br>作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。<br>引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。<br>引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?<br>作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。<br>引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。<br>引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。<br>作用域:放心吧，这个变量没有变动过，拿走，不谢。 引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。 ……</p>\n</blockquote>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 <code>var a = 2</code> 这样的声明会被分解成两个独立的步骤:</p>\n<ol>\n<li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>\n<li>接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li>\n</ol>\n<p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，但是如果对结果的操作是非法或不合理的，会抛出 TypeError 异常，或者直接抛出 ReferenceError 异常(严格模式下)。</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><h3 id=\"变量查找\"><a href=\"#变量查找\" class=\"headerlink\" title=\"变量查找\"></a>变量查找</h3><p>全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。 window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。</p>\n<p><strong>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</strong></p>\n<h3 id=\"欺骗词法\"><a href=\"#欺骗词法\" class=\"headerlink\" title=\"欺骗词法\"></a>欺骗词法</h3><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”(也可以说欺骗)词法作用域呢? JavaScript 中有两种机制来实现这个目的。</p>\n<ol>\n<li>eval</li>\n<li>with</li>\n</ol>\n<p>欺骗词法作用域会导致性能下降。</p>\n<h4 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h4><p>在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p>\n<p>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>; </span><br><span class=\"line\">    <span class=\"built_in\">eval</span>( str ); </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// ReferenceError: a is not defined </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">foo( <span class=\"string\">\"var a = 2\"</span> );</span><br></pre></td></tr></table></figure>\n<p>JavaScript 中还有其他一些功能效果和 <code>eval(..)</code> 很 相 似。setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们! new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。</p>\n<h4 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h4><p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。with 的副作用通过一个简单的例子就可以看到：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">2</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; </span><br><span class=\"line\">    b: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo( o1 );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( o1.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo( o2 );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( o2.a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2——不好，a 被泄漏到全局作用域上了!</span></span><br></pre></td></tr></table></figure>\n<p>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此<strong>这个对象的属性也会被处理为定义在这个作用域中的词法标识符</strong>。</p>\n<p>结合上面的例子，o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a=2 执行时，<strong>自动创建了一个全局变量</strong>(因为是非严格模式)。</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p>\n<h2 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h2><h3 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h3><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。</p>\n<h3 id=\"全局命名空间\"><a href=\"#全局命名空间\" class=\"headerlink\" title=\"全局命名空间\"></a>全局命名空间</h3><p>某些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyReallyCoolLibrary = &#123; </span><br><span class=\"line\">    awesome: <span class=\"string\">\"stuff\"</span>, </span><br><span class=\"line\">    doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    doAnotherThing: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"匿名和具名\"><a href=\"#匿名和具名\" class=\"headerlink\" title=\"匿名和具名\"></a>匿名和具名</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I waited 1 second!\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</p>\n<h3 id=\"然而，匿名函数也有几个缺点：\"><a href=\"#然而，匿名函数也有几个缺点：\" class=\"headerlink\" title=\"然而，匿名函数也有几个缺点：\"></a>然而，匿名函数也有几个缺点：</h3><ol>\n<li>匿名函数在栈追踪中不会显示出有意义的函数名，使得<strong>调试很困难</strong>。</li>\n<li>如果没有函数名，当函数需要引用自身时只能使用已经过期的<strong>arguments.callee</strong>引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li>\n<li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。<strong>一个描述性的名称可以让代码不言自明</strong>。</li>\n</ol>\n<p>综合考虑而言，始终给函数表达式命名是一个最佳实践（下面的例子叫做行内函数表达式）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeoutHandler</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// &lt;-- 快看，我有名字了! </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"I waited 1 second!\"</span> );</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<h3 id=\"立即执行函数表达式\"><a href=\"#立即执行函数表达式\" class=\"headerlink\" title=\"立即执行函数表达式\"></a>立即执行函数表达式</h3><p>立即执行函数表达式（IIFE）有两种形式：</p>\n<ol>\n<li>(function foo(){ .. })()</li>\n<li>(function foo(){ .. }())</li>\n</ol>\n<p>这两种形式在功能上是一致的，<strong>选择哪个全凭个人喜好</strong>。</p>\n<h3 id=\"IIFE的用途\"><a href=\"#IIFE的用途\" class=\"headerlink\" title=\"IIFE的用途\"></a>IIFE的用途</h3><h4 id=\"把它们当做函数调用并传递参数进去：\"><a href=\"#把它们当做函数调用并传递参数进去：\" class=\"headerlink\" title=\"把它们当做函数调用并传递参数进去：\"></a>把它们当做函数调用并传递参数进去：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)( <span class=\"built_in\">window</span> );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"解决-undefined-标识符的默认值被错误覆盖导致的异常-虽然不常见\"><a href=\"#解决-undefined-标识符的默认值被错误覆盖导致的异常-虽然不常见\" class=\"headerlink\" title=\"解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)\"></a>解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)</h4><p>将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 给其他代码挖了一个大坑!绝对不要这样做! </span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> undefined </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"string\">\"Undefined is safe here!\"</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\"><a href=\"#倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\" class=\"headerlink\" title=\"倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去\"></a>倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>) </span>&#123; </span><br><span class=\"line\">    def( <span class=\"built_in\">window</span> );</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。</p>\n<h3 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h3><p>块作用域的例子：</p>\n<h4 id=\"with-1\"><a href=\"#with-1\" class=\"headerlink\" title=\"with\"></a>with</h4><p>with就是块作用域的一个例子（形式），用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效</p>\n<h4 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try/catch\"></a>try/catch</h4><p>try/catch 是 ES3 的规范，而很少有人注意到，<strong>catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效</strong></p>\n<blockquote>\n<p>尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境(除了老 版本的 IE 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。</p>\n</blockquote>\n<h4 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h4><p>ES6 引入的 let 关键字可以将变量绑定到所在的任意作用域中(通常是{ .. }内部)。换句话说，let 为其声明的变量隐式地了所在的块作用域。 但是，let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError! </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h4><p>ES6 还引入了 const，同样可以用来创建块作用域变量，但是其值是固定的</p>\n<h3 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h3><h4 id=\"先有鸡还是先有蛋\"><a href=\"#先有鸡还是先有蛋\" class=\"headerlink\" title=\"先有鸡还是先有蛋\"></a>先有鸡还是先有蛋</h4><p>首先，抛出两个例子，也是很经典的JS的“坑”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>关于这一奇怪现象，可以用一句话概括：<strong>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理</strong> 当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个——声明:var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。 换句话说，<strong>先有蛋（声明）后又鸡（赋值）</strong>；所以上面的两个例子会以如下形式进行处理： 例子一：（第一部分是编译，第二部分是执行）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">a = <span class=\"number\">2</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>例子二：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 不是 ReferenceError, 而是 TypeError!</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域(在这里是全局作用域)，因此foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式，那么就会赋值)。<strong>foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常</strong>。</p>\n<p>从上面的例子，我们还可以得出：<strong>函数声明会被提升，但是函数表达式不会被提升</strong></p>\n<h3 id=\"函数优先\"><a href=\"#函数优先\" class=\"headerlink\" title=\"函数优先\"></a>函数优先</h3><p>函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。考虑下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子会被引擎理解为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>从这两段代码我们可以得出两个结论：</p>\n<ol>\n<li>var foo 尽管出现在 function foo()…的声明之前，但它是重复的声明(因此<strong>被忽略</strong>了)，因为函数声明会被提升到普通变量之前。</li>\n<li>尽管重复的 var 声明会被忽略掉，但<strong>出现在后面的函数声明还是可以覆盖前面的</strong>。</li>\n</ol>\n<h2 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h2><h3 id=\"老生常谈，闭包是什么\"><a href=\"#老生常谈，闭包是什么\" class=\"headerlink\" title=\"老生常谈，闭包是什么\"></a>老生常谈，闭包是什么</h3><p>划重点：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 这一部分之前已经讲了很多次了，感觉这本书也没有很多新意，所以想了解闭包的童鞋可以参见我的另一篇文章：<a href=\"/20170405/closure-in-js.html\">前端面试系列（10）——JS中的闭包</a></p>\n<h3 id=\"不太显性的闭包\"><a href=\"#不太显性的闭包\" class=\"headerlink\" title=\"不太显性的闭包\"></a>不太显性的闭包</h3><p>其实，你已经写过的代码中一定到处都是闭包的身影。</p>\n<h4 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait(<span class=\"string\">\"Hello, closure!\"</span>);</span><br></pre></td></tr></table></figure>\n<p>将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域 的闭包，因此还保有对变量 message 的引用。wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，<strong>timer 函数依然保有 wait(..) 作用域的闭包</strong>。</p>\n<h4 id=\"jQuery-或其他-JS-框架\"><a href=\"#jQuery-或其他-JS-框架\" class=\"headerlink\" title=\"jQuery 或其他 JS 框架\"></a>jQuery 或其他 JS 框架</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setupBot</span>(<span class=\"params\">name, selector</span>) </span>&#123;</span><br><span class=\"line\">    $( selector ).click( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">activator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"string\">\"Activating: \"</span> + name ); </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setupBot( <span class=\"string\">\"Closure Bot 1\"</span>, <span class=\"string\">\"#bot_1\"</span> );</span><br><span class=\"line\">setupBot( <span class=\"string\">\"Closure Bot 2\"</span>, <span class=\"string\">\"#bot_2\"</span> );</span><br></pre></td></tr></table></figure>\n<p>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包!</p>\n<h4 id=\"IIFE\"><a href=\"#IIFE\" class=\"headerlink\" title=\"IIFE\"></a>IIFE</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么?因为函数(示例代码中的 IIFE)并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行(而外部作用域，也就是全局作用域也持有 a)。a 是通过普通的词法作用域查找而非闭包被发现的。 尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。</p>\n<h3 id=\"块作用域和闭包\"><a href=\"#块作用域和闭包\" class=\"headerlink\" title=\"块作用域和闭包\"></a>块作用域和闭包</h3><p>一道很经典的面试题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码在运行时会以每秒一次的频率输出五次 6，具体原因就不再赘述了。。而如果我们想让他连续输出1 2 3 4 5应该怎么办呢？有两种方法:</p>\n<h4 id=\"利用闭包\"><a href=\"#利用闭包\" class=\"headerlink\" title=\"利用闭包\"></a>利用闭包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">        &#125;, j*<span class=\"number\">1000</span> ); </span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"闭包-块作用域\"><a href=\"#闭包-块作用域\" class=\"headerlink\" title=\"闭包+块作用域\"></a>闭包+块作用域</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><h4 id=\"模块有两个主要特征：\"><a href=\"#模块有两个主要特征：\" class=\"headerlink\" title=\"模块有两个主要特征：\"></a>模块有两个主要特征：</h4><ol>\n<li>为创建内部作用域而调用了一个包装函数;</li>\n<li>包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>\n</ol>\n<p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览器或引擎有一个默认的“模块加载器”(可以被重载，但这远超出了我们的讨论范围)可以在导入模块时异步地加载模块文件。 模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。</p>\n<h4 id=\"动态作用域与词法作用域\"><a href=\"#动态作用域与词法作用域\" class=\"headerlink\" title=\"动态作用域与词法作用域\"></a>动态作用域与词法作用域</h4><p>下面一段代码很有意思：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2(不是3!)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    foo(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara=<span class=\"number\">2</span>;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>如果 JS 是动态作用域，上面将会输出 3，因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。 需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>\n<h2 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h2><h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>有两种常见的对于this的解释，但是它们都是错误的：</p>\n<h4 id=\"指向自身\"><a href=\"#指向自身\" class=\"headerlink\" title=\"指向自身\"></a>指向自身</h4><p>人们很容易把 this 理解成指向函数自身，然而如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符(变量)来引用它。 思考一下下面这两个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.count = <span class=\"number\">4</span>; <span class=\"comment\">// foo 指向它自身</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匿名(没有名字的)函数无法指向自身</span></span><br><span class=\"line\">&#125;,<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p>第一个函数被称为具名函数，在它内部可以使用 foo 来引用自身。 但是在第二个例子中，传入 setTimeout(..) 的回调函数没有名称标识符(这种函数被称为匿名函数)，因此无法从函数内部引用自身。</p>\n<h4 id=\"它的作用域\"><a href=\"#它的作用域\" class=\"headerlink\" title=\"它的作用域\"></a>它的作用域</h4><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。 <strong>每当你想要把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</strong></p>\n<h3 id=\"this到底是什么\"><a href=\"#this到底是什么\" class=\"headerlink\" title=\"this到底是什么\"></a>this到底是什么</h3><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</strong> 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>\n<h2 id=\"this全面解析\"><a href=\"#this全面解析\" class=\"headerlink\" title=\"this全面解析\"></a>this全面解析</h2><h3 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h3><p>在理解 this 的绑定过程之前，首先要理解调用位置：<strong>调用位置就是函数在代码中被调用的位置(而不是声明的位置)</strong>；然而做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。 下面通过一个例子来看看到底什么是调用栈和调用位置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是:baz</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置是全局作用域</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"baz\"</span> );</span><br><span class=\"line\">    bar(); <span class=\"comment\">// &lt;-- bar 的调用位置 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是 baz -&gt; bar</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置在 baz 中</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\">    foo(); <span class=\"comment\">// &lt;-- foo 的调用位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此，当前调用位置在 bar 中</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">baz(); <span class=\"comment\">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p>\n<h4 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>this.a 被解析成了全局变量 a。为什么?因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此<strong>this会绑定到 undefined</strong> 这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是<strong>只有foo()运行在非strict mode下时，默认绑定才能绑定到全局对象；严格模式下与foo() 的调用位置无关：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>;</span><br><span class=\"line\">    foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>调用位置会使用 obj 上下文来引用函数</strong>，因此你可以说<strong>函数foo被调用时 obj 对象“拥有”或者“包含”它</strong>。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">42</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    obj2: obj2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj1.obj2.foo(); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h4><p>可以使用函数的 call(..) 和 apply(..) 方法。这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现在其他的参数上，但是现在我们不用考虑这些。 <strong>硬绑定</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.call( obj );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">setTimeout( bar, <span class=\"number\">100</span> ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 硬绑定的 bar 不可能再修改它的 this</span></span><br><span class=\"line\">bar.call( <span class=\"built_in\">window</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>无论我们如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype. bind，它的用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">3</span>);<span class=\"comment\">//23</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p>\n<h4 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h4><p>JS 中 new 的机制和面向类的语言完全不同：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>\n<ol>\n<li>创建(或者说构造)一个全新的对象。</li>\n<li>这个新对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>一个简单的例子来解释 new 绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar.a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。</strong></p>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><p>（原书中通过很多例子得到了上面四种绑定方式的优先级，这里就不再赘述了。。） 我们可以按照下面的顺序来进行判断：</p>\n<ol>\n<li>函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。 var bar = new foo()</li>\n<li>函数是否通过 call、apply(显式绑定)或者硬绑定调用?如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2)</li>\n<li>函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo()</li>\n<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo()</li>\n</ol>\n<p>然而，凡事总有例外。</p>\n<h4 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a>绑定例外</h4><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用的可能是默认绑定规则。</p>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vara=<span class=\"number\">2</span>;</span><br><span class=\"line\">foo.call( <span class=\"literal\">null</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>一般，如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择。 然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。 划重点：<strong>Object.create(null)和{}很像，但是并不会创建Object.prototype 这个委托，所以它比 {}“更空”</strong></p>\n<h4 id=\"间接引用\"><a href=\"#间接引用\" class=\"headerlink\" title=\"间接引用\"></a>间接引用</h4><p>你有可能(有意或者无意地)创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。而间接引用最容易在赋值时发生：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>:<span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>:<span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此<strong>调用位置是 foo() 而不是 p.foo() 或者 o.foo()</strong>。根据我们之前说过的，这里会应用默认绑定。</p>\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><p>硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。 下面是一种被称为软绑定的方法，有时间的话可以研究一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Function</span>.prototype.softBind) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.softBind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 捕获所有 curried 参数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = \\[\\].slice.call( <span class=\"built_in\">arguments</span>, <span class=\"number\">1</span> );</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(</span><br><span class=\"line\">                (!<span class=\"keyword\">this</span> || <span class=\"keyword\">this</span> === (<span class=\"built_in\">window</span> || global)) ?</span><br><span class=\"line\">                    obj : <span class=\"keyword\">this</span></span><br><span class=\"line\">                curried.concat.apply( curried, <span class=\"built_in\">arguments</span> )</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = <span class=\"built_in\">Object</span>.create( fn.prototype );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this语法\"><a href=\"#this语法\" class=\"headerlink\" title=\"this语法\"></a>this语法</h3><p>ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定义的。<strong>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//this 继承自 foo()</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2, 不是3!</span></span><br></pre></td></tr></table></figure>\n<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不 行!)</p>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>对象可以通过两种形式定义:声明(文字)形式和构造形式。</p>\n<h4 id=\"文字形式（对象字面量）\"><a href=\"#文字形式（对象字面量）\" class=\"headerlink\" title=\"文字形式（对象字面量）\"></a>文字形式（对象字面量）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    key: value</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"构造形式\"><a href=\"#构造形式\" class=\"headerlink\" title=\"构造形式\"></a>构造形式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">myObj.key = value;</span><br></pre></td></tr></table></figure>\n<p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键值对，但是在构造形式中你必须逐个添加属性。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>在 JavaScrip t中一共有六种主要类型（语言类型）：</p>\n<ul>\n<li>string</li>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>object</li>\n</ul>\n<p>简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。 null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 “object”。实际上，<strong>null 本身是基本类型</strong>。</p>\n<blockquote>\n<p>原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。</p>\n</blockquote>\n<h3 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h3><p>JavaScript 中还有一些对象子类型，通常被称为内置对象。</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n</ul>\n<h3 id=\"自动转换\"><a href=\"#自动转换\" class=\"headerlink\" title=\"自动转换\"></a>自动转换</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strPrimitive = <span class=\"string\">\"I am a string\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( strPrimitive.length ); <span class=\"comment\">// 13</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( strPrimitive.charAt( <span class=\"number\">3</span> ) ); <span class=\"comment\">// \"m\"</span></span><br></pre></td></tr></table></figure>\n<p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为<strong>引擎自动把字面量转换成 String 对象</strong>，所以可以访问属性和方法。同样的事也会发生在数值字面量上 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式（只能通过 new Date() 创建一个 Date 对象）。</p>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"a\"</span>\\]; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>.a 语法通常被称为“<strong>属性访问</strong>”，[“a”] 语法通常被称为“<strong>键访问</strong>”。这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject\\[<span class=\"literal\">true</span>\\] = <span class=\"string\">\"foo\"</span>;</span><br><span class=\"line\">myObject\\[<span class=\"number\">3</span>\\] = <span class=\"string\">\"bar\"</span>;</span><br><span class=\"line\">myObject\\[myObject\\] = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"true\"</span>\\]; <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"3\"</span>\\]; <span class=\"comment\">// \"bar\"</span></span><br><span class=\"line\">myObject\\[<span class=\"string\">\"\\[object Object\\]\"</span>\\]; <span class=\"comment\">// \"baz\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = \\[ <span class=\"string\">\"foo\"</span>, <span class=\"number\">42</span>, <span class=\"string\">\"bar\"</span> \\];</span><br><span class=\"line\">myArray.baz = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\">myArray.length; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myArray.baz; <span class=\"comment\">// \"baz\"</span></span><br></pre></td></tr></table></figure>\n<p>可以看到虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，<strong>数组的 length 值并未发生变化</strong>。但是，如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标(因此会修改数组的内容而不是添加一个属性)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = \\[ <span class=\"string\">\"foo\"</span>, <span class=\"number\">42</span>, <span class=\"string\">\"bar\"</span> \\];</span><br><span class=\"line\">myArray\\[<span class=\"string\">\"4\"</span>\\] = <span class=\"string\">\"baz\"</span>;</span><br><span class=\"line\">myArray.length; <span class=\"comment\">// 5</span></span><br><span class=\"line\">myArray\\[<span class=\"number\">4</span>\\]; <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\">myArray\\[<span class=\"number\">3</span>\\]; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h3><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"a\"</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"number\">2</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h3><p>有时候你会希望属性或者对象是不可改变(无论有意还是无意)的，在 ES5 中可以通过很多种方法来实现：</p>\n<h4 id=\"对象常量\"><a href=\"#对象常量\" class=\"headerlink\" title=\"对象常量\"></a>对象常量</h4><p>结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性(不可修改、重定义或者删除):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"FAVORITE_NUMBER\"</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"number\">42</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"禁止扩展\"><a href=\"#禁止扩展\" class=\"headerlink\" title=\"禁止扩展\"></a>禁止扩展</h4><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions( myObject );</span><br><span class=\"line\">myObject.b = <span class=\"number\">3</span>;</span><br><span class=\"line\">myObject.b; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"密封\"><a href=\"#密封\" class=\"headerlink\" title=\"密封\"></a>密封</h4><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable: false。 所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。</p>\n<h4 id=\"冻结\"><a href=\"#冻结\" class=\"headerlink\" title=\"冻结\"></a>冻结</h4><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable: false，这样就无法修改它们的值。 <strong>这个方法是你可以应用在对象上的级别最高的不可变性</strong>，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。</p>\n<h4 id=\"数组上不要用for-in循环\"><a href=\"#数组上不要用for-in循环\" class=\"headerlink\" title=\"数组上不要用for..in循环\"></a>数组上不要用for..in循环</h4><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><h4 id=\"ES5中增加了一些数组的辅助迭代器：\"><a href=\"#ES5中增加了一些数组的辅助迭代器：\" class=\"headerlink\" title=\"ES5中增加了一些数组的辅助迭代器：\"></a>ES5中增加了一些数组的辅助迭代器：</h4><ol>\n<li>forEach(..)：遍历数组中的所有值并忽略回调函数的返回值</li>\n<li>every(..)：会一直运行直到回调函数返回 false</li>\n<li>some(..)：会一直运行直到回调函数返回 true</li>\n</ol>\n<h2 id=\"混合对象“类”\"><a href=\"#混合对象“类”\" class=\"headerlink\" title=\"混合对象“类”\"></a>混合对象“类”</h2><h3 id=\"类的机制\"><a href=\"#类的机制\" class=\"headerlink\" title=\"类的机制\"></a>类的机制</h3><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息(状态)。 类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。</p>\n<h4 id=\"JS中的类\"><a href=\"#JS中的类\" class=\"headerlink\" title=\"JS中的类\"></a>JS中的类</h4><p>在传统的面向类的语言中 super 有一个功能，就是<strong>从子类的构造函数中通过 super 可以直接调用父类的构造函数</strong>。通常来说这没什么问题，因为对于真正的类来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——<strong>实际上“类”是属于构造函数的</strong>(类似 Foo.prototype… 这样的类型引用)。由于<strong>JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中</strong>，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用</p>\n<blockquote>\n<p>注: 其实这一部分还蛮重要的，而原文也通过比较大量的篇幅对JS中的“类”进行了介绍，只不过我感觉没有什么与众不同之处就略过了，对这一部分还不太熟悉的童鞋可以自己研究一下。。</p>\n</blockquote>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"Prototype\"><a href=\"#Prototype\" class=\"headerlink\" title=\"[[Prototype]]\"></a>[[Prototype]]</h3><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。 而[[Prototype]]的作用是：对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个关联到 anotherObject 的对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到(并且是 enumerable)的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链(无论属性是否可枚举)</p>\n<h3 id=\"Object-prototype\"><a href=\"#Object-prototype\" class=\"headerlink\" title=\"Object.prototype\"></a>Object.prototype</h3><p><strong>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype</strong>。由于所有的“普通”(内置，不是特定主机的扩展)对象都“源于”(或者说把 [[Prototype]] 链的顶端设置为)这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。</p>\n<h3 id=\"属性屏蔽\"><a href=\"#属性屏蔽\" class=\"headerlink\" title=\"属性屏蔽\"></a>属性屏蔽</h3><p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为<strong>myObject.foo 总是会选择原型链中最底层的 foo 属性</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a++; <span class=\"comment\">// 隐式屏蔽!</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>尽管 myObject.a++ 看起来应该(通过委托)查找并增加 anotherObject.a 属性，但是别忘了<strong>++操作相当于myObject.a = myObject.a + 1</strong>。因此++操作首先会通过[[Prototype]]查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐!</p>\n<h3 id=\"“类”\"><a href=\"#“类”\" class=\"headerlink\" title=\"“类”\"></a>“类”</h3><h4 id=\"“类”函数\"><a href=\"#“类”函数\" class=\"headerlink\" title=\"“类”函数\"></a>“类”函数</h4><p>所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype; <span class=\"comment\">// &#123; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这个对象通常被称为 Foo 的原型，然而，如果是我的话就 会叫它“之前被称为 Foo 的原型的那个对象”。好吧我是开玩笑的，你觉得“<strong>被贴上‘Foo 点 prototype’标签的对象</strong>”这个名字怎么样？最直接的解释就是，这个对象是在调用new Foo()时创建的，最后会被(有点武断地)关联到这个“Foo 点 prototype”对象上。</p>\n<h4 id=\"继承与原型\"><a href=\"#继承与原型\" class=\"headerlink\" title=\"继承与原型\"></a>继承与原型</h4><p>继承意味着复制操作，JavaScript(默认)并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。委托(参见第 6 章)这个术语可以更加准确地描述 JavaScript 中对象的关联机制。</p>\n<h4 id=\"构造函数还是调用\"><a href=\"#构造函数还是调用\" class=\"headerlink\" title=\"构造函数还是调用\"></a>构造函数还是调用</h4><p>在JS中，<strong>new 会劫持所有普通函数并用构造对象的形式来调用它</strong>。换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是<strong>当且仅当使用 new 时，函数调用会变成“构造函数调用”</strong>。</p>\n<h4 id=\"constructor-并不表示被构造\"><a href=\"#constructor-并不表示被构造\" class=\"headerlink\" title=\"constructor 并不表示被构造\"></a>constructor 并不表示被构造</h4><p>function Foo() { /<em> .. </em>/ }<br>Foo.prototype = { /<em> .. </em>/ }; // 创建一个新原型对象<br>var a1 = new Foo();<br>a1.constructor === Foo; // false! a1.constructor === Object; // true!</p>\n<p>a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性(不过<strong>默认的 Foo.prototype 对象有这个属性</strong>!)，所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。 a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。</p>\n<h4 id=\"（原型）继承\"><a href=\"#（原型）继承\" class=\"headerlink\" title=\"（原型）继承\"></a>（原型）继承</h4><h3 id=\"Object-setPrototypeOf-…\"><a href=\"#Object-setPrototypeOf-…\" class=\"headerlink\" title=\"Object.setPrototypeOf(…)\"></a>Object.setPrototypeOf(…)</h3><p>ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6 之前需要抛弃默认的 Bar.prototype</span></span><br><span class=\"line\">Bar.ptototype = <span class=\"built_in\">Object</span>.create( Foo.prototype );</span><br><span class=\"line\"><span class=\"comment\">// ES6 开始可以直接修改现有的 Bar.prototype </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象关联\"><a href=\"#对象关联\" class=\"headerlink\" title=\"对象关联\"></a>对象关联</h3><p>[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。 这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p>\n<h2 id=\"行为委托\"><a href=\"#行为委托\" class=\"headerlink\" title=\"行为委托\"></a>行为委托</h2><p>委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Task = &#123;</span><br><span class=\"line\">    setID: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ID</span>) </span>&#123; <span class=\"keyword\">this</span>.id = ID; &#125;,</span><br><span class=\"line\">    outputID: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.id ); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 让XYZ委托Task</span></span><br><span class=\"line\">XYZ = <span class=\"built_in\">Object</span>.create( Task );</span><br><span class=\"line\"></span><br><span class=\"line\">XYZ.prepareTask = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ID,Label</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setID( ID );</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.label = Label;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">XYZ.outputTaskDetails = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.outputID();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.label );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ABC = Object.create( Task );</span></span><br><span class=\"line\"><span class=\"comment\">// ABC ... = ...</span></span><br></pre></td></tr></table></figure>\n<p>在上面这段代码中，Task 和 XYZ 并不是类（或者函数），它们是对象。<strong>XYZ 通过 Object. create(..) 创建，它的 [[Prototype]] 委托了 Task 对象</strong></p>\n<h3 id=\"互相委托（禁止）\"><a href=\"#互相委托（禁止）\" class=\"headerlink\" title=\"互相委托（禁止）\"></a>互相委托（禁止）</h3><p>你无法在两个或两个以上互相(双向)委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。如果你引用了一个两边都不存在的属性或者方法，那就会在 [[Prototype]] 链上产生一个<strong>无限递归的循环</strong>。 所以互相委托是被禁止的。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>JavaScript 规范并不会控制浏览器中开发者工具对于特定值或者结构的表示方式，所以浏览器和工具的解析结果并不一定相同。下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a1 = <span class=\"keyword\">new</span> Foo(); </span><br><span class=\"line\">a1; <span class=\"comment\">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>这段代码在chrome中会输出：Foo {}；而在Firefox中会得到Object {}</strong></p>\n<p>Chrome 实际上想说的是“<strong>{} 是一个空对象，由名为 Foo 的函数构造</strong>”。Firefox 想说的是“<strong>{} 是一个空对象，由 Object 构造</strong>”。之所以有这种细微的差别，是因为 <strong>Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性</strong>，但是其他浏览器并不会跟踪这些额外的信息。</p>\n<p>然而，这个行为被认定是 Chrome 的一个 bug，当你读到此书时，它可能已经被修复了。所以你看到的可能是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1; <span class=\"comment\">// Object &#123;&#125;。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h3><p>相比“类”的构造方式，<strong>对象关联可以更好地支持关注分离（separation of concerns）原则</strong>，创建和初始化并不需要合并为一个步骤。 对象关联除了能让代码看起来更简洁(并且更具扩展性)外还可以通过行为委托模式简化代码结构。</p>\n<h3 id=\"更好的语法\"><a href=\"#更好的语法\" class=\"headerlink\" title=\"更好的语法\"></a>更好的语法</h3><p>在 ES6 中，你可以使用对象的字面形式(这样就可以使用简洁方法定义)来改写之前繁琐的属性赋值语法(比如 AuthController 的定义)，然后用 Object.setPrototypeOf(..) 来修改它的 [[Prototype]]:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用更好的对象字面形式语法和简洁方法 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> AuthController = &#123;</span><br><span class=\"line\">    errors: \\[\\],</span><br><span class=\"line\">    checkAuth() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    server(url, data) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在把 AuthController 关联到 LoginController</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( AuthController, LoginController );</span><br></pre></td></tr></table></figure>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。</p>\n<p>在 js 中，instanceof 语法会产生语义困惑而且非常不直观。如果你想检查对象 a1 和某个对象的关系，那必须使用另一个引用该对象的函数才行——你不能直接判断两个对象是否关联。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* .. */</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* .. */</span> &#125;</span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create( Foo.prototype ); <span class=\"comment\">// 让Foo和Bar互相关联</span></span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype <span class=\"keyword\">instanceof</span> Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\">Bar <span class=\"keyword\">instanceof</span> Foo; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>然而，又回到上面的那个问题，<strong>如果通过对象关联的方式构造对象，内省的方法将更加简洁并且清晰</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Foo = &#123; <span class=\"comment\">/* .. */</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Bar = <span class=\"built_in\">Object</span>.create( Foo ); <span class=\"comment\">// 让Foo和Bar互相关联</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"built_in\">Object</span>.create( Bar ); <span class=\"comment\">// 让b1关联到Foo和Bar</span></span><br><span class=\"line\"></span><br><span class=\"line\">Foo.isPrototypeOf( Bar ); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf( Bar ) === Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Foo.isPrototypeOf( b1 ); <span class=\"comment\">// true </span></span><br><span class=\"line\">Bar.isPrototypeOf( b1 ); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf( b1 ) === Bar; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"ES6中的Class\"><a href=\"#ES6中的Class\" class=\"headerlink\" title=\"ES6中的Class\"></a>ES6中的Class</h3><p>除了语法更好看之外，ES6 还解决了什么问题？</p>\n<ol>\n<li>（基本上）不再引用杂乱的 .prototype 了；</li>\n<li>不再需要通过 Object.create(..) 来替换 .prototype 对象，也不需要设置 .__proto__ 或者 Object.setPrototypeOf(..)；</li>\n<li>可以通过 super(..) 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法；</li>\n<li>class 字面语法不能声明属性(只能声明方法)。看起来这是一种限制，但是它会排除掉许多不好的情况，可以帮助你避免犯错；</li>\n<li>可以通过 extends 很自然地扩展对象(子)类型，甚至是内置的对象(子)类型，比如 Array 或 RegExp。</li>\n</ol>\n<p>然而，class 语法并没有解决所有的问题，你可能会认为 ES6 的 class 语法是向 JavaScript 中引入了一种新的“类”机制，其实不是这样。class 基本上只是现有 [[Prototype]](委托!)机制的一种语法糖。 也就是说，class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你 (有意或无意)修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为<strong>它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托。</strong> 除此之外，class 还有以下问题：</p>\n<ol>\n<li><strong>class 语法无法定义类成员属性（只能定义方法）；</strong></li>\n<li>class 语法仍然面临<strong>意外屏蔽</strong>的问题；</li>\n<li>super 并不是动态绑定this的，它会在声明时“静态”绑定。（可以通过 toMethod(…) 手动修改 super 绑定）</li>\n</ol>\n<p>综上，class 最大的问题在于，像传统的类一样)它的语法有时会让你认为，定义了一个 class 后，它就变成了一个(未来会被实例化的)东西的静态定义。<strong>你会彻底忽略 C 是一个对象，是一个具体的可以直接交互的东西。</strong></p>\n<p>ES6 的 class 想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让 JavaScript 更加难以理解。</p>\n","raw":null,"categories":[{"name":"note","path":"api/categories/note.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]}]}