{"name":"js","postlist":[{"title":"Blue老师ES6视频笔记","slug":"Blue老师ES6视频笔记","date":"2017-12-12T14:10:42.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/Blue老师ES6视频笔记.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>请容许我吐槽一下，我发现中国很多前端的大神的英文真的差啊。。</p>\n<h2 id=\"ES6-兼容性\"><a href=\"#ES6-兼容性\" class=\"headerlink\" title=\"ES6 兼容性\"></a>ES6 兼容性</h2><p>可以在线查看兼容性：</p>\n<ul>\n<li>ES5：<a href=\"https://kangax.github.io/compat-table/es5/\" target=\"_blank\" rel=\"noopener\">kangax.github.io/compat-table/es5/</a></li>\n<li>ES6：<a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"noopener\">kangax.github.io/compat-table/es6/</a></li>\n</ul>\n<h3 id=\"在线编译\"><a href=\"#在线编译\" class=\"headerlink\" title=\"在线编译\"></a>在线编译</h3><p><strong>babel === browser.js</strong>，只不过叫法不同 可以通过如下方式实现在线编译 ES6，只不过会多出额外的编译时间，用户体验稍差：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"browser.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/babel\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> a = <span class=\"number\">12</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> b = <span class=\"number\">5</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    alert(a+b);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"ES5-中-var-的缺点：\"><a href=\"#ES5-中-var-的缺点：\" class=\"headerlink\" title=\"ES5 中 var 的缺点：\"></a>ES5 中 var 的缺点：</h3><ul>\n<li>可以重复声明</li>\n<li>无法限制修改，即没有常量的概念</li>\n<li>没有块级作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert a; <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"块级作用域有什么用？\"><a href=\"#块级作用域有什么用？\" class=\"headerlink\" title=\"块级作用域有什么用？\"></a>块级作用域有什么用？</h3><p>可以限定变量在块中起作用，而不像ES5一样在函数块中起作用，最常见的是 for 循环中的索引值</p>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ol>\n<li>如果只有一个参数，()可以省略</li>\n<li>如果只有一个 return，{}可以省略</li>\n</ol>\n<h2 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h2><p>ES6新增：</p>\n<h3 id=\"参数扩展（…args必须为最后一个形参）\"><a href=\"#参数扩展（…args必须为最后一个形参）\" class=\"headerlink\" title=\"参数扩展（…args必须为最后一个形参）\"></a>参数扩展（…args必须为最后一个形参）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b, ...args</span>)</span>&#123;</span><br><span class=\"line\">  alert(a);</span><br><span class=\"line\">  alert(b);</span><br><span class=\"line\">  alert(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">show(<span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"展开一个数组\"><a href=\"#展开一个数组\" class=\"headerlink\" title=\"展开一个数组\"></a>展开一个数组</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\];</span><br><span class=\"line\">\\[...arr\\] = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\];</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b=<span class=\"number\">5</span>, c=<span class=\"number\">12</span></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b, c\\] = \\[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\\]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[&#123;a, b&#125;, \\[n1, n2, n3\\], num, str\\] = \\[&#123;<span class=\"attr\">a</span>: <span class=\"number\">12</span>, <span class=\"attr\">b</span>: <span class=\"number\">5</span>&#125;, \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>\\], <span class=\"number\">8</span>, <span class=\"string\">'cxzcv'</span>\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, n1, n2, n3, num, str);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b\\] = &#123;<span class=\"attr\">a</span>: <span class=\"number\">12</span>, <span class=\"attr\">b</span>: <span class=\"number\">45</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// undefined is not a function, 前提1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125; = &#123;<span class=\"number\">12</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// unexpected token, 前提2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> \\[a, b\\];</span><br><span class=\"line\">\\[a, b\\] = \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>\\]; <span class=\"comment\">// XXXX error, 前提3</span></span><br></pre></td></tr></table></figure>\n<p>前提：</p>\n<ol>\n<li>左右两边解构必须一样</li>\n<li>右边必须是个东西</li>\n<li>声明和赋值不能分开（必须在一句话中完成）</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>新增四个方法：</p>\n<ul>\n<li>map：映射</li>\n<li>reduce：汇总</li>\n<li>filter：过滤器</li>\n<li>forEach：循环（迭代）</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result); <span class=\"comment\">// 24, 10, 16</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><p>经常用来算总数、平均数等指标</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">69</span>, <span class=\"number\">180</span>, <span class=\"number\">8763</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tmp, item, index</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp + item;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result);</span><br></pre></td></tr></table></figure>\n<p>求平均数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = \\[<span class=\"number\">12</span>, <span class=\"number\">69</span>, <span class=\"number\">180</span>, <span class=\"number\">8763</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\">(<span class=\"params\">tmp, item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index != arr.length - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp+item;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (tmp+item)/arr.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">alert(result);</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>filter 中 return true 就留下来，return false 就不保留</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>类似于传统的 for 循环，参数为 item, index</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>新增：</p>\n<ol>\n<li>多了两个新方法，startsWith，endsWith</li>\n<li>字符串模板</li>\n</ol>\n<h3 id=\"字符串模板\"><a href=\"#字符串模板\" class=\"headerlink\" title=\"字符串模板\"></a>字符串模板</h3><p>普通字符串无法折行，字符串模板可以折行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = \\<span class=\"string\">`a<span class=\"subst\">$&#123;a&#125;</span>bc\\`;</span></span><br><span class=\"line\"><span class=\"string\">alert(str); // a12bc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p>ES5 中的面向对象：类和构造函数不分，混为一谈；ES6 中的面向对象：</p>\n<ol>\n<li>class 关键字，构造器和类分开了</li>\n<li>class 里面直接加方法</li>\n<li>extends-继承</li>\n</ol>\n<h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2><p>json 的标准写法：</p>\n<ol>\n<li>只能用双引号</li>\n<li>所有的名字（key）都必须用引号包起来</li>\n</ol>\n<p>在 ES 中，当名字和值相同时，可以只写其中一个；方法可以省掉: function</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>异步会让代码更复杂，而同步的代码简单，而 Promise 用同步的方式来书写异步代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">  $.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'arr.txt'</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    success(arr)&#123;</span><br><span class=\"line\">      resolve(arr);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error(err)&#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'成功'</span>)&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'失败'</span>)&#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise.all([promise1, promise2, …]) =&gt; 都 resolve 的时候才算成功，只要有一个 reject 就算失败<br>Promise.\brace([promise1, promise2, …]) =&gt; 只要有一个 resolve 的时候就算成功，全部 reject 才算失败 在高版本 jQuery 中，$.ajax 的返回值就是一个 Promise 对象</p>\n<h2 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h2><p>和普通函数相比，中间能暂停，需要和 yield 配合使用 generator 并不会直接执行，而是会创建一个 generator 对象，其中该对象的 next 方法用于继续执行，碰到 yield 就会停</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  alert(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = show();</span><br><span class=\"line\">genObj.next(); <span class=\"comment\">// a</span></span><br><span class=\"line\">genObj.next(); <span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><p>yield 既可以传参，又可以返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">show</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">`<span class=\"subst\">$&#123;num1&#125;</span>, <span class=\"subst\">$&#123;num2&#125;</span>`</span>);</span><br><span class=\"line\">  alert(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  alert(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  alert(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = show(<span class=\"number\">99</span>, <span class=\"number\">88</span>);</span><br><span class=\"line\">gen.next(<span class=\"number\">12</span>); <span class=\"comment\">// 第一个next没法给yield传参</span></span><br><span class=\"line\">gen.next(<span class=\"number\">5</span>); <span class=\"comment\">// 会传给上面的yield，所以a=5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-的局限性\"><a href=\"#Promise-的局限性\" class=\"headerlink\" title=\"Promise 的局限性\"></a>Promise 的局限性</h3><p>其实 generator 之所以出现也是因为纯 Promise 也有其自身的缺陷，并不能完全避免“回调陷阱”，而网上对于 Promise 的局限性解释很多，建议大家直接去看相关博客就可以了，而在我理解就是<strong>Promise 在解决数据依赖问题时避免不了“回调陷阱”</strong>，比如我需要根据数据 A 去请求数据 B，然后再根据数据 B 请求数据 C，然后再……，如果你自己用 Promis e实现一下的话就会发现这时候它的局限性所在；这也再一次证明了那句话：<strong>懒惰是最大生产力</strong></p>\n<h2 id=\"ES7-预览\"><a href=\"#ES7-预览\" class=\"headerlink\" title=\"ES7 预览\"></a>ES7 预览</h2><p>ES6 还没掌握，ES7 都定稿了。。ES8 都有草案了。。，不过现在浏览器对 ES7 的支持很惨</p>\n<ul>\n<li>数组 includes -&gt; 检查数组是否包含某元素</li>\n<li>数组 keys/values/entries -&gt; 一般配合 for…of 使用，for…of 即对 value 的循环，entries 是对键值对的循环</li>\n<li>求幂新操作符 -&gt; 3**8 === Math.pow(3, 8)</li>\n<li>字符串的 padStart/padEnd 方法 -&gt; 补充空格或其他字符串</li>\n<li>增加了函数容忍度 function show(a, b, c, ) -&gt; 不报错</li>\n<li>async 和 await，这基本上是 ES7 最好用的。。用于替代 generator 和 yield</li>\n<li>……</li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"ES6","path":"api/tags/ES6.json"},{"name":"笔记","path":"api/tags/笔记.json"}]},{"title":"JS中判断字符串中是否含有一个子串","slug":"JS中判断字符串中是否含有一个子串","date":"2017-08-01T07:33:27.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS中判断字符串中是否含有一个子串.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_273.png","content":"<p>题目我就不过多解释了，这篇文章是对 <a href=\"https://stackoverflow.com/questions/1789945/how-to-check-whether-a-string-contains-a-substring-in-javascript\" target=\"_blank\" rel=\"noopener\">stackoverflow 上一个问题</a>的总结，如果英文不是特别差的话，推荐大家点击上面链接看大家对这个问题的详细讨论</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">string.indexOf(substring) !== <span class=\"number\">-1</span>;</span><br></pre></td></tr></table></figure>\n<p>String 的原型方法，返回一个字符串在另一个字符串中的位置，如果没有找到的话就返回 -1；也是大家经常用的方案</p>\n<h3 id=\"ES6-的-includes\"><a href=\"#ES6-的-includes\" class=\"headerlink\" title=\"ES6 的 includes\"></a>ES6 的 includes</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">string.includes(substring);</span><br></pre></td></tr></table></figure>\n<p>ES6 中新增的 String 原型方法（其实 Array 原型也有 includes 方法），可以<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看文档</p>\n<h3 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search\"></a>search</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;</span><br><span class=\"line\">string.search(expr);</span><br></pre></td></tr></table></figure>\n<p>String.prototype.search() 执行正则表达式和 String 对象之间的一个搜索匹配，所以参数需要是正则表达式，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看中文文档</p>\n<h3 id=\"lodash-的-includes\"><a href=\"#lodash-的-includes\" class=\"headerlink\" title=\"lodash 的 includes\"></a>lodash 的 includes</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    substring = <span class=\"string\">\"oo\"</span>;</span><br><span class=\"line\">_.includes(string, substring);</span><br></pre></td></tr></table></figure>\n<p>lodash 是一个前端库，其提供了一些更加拥抱未来的方法，其中就有 _.includes(str,substr)</p>\n<h3 id=\"RegExp-和-test\"><a href=\"#RegExp-和-test\" class=\"headerlink\" title=\"RegExp 和 test\"></a>RegExp 和 test</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;  <span class=\"comment\">// no quotes here</span></span><br><span class=\"line\">expr.test(string);</span><br></pre></td></tr></table></figure>\n<p>“正则表达式是万能的”，RegExp.prototype.test(str)</p>\n<h3 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    expr = <span class=\"regexp\">/oo/</span>;</span><br><span class=\"line\">string.match(expr);</span><br></pre></td></tr></table></figure>\n<p>和上面的 test 正好相反，match 方式是 String 的原型方法，String.prototype.match(expr)</p>\n<h2 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h2><p>既然有这么多方法都可以实现，那么哪一种才是“性能最优”的方法呢？早就有前辈替我们做了测试，可以<a href=\"http://jsben.ch/#/RVYk7\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看测试结果，或者直接看下面这张图片：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_273.png\" alt=\"\" width=\"500\"></div>\n\n<p>不出所料，果然原生方法 indexOf() 是最快的，所以我们以后就还尽量用 indexOf() 吧！</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"}]},{"title":"JS中数组方法总结","slug":"JS中数组方法总结","date":"2017-03-22T14:12:57.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS中数组方法总结.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>因为刷 leetcode 的时候，发现会经常用到数组，因为 JS 中没有明确的栈和队列，所以需要用数组进行模拟，在刷算法题的过程中碰到了好多关于数组的计算方法，所以就打算对算法中经常用的数组方法进行总结，可能会对刚开始用 JS 刷 Leetcode 的码农有好处，如果你有任何补充，请留言评论或直接给我发邮件。</p>\n<h2 id=\"JS-自带数组方法\"><a href=\"#JS-自带数组方法\" class=\"headerlink\" title=\"JS 自带数组方法\"></a>JS 自带数组方法</h2><ul>\n<li>concat() =&gt; 连接两个或更多的数组，并返回结果。</li>\n<li>join() =&gt; 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</li>\n<li>pop() =&gt; 删除并返回数组的最后一个元素</li>\n<li>push() =&gt; 向数组的末尾添加一个或更多元素，并返回新的长度。</li>\n<li>reverse() =&gt; 颠倒数组中元素的顺序。</li>\n<li>shift() =&gt; 删除并返回数组的第一个元素</li>\n<li>slice() =&gt; 从某个已有的数组返回选定的元素</li>\n<li>sort() =&gt; 对数组的元素进行排序</li>\n<li>splice() =&gt; 删除元素，并向数组添加新元素。</li>\n<li>toSource() =&gt; 返回该对象的源代码。</li>\n<li>toString() =&gt; 把数组转换为字符串，并返回结果。</li>\n<li>toLocaleString() =&gt; 把数组转换为本地数组，并返回结果。</li>\n<li>unshift() =&gt; 向数组的开头添加一个或更多元素，并返回新的长度。</li>\n<li>valueOf() =&gt; 返回数组对象的原始值</li>\n</ul>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>JS 数组对象排序有内置方法 sort()，但是默认以字符串方式排序:</p>\n<h3 id=\"简单数组简单排序\"><a href=\"#简单数组简单排序\" class=\"headerlink\" title=\"简单数组简单排序\"></a>简单数组简单排序</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrSimple = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">arrSimple.sort();  <span class=\"comment\">// [1,6,7,8]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"简单数组自定义排序\"><a href=\"#简单数组自定义排序\" class=\"headerlink\" title=\"简单数组自定义排序\"></a>简单数组自定义排序</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrSimple2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">arrSimple2.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123; <span class=\"keyword\">return</span> b - a &#125;);  <span class=\"comment\">// [8,7,6,1]</span></span><br><span class=\"line\"><span class=\"comment\">// 解释：a, b表示数组中的任意两个元素，若return &gt; 0 b 前 a 后；reutrn &lt; 0 a 前 b 后；a = b 时存在浏览器兼容</span></span><br><span class=\"line\"><span class=\"comment\">// 简化一下：a-b 输出从小到大排序，b-a 输出从大到小排序。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除重复的元素只保留一个（两种实现思路）\"><a href=\"#删除重复的元素只保留一个（两种实现思路）\" class=\"headerlink\" title=\"删除重复的元素只保留一个（两种实现思路）\"></a>删除重复的元素只保留一个（两种实现思路）</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：遍历要删除的数组arr, 把元素分别放入另一个数组tmp中，在判断该元素在arr中不存在才允许放入tmp中用到两个函数：for ...in 和 indexOf()</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"a\"</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique1</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历arr，把元素分别放入tmp数组(不存在才放)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> arr)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该元素在tmp内部不存在才允许追加</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp.indexOf(arr[i])==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            tmp.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unique1(test);  <span class=\"comment\">// [2,4,5,\"a\"]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法二：把目标数组arr的元素值和键的位置调换 自动就把重复的元素给删除掉了，调换后的样子：array('qiang'=&gt;1,'ming'=&gt;1,'tao'=&gt;1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique2</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> m <span class=\"keyword\">in</span> arr)&#123;</span><br><span class=\"line\">        tmp[arr[m]]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 再把键和值的位置再次调换</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmparr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> n <span class=\"keyword\">in</span> tmp)&#123;</span><br><span class=\"line\">        tmparr.push(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmparr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unique2(test);  <span class=\"comment\">//[2,4,5,\"a\"]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法三：返回新数组，保证类型不变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique3</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hash=[],arr=[];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">        hash[a[i]]!=<span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!hash[a[i]])&#123;</span><br><span class=\"line\">            arr.push(a[i]);</span><br><span class=\"line\">            hash[a[i]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unique3(test);<span class=\"comment\">// [2, 4, 5, \"a\"]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取数组中的最大值和最小值\"><a href=\"#获取数组中的最大值和最小值\" class=\"headerlink\" title=\"获取数组中的最大值和最小值\"></a>获取数组中的最大值和最小值</h3><p>可以用传统的遍历，也可以用math</p>\n<p>首先定义一个数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">54</span>,<span class=\"number\">65</span>,<span class=\"number\">43</span>,<span class=\"number\">21</span>,<span class=\"number\">12</span>,<span class=\"number\">34</span>,<span class=\"number\">45</span>,<span class=\"number\">58</span>,<span class=\"number\">97</span>,<span class=\"number\">24</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一、字符串拼接法</span></span><br><span class=\"line\"><span class=\"comment\">// 利用toString和join把数组转换为字符串，再和Math的max和min方法分别进行拼接，最后执行eval方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = <span class=\"built_in\">eval</span>(<span class=\"string\">\"Math.max(\"</span> + arr.toString() + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = <span class=\"built_in\">eval</span>(<span class=\"string\">\"Math.min(\"</span> + arr.toString() + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = <span class=\"built_in\">eval</span>(<span class=\"string\">\"Math.max(\"</span> + arr.join() + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = <span class=\"built_in\">eval</span>(<span class=\"string\">\"Math.min(\"</span> + arr.join() + <span class=\"string\">\")\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法二、排序法</span></span><br><span class=\"line\"><span class=\"comment\">// 先把数组从小到大排序，数组第一个即为最小值，最后一个即为最大值</span></span><br><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;<span class=\"keyword\">return</span> a-b;&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = arr[arr.length<span class=\"number\">-1</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三-1\"><a href=\"#方法三-1\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法三、假设法</span></span><br><span class=\"line\"><span class=\"comment\">// 假设数组第一个为最大（或最小值），和后边进行比较，若后边的值比最大值大（或比最小值小），则替换最大值（或最小值）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cur = arr[i];</span><br><span class=\"line\">    cur&gt;maxN ? maxN=cur : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    cur&lt;minN ? minN=cur : <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法四\"><a href=\"#方法四\" class=\"headerlink\" title=\"方法四\"></a>方法四</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法四、Math的max和min方法</span></span><br><span class=\"line\"><span class=\"comment\">// 使用apply方法使数组可以作为传递的参数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>,arr);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = <span class=\"built_in\">Math</span>.min.apply(<span class=\"literal\">null</span>,arr);</span><br><span class=\"line\"><span class=\"comment\">// 多维数组可以这样做：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,[<span class=\"number\">5</span>,<span class=\"number\">6</span>],[<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>]];</span><br><span class=\"line\"><span class=\"keyword\">var</span> ta=a.join(<span class=\"string\">\",\"</span>).split(<span class=\"string\">\",\"</span>);<span class=\"comment\">// 转化为一维数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxN = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>,ta);<span class=\"comment\">// 最大值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> minN = <span class=\"built_in\">Math</span>.min.apply(<span class=\"literal\">null</span>,ta);<span class=\"comment\">// 最小值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展：增加原型方法，同时为了避免其他库也实现了同名的原型方法，可以在生成函数之前进行重名判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype[<span class=\"string\">'max'</span>] == <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max.apply(&#123;&#125;,<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype[<span class=\"string\">'min'</span>] == <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.min.apply(&#123;&#125;,<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化二维数组\"><a href=\"#初始化二维数组\" class=\"headerlink\" title=\"初始化二维数组\"></a>初始化二维数组</h3><h4 id=\"方法一-2\"><a href=\"#方法一-2\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：直接定义并且初始化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _TheArray = [[<span class=\"string\">\"0-1\"</span>,<span class=\"string\">\"0-2\"</span>],[<span class=\"string\">\"1-1\"</span>,<span class=\"string\">\"1-2\"</span>],[<span class=\"string\">\"2-1\"</span>,<span class=\"string\">\"2-2\"</span>]]</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-2\"><a href=\"#方法二-2\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法二：未知长度的二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tArray = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();  <span class=\"comment\">// 先声明一维</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;k&lt;i;k++)&#123;    <span class=\"comment\">// 一维长度为i,i为变量，可以根据实际情况改变</span></span><br><span class=\"line\">    tArray[k]=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();  <span class=\"comment\">// 声明二维，每一个一维数组里面的一个元素都是一个数组；</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=<span class=\"number\">0</span>;j&lt;p;j++)&#123;   <span class=\"comment\">// 一维数组里面每个元素数组可以包含的数量p，p也是一个变量；</span></span><br><span class=\"line\">        tArray[k][j]=<span class=\"string\">\"\"</span>;    <span class=\"comment\">// 这里将变量初始化，我这边统一初始化为空，后面在用所需的值覆盖里面的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三-2\"><a href=\"#方法三-2\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以上方法都有问题，推荐方法三</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> r = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;k&lt;length;k++)&#123;    </span><br><span class=\"line\">   r[k]= [];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组随机排序\"><a href=\"#数组随机排序\" class=\"headerlink\" title=\"数组随机排序\"></a>数组随机排序</h3><h4 id=\"Fisher–Yates-shuffle-算法\"><a href=\"#Fisher–Yates-shuffle-算法\" class=\"headerlink\" title=\"Fisher–Yates shuffle 算法\"></a>Fisher–Yates shuffle 算法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shuffle</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = arr.length, t, j;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i) &#123;</span><br><span class=\"line\">    j = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * i--);</span><br><span class=\"line\">    t = arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来自——<a href=\"https://blog.oldj.net/2017/01/23/shuffle-an-array-in-javascript/\" target=\"_blank\" rel=\"noopener\">关于JavaScript的数组随机排序</a></p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"数组","path":"api/tags/数组.json"}]},{"title":"JS中的传值与传址","slug":"JS中的传值与传址","date":"2017-04-25T12:36:04.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS中的传值与传址.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_21.jpg","content":"<p>在 JS 中，有两种不同的方式可以操作数据的值，这两种技术分别叫做<strong>传值</strong>和<strong>传址</strong>。</p>\n<h2 id=\"数据值的操作\"><a href=\"#数据值的操作\" class=\"headerlink\" title=\"数据值的操作\"></a>数据值的操作</h2><p>要知道传址跟传址，首先我们先了解下数据值的操作。</p>\n<ol>\n<li><strong>复制</strong>：可以把它赋值给一个新的变量</li>\n<li><strong>传递</strong>：可以将他传递给一个函数或者方法</li>\n<li><strong>比较</strong>：可以与另外一个值比较，判断是否相等</li>\n</ol>\n<h2 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h2><p><strong>传值</strong>：在赋值过程中，首先对值进行了一份拷贝，而后将这份拷贝存储到一个变量、对象属性或数组元素中。拷贝的值和原始的值是完全独立、互不影响的。当一份数据通过值传递给一个函数，实际上被传递的不是数据本身，而是数据的一份拷贝。因此，如果函数修改了这个值，影响到的只是数据的那份拷贝，而并不影响数据本身。</p>\n<p><strong>传址</strong>：在赋值过程中，变量实际上存储的是数据的地址（对数据的引用），而不是原始数据或者是数据的拷贝。如果值通过一个地址发生了改变，这个改变也会通过原始地址表现出来。</p>\n<h2 id=\"参阅对比表\"><a href=\"#参阅对比表\" class=\"headerlink\" title=\"参阅对比表\"></a>参阅对比表</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>传值</th>\n<th>传址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复制</td>\n<td>实际复制的是值，存在于两个不同的独立拷贝</td>\n<td>复制的只是对数值的引用，即地址，如果通过这个新的引用修改了数值，这个改变对最初的引用也是可见的</td>\n</tr>\n<tr>\n<td>传递</td>\n<td>传递给函数的值是一个独立的拷贝，对它的改变函数外没有影响</td>\n<td>传递给函数的是对数值的一个引用。如果通过这个新的引用修改了数值，这个改变对最初的引用也是可见的</td>\n</tr>\n<tr>\n<td>比较</td>\n<td>比较两个独立的值，判断是否相同</td>\n<td>比较的是两个的引用，判断引用是否是同一个数值。对两个不同数值的引用不相等，即使这两个数值相等</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>根据操作数据方式的不同，我们可以把数据类型分为两类：<strong>基础类型</strong>和<strong>引用类型</strong>。</p>\n<ul>\n<li>基础类型主要有：数字(Number)、布尔类型(Boolean)；其操作方式为传值。</li>\n<li>引用类型主要有：对象(Object) —— 数组(Array)、函数(Function)；其操作方式为传址。</li>\n</ul>\n<p>数字和布尔类型是基础类型，它们是由很小的，固定数目字节组成，所以可以通过传值来操作；而数组和函数，是对象的特殊类型，也是引用类型。由于对象没有固定大小，所以无法通过传值进行操作。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"传值（赋值操作）\"><a href=\"#传值（赋值操作）\" class=\"headerlink\" title=\"传值（赋值操作）\"></a>传值（赋值操作）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>, b = a, a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"a=\"</span> + a + <span class=\"string\">\",b=\"</span> + b);</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_21.jpg\" alt=\"\" width=\"400\"></div>\n\n<p>a 先是被赋值为 1，接着把 a 的值赋给 b，这时会进行值的拷贝，因此b = 1；然后又把 a 赋值为 2。在没有执行 a = 2 之前，我们试试下列代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b);  <span class=\"comment\">// 输出为true. 可见它们在内存中是指向同一个位置的。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"传值（基础类型）\"><a href=\"#传值（基础类型）\" class=\"headerlink\" title=\"传值（基础类型）\"></a>传值（基础类型）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;            <span class=\"comment\">// 将a复制给b</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add1</span>(<span class=\"params\">x,y</span>) </span>&#123;     <span class=\"comment\">// 函数修改参数的值</span></span><br><span class=\"line\">  x = x + y;              <span class=\"comment\">// 虽然这个里面将值进行相加，但是仅仅是值的独立拷贝，进行相加，在函数外面没有影响</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add1(a,b);                <span class=\"comment\">// 数字类型为传值</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\"n\"</span> + <span class=\"string\">\"b:\"</span> + b);      <span class=\"comment\">// a为1，b为1  </span></span><br><span class=\"line\">(a == b) ? c = <span class=\"string\">\"true\"</span> : c = <span class=\"string\">\"false\"</span>;  </span><br><span class=\"line\">alert(c);         <span class=\"comment\">// c = \"true\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"传址（引用类型）\"><a href=\"#传址（引用类型）\" class=\"headerlink\" title=\"传址（引用类型）\"></a>传址（引用类型）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];      <span class=\"comment\">// 定义数组，引用类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;                           <span class=\"comment\">// 将a复制给b</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123;           <span class=\"comment\">// 函数修改参数的值</span></span><br><span class=\"line\">  x[<span class=\"number\">0</span>] = <span class=\"string\">\"tt\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(b);             <span class=\"comment\">// 数组对象为传址  </span></span><br><span class=\"line\">alert(<span class=\"string\">\"a:\"</span> + a[<span class=\"number\">0</span>] + a[<span class=\"number\">1</span>] + a[<span class=\"number\">2</span>] + a[<span class=\"number\">3</span>] + <span class=\"string\">\"n\"</span> + <span class=\"string\">\"b:\"</span> + b[<span class=\"number\">0</span>] + b[<span class=\"number\">1</span>] + b[<span class=\"number\">2</span>] + b[<span class=\"number\">3</span>]);  <span class=\"comment\">// b对象修改，则a也会修改，传址</span></span><br><span class=\"line\">(a == b) ? q = <span class=\"string\">\"true\"</span> : q = <span class=\"string\">\"false\"</span>;    <span class=\"comment\">// 判断 a=b  ，返回true</span></span><br><span class=\"line\">alert(q);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];</span><br><span class=\"line\">(a == b) ? q = <span class=\"string\">\"true\"</span> : q = <span class=\"string\">\"false\"</span>;     <span class=\"comment\">// 这里定义了两个对象，虽然值一样，但是不是同样的地址，所以为false</span></span><br><span class=\"line\">alert(q);    <span class=\"comment\">// 输出\"false\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数内的特殊引用\"><a href=\"#函数内的特殊引用\" class=\"headerlink\" title=\"函数内的特殊引用\"></a>函数内的特殊引用</h3><p>按值传递一个参数给函数就是制作该参数的一个独立复本，即一个只存在于该函数内的复本。即使按引用传递对象和数组时，如果直接在函数中用新值覆盖原先的值，在函数外并不反映新值。只有在对象的属性或者数组的元素改变时，在函数外才可以看出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newa = <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  newa[<span class=\"number\">0</span>] = a[<span class=\"number\">0</span>] + b;</span><br><span class=\"line\">  newa[<span class=\"number\">1</span>] = a[<span class=\"number\">1</span>] + b;</span><br><span class=\"line\">  newa[<span class=\"number\">2</span>] = a[<span class=\"number\">2</span>] + b;</span><br><span class=\"line\">  a = newa;     <span class=\"comment\">// 重新覆盖了引用，所以外部是不可见的</span></span><br><span class=\"line\">  alert(a[<span class=\"number\">0</span>]);  <span class=\"comment\">// 11</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(a1, <span class=\"number\">10</span>);   </span><br><span class=\"line\">alert(a1[<span class=\"number\">0</span>]);     <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h2><p>前面看了这么多类型，一直都没有介绍字符串类型，它不好直接分为基础类型和引用类型，因为字符串\b可以是任意的长度，看上去应该是引用类型，可是他却不是对象，所以也不可作为引用类型；总结一下，<strong>字符串是按引用(即地址)复制和传递的，但是是按值来比较的。</strong></p>\n<p>请注意，假如有两个 String 对象（用 new String(“something”) 创建的），按引用比较它们，但是，如果其中一个或者两者都是字符串值的话，按值比较它们</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>复制</th>\n<th>传递</th>\n<th>比较</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数字</td>\n<td>传值</td>\n<td>传值</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>布尔</td>\n<td>传值</td>\n<td>传值</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>不可变</td>\n<td>不可变</td>\n<td>传值</td>\n</tr>\n<tr>\n<td>对象</td>\n<td>传址</td>\n<td>传址</td>\n<td>传址</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/joe2014/archive/2014/06/28/3813919.html\" target=\"_blank\" rel=\"noopener\">JS 基础知识2 传值和传址</a></li>\n<li><a href=\"http://www.cnblogs.com/idayln/p/3346242.html\" target=\"_blank\" rel=\"noopener\">图解JS的传值与传址</a></li>\n<li><a href=\"http://lxneliu.iteye.com/blog/1567205\" target=\"_blank\" rel=\"noopener\">JS 传值与传址</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"JS 中的浅拷贝和深拷贝","slug":"JS中的浅拷贝和深拷贝","date":"2017-07-30T10:17:35.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS中的浅拷贝和深拷贝.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"浅拷贝-VS-深拷贝\"><a href=\"#浅拷贝-VS-深拷贝\" class=\"headerlink\" title=\"浅拷贝 VS 深拷贝\"></a>浅拷贝 VS 深拷贝</h2><p>浅拷贝和深拷贝也成为<strong>浅复制</strong>和<strong>深复制</strong>，是在很多编程语言中经常用到的方法。另外，本文只会涉及到 js 中<strong>复杂数据类型</strong>的拷贝问题（Object, Array 等），不讨论基本数据类型（null, undefined, string, number 和 boolean），因为基本数据类型不存在引用值的情况。浅拷贝和深拷贝都可以实现在已有对象的基础上再生一份的作用，但是对象的实例是存储在堆内存中然后通过一个<strong>引用值</strong>去操作对象，由此拷贝的时候就存在两种情况了：<strong>拷贝引用和拷贝实例</strong>，这也是浅拷贝和深拷贝的区别所在：浅拷贝：只会将对象的各个属性进行依次复制，<strong>并不会进行递归复制</strong>，而JS中存储对象都是存地址的，所以浅拷贝会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址 深拷贝：不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法<strong>递归复制</strong>到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。 </p>\n<p>NOTE：如果对象比较大，层级也比较多，<strong>深拷贝会带来性能上的问题</strong>。在遇到需要采用深拷贝的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅拷贝更为常用。</p>\n<h2 id=\"浅拷贝的实现方式\"><a href=\"#浅拷贝的实现方式\" class=\"headerlink\" title=\"浅拷贝的实现方式\"></a>浅拷贝的实现方式</h2><p>从以上的对比可以总结出：浅拷贝就是简单的<strong>引用复制</strong>，有以下几种实现方式：</p>\n<h3 id=\"jQuery-extend-false-…\"><a href=\"#jQuery-extend-false-…\" class=\"headerlink\" title=\"jQuery.extend(false,…)\"></a>jQuery.extend(false,…)</h3><p>jQuery.extend 的第一个参数可以是布尔值，用来设置是否深度拷贝，设置为 false 或设置为空时就可以实现浅拷贝</p>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><p>ES6 中的 Object.assign(…) 方法可用来实现浅拷贝–它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到目标对象，最后返回目标对象。</p>\n<p>NOTE：这里<a href=\"https://stackoverflow.com/questions/38345937/object-assign-vs-extend\" target=\"_blank\" rel=\"noopener\">有一篇stackoverflow的文章</a>，是关于jQuery.extend()和Object.assign()区别的，当然你也可以直接点击<a href=\"https://jsfiddle.net/on9x55ow/2/\" target=\"_blank\" rel=\"noopener\">这里</a>通过实例比较两者区别</p>\n<h3 id=\"Underscore-的-clone\"><a href=\"#Underscore-的-clone\" class=\"headerlink\" title=\"Underscore 的 _.clone()\"></a>Underscore 的 _.clone()</h3><p>在 Underscore 中有这样一个方法：<code>_.clone()</code>，这个方法实际上是一种浅拷贝，所有嵌套的对象和数组都是直接复制引用，但是它比直接赋值来得“深”一些，因为它创建了一个新的对象，可以看下面例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: &#123; <span class=\"attr\">z</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = _.clone(x);</span><br><span class=\"line\"></span><br><span class=\"line\">y === x       <span class=\"comment\">// false</span></span><br><span class=\"line\">y.b === x.b   <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">x.b.z = <span class=\"number\">100</span>;</span><br><span class=\"line\">y.b.z         <span class=\"comment\">// 100</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-的-slice-和-concat\"><a href=\"#Array-的-slice-和-concat\" class=\"headerlink\" title=\"Array 的 slice 和 concat\"></a>Array 的 slice 和 concat</h3><p>Array 的 slice 和 concat 方法都会<strong>返回一个新的数组实例</strong>，但是这两个方法对于数组中的对象元素却没有执行深拷贝，而只是复制了引用。（和上面的 _.clone() 类似）</p>\n<h3 id=\"for…in…\"><a href=\"#for…in…\" class=\"headerlink\" title=\"for…in…\"></a>for…in…</h3><p>利用 for…in… 遍历对象就可以实现浅拷贝，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowCopy</span>(<span class=\"params\">p,c</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i;</span><br><span class=\"line\">    c = c||&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i <span class=\"keyword\">in</span> p)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.hasOwnProperty(i))&#123;</span><br><span class=\"line\">            c\\[i\\] = p\\[i\\];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"深拷贝的实现方式\"><a href=\"#深拷贝的实现方式\" class=\"headerlink\" title=\"深拷贝的实现方式\"></a>深拷贝的实现方式</h2><p>浅拷贝的实现方式如上所述，浅拷贝适合用在开发 jQuery 插件或者 redux 中返回 new state，而我们有时需要的是深拷贝，就是<strong>保证拷贝的对象与源对象完全隔离</strong>：</p>\n<h3 id=\"jQuery-extend-true-…\"><a href=\"#jQuery-extend-true-…\" class=\"headerlink\" title=\"jQuery.extend(true,…)\"></a>jQuery.extend(true,…)</h3><p>将 jQuery.extend 的第一个参数设置为 true 即可实现深度拷贝。但是缺点是<strong>无法深拷贝 JSON 对象以外的对象</strong></p>\n<p>NOTE：jQuery 中有一个叫做 $.clone() 的方法，可是它并不是用于一般的 JS 对象的拷贝，而是用于 DOM 对象的克隆，所以不要被它的名字骗到~</p>\n<h3 id=\"借助-JSON-全局对象\"><a href=\"#借助-JSON-全局对象\" class=\"headerlink\" title=\"借助 JSON 全局对象\"></a>借助 JSON 全局对象</h3><p>相比于使用插件，使用 JSON 全局对象的 <code>parse</code> 和 <code>stringify</code> 方法来实现深复制也算是一个简单讨巧的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> clone = jsonClone(&#123; <span class=\"attr\">a</span>:<span class=\"number\">1</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>然而这种方法<strong>有一些隐藏的坑</strong>：</p>\n<ul>\n<li>只能处理能够被json直接表示的数据结构：Number, String, Boolean, Array, 扁平对象；而对于正则表达式、Date 和 Function这种特殊的 Object 就无能为力了</li>\n<li>如果对象中存在循环引用的情况，这个方法也无法正确处理</li>\n</ul>\n<h3 id=\"lodash-的-clone-cloneDeep\"><a href=\"#lodash-的-clone-cloneDeep\" class=\"headerlink\" title=\"lodash 的 _.clone() / _.cloneDeep()\"></a>lodash 的 _.clone() / _.cloneDeep()</h3><p>在 lodash 中关于复制的方法有两个，分别是 <code>_.clone()</code> 和 <code>_.cloneDeep()</code>。其中 <code>_.clone(obj, true)</code> 等价于 <code>_.cloneDeep(obj)</code>。看了源码会发现，lodash 中与深拷贝相关的代码有上百行，而 jQuery 却只有 60 多行，这是为什么呢？原因是 lodash 花了大量的代码来实现 ES6 引入的大量新的标准对象。更厉害的是，lodash 针对<strong>存在环的对象</strong>的处理也是非常出色的。 所以，loadsh 在深拷贝上下了很多功夫，是一个很完美同时更拥抱未来的一个第三方库</p>\n<h2 id=\"各个深拷贝方法的比较\"><a href=\"#各个深拷贝方法的比较\" class=\"headerlink\" title=\"各个深拷贝方法的比较\"></a>各个深拷贝方法的比较</h2><p><a href=\"https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074\" target=\"_blank\" rel=\"noopener\">stackoverflow 上有一个提问</a>，讨论了 JS 中各个深拷贝方法的效率问题，然后有位大牛借助 jsben 对各个深拷贝方法进行了<a href=\"http://jsben.ch/bWfk9\" target=\"_blank\" rel=\"noopener\">实例测试</a>，强烈推荐大家看一下这个提问下的讨论以及实例测试的结果，相信看完后你对 JS 中的深拷贝会有更深刻的理解~</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/tracylin/p/5346314.html\" target=\"_blank\" rel=\"noopener\">也来谈一谈js的浅复制和深复制</a></li>\n<li><a href=\"https://www.zhihu.com/question/23031215\" target=\"_blank\" rel=\"noopener\">javascript中的深拷贝和浅拷贝？</a></li>\n<li><a href=\"http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/\" target=\"_blank\" rel=\"noopener\">深入剖析 JavaScript 的深复制</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]},{"title":"JS几种数组遍历方式","slug":"JS几种数组遍历方式","date":"2017-03-18T08:50:29.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS几种数组遍历方式.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这是从 Lichun Dai 博客中看到的一篇文章，作者对 JS 中的数组遍历方式进行了总结，同时进行了性能对比。但根据评论者的回答，性能分析需要结合具体环境，单纯在浏览器中进行测试是难下结论的，所以我只会展示实现的方式，至于在浏览器中的性能可以点击文末的链接跳转至原作者的分析工具 demo。</p>\n<h2 id=\"第一种：普通-for-循环\"><a href=\"#第一种：普通-for-循环\" class=\"headerlink\" title=\"第一种：普通 for 循环\"></a>第一种：普通 for 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简要说明：最简单的一种，也是使用频率最高的一种，虽然性能不弱，但仍有优化空间</p>\n<h2 id=\"第二种：优化版-for-循环\"><a href=\"#第二种：优化版-for-循环\" class=\"headerlink\" title=\"第二种：优化版 for 循环\"></a>第二种：优化版 for 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>,len=arr.length; j &lt; len; j++) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简要说明: 使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。 <strong>这种方法基本上是所有循环遍历方法中性能最高的一种</strong></p>\n<h2 id=\"第三种：弱化版-for-循环\"><a href=\"#第三种：弱化版-for-循环\" class=\"headerlink\" title=\"第三种：弱化版 for 循环\"></a>第三种：弱化版 for 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; arr\\[j\\]!=<span class=\"literal\">null</span>; j++) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简要说明: 这种方法其实严格上也属于 for 循环，只不过是没有使用 length 判断，而使用变量本身判断 <strong>实际上，这种方法的性能要远远小于普通 for 循环</strong></p>\n<h2 id=\"第四种：foreach-循环\"><a href=\"#第四种：foreach-循环\" class=\"headerlink\" title=\"第四种：foreach 循环\"></a>第四种：foreach 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;  </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简要说明: 数组自带的 foreach 循环，使用频率较高，实际上性能比普通 for 循环弱</p>\n<h2 id=\"第五种：foreach-变种\"><a href=\"#第五种：foreach-变种\" class=\"headerlink\" title=\"第五种：foreach 变种\"></a>第五种：foreach 变种</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.forEach.call(arr,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>)</span>&#123;  </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简要说明: 由于 foreach 是 Array 型自带的，对于一些非这种类型的，无法直接使用(如 NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有 foreach 功能。 实际性能要比普通 foreach 弱</p>\n<h2 id=\"第六种：forin-循环\"><a href=\"#第六种：forin-循环\" class=\"headerlink\" title=\"第六种：forin 循环\"></a>第六种：forin 循环</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简要说明: 这个循环很多人爱用，但实际上，经分析测试，在众多的循环遍历方式中 <strong>它的效率是最低的</strong></p>\n<h2 id=\"第七种：map-遍历\"><a href=\"#第七种：map-遍历\" class=\"headerlink\" title=\"第七种：map 遍历\"></a>第七种：map 遍历</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>)</span>&#123;  </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简要说明: 这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上 foreach</p>\n<h2 id=\"第八种：forof-遍历（ES6）\"><a href=\"#第八种：forof-遍历（ES6）\" class=\"headerlink\" title=\"第八种：forof 遍历（ES6）\"></a>第八种：forof 遍历（ES6）</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> arr) &#123;  </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简要说明: 这种方式是 ES6 里面用到的，性能要好于 forin，但仍然比不上普通 for 循环</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p><strong>普通 for 循环才是最优雅的</strong></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://dailc.github.io/2016/11/25/baseKnowlenge_javascript_jsarrayGoThrough.html\" target=\"_blank\" rel=\"noopener\">JS几种数组遍历方式以及性能分析对比</a></li>\n<li><a href=\"https://dailc.github.io/jsfoundation-perfanalysis/html/performanceAnalysis/demo_performanceAnalysis_jsarrayGoThrough.html\" target=\"_blank\" rel=\"noopener\">Js中几种常用数组遍历方式分析比较工具</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"数组","path":"api/tags/数组.json"}]},{"title":"Promise入门","slug":"Promise入门","date":"2018-02-26T14:14:10.000Z","updated":"2019-02-02T10:19:58.046Z","comments":true,"path":"api/articles/Promise入门.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>幕课网上的视频——<a href=\"https://www.imooc.com/learn/949\" target=\"_blank\" rel=\"noopener\">Promise入门</a>笔记，Promise 作为 ES6 中最重要的特性之一，对其进行了解和学习是非常有必要的，课程的源码已经上传至<a href=\"https://github.com/merrier/imooc-promise-sample\" target=\"_blank\" rel=\"noopener\">我的github</a>。</p>\n<h2 id=\"Promise是什么\"><a href=\"#Promise是什么\" class=\"headerlink\" title=\"Promise是什么\"></a>Promise是什么</h2><h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><blockquote>\n<ul>\n<li>The Promise object is used for asynchronous computations.</li>\n<li>A Promise represents a value which may be available now, or in the future, or never.</li>\n</ul>\n</blockquote>\n<h3 id=\"MDN中文\"><a href=\"#MDN中文\" class=\"headerlink\" title=\"MDN中文\"></a>MDN中文</h3><blockquote>\n<ul>\n<li>Promise对象用于异步计算。</li>\n<li>一个Promise表示一个现在、将来或永不可能可用的值。</li>\n</ul>\n</blockquote>\n<h3 id=\"按照用途来解释\"><a href=\"#按照用途来解释\" class=\"headerlink\" title=\"按照用途来解释\"></a>按照用途来解释</h3><ul>\n<li>主要用于异步计算</li>\n<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。</li>\n<li>可以在对象之间传递和操作Promise，帮助我们处理队列。</li>\n</ul>\n<h2 id=\"回调存在的问题\"><a href=\"#回调存在的问题\" class=\"headerlink\" title=\"回调存在的问题\"></a>回调存在的问题</h2><ol>\n<li>嵌套层次很深，难以维护</li>\n<li>无法正常使用 return 和 throw</li>\n<li>无法正常检索堆栈信息</li>\n<li>多个回调之间难以建立联系</li>\n</ol>\n<h2 id=\"Promise-详解\"><a href=\"#Promise-详解\" class=\"headerlink\" title=\"Promise 详解\"></a>Promise 详解</h2><ul>\n<li>Promise 是一个代理对象，它和原先要进行的操作并无关系</li>\n<li>它通过引入一个回调，避免更多的回调</li>\n</ul>\n<h3 id=\"Promise-有-3-个状态\"><a href=\"#Promise-有-3-个状态\" class=\"headerlink\" title=\"Promise 有 3 个状态\"></a>Promise 有 3 个状态</h3><ol>\n<li>pending[待定]——初始状态</li>\n<li>fulfilled[实现\\——操作成功</li>\n<li>rejected[被否决]——操作失败</li>\n</ol>\n<p>当 Promise 的状态发生改变，就会触发 .then() 里的响应函数处理后续步骤；Promise 状态一经改变，不会再变；只有在连续多个回调顺序执行的时候，Promise才会显示出其威力</p>\n<h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\".then()\"></a>.then()</h3><ul>\n<li>.then() 接受两个函数作为参数，分别代表 fulfilled 和 rejected</li>\n<li>.then() 返回一个新的 Promise 实例，所以它可以链式调用</li>\n<li>当前面的 Promise 状态改变时，.then() 根据其最终状态，选择特定的状态响应函数执行</li>\n<li>状态响应函数可以返回新的 Promise，或其它值</li>\n<li>如果返回新的 Promise，那么下一级 .then() 会在新的 Promise 状态改变之后执行</li>\n<li>如果返回其它任何值，则会立刻执行下一级 .then()</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>Promise 会自动捕获内部异常，并交给 rejected 响应函数处理 最好是在语句的最后通过 catch 捕获错误，因为 catch 可以捕获 resolve 回调中发生的错误，而 reject 回调无法捕获；catch 也会返回一个 Promise 实例，并且它返回的 Promise 实例如果没有错误的话也是 fulfilled 状态，所以 catch() 后面的 .then() 也都会触发，但是 catch() 后面的 .catch() 不会触发（<strong>如果在第一个catch()中没有抛出错误</strong>）</p>\n<p><strong>强烈建议在所有队列最后都加上.catch()，以避免漏掉错误处理造成意想不到的问题：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething()</span><br><span class=\"line\">  .doAnotherThing()</span><br><span class=\"line\">  .doMoreThing()</span><br><span class=\"line\">  .catch( <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现队列\"><a href=\"#实现队列\" class=\"headerlink\" title=\"实现队列\"></a>实现队列</h3><p>有时候我们不希望所有动作一起发生，而是按照一定顺序，逐个进行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = doSomething();</span><br><span class=\"line\">promise = promise.then(doSomethingElse);</span><br><span class=\"line\">promise = promise.then(doSomethingElse2);</span><br><span class=\"line\">promise = promise.then(doSomethingElse3);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-forEach\"><a href=\"#使用-forEach\" class=\"headerlink\" title=\"使用.forEach()\"></a>使用.forEach()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">queue</span>(<span class=\"params\">things</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  things.forEach( <span class=\"function\"><span class=\"params\">thing</span> =&gt;</span> &#123;</span><br><span class=\"line\">    promise = promise.then( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>( <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        doThing(thing, () =&gt; &#123;</span><br><span class=\"line\">          resolve();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(\\[<span class=\"string\">'lots'</span>, <span class=\"string\">'of'</span>, <span class=\"string\">'things'</span>, ....\\]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-reduce\"><a href=\"#使用-reduce\" class=\"headerlink\" title=\"使用.reduce()\"></a>使用.reduce()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">queue</span>(<span class=\"params\">things</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> things.reduce( <span class=\"function\">(<span class=\"params\">promise, thing</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    promise = promise.then( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>( <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        doThing(thing, () =&gt; &#123;</span><br><span class=\"line\">          resolve();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, <span class=\"built_in\">Promise</span>.resolve());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(\\[<span class=\"string\">'lots'</span>, <span class=\"string\">'of'</span>, <span class=\"string\">'things'</span>, ....\\]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise常用函数\"><a href=\"#Promise常用函数\" class=\"headerlink\" title=\"Promise常用函数\"></a>Promise常用函数</h2><h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h3><p>返回一个 fulfilled 的 Promise 实例，或原始 Promise 实例</p>\n<ul>\n<li>参数为空，返回一个状态为 fulfilled 的 Promise 实例</li>\n<li>参数是一个跟 Promise 无关的值，同上，不过 fulfilled 响应函数会得到这个参数</li>\n<li>参数为 Promise 实例，则返回该实例，不做任何修改</li>\n<li>参数为 thenable（有 then 方法），立刻执行它的 .then()</li>\n</ul>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h3><p>返回一个 rejected 的 Promise 实例</p>\n<ul>\n<li><strong>Promise.reject()不认thenable</strong></li>\n<li>其他和 Promise.resolve() 类似</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h3><p><code>Promise.all(\\[p1, p2, p3, ...\\])</code> 用于将多个 Promise 实例包装成一个新的 Promise 实例 当所有子 Promise 都完成，该 Promise 完成，返回值是<strong>全部值的数组</strong>；有任何一个失败，该 Promise 失败，返回值是<strong>第一个失败的子Promise的结果</strong>，最常见的是和 .map() 连用</p>\n<p>###Promise.race()</p>\n<p>类似 Promise.all() ，区别在于它有任意一个完成就算完成。</p>\n<h3 id=\"常见用法：\"><a href=\"#常见用法：\" class=\"headerlink\" title=\"常见用法：\"></a>常见用法：</h3><ul>\n<li>把异步操作和定时器放在一起</li>\n<li>如果定时器先触发，就认为超时，告知用户</li>\n</ul>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2><p>ES2017 新增运算符，新的语言元素</p>\n<ul>\n<li>赋予 JavaScript 以顺序手法编写异步脚本的能力！</li>\n<li>既保留异步运算的无阻赛特性，还继续使用同步写法。</li>\n<li>还能正常使用 return/try/catch</li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"ES6","path":"api/tags/ES6.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"慕课网","path":"api/tags/慕课网.json"}]},{"title":"前端面试系列（9）——JS实现继承","slug":"前端面试系列（9）——JS实现继承","date":"2017-04-05T13:11:07.000Z","updated":"2019-02-02T10:19:58.050Z","comments":true,"path":"api/articles/前端面试系列（9）——JS实现继承.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_316.jpg","content":"<p>JS 虽然声称面向对象，但是其很多特性与真正的“面向对象”仍有一定差距；面向对象的一大特性就是可以继承，所以如何在 JS 这种弱类型语言中实现继承就成为了前端面试中的常见问题，下面我就总结一下在 JS 中实现继承的几种方式：</p>\n<h2 id=\"定义父类\"><a href=\"#定义父类\" class=\"headerlink\" title=\"定义父类\"></a>定义父类</h2><p>既然要实现继承，首先得有一个父类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1、原型链继承\"><a href=\"#1、原型链继承\" class=\"headerlink\" title=\"1、原型链继承\"></a>1、原型链继承</h2><p><strong>核心</strong>：将父类的实例作为子类的原型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>\n<li>父类新增原型方法 / 原型属性，子类都能访问到</li>\n<li>简单，易于实现</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>要想为子类新增属性和方法，必须要在 <code>new Animal()</code> 这样的语句之后执行，不能放到构造器中</li>\n<li>无法实现多继承</li>\n<li>来自原型对象的引用属性是所有实例共享的</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n</ol>\n<p><strong>推荐指数</strong>：★★（3、4 两大致命缺陷）</p>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p><strong>核心</strong>：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 除了 call 方法，也可以用 apply()，由于篇幅原因，就不再详细介绍这两种方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>解决了 1 中，子类实例共享父类引用属性的问题</li>\n<li>创建子类实例时，可以向父类传递参数</li>\n<li>可以实现多继承（call 多个父类对象）</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实例并不是父类的实例，只是子类的实例</li>\n<li>只能继承父类的实例属性和方法，不能继承原型属性 / 方法</li>\n<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>\n</ol>\n<p><strong>推荐指数</strong>：★★（缺点3）</p>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p><strong>核心：</strong>：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>不限制调用方式，不管是 <code>new 子类()</code>还是<code>子类()</code>，返回的对象具有相同的效果</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实例是父类的实例，不是子类的实例</li>\n<li>不支持多继承</li>\n</ol>\n<p><strong>推荐指数</strong>：★★</p>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><p><strong>特点</strong>：使用 for in 将父类实例中的方法赋给子类实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>\n<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）</li>\n</ol>\n<p><strong>推荐指数</strong>：★（缺点 1）</p>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p><strong>核</strong>：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>弥补了方式 2 的缺陷，可以继承实例属性 / 方法，也可以继承原型属性 / 方法</li>\n<li>既是子类的实例，也是父类的实例</li>\n<li>不存在引用属性共享问题</li>\n<li>可传参</li>\n<li>函数可复用</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<p><strong>推荐指数</strong>：★★★★（仅仅多消耗了一点内存，也是最常用的一种继承方式）</p>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p><strong>核心</strong>：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法 / 属性，避免的组合继承的缺点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>堪称完美</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>实现较为复杂</li>\n</ol>\n<p><strong>推荐指数</strong>：★★★★（实现复杂，扣掉一颗星）</p>\n<h2 id=\"7、六种继承方式的联系\"><a href=\"#7、六种继承方式的联系\" class=\"headerlink\" title=\"7、六种继承方式的联系\"></a>7、六种继承方式的联系</h2><div align=\"center\"><img src=\"/images/hexo_post_316.jpg\" alt=\"\" width=\"300\"></div>\n\n<p>PS：虚线表示辅助作用，实现表示决定性作用</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/humin/p/4556820.html\" target=\"_blank\" rel=\"noopener\">JS继承的实现方式</a></li>\n<li><a href=\"http://www.cnblogs.com/ayqy/p/4471638.html\" target=\"_blank\" rel=\"noopener\">重新理解JS的6种继承方式</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"理解JS中的内存分配","slug":"理解JS中的内存分配","date":"2017-08-03T02:06:42.000Z","updated":"2019-02-02T10:19:58.050Z","comments":true,"path":"api/articles/理解JS中的内存分配.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_113.jpeg","content":"<h2 id=\"原始值和引用值\"><a href=\"#原始值和引用值\" class=\"headerlink\" title=\"原始值和引用值\"></a>原始值和引用值</h2><p>在 ECMAScript 中，变量可以存放两种类型的值，即原始值和引用值；原始值：原始数据类型（简单类型）的值，即undefined、null、Number、String、Boolean 类型所表示的值；引用值：复合数据类型（对象类型）的值，即Object、Function、Array 以及自定义对象等</p>\n<h2 id=\"栈和堆\"><a href=\"#栈和堆\" class=\"headerlink\" title=\"栈和堆\"></a>栈和堆</h2><p>与原始值和引用值对应存在两种结构的内存，即栈和堆</p>\n<h3 id=\"栈和原始值\"><a href=\"#栈和原始值\" class=\"headerlink\" title=\"栈和原始值\"></a>栈和原始值</h3><p>栈是一种后进先出的数据结构，在 JS 中可以通过 Array（数组）来模拟栈的行为 原始值是存储在栈中的简单数据，也就是说，它们的值直接存储在变量访问的位置</p>\n<h3 id=\"堆和引用值\"><a href=\"#堆和引用值\" class=\"headerlink\" title=\"堆和引用值\"></a>堆和引用值</h3><p>堆是基于散列算法的数据结构，在 JS 中，引用值是存放在堆中的 引用值是存储在堆中的对象，也就是说，存储在变量处的值（即指向对象的变量，存储在栈中）是一个指针，指向存储在堆中的实际对象</p>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><p>通过上面的讲解，我们可以得到如下简单的结论：</p>\n<ul>\n<li><strong>简单类型都放在栈里</strong></li>\n<li><strong>对象类型都放在堆里，指向对象的指针放在栈里</strong></li>\n</ul>\n<p>假如我们有如下几个变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = &#123; <span class=\"attr\">m</span>: <span class=\"number\">20</span> &#125;  <span class=\"comment\">//地址假设为0x0012ff7c</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> e = &#123; <span class=\"attr\">m</span>: <span class=\"number\">20</span> &#125;  <span class=\"comment\">//重新开辟一段内存空间假设为0x0012ff8f</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e==d);  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>它们在实际存储时的内存空间占用是这样的：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_113.jpeg\" alt=\"\" width=\"600\"></div>\n\n<p>看到这里，你可能会问：为什么引用值要放在堆中，而原始值要放在栈中，不都是在内存中吗，为什么不放在一起呢？接下来，让我们来探索问题的答案！ 首先，请允许我再举个栗子:）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">id, name, age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bol = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = \\[<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>\\];</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"number\">100</span>,<span class=\"string\">\"笨蛋的座右铭\"</span>,<span class=\"number\">25</span>);</span><br></pre></td></tr></table></figure>\n<p>然后，我们来看一下分析图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_38.jpeg\" alt=\"\" width=\"400\"></div>\n\n<p>从上图我们可以看到，我们无法直接操纵堆中的数据，也就是说我们无法直接操纵对象，但我们可以通过栈中对对象的引用来操纵对象。</p>\n<h2 id=\"答案揭晓\"><a href=\"#答案揭晓\" class=\"headerlink\" title=\"答案揭晓\"></a>答案揭晓</h2><p>现在让我们来回答为什么引用值要放在堆中，而原始值要放在栈中的问题： 记住一句话：</p>\n<blockquote>\n<p>能量是守恒的，无非是时间换空间，空间换时间的问题</p>\n</blockquote>\n<p>堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008432611\" target=\"_blank\" rel=\"noopener\">从[]==![]为true来剖析JavaScript各种蛋疼的类型转换</a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html\" target=\"_blank\" rel=\"noopener\">理解js内存分配</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"数据结构","path":"api/tags/数据结构.json"},{"name":"内存","path":"api/tags/内存.json"}]},{"title":"JS中的==、===和Object.is","slug":"JS中的==、===和Object.is","date":"2017-08-02T12:07:47.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS中的==、===和Object.is.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_51.png","content":"<p>在查阅了很多资料之后，我将在这篇文章对于 JS 中的 ==、===、Object.is 进行详细的讲解，所以这很有可能是一篇很长很长的“唠叨文”，但是我相信你一定可以从这篇文章中收货很多，所以抖擞精神，往下看吧！</p>\n<h2 id=\"比较操作\"><a href=\"#比较操作\" class=\"headerlink\" title=\"比较操作\"></a>比较操作</h2><p>首先，你需要知道 JavaScript 提供了三种不同的值比较操作：</p>\n<ul>\n<li>严格相等（’triple equals’或’identity’），即 “===”</li>\n<li>宽松相等（’double equals’），即 “==”</li>\n<li>Object.js（ECMAScript 2015/ES6 新特性）</li>\n</ul>\n<p>现在考虑表达式 x==y，当 x 和 y 的类型相同时，x==y 可以转化为 x===y，而对于后者是很简单的，因为不涉及到类型转换，只需要注意：</p>\n<ul>\n<li>+0 ==(=) -0  //true</li>\n<li>NaN ==(=) NaN  //false</li>\n</ul>\n<p>对于上面这两种，你可以理解为 JavaScript 设计的问题（其实还是那句老话，王八的屁股——规定！），所以只需要死记硬背就可以了，当然还有两个长得像的 Object 也不相等，表现在：</p>\n<ul>\n<li>[] ==(=) []  //false</li>\n<li>{} ==(=) {}  //false</li>\n</ul>\n<p>之所以两个长得像的对象和数组都不相等，是因为在JS中，数组和对象是复杂数据类型，所以其实比较的是引用值，所以任意两个长得像的对象都不相等，具体参见：<a href=\"/20170803/understanding-memory-allocation-in-js.html\">理解JS中的内存分配</a>。ES6 中新增了 Object.is() 方法，它和 “===” 是基本相同的，除了下面这两种情况：</p>\n<ul>\n<li>Object.is(+0, -0)  //false</li>\n<li>Object.is(NaN, NaN)  //true</li>\n</ul>\n<p>所以你可以理解为 Object.is() 其实是对 “===” 的修正。“===” 和 Object.is() 介绍完了，下面就着重介绍一下 “==”（因为 JS 中的 “==” 会将等号两边进行类型转换，所以情况比较复杂）</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h2><p>“==” 在比较前会将比较的值转换为相同类型，在转换后（等式的一边或两边都可能被转换），最终的比较方式就等同于全等操作符 “===”。同时请注意，“===” 满足交换律，但是 “==” 不满足交换律（比如![]和{}）。先来看一张吊炸天的图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_51.png\" alt=\"\" width=\"600\"></div>\n\n<p><strong>我们接下来的讲解都建立在这张图上面：</strong></p>\n<h3 id=\"有和无\"><a href=\"#有和无\" class=\"headerlink\" title=\"有和无\"></a>有和无</h3><p>从这张图我们可以明显的看出，它们被分成了两个阵营：</p>\n<ul>\n<li>String、Number、Boolean 和 Object（对应左侧）</li>\n<li>undefined 和 null（对应右侧）</li>\n</ul>\n<p>分组的依据是什么呢？就是左侧是一个存在的世界，右侧是一个空的世界。所以就有如下规则：</p>\n<ul>\n<li>左侧任意 == 右侧任意  // false</li>\n</ul>\n<p>也就是左右两个世界中的任意值做 “==” 比较的结果都是 false</p>\n<h3 id=\"空和空\"><a href=\"#空和空\" class=\"headerlink\" title=\"空和空\"></a>空和空</h3><p>JavaScript 中的 undefined 和 null 是另一个经常让我们崩溃的地方。通常它被认为是一个设计缺陷，这一点我们不去深究。不过我曾听说，JavaScript 的作者最初是这样想的：</p>\n<blockquote>\n<p>假如你打算把一个变量赋予对象类型的值，但是现在还没有赋值，那么你可以用 null 表示此时的状态(证据之一就是 typeof null 的结果是 ‘object’)；相反，假如你打算把一个变量赋予原始类型的值，但是现在还没有赋值，那么你可以用 undefined 表示此时的状态。</p>\n</blockquote>\n<p>不管这个传闻是否可信，它们两者做 == 比较的结果是 true 是很合理的。(见上图中右侧垂直线上标的 true，也就是 <code>undefined == null</code>)</p>\n<h3 id=\"P和N\"><a href=\"#P和N\" class=\"headerlink\" title=\"P和N\"></a>P和N</h3><p>依然是上面那张图，从图中可以看到两个符号：大写字母 N 和 P：N 表示 ToNumber 操作，即将操作数转为数字。它是规范中的抽象操作，但我们可以用 JS 中的 Number() 函数来等价替代；P 表示 ToPrimitive 操作，即将操作数转为原始类型的值。它也是规范中的抽象操作，同样也可以翻译成等价的 JS 代码，但是会比 ToNumber 复杂一些，所以我们后面会详细解释。  </p>\n<h4 id=\"ToPrimitive\"><a href=\"#ToPrimitive\" class=\"headerlink\" title=\"ToPrimitive\"></a>ToPrimitive</h4><p>我们先讲 ToPrimitive，因为 ToNumber 中会用到 ToPrimitive，下面是关于 ToPrimitive 的规范：</p>\n<blockquote>\n<p>ToPrimitive 运算符接受一个值和一个可选的期望类型作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原始类型，可以使用可选的期望类型来暗示那个类型。根据下表完成转换：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>null</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>String</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>返回该对象的默认值。对象的默认值由把期望类型传入作为hint参数调用对象的内部方法 <code>[[DefaultValue]]</code> 得到</td>\n</tr>\n</tbody>\n</table>\n<p>对于 Object 这种输入类型，上面的表格中的描述不够清楚，我查了一些资料，概括如下：MDN 上对于 ToPrimitive 的语法规范定位为：</p>\n<blockquote>\n<p>ToPrimitive(obj, preferredType)</p>\n</blockquote>\n<p><strong>在执行 ToPrimitive(obj, preferredType) 时如果第二个参数为空并且 obj 为 Date 的实例时，此时 preferredType 会被设置为 String，其他情况下 preferredType 都会被设置为 Number</strong>。如果 preferredType 为 Number，ToPrimitive 执行过程如下：</p>\n<ol>\n<li>如果 obj 为原始值，直接返回；</li>\n<li>否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</li>\n<li>否则调用 obj.toString()，如果执行结果是原始值，返回之；</li>\n<li>否则抛异常。</li>\n</ol>\n<p>如果 preferredType 为 String，将上面的第 2 步和第 3 步调换，即：</p>\n<ol>\n<li>如果 obj 为原始值，直接返回；</li>\n<li>否则调用 obj.toString()，如果执行结果是原始值，返回之；</li>\n<li>否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</li>\n<li>否则抛异常。</li>\n</ol>\n<p>接下来我们就开始介绍v alueOf() 和 toString() 以及原始值了：</p>\n<h3 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf()\"></a>valueOf()</h3><p>valueOf 方法返回对象的原始值，可能是字符串、数值或 bool 值等，看具体的对象。还是看具体的例子吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"obj\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.valueOf());<span class=\"comment\">//Object &#123;name: \"obj\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = \\[<span class=\"number\">1</span>\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.valueOf());<span class=\"comment\">//\\[1\\]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date.valueOf());<span class=\"comment\">//1456638436303</span></span><br><span class=\"line\"><span class=\"comment\">//如代码所示，三个不同的对象实例调用valueOf返回不同的数据</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>toString 方法用来返回对象的字符串表示</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString());<span class=\"comment\">//\\[object Object\\]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = \\[\\];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.toString());<span class=\"comment\">//\"\"，即空字符串</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date.toString());<span class=\"comment\">//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>\n<p>这个方法具体的运行机制是个比较复杂的过程，我之后会专门写一篇文章讲解这两个方法，可以尝试搜索一下。（当然，也可以自己在控制台敲一下，加深印象）</p>\n<h3 id=\"原始值（Primitive）\"><a href=\"#原始值（Primitive）\" class=\"headerlink\" title=\"原始值（Primitive）\"></a>原始值（Primitive）</h3><p>“原始值”这三个字虽然听上去很高大上，其实很容易理解，就是指 null、undefined、String、Boolean、Number 这五种基本数据类型之一。 花了这么大力气终于把 ToPrimitive 介绍完了，下面我们介绍一下 ToNumber：</p>\n<h3 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h3><p>ToNumber 运算符根据下表将其参数转换为数值类型的值：</p>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>null</td>\n<td>+0</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>如果参数是true，结果为1。如果参数是false，结果为+0</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>结果等于输入的参数（不转换）</td>\n</tr>\n<tr>\n<td>String</td>\n<td>下面会介绍</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>“应用下列步骤：1.设原始值为ToPrimitive(输入参数，暗示数值类型)；2.返回ToNumber(上面的原始值)”</td>\n</tr>\n</tbody>\n</table>\n<p>上面表格已经很清楚了，但是还有个 ToNumber(String 类型)没有介绍：</p>\n<h4 id=\"字符转数字\"><a href=\"#字符转数字\" class=\"headerlink\" title=\"字符转数字\"></a>字符转数字</h4><p>字符转数字的规则是这样的：把字符串两边的空白字符去掉，然后把两边的引号去掉，看它能否组成一个合法的数字。如果能，转化结果就是这个数字，否则结果就是 NaN。举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'123'</span>) <span class=\"comment\">//结果123</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'1.2e3'</span>) <span class=\"comment\">//结果1200</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'123abc'</span>) <span class=\"comment\">//结果NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'\\\\r\\\\n\\\\t123\\\\v\\\\f'</span>) <span class=\"comment\">//结果123</span></span><br></pre></td></tr></table></figure>\n<p>当然也有例外，比如空白字符串转换为数字的结果是 0。即：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">''</span>) <span class=\"comment\">// 结果+0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'\\\\r\\\\n\\\\t \\\\v\\\\f'</span>) <span class=\"comment\">// 结果+0</span></span><br></pre></td></tr></table></figure>\n<p>到目前为止，我们介绍完了 ToPrimitive 和 ToNumber，所以上面那张图的内容基本上就介绍完了。但是还有个运算符没有讲，就是 “!” 取非操作，下面就介绍一下这个看似简单的取非操作：</p>\n<h3 id=\"ToBoolean\"><a href=\"#ToBoolean\" class=\"headerlink\" title=\"ToBoolean\"></a>ToBoolean</h3><p>取非其实是执行了 ToBoolean 运算符之后再取反，ToBoolean 运算符根据下表将其参数转换为布尔值类型的值：</p>\n<table>\n<thead>\n<tr>\n<th>输入类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>false</td>\n</tr>\n<tr>\n<td>null</td>\n<td>false</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>结果等于输入的参数</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>如果参数是+0，-0或NaN，结果为false；否则结果为true</td>\n</tr>\n<tr>\n<td>String</td>\n<td>如果参数时空字符串（长度为零），结果为false；否则为true</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"没图你说个\"><a href=\"#没图你说个\" class=\"headerlink\" title=\"没图你说个**\"></a>没图你说个**</h3><p>相等操作符 (==) 对于不同类型的值，进行的比较如下图所示：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_276.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"万物皆数\"><a href=\"#万物皆数\" class=\"headerlink\" title=\"万物皆数\"></a>万物皆数</h2><p>我们再来看上面那张图，里面标有 N 或 P 的那几条连线是没有方向的。假如我们在这些线上表上箭头，使得连线从标有 N 或 P 的那一端指向另一端，那么就会得到：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_50.png\" alt=\"\" width=\"300\"></div>\n\n<p>聪明的你肯定发现了，在 == 运算过程中，所有类型的值都有一种向数字类型转化的趋势。毕竟有这样一句名言：</p>\n<blockquote>\n<p>万物皆数</p>\n</blockquote>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>前面废话一堆，还不如举个实例来的痛快：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] == ![]</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">首先你需要明确的是上面这段代码执行的顺序，这就涉及到运算符的优先级了：`</span>! &gt; ==<span class=\"string\">`。所以 ! 取反运算符的优先级会高于 ==，那让我们先来看等号右边的 “!\\[\\]”，根据上面的 ToBoolean，**\\[\\]是一个对象**，那么 ToBoolean(\\[\\]) 就是 true，!\\[\\] 就是 false 了 然后，我们根据上面那张图，等号左边的 \\[\\] 是 Object，等号右边的 !\\[\\] 是一个 Boolean 值，所以最终就成为了 ToPrimitive(\\[\\]) == ToNumber(false) 了；而 ToPrimitive 默认调用 toString 方法，于是 ToPrimitive(\\[\\]) 就是空字符串，而 ToNumber(false) 就是 0；那么最后就成为了 \"\" == 0，这种形态，此时是 String 和 Number 之间的比较，很明显就是 toNumber(\"\") == 0 的比较了，根据 ToNumber 的转换规则，toNumber(\"\")=0，于是 \\[\\] == !\\[\\] 最后成了 0 == 0 的问题，答案显而易见为 true。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 总结一下</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">最后，我们总结一下 == 运算的规则：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* undefined == null，结果是 true。且它俩与所有其他值比较的结果都是 false。</span></span><br><span class=\"line\"><span class=\"string\">* String == Boolean，需要两个操作数同时转为 Number。</span></span><br><span class=\"line\"><span class=\"string\">* String/Boolean == Number，需要 String/Boolean 转为 Number。</span></span><br><span class=\"line\"><span class=\"string\">* Object == Primitive，需要 Object 转为 Primitive(具体通过 valueOf 和 toString方法)。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">所以，其实只有 4 条规则！只要我们完全理解了这四条规则，以后再遇到 == 就不会头疼了！</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 一些经典题目</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">\\[\\]==\\[\\]  <span class=\"comment\">//false</span></span><br><span class=\"line\">&#123;&#125;==&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">\\[\\]==!\\[\\]  <span class=\"comment\">//true</span></span><br><span class=\"line\">&#123;&#125;==!&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">&#123;&#125;==!\\[\\]  <span class=\"comment\">//VM1896:1 Uncaught SyntaxError: Unexpected token ==</span></span><br><span class=\"line\">!\\[\\]==&#123;&#125;  <span class=\"comment\">//false</span></span><br><span class=\"line\">\\[\\]==!&#123;&#125;  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span>==<span class=\"literal\">null</span>  <span class=\"comment\">//true</span></span><br><span class=\"line\">+<span class=\"number\">0</span> === <span class=\"number\">-0</span>  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>  <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> !== <span class=\"literal\">false</span>  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>更新自2017-8-4：根据<a href=\"https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric\" target=\"_blank\" rel=\"noopener\">stackoverflow上的一个讨论</a>，我发现还有如下规则：2e308 === Infinity，原因是<strong>2e308 &gt; Number.MAX_VALUE</strong>，所以其相当于是无穷大，负无穷大同理。</p>\n</blockquote>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness\" target=\"_blank\" rel=\"noopener\">JavaScript 中的相等性判断</a></li>\n<li><a href=\"http://dorey.github.io/JavaScript-Equality-Table/\" target=\"_blank\" rel=\"noopener\">JS比较表</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008432611\" target=\"_blank\" rel=\"noopener\">从[]==![]为true来剖析JavaScript各种蛋疼的类型转换</a></li>\n<li><a href=\"http://www.admin10000.com/document/9242.html\" target=\"_blank\" rel=\"noopener\">通过一张简单的图，让你彻底地、永久地搞懂JS的==运算</a></li>\n<li><a href=\"https://www.zhihu.com/question/31442029\" target=\"_blank\" rel=\"noopener\">Javascript 中 == 和 === 区别是什么？</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"面试","path":"api/tags/面试.json"},{"name":"运算符","path":"api/tags/运算符.json"}]},{"title":"JS中的apply、call和bind","slug":"JS中的apply、call和bind","date":"2017-08-03T08:30:08.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS中的apply、call和bind.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>关于 JS 中的 apply、call 和 bind，网上的相关文章实在是太多了，但是对于我这种比较重视基础的人来说，感觉大部分文章都讲不到点子上，不乏无脑复制粘贴之辈，所以我在参考了一些资料之后，决定用比较容易理解的方式来讲解，同时会用更多的实例来说明它们之间的区别。</p>\n<h2 id=\"为什么会有它们仨\"><a href=\"#为什么会有它们仨\" class=\"headerlink\" title=\"为什么会有它们仨\"></a>为什么会有它们仨</h2><p>首先，哲学中有一句话：</p>\n<blockquote>\n<p>存在即合理</p>\n</blockquote>\n<p>所以，JS 中为什么会有它们仨呢？让我们来一看一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cat</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cat.prototype=&#123;     </span><br><span class=\"line\">    food:<span class=\"string\">\"fish\"</span>,     </span><br><span class=\"line\">    say: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;          </span><br><span class=\"line\">    alert(<span class=\"string\">\"I love \"</span>+<span class=\"keyword\">this</span>.food);     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> blackCat = <span class=\"keyword\">new</span> cat;</span><br><span class=\"line\">blackCat.say();</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，也是我们经常会碰到的，就是我们定义了一个 cat 类，然后 blackCat 是 cat 类的一个实例， cat 类有一个 say 方法。那么问题来了，如果我们又有一个对象叫做 <code>whiteDog={food:&quot;bone&quot;}</code>，我们想让 whiteDog 也有 cat 类的 say 方法，那应该怎么办呢？所以这时候就体验出它们仨的作用了，我们可以通过下面的方式让 whiteDog 也有 say 方法：</p>\n<ul>\n<li>blackCat.say.call(whiteDog)</li>\n<li>blackCat.say.apply(whiteDog)</li>\n<li>blackCat.say.bind(whiteDog)()</li>\n</ul>\n<p>通过上面这个“猫与狗”的栗子，我们可以总结出 apply、call 和 bind 的共同点，就是它们都是为了改变函数体内部 this 的指向，也就是为了改变某个函数运行时的上下文（context）而存在的（JavaScript 的函数存在【定义时上下文】、【运行时上下文】和【上下文是可以改变的】这样的概念，具体参见简书-波同学的文章：<a href=\"http://www.jianshu.com/p/a6d37c77e8db\" target=\"_blank\" rel=\"noopener\">前端基础进阶（二）：执行上下文详细图解</a>）</p>\n<h2 id=\"bind-的独特性\"><a href=\"#bind-的独特性\" class=\"headerlink\" title=\"bind 的独特性\"></a>bind 的独特性</h2><p>通过上面的调用方式你可能发现了一些端倪，就是 bind 在调用之后还需要加一个“()”，这就是 call、apply 它们和 bind 的区别了：</p>\n<ul>\n<li>只传一个参数时，call 和 apply 都是对函数的直接调用</li>\n<li>而 bind 方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以</li>\n</ul>\n<p>也许你又有疑问了，一般我们的方法都会有参数的，如果有参数的话应该如何调用呢？我们再举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'asd'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">29</span> ,</span><br><span class=\"line\">  sayname: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i, j</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.name + <span class=\"string\">'是'</span> + <span class=\"keyword\">this</span>.age+i+j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 =&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'aaa'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">30</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.sayname.apply(obj2,\\[<span class=\"string\">'男'</span>,<span class=\"number\">180</span>\\]);</span><br><span class=\"line\">obj1.sayname.call(obj2,<span class=\"string\">'女'</span>,<span class=\"number\">167</span>);</span><br><span class=\"line\">obj1.sayname.bind(obj2,<span class=\"string\">'x'</span>,<span class=\"number\">150</span>)();</span><br><span class=\"line\">obj1.sayname.bind(obj2)(<span class=\"string\">'y'</span>,<span class=\"number\">110</span>);</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，我们可以直观的总结出如下几个知识点：</p>\n<ul>\n<li>call 后面的参数与 sayname 方法中是一一对应的</li>\n<li>apply 的第二个参数是一个数组，数组中的元素是和 sayname 方法中一一对应的（<strong>这其实就是和 call 最大的区别</strong>）</li>\n<li>bind 可以像 call 那样传参，但是由于 bind 返回的仍然是一个函数，还可以在调用的时候再进行传参</li>\n</ul>\n<h2 id=\"apply、call-的区别\"><a href=\"#apply、call-的区别\" class=\"headerlink\" title=\"apply、call 的区别\"></a>apply、call 的区别</h2><p>通过上面的栗子，我们可以看到，bind 和 apply、call 是有本质上的区别的，所以我们先讲 apply 和 call 这一对“近亲”。对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg1 + arg2);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过如下方式来调用：</p>\n<ul>\n<li>func.call(this, arg1, arg2);</li>\n<li>func.apply(this, [arg1, arg2]);</li>\n</ul>\n<p>其中 this 是你想指定的上下文，它可以是任何一个 JavaScript 对象，而不同点在于：call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 因此，如果你的参数明确知道数量的话，就用 call。而不确定的时候用 apply，然后把参数 push 进数组再传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数，所以也有人用一句话区分 apply 和 call：<code>foo.call(this, arg1, arg2, arg3) == foo.apply(this, arguments) == this.foo(arg1, arg2, arg3)</code></p>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><p>JS 中存在一种名为伪数组的对象结构，比较特别的是 arguments 对象，还有像调用 getElementsByTagName，document.childNodes 之类的，它们返回 NodeList 对象都属于<strong>伪数组（也有文章描述这类对象为“类数组对象”）</strong>，不能应用 Array 下的 push，pop 等方法。但是我们能够通过 Array.prototype.slice.call 将带有 length 属性的对象转换为真正的数组，这样 domNodes 就可以应用 Array 下的所有方法了。</p>\n<h2 id=\"一道面试题\"><a href=\"#一道面试题\" class=\"headerlink\" title=\"一道面试题\"></a>一道面试题</h2><p>可能你还是不太理解上面的“当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数”这句话，下面通过一道面试题，来更深入的理解 apply 和 call：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们定义一个log方法，让它可以代理console.log方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">msg</span>)　</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">1</span>);    <span class=\"comment\">//1</span></span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>上面定义的方法可以解决最基本的需求，但是有一个问题在于：当传入参数的个数是不确定的时候，上面的方法就失效了。这个时候，因为传入多少个参数是不确定的，所以使用 apply：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">log(<span class=\"number\">1</span>);    <span class=\"comment\">//1</span></span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">//1 2</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们又有一个需求，就是给每一个 log 信息添加一个 “(app)” 的前缀，比如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"string\">\"hello world\"</span>);    <span class=\"comment\">//(app)hello world</span></span><br></pre></td></tr></table></figure>\n<p>我们该如何实现呢？这个时候需要想到 arguments 参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法 unshift，像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  args.unshift(<span class=\"string\">'(app)'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"bind-详解\"><a href=\"#bind-详解\" class=\"headerlink\" title=\"bind 详解\"></a>bind 详解</h2><p>apply 和 call 就介绍完了，下面我们再介绍一下有些特殊的 bind。MDN 上对于 bind 的解释是：</p>\n<blockquote>\n<p>bind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n</blockquote>\n<p>我表示看完还是不懂，所以还是直接看实例来的痛快：在常见的单例模式中，通常我们会使用 _this, that, self 等保存 this，这样我们可以在改变了上下文之后继续引用到它。像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar : <span class=\"number\">1</span>,</span><br><span class=\"line\">    eventBind: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        $(<span class=\"string\">'.someClass'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(_this.bar);     <span class=\"comment\">//1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 Javascript 特有的机制，上下文环境在 eventBind: function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar : <span class=\"number\">1</span>,</span><br><span class=\"line\">    eventBind: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'.someClass'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.bar);      <span class=\"comment\">//1</span></span><br><span class=\"line\">        &#125;.bind(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码里，bind() 创建了一个函数，当这个 click 事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用 bind() 时传入的参数）。因此，这里我们传入想要的上下文 this (其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。</p>\n<h3 id=\"再来一个简单的栗子：\"><a href=\"#再来一个简单的栗子：\" class=\"headerlink\" title=\"再来一个简单的栗子：\"></a>再来一个简单的栗子：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo);</span><br><span class=\"line\">func(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。</p>\n<h3 id=\"连续-bind\"><a href=\"#连续-bind\" class=\"headerlink\" title=\"连续 bind()\"></a>连续 bind()</h3><p>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sed = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo).bind(sed);</span><br><span class=\"line\">func(); <span class=\"comment\">//?</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> fiv = &#123;</span><br><span class=\"line\">    x:<span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class=\"line\">func(); <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure>\n<p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在 Javascript 中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind(),故第二次以后的 bind 是无法生效的。</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h2><p>最近发现“总结一下”很好用，因为可以堂而皇之的给自己的文章增加很多篇幅，同时还可以显得高大上：</p>\n<ul>\n<li><strong>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</strong></li>\n<li><strong>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</strong></li>\n<li><strong>apply 、 call 、bind 三者都可以利用后续参数传参；</strong></li>\n<li><strong>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。</strong></li>\n</ul>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.cnblogs.com/coco1s/p/4833199.html\" target=\"_blank\" rel=\"noopener\">【优雅代码】深入浅出 妙用Javascript中apply、call、bind</a></li>\n<li><a href=\"http://www.jianshu.com/p/f17a7b5efc5d\" target=\"_blank\" rel=\"noopener\">javascript call apply bind this指向和区别</a></li>\n<li><a href=\"http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html\" target=\"_blank\" rel=\"noopener\">关于javascript中apply()和call()方法的区别</a></li>\n<li><a href=\"https://www.zhihu.com/question/20289071\" target=\"_blank\" rel=\"noopener\">如何理解和熟练运用js中的call及apply？</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply\" target=\"_blank\" rel=\"noopener\">What is the difference between call and apply?</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"}]},{"title":"JS中的一些小技巧，精妙且实用","slug":"JS中的一些小技巧，精妙且实用","date":"2017-04-13T01:33:29.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS中的一些小技巧，精妙且实用.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这里总结了我在项目中经常会用到的一些 JS 小技巧，同时参考了其他开发者对于 JS 小技巧的总结，从而形成了这篇文章，如果在日后我发现了更多的小技巧，我会及时更新</p>\n<h2 id=\"使用-操作符转换布尔值\"><a href=\"#使用-操作符转换布尔值\" class=\"headerlink\" title=\"使用 !! 操作符转换布尔值\"></a>使用 !! 操作符转换布尔值</h2><p>有时候我们需要对一个变量检查其是否存在或者检查值是否有一个有效值，如果存在就返回 true 值。为了做这样的验证，我们可以使用 !! 操作符来实现是非常的方便与简单。对于变量可以使用 !!variable 进行检测</p>\n<p><strong>只要变量的值为：0、null、” “、undefined 或者 NaN 都将返回的是 false，反之返回的是 true</strong>。</p>\n<h2 id=\"使用-“-”-或-“-“-转化数值\"><a href=\"#使用-“-”-或-“-“-转化数值\" class=\"headerlink\" title=\"使用 “+” 或 “-“ 转化数值\"></a>使用 “+” 或 “-“ 转化数值</h2><p>这个技巧非常有用，其非常简单，可以将字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回 NaN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">strNumber</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> +strNumber;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"1234\"</span>)); <span class=\"comment\">// 1234</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"ACB\"</span>)); <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"检测对象中属性\"><a href=\"#检测对象中属性\" class=\"headerlink\" title=\"检测对象中属性\"></a>检测对象中属性</h2><p>当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用 document.querySelector() 来选择一个 id，并且让它能兼容 IE6 浏览器，但是在 IE6 浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">'querySelector'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#id\"</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，如果 document 不存在 querySelector 函数，那么就会调用 docuemnt.getElementById(“id”)。</p>\n<h2 id=\"数组截断\"><a href=\"#数组截断\" class=\"headerlink\" title=\"数组截断\"></a>数组截断</h2><p>这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有 10 个元素，但你只想只要前五个元素，那么你可以通过 array.length = 5 来截断数组。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 6</span></span><br><span class=\"line\">array.length = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array); <span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"合并数组\"><a href=\"#合并数组\" class=\"headerlink\" title=\"合并数组\"></a>合并数组</h2><p>如果你要合并两个数组，一般情况之下你都会使用 Array.concat() 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1.concat(array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure>\n<p>然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之下，可以使用 Array.pus().apply(arr1,arr2) 来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1.push.apply(array1, array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"将-NodeList-转换成数组\"><a href=\"#将-NodeList-转换成数组\" class=\"headerlink\" title=\"将 NodeList 转换成数组\"></a>将 NodeList 转换成数组</h2><p>如果你运行 document.querySelectorAll(“p”) 函数时，它可能返回 DOM 元素的数组，也就是 NodeList 对象。但这个对象不具有数组的函数功能，比如 sort()、reduce()、map()、filter() 等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用 <strong>[].slice.call(elements)</strong> 来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elements = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"p\"</span>); <span class=\"comment\">// NodeListvar </span></span><br><span class=\"line\">arrayElements = [].slice.call(elements); <span class=\"comment\">// Now the NodeList is an array</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayElements = <span class=\"built_in\">Array</span>.from(elements); <span class=\"comment\">// This is another way of converting NodeList to Array</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"数组元素随机排序\"><a href=\"#数组元素随机排序\" class=\"headerlink\" title=\"数组元素随机排序\"></a>数组元素随机排序</h2><p>利用随机数模拟随机排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(list.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">Math</span>.random() - <span class=\"number\">0.5</span>&#125;)); <span class=\"comment\">// [2,1,3]</span></span><br></pre></td></tr></table></figure>\n<p>其实利用 Math.random() 得到的结果并不是真正的随机排序，参见我的另外一篇文章：<a href=\"/20170322/summary-of-array-method-in-js.html\">JS中数组方法总结</a>，这篇文章中的数组随机排序方法是比较好的一个方法</p>\n<h2 id=\"从数组中获取一个随机项\"><a href=\"#从数组中获取一个随机项\" class=\"headerlink\" title=\"从数组中获取一个随机项\"></a>从数组中获取一个随机项</h2><p>很难说这是一个技巧，如果你的前端水平还算可以的话，这个应该难不倒你：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [<span class=\"number\">12</span>, <span class=\"number\">548</span> , <span class=\"string\">'a'</span> , <span class=\"number\">2</span> , <span class=\"number\">5478</span> , <span class=\"string\">'foo'</span> , <span class=\"number\">8852</span>, , <span class=\"string\">'Doe'</span> , <span class=\"number\">2145</span> , <span class=\"number\">119</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> randomItem = items[<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * items.length)];</span><br></pre></td></tr></table></figure>\n<h2 id=\"在特定范围内获取一个随机数\"><a href=\"#在特定范围内获取一个随机数\" class=\"headerlink\" title=\"在特定范围内获取一个随机数\"></a>在特定范围内获取一个随机数</h2><p>这个在生成测试数据的时候非常有用，比如一个在最小最大值之间的一个随机薪水值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min + <span class=\"number\">1</span>)) + min;</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成一个随机的数字字母字符串\"><a href=\"#生成一个随机的数字字母字符串\" class=\"headerlink\" title=\"生成一个随机的数字字母字符串\"></a>生成一个随机的数字字母字符串</h2><p>有时候，我们需要给某个元素赋一个唯一的 id，这个时候随机字符串就可以派上用场了，在这个技巧里，你可以见识到 js 中的 toString() 方法是多么的强大；Math.random() 生成 0 到 1 之间的随机数，number.toString(36) 是将这个数字转换成36进制（0-9，a-z），最后 substr 去掉前面的 “0.” 字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateRandomAlphaNum</span>(<span class=\"params\">len</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rdmstring = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ;rdmString.length &lt; len; ) &#123;</span><br><span class=\"line\">        rdmString += <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substr(<span class=\"number\">2</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rdmString.substr(<span class=\"number\">0</span>, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"更快的四舍五入\"><a href=\"#更快的四舍五入\" class=\"headerlink\" title=\"更快的四舍五入\"></a>更快的四舍五入</h2><p>见到过双波浪线 “~~” 操作符吗？它有时也被称为 <code>double NOT</code> 运算符。你可以更快的使用它来作为 Math.floor() 替代品。为什么呢？单位移 ~ 将 32 位转换输入 -(输入+1)，因此双位移将输入转换为 -(-(输入+1))，这是个趋于 0 的伟大的工具。对于输入的数字，它将模仿 Math.ceil() 取负值和 Math.floor() 取正值。如果执行失败，则返回 0，这可能在用来代替 Math.floor() 失败时返回一个 NaN 的时候发挥作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单位移</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~<span class=\"number\">1337</span>) <span class=\"comment\">// -1338</span></span><br><span class=\"line\"><span class=\"comment\">// 双位移</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"number\">47.11</span>) <span class=\"comment\">// -&gt; 47</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"number\">-12.88</span>) <span class=\"comment\">// -&gt; -12</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"number\">1.9999</span>) <span class=\"comment\">// -&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"number\">3</span>) <span class=\"comment\">// -&gt; 3</span></span><br><span class=\"line\"><span class=\"comment\">//失败的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~[]) <span class=\"comment\">// -&gt; 0 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"literal\">NaN</span>) <span class=\"comment\">// -&gt; 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~<span class=\"literal\">null</span>) <span class=\"comment\">// -&gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">//大于32位整数则失败</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(~~(<span class=\"number\">2147483647</span> + <span class=\"number\">1</span>) === (<span class=\"number\">2147483647</span> + <span class=\"number\">1</span>)) <span class=\"comment\">// -&gt; 0</span></span><br></pre></td></tr></table></figure>\n<p>虽然 ~~ 可能有更好的表现，不过为了可读性，还是推荐使用 Math.floor()。</p>\n<h2 id=\"测量一个-JavaScript-代码块的性能\"><a href=\"#测量一个-JavaScript-代码块的性能\" class=\"headerlink\" title=\"测量一个 JavaScript 代码块的性能\"></a>测量一个 JavaScript 代码块的性能</h2><p>快速测量一个 JavaScript 块的性能，我们可以使用控制台的功能像 console.time(label) 和console.timeEnd(label)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">\"Array initialize\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">100</span>),</span><br><span class=\"line\">    len = arr.length,</span><br><span class=\"line\">    i;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    arr[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"Array initialize\"</span>); <span class=\"comment\">// 输出: Array initialize: 0.711ms</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"自调用函数\"><a href=\"#自调用函数\" class=\"headerlink\" title=\"自调用函数\"></a>自调用函数</h2><p>这个经常被称为自调用匿名函数（Self-Invoked Anonymous Function）或者即时调用函数表达式（IIFE-Immediately Invoked Function Expression)。这是一个在创建后立即自动执行的函数，可以用于数据回填以及窗口 resize() 事件，我在项目中屡试不爽，示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// some private code that will be executed automatically</span></span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = a + b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;)(<span class=\"number\">10</span>, <span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现-String-的-trim-函数\"><a href=\"#实现-String-的-trim-函数\" class=\"headerlink\" title=\"实现 String 的 trim 函数\"></a>实现 String 的 trim 函数</h2><p>在 Java、C#、PHP 和很多其他语言中都有一个经典的 trim 函数，用来去除字符串中首尾的空格符，而在 JavaScript 中并没有，所以我们需要在 String 对象上加上这个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.trim = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.replace(<span class=\"regexp\">/^\\s+|\\s+$/g</span>, <span class=\"string\">\"\"</span>);&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"将-arguments-对象转换成一个数组\"><a href=\"#将-arguments-对象转换成一个数组\" class=\"headerlink\" title=\"将 arguments 对象转换成一个数组\"></a>将 arguments 对象转换成一个数组</h2><p>arguments 对象是一个类数组对象，但不是一个真正的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> argArray = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"验证是否是数字\"><a href=\"#验证是否是数字\" class=\"headerlink\" title=\"验证是否是数字\"></a>验证是否是数字</h2><p>这是一个可以称得上技巧的 js 方法，当然你也可以用正则表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"built_in\">isNaN</span>(<span class=\"built_in\">parseFloat</span>(n)) &amp;&amp; <span class=\"built_in\">isFinite</span>(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"验证是否是数组\"><a href=\"#验证是否是数组\" class=\"headerlink\" title=\"验证是否是数组\"></a>验证是否是数组</h3><p>call() 这个方法在 js 里如同神技，而这里也是它的一个应用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj) === <span class=\"string\">'[object Array]'</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不要使用-delete-来删除一个数组中的项\"><a href=\"#不要使用-delete-来删除一个数组中的项\" class=\"headerlink\" title=\"不要使用 delete 来删除一个数组中的项\"></a>不要使用 delete 来删除一个数组中的项</h2><p>使用 splice 而不要使用 delete 来删除数组中的某个项。使用 delete 只是用 undefined 来替换掉原有的项，并不是真正的从数组中删除。 不要使用这种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [<span class=\"number\">12</span>, <span class=\"number\">548</span>, <span class=\"string\">'a'</span>, <span class=\"number\">2</span>, <span class=\"number\">5478</span>, <span class=\"string\">'foo'</span>, <span class=\"number\">8852</span>, , <span class=\"string\">'Doe'</span>, <span class=\"number\">2154</span>, <span class=\"number\">119</span>];</span><br><span class=\"line\">items.length; <span class=\"comment\">// return 11</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> items[<span class=\"number\">3</span>]; <span class=\"comment\">// return true</span></span><br><span class=\"line\">items.length; <span class=\"comment\">// return 11</span></span><br><span class=\"line\"><span class=\"comment\">/* items will be equal to [12, 548, \"a\", undefined × 1, 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119] */</span></span><br></pre></td></tr></table></figure>\n<p>而使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [<span class=\"number\">12</span>, <span class=\"number\">548</span>, <span class=\"string\">'a'</span>, <span class=\"number\">2</span>, <span class=\"number\">5478</span>, <span class=\"string\">'foo'</span>, <span class=\"number\">8852</span>, , <span class=\"string\">'Doe'</span>, <span class=\"number\">2154</span>, <span class=\"number\">119</span>];</span><br><span class=\"line\">items.length; <span class=\"comment\">// return 11</span></span><br><span class=\"line\">items.splice(<span class=\"number\">3</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">items.length; <span class=\"comment\">// return 10</span></span><br><span class=\"line\"><span class=\"comment\">/* items will be equal to [12, 548, \"a\", 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119] */</span></span><br></pre></td></tr></table></figure>\n<p>delete 方法应该被用来删除一个对象的某个属性。</p>\n<h2 id=\"使用逻辑-AND-OR-做条件判断\"><a href=\"#使用逻辑-AND-OR-做条件判断\" class=\"headerlink\" title=\"使用逻辑 AND / OR 做条件判断\"></a>使用逻辑 AND / OR 做条件判断</h2><p>这个技巧在一定程度上降低了可读性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">10</span>;</span><br><span class=\"line\">foo == <span class=\"number\">10</span> &amp;&amp; doSomething(); <span class=\"comment\">// 等价于 if (foo == 10) doSomething();</span></span><br><span class=\"line\">foo == <span class=\"number\">5</span> || doSomething(); <span class=\"comment\">// 等价于 if (foo != 5) doSomething();</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用逻辑-OR-为函数参数设置默认值\"><a href=\"#使用逻辑-OR-为函数参数设置默认值\" class=\"headerlink\" title=\"使用逻辑 OR 为函数参数设置默认值\"></a>使用逻辑 OR 为函数参数设置默认值</h2><p>这个技巧实用到爆，尤其是开发插件的时候</p>\n<blockquote>\n<p>不过 ES6 语法已经支持默认值了</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">arg1</span>) </span>&#123;</span><br><span class=\"line\">    Arg1 = arg1 || <span class=\"number\">10</span>; <span class=\"comment\">// 如果 arg1 没有被设置的话，Arg1 将被默认设成 10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"浮点数问题\"><a href=\"#浮点数问题\" class=\"headerlink\" title=\"浮点数问题\"></a>浮点数问题</h2><p>这是一个需要注意的地方，但是计算机专业的人应该早就知道了吧</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> === <span class=\"number\">0.3</span> <span class=\"comment\">// is false</span></span><br><span class=\"line\"><span class=\"number\">9007199254740992</span> + <span class=\"number\">1</span> <span class=\"comment\">// is equal to 9007199254740992</span></span><br><span class=\"line\"><span class=\"number\">9007199254740992</span> + <span class=\"number\">2</span> <span class=\"comment\">// is equal to 9007199254740994</span></span><br></pre></td></tr></table></figure>\n<p>为什么会这样？ 0.1 + 0.2 等于 0.30000000000000004。这是因为，所有的 JavaScript 数字在内部都是以 64 位二进制表示的浮点数，符合 IEEE 754 标准。更多的介绍，可以阅读<a href=\"http://www.2ality.com/2012/04/number-encoding.html\" target=\"_blank\" rel=\"noopener\">这篇博文</a>。你可以使用 toFixed() 和 toPrecision() 方法解决这个问题。</p>\n<h2 id=\"使用-for-in-遍历一个对象内部属性的时候注意检查属性\"><a href=\"#使用-for-in-遍历一个对象内部属性的时候注意检查属性\" class=\"headerlink\" title=\"使用 for-in 遍历一个对象内部属性的时候注意检查属性\"></a>使用 for-in 遍历一个对象内部属性的时候注意检查属性</h2><p>下面的代码片段能够避免在遍历一个对象属性的时候访问原型的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> object) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (object.hasOwnProperty(name)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something with name</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"isFinite\"><a href=\"#isFinite\" class=\"headerlink\" title=\"isFinite()\"></a>isFinite()</h2><p>在使用这个方法之前需要验证一下参数，因为 null 的存在</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">0</span>/<span class=\"number\">0</span>) ; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"foo\"</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"10\"</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">10</span>);   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(undifined);  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>();   <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"literal\">null</span>);  <span class=\"comment\">// true  !!!</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在调用-setTimeout-和-setInterval-的时候传入函数，而不是字符串\"><a href=\"#在调用-setTimeout-和-setInterval-的时候传入函数，而不是字符串\" class=\"headerlink\" title=\"在调用 setTimeout() 和 setInterval() 的时候传入函数，而不是字符串\"></a>在调用 setTimeout() 和 setInterval() 的时候传入函数，而不是字符串</h2><p>如果你将字符串传递给 setTimeout() 或者 setInterval()，这个字符串将被如使用 eval 一样被解析，这个是非常耗时的 不要使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(<span class=\"string\">'doSomethingPeriodically()'</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">setTimeOut(<span class=\"string\">'doSomethingAfterFiveSeconds()'</span>, <span class=\"number\">5000</span>)</span><br></pre></td></tr></table></figure>\n<p>而用:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(doSomethingPeriodically, <span class=\"number\">1000</span>);</span><br><span class=\"line\">setTimeOut(doSomethingAfterFiveSeconds, <span class=\"number\">5000</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"用-JavaScript-获取伪元素-pseudo-element-属性\"><a href=\"#用-JavaScript-获取伪元素-pseudo-element-属性\" class=\"headerlink\" title=\"用 JavaScript 获取伪元素 (pseudo-element) 属性\"></a>用 JavaScript 获取伪元素 (pseudo-element) 属性</h2><p>大家都知道如何通过一个元素的 style 属性获取它的 CSS 样式值，但能获取伪元素 (pseudo-element) 的属性值吗？可以的，使用 JavaScript 也可以访问页面中的伪元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get the color value of .element:before</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"built_in\">window</span>.getComputedStyle(</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.element'</span>), <span class=\"string\">':before'</span></span><br><span class=\"line\">).getPropertyValue(<span class=\"string\">'color'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the content value of .element:before</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"built_in\">window</span>.getComputedStyle(</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.element'</span>), <span class=\"string\">':before'</span></span><br><span class=\"line\">).getPropertyValue(<span class=\"string\">'content'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"classList-API\"><a href=\"#classList-API\" class=\"headerlink\" title=\"classList API\"></a>classList API</h2><p>很多的 JavaScript 工具库里都有 <code>addClass</code>，<code>removeClass</code> 和 <code>toggleClass</code> 等方法。为了对老式浏览器的兼容，这些类库采用的方法都是先搜索元素的 <code>className</code>，追加和删除这个类，然后更新 <code>className</code>。其实有一个 API 提供了添加，删除和反转 CSS 类属性的方法，叫做 classList：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDiv.classList.add(<span class=\"string\">'myCssClass'</span>); <span class=\"comment\">// Adds a class</span></span><br><span class=\"line\">myDiv.classList.remove(<span class=\"string\">'myCssClass'</span>); <span class=\"comment\">// Removes a class</span></span><br><span class=\"line\">myDiv.classList.toggle(<span class=\"string\">'myCssClass'</span>); <span class=\"comment\">// Toggles a class</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"直接对样式表进行添加和删除样式规则\"><a href=\"#直接对样式表进行添加和删除样式规则\" class=\"headerlink\" title=\"直接对样式表进行添加和删除样式规则\"></a>直接对样式表进行添加和删除样式规则</h2><p>我们都非常熟悉使用 <code>element.style.propertyName</code> 来修改样式，使用 JavaScript 能帮助我们做到这些，但你知道如何新增或修一个现有的 CSS 样式规则吗？其实非常的简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addCSSRule</span>(<span class=\"params\">sheet, selector, rules, index</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sheet.insertRule) &#123;</span><br><span class=\"line\">\t\tsheet.insertRule(selector + <span class=\"string\">\"&#123;\"</span> + rules + <span class=\"string\">\"&#125;\"</span>, index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tsheet.addRule(selector, rules, index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Use it!</span></span><br><span class=\"line\">addCSSRule(<span class=\"built_in\">document</span>.styleSheets[<span class=\"number\">0</span>], <span class=\"string\">\"header\"</span>, <span class=\"string\">\"float: left\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"加载-CSS-文件\"><a href=\"#加载-CSS-文件\" class=\"headerlink\" title=\"加载 CSS 文件\"></a>加载 CSS 文件</h2><p>延迟加载图片、JSON、脚本等是用来加快页面显示速度的好方法。我们可以使用 curl.js 等这样 JavaScript 加载器来延迟加载这些外部资源，可你知道 CSS 样式表也可以延迟加载吗，而且在加载成功后回调函数会给予通知。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl(</span><br><span class=\"line\">\t[</span><br><span class=\"line\">\t\t<span class=\"string\">\"namespace/MyWidget\"</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"css!namespace/resources/MyWidget.css\"</span></span><br><span class=\"line\">\t], </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">MyWidget</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 你可以对MyWidget进行操作</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 这里没有对这个CSS文件引用，因为不需要;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 我们只需要它已经加载到页面上了</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"CSS-鼠标指针事件\"><a href=\"#CSS-鼠标指针事件\" class=\"headerlink\" title=\"CSS 鼠标指针事件\"></a>CSS 鼠标指针事件</h2><p>CSS 鼠标指针事件 <code>pointer-events</code> 属性非常的有趣，它的功效非常像 JavaScript，当你把这个属性设置为 none 时，它能有效的阻止禁止这个元素，你也许会说“这又如何？”，但事实上，它是禁止了这个元素上的任何 JavaScript 事件或回调函数！</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.disabled</span> &#123; <span class=\"attribute\">pointer-events</span>: none; &#125;</span><br></pre></td></tr></table></figure>\n<p>点击这个元素，你会发现任何你放置在这个元素上的监听器都不会触发任何事件。一个神奇的功能——你不再需要为了防止某个事件会被触发而去检查某个 css 类是否存在。</p>\n<h2 id=\"拓展阅读\"><a href=\"#拓展阅读\" class=\"headerlink\" title=\"拓展阅读\"></a>拓展阅读</h2><ul>\n<li><a href=\"http://blog.sae.sina.com.cn/archives/2291\" target=\"_blank\" rel=\"noopener\">45个实用的JavaScript技巧、窍门和最佳实践</a></li>\n<li><a href=\"http://blog.sae.sina.com.cn/archives/5569\" target=\"_blank\" rel=\"noopener\">5种你未必知道的JavaScript和CSS交互的方法</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"JS","path":"api/tags/JS.json"}]},{"title":"JS中的对象系统","slug":"JS中的对象系统","date":"2017-08-07T02:10:23.000Z","updated":"2019-02-02T10:19:58.042Z","comments":true,"path":"api/articles/JS中的对象系统.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_111.png","content":"<p>转载自<a href=\"http://www.jianshu.com/p/d0930dc0f95d\" target=\"_blank\" rel=\"noopener\">简书-浅析JavaScript的对象系统</a> 首先，你肯定在不少地方看到过这句话：</p>\n<blockquote>\n<p>JavaScript 中一切皆对象</p>\n</blockquote>\n<p>这句话是很有道理的（废话，要不然能在不少地方都看到吗。。），你可能没有意识到，在 JavaScript（以下简称 JS）中，你声明一个变量 <code>let a = 3</code>，此时的 a 其实是一个对象，因为你可以将它当做对象一样去调用 <code>toString()</code> 方法，这其中的答案都在 JS 对象系统中，请看下面这张图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_111.png\" alt=\"\" width=\"600\"></div>\n\n<p>下面我们就结合这张图来分析一下 JS 对象系统的结构</p>\n<h2 id=\"本地对象\"><a href=\"#本地对象\" class=\"headerlink\" title=\"本地对象\"></a>本地对象</h2><p>“本地对象”的说法可能比较陌生，也可以叫做“原生对象”、“内置对象”、“内建对象”，但其实指的都是 native object。ECMA-262 对于 native object 的定义为：</p>\n<blockquote>\n<p>独立于宿主环境的 ECMAScript 实现提供的对象</p>\n</blockquote>\n<p>我们知道，“宿主”一般指浏览器，而“独立于宿主环境”，也就是说与浏览器环境不相关，这就是说：native object 与浏览器不相关，只要这个浏览器按照 ECMAScript 规范实现了JS，那就必然实现了规范中的所有 native object。换句话说就是：<strong>本地对象（native object）是语言本身实现和提供的对象，和语言运行在哪个环境无关</strong>。也就是说，不管你的JS代码在哪里跑，你都可以 <code>new</code> 出 native object 并使用它。照此理解，我觉得其实把 native object 翻译成“原生对象”最合意。</p>\n<h3 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h3><blockquote>\n<p>到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且，Object 也是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。——《JavaScript高级程序设计（第3版）》</p>\n</blockquote>\n<p>“万物从无到有”，JS 中的大多数引用类型值都是 Object 类型的实例，而 Object 的原型就是 null 了（可以在 chrome 控制台中打印 Object.prototype.__proto__），Object 是所有其他对象类型的基础类型，提供了 toString() 等基础方法</p>\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><p>数组类型</p>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>日期类型</p>\n<h3 id=\"RegExp\"><a href=\"#RegExp\" class=\"headerlink\" title=\"RegExp\"></a>RegExp</h3><p>正则类型</p>\n<h3 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h3><blockquote>\n<p>说起来 ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。——《J3》</p>\n</blockquote>\n<p>没错，请注意大小写，Function 是一种对象类型，而 function 则是一个对象实例，见如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>() <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>);    <span class=\"comment\">//true(构造函数Function()是Function类型的实例)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>() <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);    <span class=\"comment\">//true(构造函数Function()当然也是Object类型的实例)</span></span><br></pre></td></tr></table></figure>\n<p>事实上，任何一个函数都是函数对象的实例，而函数类型本身就是一种对象类型，所以：<strong>函数也是对象</strong>。</p>\n<h3 id=\"Error-等各种错误类对象\"><a href=\"#Error-等各种错误类对象\" class=\"headerlink\" title=\"Error 等各种错误类对象\"></a>Error 等各种错误类对象</h3><p>Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 等错误类型的对象。</p>\n<h3 id=\"String、Number、Boolean\"><a href=\"#String、Number、Boolean\" class=\"headerlink\" title=\"String、Number、Boolean\"></a>String、Number、Boolean</h3><p>之所以将这三类放到一起，是因为它们属于JS中的基本数据类型，但其实它们也是一种对象类型，这样你才能像使用对象一般操作字符串、数值、布尔值，见下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">str = str.substr(<span class=\"number\">0</span>,<span class=\"number\">5</span>);    <span class=\"comment\">//调用substr()方法截取字符串，我是字符串，但实际上是一个对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str);    <span class=\"comment\">//'Hello'</span></span><br></pre></td></tr></table></figure>\n<p>所以，当我们通过变量声明的方式去声明一个字符串、数字、布尔值的时候，其实后台帮我们创建了一个对象：</p>\n<blockquote>\n<p>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据 ——《J3》</p>\n</blockquote>\n<p>书上一语道明。注意一下这句话中的“读取”和“对应”两个词。“读取”是指进入读取模式，即从内存中去读取这个字符串值的时候；“对应”指的是基本类型值是哪种类型，后台自动给你创建的基本包装类型就是哪种对应的类型，比如这里的基本类型值是 <code>String</code> 类型，那后台创建的基本包装类型也就是 <code>String</code> 包装类型。 因为这一机制，上面代码的实际执行情况其实是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\"><span class=\"comment\">//str = str.substr(0,5);    //(str进入读取模式，准备创建基本包装类型对象)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'Hello World'</span>);</span><br><span class=\"line\">str = _str.substr(<span class=\"number\">0</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">_str = <span class=\"literal\">null</span>;    <span class=\"comment\">//使用完后台会立即将该包装对象销毁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str);    <span class=\"comment\">//'Hello'</span></span><br></pre></td></tr></table></figure>\n<p>这里只展示了 String 包装类型，其实 Number 和 Boolean 也是完全一样的原理</p>\n<h3 id=\"内置对象（单体内置对象）（built-in-object）\"><a href=\"#内置对象（单体内置对象）（built-in-object）\" class=\"headerlink\" title=\"内置对象（单体内置对象）（built-in object）\"></a>内置对象（单体内置对象）（built-in object）</h3><p>这个叫 built-in object，上面那个叫 native object，那么它们有什么区别呢，还是看一下《J3》这本书中的解释吧：</p>\n<blockquote>\n<p>ECMA-262 对内置对象的定义是：“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。——《J3》</p>\n</blockquote>\n<p>这是 ECMA-262 对于 built-in object 的定义。对比 native object 的定义：“独立于宿主环境的 ECMAScript 实现提供的对象”，可以看出，built-in object 是更加特殊的 native object，built-in object 属于 native object。ECMA-262 定义了两种 built-in object：Global 对象、Math 对象。</p>\n<h4 id=\"Global-对象\"><a href=\"#Global-对象\" class=\"headerlink\" title=\"Global 对象\"></a>Global 对象</h4><p>事实上，js 中并不存在所谓的全局变量以及完全独立的函数。没错，你定义的所有全局变量其实都是 Global 对象的属性，<strong>你在全局作用域下定义的所有函数其实都是 Global 对象的方法</strong>。</p>\n<blockquote>\n<p>ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象” 来定义的。换句话说，不属于任何其他对象的属性和方法，终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。——《J3》</p>\n</blockquote>\n<p>parseInt()、eval()、encodeURIComponent() 这些函数实际上都是 Global 对象的方法，在使用这些方法的时候无需通过对象去调用，直接就可以使用。引文说过：“这些对象在 ECMAScript 程序执行之前就已经存在了。”这也算 build-in object 的一个特别之处，《J3》将 build-in object 定义为“单体内置对象”，这个“单体”是否就是指无需手动实例化这一点？ Global 对象的所有属性如下表：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_103.png\" alt=\"\" width=\"400\"></div>\n\n<p>好吧，特殊值 undefined 居然是 Global 对象的一个属性值 - -。乍看之下可能会有点诧异，不过仔细想想，我们之所以说 JavaScript 中一切皆对象是有原因的，你看，就连 undefined 都是对象的属性值。从表中还可以看到，所有原生引用类型的构造函数也都是 Global 对象的属性。这怎么理解？其实也很好理解，比如说当你想要创建一个日期类型的变量时，直接上构造函数 <code>var date = new Date();</code> 就可以了，可是你想过没有，Date() 构造函数本身是一个函数，而前面我们说过，JS并不存在完全独立的函数，任何函数其实都是挂在某个对象下的方法，哪怕它是一个构造函数。而这些原生构造函数，其“挂载”的对象正是 Global 对象。 介绍了这么多关于 Global 对象的内容，是不是还是不清楚它是个什么玩意儿？这是因为我们在浏览器中并不能直接访问这个对象。好在浏览器为我们实现了一个包含了 Global 对象的 window 对象。</p>\n<blockquote>\n<p>ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性。——《J3》</p>\n</blockquote>\n<p>window 对象包含了 Global 对象的所有内容，同时扩展了大量自身需要的属性和方法（比如常用的 <code>alert()</code>）。因此，在浏览器中我们可以通过 window 对象随意访问上述的属性和方法。请看下面代码并加以理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">window</span>.Date();    <span class=\"comment\">//window是对Global对象的扩展实现，构造函数Date()确实是挂在window上面的</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date);    <span class=\"comment\">//Mon Aug 07 2017 10:07:28 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>\n<p>其实你也可以在控制台中打印一下 window，你就可以发现它确实包含了上述属性和构造函数</p>\n<h4 id=\"Math-对象\"><a href=\"#Math-对象\" class=\"headerlink\" title=\"Math     对象\"></a>Math     对象</h4><p>Math 对象是一个保存着必要的数学操作的 build-in object。里面保存着常量 e、圆周率 π 等的值作为属性，同时提供了取整 Math.floor()、取随机数 Math.random()、求平方根等等数学方法。和 Global 对象一样，这些属性和方法都可以在任何时候任何地方直接访问和调用，只不过其形式统一为：Math.***。</p>\n<h2 id=\"宿主对象\"><a href=\"#宿主对象\" class=\"headerlink\" title=\"宿主对象\"></a>宿主对象</h2><p>宿主对象是指宿主环境所实现和提供的对象。所有非本地对象（native object）都是宿主对象。我之所以在结构图中把自定义对象挂到了宿主对象下正是基于此，不过这并非定死的，你若将自定义对象拎出来和本地对象、宿主对象并列放也并非不可。 <strong>所谓宿主，就是指 JS 代码所在的运行环境</strong>。对于浏览器环境而言，我们显示一个页面需要 HTML，所以浏览器实现了 DOM 对象 —— window.document；我们还需要浏览器本身给我们提供一些必要的东西，比如 URL 地址相关的 location、设备屏幕相关的 screen 等，所以浏览器又为我们提供了 BOM 对象 —— window。这些对象，就是 host object。等等，怎么 window 对象又出场了？上面不是说过了，window 对象是浏览器对 Global 对象的扩展实现，是 Global 对象的超集，那这玩意儿究竟该挂到 build-in object 上，还是宿主对象下的 BOM 上？答案当然是后者。可以明确的是，window 对象本就是浏览器所实现的，那它当然属于浏览器对象模型（BOM）了！只不过，window 把 ECMAScript 规定的 Global 对象也给一并实现了而已。还有，DOM 对象即是 window.document，而 window.document 就是 DOM 的根节点，从这点来讲，我们可以理解为 BOM 包含了 DOM。 如此，我们终于找到最终对象了 - -，它正是 BOM —— window。你几乎可以在这个对象中找到一切。全局变量、自定义对象、JSON 对象（ECMA262-5 引入为规范）、Math 对象、原生构造函数、Global 的东西。。。 万物合一，世界清静了。 最后，可以把最开始给的图修正更新一下了：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_112.png\" alt=\"\" width=\"600\"></div>\n\n<p>从图上可以看到多了一个 JSON 对象，原因是 ECMA262-5 已经将 JSON 对象纳 入native object 了。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"对象","path":"api/tags/对象.json"}]},{"title":"JS实现复杂数据结构","slug":"JS实现复杂数据结构","date":"2017-03-26T04:51:34.000Z","updated":"2019-02-02T10:19:58.046Z","comments":true,"path":"api/articles/JS实现复杂数据结构.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"一、哈希表\"><a href=\"#一、哈希表\" class=\"headerlink\" title=\"一、哈希表\"></a>一、哈希表</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>javascript 里面是没有哈希表的，而在 java、C#、C++ 中会经常用到这一种数据结构，同时在刷 Leetcode 过程中也会经常用到。细细看来，其实 javascript 的 object 的属性与哈希表非常类似。我们只需要在其基础上封装一些 HashTable 的函数，就能够得到一个精简版的哈希表。</p>\n<h3 id=\"加入函数\"><a href=\"#加入函数\" class=\"headerlink\" title=\"加入函数\"></a>加入函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add(key,value)</td>\n<td>添加项</td>\n<td>无</td>\n</tr>\n<tr>\n<td>getValue(key)</td>\n<td>根据key取值</td>\n<td>object</td>\n</tr>\n<tr>\n<td>remove(key)</td>\n<td>根据key删除一项</td>\n<td>无</td>\n</tr>\n<tr>\n<td>containsKey(key)</td>\n<td>是否包含某个key</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>containsValue(value)</td>\n<td>是否包含某个值</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>getValues()</td>\n<td>获取所有的值的数组</td>\n<td>array</td>\n</tr>\n<tr>\n<td>getKeys()</td>\n<td>获取所有的key的数组</td>\n<td>array</td>\n</tr>\n<tr>\n<td>getSize()</td>\n<td>获取项总数</td>\n<td>int</td>\n</tr>\n<tr>\n<td>clear()</td>\n<td>清空哈希表</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HashTable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> entry = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.containsKey(key)) &#123;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        entry[key] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.containsKey(key) ? entry[key] : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.containsKey(key) &amp;&amp; (<span class=\"keyword\">delete</span> entry[key])) &#123;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.containsKey = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key <span class=\"keyword\">in</span> entry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.containsValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> entry) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry[prop] == value) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getValues = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> values = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> entry) &#123;</span><br><span class=\"line\">            values.push(entry[prop]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getKeys = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> keys = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> entry) &#123;</span><br><span class=\"line\">            keys.push(prop);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getSize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        entry = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> manHT = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\">manHT.add(<span class=\"string\">\"p1\"</span>,<span class=\"string\">\"刘备\"</span>);</span><br><span class=\"line\">manHT.add(<span class=\"string\">\"p2\"</span>,<span class=\"string\">\"关羽\"</span>);</span><br><span class=\"line\">$(<span class=\"string\">\"#div1\"</span>).text(manHT.getValue(<span class=\"string\">\"p1\"</span>));</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"http://www.cnblogs.com/kissdodog/p/4666352.html\" target=\"_blank\" rel=\"noopener\">javascript 实现HashTable(哈希表)</a></li>\n</ul>\n<h2 id=\"二、栈\"><a href=\"#二、栈\" class=\"headerlink\" title=\"二、栈\"></a>二、栈</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>栈是一种遵从后进先出原则(LIFO，全称为 Last In First Out)的有序集合。栈顶永远是最新的元素。</p>\n<h3 id=\"加入函数-1\"><a href=\"#加入函数-1\" class=\"headerlink\" title=\"加入函数\"></a>加入函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>push(element(s))</td>\n<td>添加几个元素到栈顶</td>\n<td>无</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>移除并返回栈顶元素</td>\n<td>object</td>\n</tr>\n<tr>\n<td>peek()</td>\n<td>返回栈顶元素</td>\n<td>object</td>\n</tr>\n<tr>\n<td>isAmpty</td>\n<td>检查栈是否为空</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>移除栈中所有元素</td>\n<td>无</td>\n</tr>\n<tr>\n<td>size</td>\n<td>返回栈中元素个数</td>\n<td>int</td>\n</tr>\n<tr>\n<td>print</td>\n<td>以字符串显示栈中所有内容</td>\n<td>string</td>\n</tr>\n<tr>\n<td>top</td>\n<td>记录栈顶位置</td>\n<td>int</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.dataStore = [];<span class=\"comment\">//保存栈内元素  </span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.top = <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.push=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;  </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.dataStore[<span class=\"keyword\">this</span>.top++] = element;<span class=\"comment\">//添加一个元素并将top+1  </span></span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.peek=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataStore[<span class=\"keyword\">this</span>.top<span class=\"number\">-1</span>];<span class=\"comment\">//返回栈顶元素  </span></span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pop=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataStore[--<span class=\"keyword\">this</span>.top];<span class=\"comment\">//返回栈顶元素并将top-1  </span></span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.clear=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.top = <span class=\"number\">0</span>;<span class=\"comment\">//将top归0     </span></span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.size=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.top;<span class=\"comment\">//返回栈内的元素个数  </span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isAmpty = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataStore.length === <span class=\"number\">0</span>;<span class=\"comment\">//确定栈是否为空</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.dataStore.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-1\"><a href=\"#使用示例-1\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lk=<span class=\"keyword\">new</span> Stack();  </span><br><span class=\"line\">lk.push(<span class=\"string\">\"likeke\"</span>);  </span><br><span class=\"line\">lk.push(<span class=\"string\">\"zhangsan\"</span>);  </span><br><span class=\"line\">lk.push(<span class=\"string\">\"wangwu\"</span>);  </span><br><span class=\"line\">lk.peek();<span class=\"comment\">//\"wangwu\"  </span></span><br><span class=\"line\">lk.size();<span class=\"number\">3</span>  </span><br><span class=\"line\">lk.pop();<span class=\"comment\">//\"wangwu\"  </span></span><br><span class=\"line\">lk.peek();<span class=\"comment\">//\"zhangsan\"  </span></span><br><span class=\"line\">lk.clear();  </span><br><span class=\"line\">lk.peek();<span class=\"comment\">//undefind  </span></span><br><span class=\"line\">lk.size();<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"参考文章-1\"><a href=\"#参考文章-1\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"https://cobain-li.iteye.com/blog/2335935\" target=\"_blank\" rel=\"noopener\">数据结构与算法－栈篇(js实现)</a></li>\n<li><a href=\"http://www.jb51.net/article/79624.htm\" target=\"_blank\" rel=\"noopener\">JavaScipt中栈的实现方法</a></li>\n</ul>\n<h2 id=\"三、队列\"><a href=\"#三、队列\" class=\"headerlink\" title=\"三、队列\"></a>三、队列</h2><h3 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>队列是一种先进先出的结构。队列也是一种表结构，不同的是队列只能在队尾插入元素，在队首删除元素；在 JS 中可以用数组来实现队列结构</p>\n<h3 id=\"加入函数-2\"><a href=\"#加入函数-2\" class=\"headerlink\" title=\"加入函数\"></a>加入函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>enqueue</td>\n<td>在队列的末尾添加一个元素</td>\n<td>无</td>\n</tr>\n<tr>\n<td>dequeue</td>\n<td>出队，删除队列的第一个元素并返回</td>\n<td>object</td>\n</tr>\n<tr>\n<td>front</td>\n<td>取出队列的第一个元素</td>\n<td>object</td>\n</tr>\n<tr>\n<td>back</td>\n<td>取出队列的最后一个元素</td>\n<td>object</td>\n</tr>\n<tr>\n<td>toString</td>\n<td>将队列中的元素以字符串形式输出</td>\n<td>string</td>\n</tr>\n<tr>\n<td>empty</td>\n<td>判断队列是否为空</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>count</td>\n<td>返回队列中元素的个数</td>\n<td>int</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>清楚队列</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Queue</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dataStore = [],<span class=\"comment\">//队列数据</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.enqueue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//入队，就是在数组的末尾添加一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataStore.push(element);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dequeue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//出队，就是删除数组的第一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataStore.shift();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.front = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//取出数组的第一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataStore[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.back = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//取出数组的最后一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataStore[<span class=\"keyword\">this</span>.dataStore.length<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//将数组中的元素以字符串形式输出</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> retStr = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"keyword\">this</span>.dataStore.length; ++i) &#123;</span><br><span class=\"line\">            retStr += <span class=\"keyword\">this</span>.dataStore[i] + <span class=\"string\">\"&amp;nbsp;\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> retStr;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.empty = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//判断数组是否为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.dataStore.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//返回数组中元素的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataStore.length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//清除队列</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataStore = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-2\"><a href=\"#使用示例-2\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> q = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\">q.enqueue(<span class=\"string\">\"Meredith\"</span>);</span><br><span class=\"line\">q.enqueue(<span class=\"string\">\"Cynthia\"</span>);</span><br><span class=\"line\">q.enqueue(<span class=\"string\">\"Jennifer\"</span>);</span><br><span class=\"line\">\b<span class=\"built_in\">console</span>.log(q.toString());<span class=\"comment\">//Meredith Cynthia Jennifer</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q.front());<span class=\"comment\">//Meredith</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q.back());<span class=\"comment\">//Jennifer</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"参考文章-2\"><a href=\"#参考文章-2\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"http://www.cnblogs.com/tylerdonet/p/5837730.html\" target=\"_blank\" rel=\"noopener\">javascript中的队列结构</a></li>\n</ul>\n<h2 id=\"四、单链表\"><a href=\"#四、单链表\" class=\"headerlink\" title=\"四、单链表\"></a>四、单链表</h2><h3 id=\"简介-3\"><a href=\"#简介-3\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>单链表是一种链式存取的数据结构。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p>\n<h3 id=\"加入函数-3\"><a href=\"#加入函数-3\" class=\"headerlink\" title=\"加入函数\"></a>加入函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value(_key)</td>\n<td>根据key的值来获取value值</td>\n<td>value</td>\n</tr>\n<tr>\n<td>add(_key,_value)”</td>\n<td>往链表的尾部加入一个节点</td>\n<td>value</td>\n</tr>\n<tr>\n<td>insert(_key,node)”</td>\n<td>从某节点之后插入新节点node</td>\n<td>无</td>\n</tr>\n<tr>\n<td>insertBefore(_key,node)</td>\n<td>从某节点之后插入新节点node</td>\n<td>无</td>\n</tr>\n<tr>\n<td>remove(_key)</td>\n<td>从链表中移除一个key</td>\n<td>无</td>\n</tr>\n<tr>\n<td>removeAt(n)</td>\n<td>删除指定位置的节点</td>\n<td>无</td>\n</tr>\n<tr>\n<td>removeAll</td>\n<td>清空链表</td>\n<td>无</td>\n</tr>\n<tr>\n<td>exists(_key)</td>\n<td>检查链表类中是否存在一个key</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>getJSON</td>\n<td>转换成JSON字符串</td>\n<td>str</td>\n</tr>\n<tr>\n<td>getArrayJSON</td>\n<td>将所有节点的value转换成JSON字符串，数组格式</td>\n<td>array</td>\n</tr>\n<tr>\n<td>getNodeByIndex</td>\n<td>取第N个位置的节点（头节点为第0个位置）</td>\n<td>node</td>\n</tr>\n<tr>\n<td>getNodeByValue</td>\n<td>查询值为V的节点（返回第一个找到的）</td>\n<td>node</td>\n</tr>\n<tr>\n<td>print</td>\n<td>打印输出所有节点</td>\n<td>string</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>对链表进行排序</td>\n<td>无</td>\n</tr>\n<tr>\n<td>hasSameValueNode</td>\n<td>测试单链表L中是否有重复元素</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>reverseSingleLink</td>\n<td>单链表元素反转</td>\n<td>link</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">linkNode</span>(<span class=\"params\">\\_key, \\_value</span>) </span>&#123;<span class=\"comment\">// 链表类的节点类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.Key = _key;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.Value = _value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Link</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// 创建一个链表类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> linkNode(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>); <span class=\"comment\">//root永远是个空节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.end = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Link.prototype = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span>,<span class=\"comment\">//key的数量</span></span><br><span class=\"line\">    value: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_key</span>) </span>&#123;<span class=\"comment\">//根据key的值来获取value值</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(i = i.next)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i.Key == _key)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i.Value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    add: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">\\_key, \\_value</span>) </span>&#123;<span class=\"comment\">// 往链表的尾部中加入一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(i = i.next)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i.Key == _key)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i.Value = _value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> linkNode(\\_key, \\_value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.root.next = node;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.end.next = node;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = node;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.count++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    insert: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_key, node</span>) </span>&#123;<span class=\"comment\">// 从链表类的某节点之后插入新节点node.</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(i = i.next)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i.Key == _key) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> tmp = i.next;</span><br><span class=\"line\">                i.next = node;</span><br><span class=\"line\">                node.next = tmp;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    insertBefore: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_key, node</span>) </span>&#123;<span class=\"comment\">// 从链表类的某节点之后插入新节点node.</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(i = i.next)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i.next.Key == _key) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> tmp = i.next;</span><br><span class=\"line\">                i.next = node;</span><br><span class=\"line\">                node.next = tmp;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    remove: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_key</span>) </span>&#123;<span class=\"comment\">// 从链表类中移除一个key</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">do</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i.next.Key == _key) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i.next.next == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.end = i;</span><br><span class=\"line\">                i.next = i.next.next;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.count--;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(i = i.next))</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    removeAt : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;<span class=\"comment\">//删除指定位置的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> preNode = <span class=\"keyword\">this</span>.getNodeByIndex(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        preNode.next = preNode.next.next;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    removeAll: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// 清空链表类</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> linkNode(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    exists: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_key</span>) </span>&#123;<span class=\"comment\">// 检查链表类中是否存在一个key</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(i = i.next))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i.Key == _key)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getJSON: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// 转换成JSON字符串，内部方法，用于递归</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> me = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> getChild = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            str += <span class=\"string\">\"&#123;\\\\\"</span>Key\\\\<span class=\"string\">\":\\\\\"</span><span class=\"string\">\" + node.Key + \"</span>\\\\<span class=\"string\">\",\\\\\"</span>Value\\\\<span class=\"string\">\":\"</span> + me.Obj2str(node.Value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.next != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                str += <span class=\"string\">\",\\\\\"</span>next\\\\<span class=\"string\">\":\"</span> + getChild(node.next);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                str += <span class=\"string\">\",\\\\\"</span>next\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            str += <span class=\"string\">\"&#125;\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> link = <span class=\"string\">\"&#123;\\\\\"</span>root\\\\<span class=\"string\">\":&#123;\\\\\"</span>Key\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\",\\\\\"</span>Value\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\",\\\\\"</span>next\\\\<span class=\"string\">\":\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.count == <span class=\"number\">0</span>)<span class=\"comment\">//如果空表</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;\\\\\"</span>root\\\\<span class=\"string\">\":&#123;\\\\\"</span>Key\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\",\\\\\"</span>Value\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\",\\\\\"</span>next\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\"&#125;,\\\\\"</span>end\\\\<span class=\"string\">\":&#123;\\\\\"</span>Key\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\",\\\\\"</span>Value\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\",\\\\\"</span>next\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\"&#125;,\\\\\"</span>count\\\\<span class=\"string\">\":\\\\\"</span><span class=\"number\">0</span>\\\\<span class=\"string\">\"&#125;\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        link += getChild(<span class=\"keyword\">this</span>.root.next) + <span class=\"string\">\"&#125;\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">//加上end</span></span><br><span class=\"line\">        link += <span class=\"string\">\",\\\\\"</span>end\\\\<span class=\"string\">\":&#123;\\\\\"</span>Key\\\\<span class=\"string\">\":\\\\\"</span><span class=\"string\">\" + this.end.Key + \"</span>\\\\<span class=\"string\">\",\\\\\"</span>Value\\\\<span class=\"string\">\":\"</span> + me.Obj2str(<span class=\"keyword\">this</span>.end.Value) + <span class=\"string\">\",\\\\\"</span>next\\\\<span class=\"string\">\":\\\\\"</span><span class=\"literal\">null</span>\\\\<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        link += <span class=\"string\">\"&#125;,\\\\\"</span>count\\\\<span class=\"string\">\":\\\\\"</span><span class=\"string\">\" + this.count + \"</span>\\\\<span class=\"string\">\"&#125;\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> link;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getArrayJSON: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// 转所有节点的value换成JSON字符串,数组格式</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> link = <span class=\"string\">\"&#123;'link':[\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(i = i.next)) &#123;</span><br><span class=\"line\">            link += <span class=\"keyword\">this</span>.Obj2str(i.Value) + <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        link = link.substr(<span class=\"number\">0</span>, link.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        link += <span class=\"string\">\"]&#125;\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> link;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getNodeByIndex: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;<span class=\"comment\">//取第N个位置的节点(约定头节点为第0个位置)，N大于链表元素个数时，返回最后一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> p = <span class=\"keyword\">this</span>.head;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p.next != <span class=\"literal\">null</span> &amp;&amp; i &lt; n) &#123;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getNodeByValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;<span class=\"comment\">//查询值为V的节点，如果链表中有多个相同值的节点，返回第一个找到的</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> p = <span class=\"keyword\">this</span>.head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.data == v) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    print: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">//打印输出所有节点</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> p = <span class=\"keyword\">this</span>.head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">            print(p.data + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        println(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    sort: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;<span class=\"comment\">// 对链表进行排序</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fn != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> i = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(i = i.next)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> j = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"built_in\">Boolean</span>(j = j.next)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (fn.call(<span class=\"keyword\">this</span>, j)) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">var</span> Key = j.Key;</span><br><span class=\"line\">                            <span class=\"keyword\">var</span> Value = j.Value;</span><br><span class=\"line\">                            j.Key = j.next.Key;</span><br><span class=\"line\">                            j.Value = j.next.Value;</span><br><span class=\"line\">                            j.next.Key = Key;</span><br><span class=\"line\">                            j.next.Value = Value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.end = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">msg</span>) </span>&#123;<span class=\"comment\">//打印内容</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">println</span>(<span class=\"params\">msg</span>) </span>&#123;<span class=\"comment\">//换行打印内容</span></span><br><span class=\"line\">    print(msg + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasSameValueNode</span>(<span class=\"params\">singleLink</span>) </span>&#123;<span class=\"comment\">//测试单链表L中是否有重复元素</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = singleLink.head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        i = i.next;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            j = j.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i.data == j.data) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reverseSingleLink</span>(<span class=\"params\">singleLink</span>) </span>&#123;<span class=\"comment\">//单链表元素反转</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = singleLink.head;</span><br><span class=\"line\">    <span class=\"comment\">//先跑一遍，把所有节点放入数组</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p = p.next;</span><br><span class=\"line\">        arr.push(p.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newLink = <span class=\"keyword\">new</span> SingleLink();</span><br><span class=\"line\">    <span class=\"comment\">//再从后向前遍历数组,加入新链表</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        newLink.insert(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newLink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-3\"><a href=\"#使用示例-3\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkTest = <span class=\"keyword\">new</span> SingleLink();</span><br><span class=\"line\">    linkTest.insert(<span class=\"string\">'A'</span>);</span><br><span class=\"line\">    linkTest.insert(<span class=\"string\">'B'</span>);</span><br><span class=\"line\">    linkTest.insert(<span class=\"string\">'C'</span>);</span><br><span class=\"line\">    linkTest.insert(<span class=\"string\">'D'</span>);</span><br><span class=\"line\">    linkTest.print();<span class=\"comment\">//A B C D</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">var</span> newLink = reverseSingleLink(linkTest);</span><br><span class=\"line\">    newLink.print();<span class=\"comment\">//D C B A</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"参考文章-3\"><a href=\"#参考文章-3\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"http://www.cnblogs.com/yjmyzz/archive/2013/05/21/3091653.html\" target=\"_blank\" rel=\"noopener\">javascript:算法笔记</a></li>\n<li><a href=\"http://www.jb51.net/article/38870.htm\" target=\"_blank\" rel=\"noopener\">js单向链表的具体实现实例</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]},{"title":"JS宽高的理解和应用","slug":"JS宽高的理解和应用","date":"2017-05-01T14:49:51.000Z","updated":"2019-02-02T10:19:58.046Z","comments":true,"path":"api/articles/JS宽高的理解和应用.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_31.png","content":"<h2 id=\"window-和-document\"><a href=\"#window-和-document\" class=\"headerlink\" title=\"window 和 document\"></a>window 和 document</h2><p><strong>document 是 window 对象的一部分</strong>：document.body -&gt; window.document.body，浏览器的 HTML 文档称为 document 对象<br><strong>window.location === document.location</strong>：window 对象的 location 属性引用的是 location 对象，表示该窗口中当前显示文档的 URL，document 对象的 location 属性也是引用了 location 对象</p>\n<h2 id=\"window-screen\"><a href=\"#window-screen\" class=\"headerlink\" title=\"window.screen\"></a>window.screen</h2><p>window.screen 包含有关用户屏幕的信息，它包括：</p>\n<ul>\n<li><code>window.screen.width</code></li>\n<li><code>window.screen.height</code></li>\n<li><code>window.screen.availHeight</code></li>\n<li><code>window.screen.availWidth</code></li>\n<li><code>window.screenTop</code></li>\n<li><code>window.screenLeft</code></li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_31.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"与-window-相关的宽高\"><a href=\"#与-window-相关的宽高\" class=\"headerlink\" title=\"与 window 相关的宽高\"></a>与 window 相关的宽高</h2><ul>\n<li><code>window.innerWidth</code> 内部的宽度</li>\n<li><code>window.innerHeight</code> 内部的高度</li>\n<li><code>window.outWidth</code> 外部的宽度</li>\n<li><code>window.outHeight</code> 外部的高度</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_24.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"与-document-相关的宽高\"><a href=\"#与-document-相关的宽高\" class=\"headerlink\" title=\"与 document 相关的宽高\"></a>与 document 相关的宽高</h2><h3 id=\"与-client-相关的宽高\"><a href=\"#与-client-相关的宽高\" class=\"headerlink\" title=\"与 client 相关的宽高\"></a>与 client 相关的宽高</h3><ul>\n<li><code>document.body.clientWidth</code> 元素宽度（可视内容区+内边距）</li>\n<li><code>document.body.clientHeight</code> 元素高度（可视内容区+内边距）</li>\n</ul>\n<p>该属性指的是元素的可视部分宽度和高度，即 <code>padding+content</code></p>\n<ul>\n<li>如果没有滚动条，即为元素设定的宽度和高度</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientWidth);  <span class=\"comment\">// 350+padding(80) = 430</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientHeight);  <span class=\"comment\">// 500 + padding(80) = 580</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#exp2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"exp2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.clientHeight); <span class=\"comment\">// 200</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.clientWidth); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>document.body.clientLeft</code></li>\n<li><code>document.body.clientTop</code></li>\n</ul>\n<p>这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是 0</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientLeft);  <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.clientTop);  <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>无 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code></li>\n<li>有 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code> + 盒子的 <code>padding * 2</code></li>\n<li>有 <code>padding</code> 有滚动 ：<code>clientWidth</code> = 盒子和 <code>width</code> + 盒子的 <code>padding * 2</code> - 滚动轴宽度</li>\n<li><code>clientTop = border-top</code></li>\n<li><code>clientLeft = border-left</code></li>\n</ul>\n<h3 id=\"与-offset-相关的宽高\"><a href=\"#与-offset-相关的宽高\" class=\"headerlink\" title=\"与 offset 相关的宽高\"></a>与 offset 相关的宽高</h3><ul>\n<li><strong>document.body.offsetWidth（元素的border + padding + content的宽度）</strong></li>\n<li><strong>document.body.offsetHeight（元素的border + padding + content的高度）</strong></li>\n</ul>\n<p>该属性和其内部的内容是否超出元素大小无关，只和本来设定的 border 以及 width 和 height 有关</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.offsetWidth);  <span class=\"comment\">// 470 = padding\\*2 + 350 + border\\*2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body.offsetHeight);  <span class=\"comment\">// 620 = padding\\*2 + 500 + border\\*2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>document.offsetLeft</strong></li>\n<li><strong>document.offsetTop</strong></li>\n</ul>\n<p>了解这两个属性我们必须先了解它，什么是 <code>offsetParent</code></p>\n<ul>\n<li>如果当前元素的父级元素没有进行 <code>CSS</code> 定位（<code>position</code> 为 <code>absolute</code> 或 <code>relative</code>）,<code>offsetParent</code> 为 <code>body.</code></li>\n<li>假如当前元素的父级元素中有 <code>CSS</code> 定位，<code>offsetParent</code> 取最近的那个父级元素</li>\n</ul>\n<h3 id=\"offsetLeft-的兼容性问题\"><a href=\"#offsetLeft-的兼容性问题\" class=\"headerlink\" title=\"offsetLeft 的兼容性问题\"></a>offsetLeft 的兼容性问题</h3><ul>\n<li>在 <code>IE6/7</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 padding-left + 当前元素的 margin-left</li>\n</ul>\n</li>\n<li>在 <code>IE8/9/10</code> 以及 <code>chrome</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 margin-left + offsetParent 的 border 宽度 + offsetParent 的 padding-left + 当前元素的 margin-left</li>\n</ul>\n</li>\n<li>在 <code>FireFox</code> 中<ul>\n<li><code>offsetLeft</code> = offsetParent 的 margin-left + 当前元素的 margin-left + offsetParent 的padding-left</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-id\">#exp</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">20px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 IE8 / 9 / 10 以及 chrome 中：<ul>\n<li>div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 + margin10 + border20 = 80</li>\n<li>div.offsetTop = 本身的 margin10 + 父级元素的 padding40 + margin10 + border20 = 80</li>\n</ul>\n</li>\n<li>在 FireFox：（相比 chrome 中少了 border）<ul>\n<li>div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 + margin10 = 60</li>\n<li>div.offsetTop = 本身的 margin10 + 父级元素的 padding40 + margin10 = 60</li>\n</ul>\n</li>\n<li>在 IE6/7 中：（相比在 FireFox，不但少了 border 还少了父级元素的 margin）<ul>\n<li><code>div.offsetLeft</code> = 本身的 <code>margin10</code> + 父级元素的 <code>padding40</code> = 50</li>\n<li><code>div.offsetTop</code> = 本身的 <code>margin10</code> + 父级元素的 <code>padding40</code> = 50</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>无 <code>padding</code> 无滚动无 <code>border</code><ul>\n<li>offsetWidth = clientWidth = 盒子的宽度</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 无滚动有 <code>border</code><ul>\n<li>offsetWidth = 盒子的宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 边框宽度 * 2</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 有滚动，且滚动是显示的，有 <code>border</code><ul>\n<li>offsetWidth = 盒子宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"与-scroll-相关的宽高\"><a href=\"#与-scroll-相关的宽高\" class=\"headerlink\" title=\"与 scroll 相关的宽高\"></a>与 scroll 相关的宽高</h2><ul>\n<li><strong>document.body.scrollWidth</strong></li>\n<li><strong>document.body.scrollHeight</strong></li>\n</ul>\n<p>document.body 的 scrollWidth 和 scrollHeight 与 div 的 scrollWidth 和 scrollHeight 是有区别的</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#000</span>; </span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">350px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: scroll; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.scrollHeight; <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.scrollWidth; <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>当给定宽高小于浏览器窗口的宽高<ul>\n<li>scrollWidth = 通常是浏览器窗口的宽度</li>\n<li>scrollHeight = 通常是浏览器窗口的高度</li>\n</ul>\n</li>\n<li>当给定宽高大于浏览器窗口的宽高，且内容小于给定宽高的时候<ul>\n<li>scrollWidth = 给定宽度 + 其所有的 padding + margin + border</li>\n<li>scrollHeight = 给定高度 + 其所有的 padding + margin + border</li>\n</ul>\n</li>\n<li>当给定宽高大于浏览器窗口宽高，且内容大于给定宽高<ul>\n<li>scrollWidth = 内容宽度 + 其所有的 padding + margin + border</li>\n<li>scrollHeight = 内容高度 + 其所有的 padding + margin + border</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在某-div-中的-scrollWidth-和-scrollHeight\"><a href=\"#在某-div-中的-scrollWidth-和-scrollHeight\" class=\"headerlink\" title=\"在某 div 中的 scrollWidth 和 scrollHeight\"></a><strong>在某 div 中的 scrollWidth 和 scrollHeight</strong></h3><p>无滚动轴时：</p>\n<ul>\n<li>scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_28.png\" alt=\"\" width=\"450\"></div>\n\n<p>有滚动轴时：</p>\n<ul>\n<li>scrollWidth = 实际内容的宽度 + padding * 2</li>\n<li>scrollHeight = 实际内容的高度 + padding * 2</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_32.png\" alt=\"\" width=\"450\"></div>\n\n<ul>\n<li><strong>document.body.scrollLeft</strong></li>\n<li><strong>document.body.scrollTop</strong></li>\n</ul>\n<p>与前面不同的是，这对属性是<strong>可读写</strong>的，指的是当元素其中的超出其宽高的时候，元素被卷起来的高度和宽度</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#exp</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">20px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>:scroll;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"exp\"</span>);</span><br><span class=\"line\">mydiv.scrollTop ;  <span class=\"comment\">// 默认情况下是0 </span></span><br><span class=\"line\">mydiv.scrollLeft ; <span class=\"comment\">// 默认情况下是0 </span></span><br><span class=\"line\"><span class=\"comment\">// 可以改写它</span></span><br><span class=\"line\">mydiv.scrollTop = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mydiv.scrollTop)</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_25.png\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"obj-style-width-和-obj-style-height\"><a href=\"#obj-style-width-和-obj-style-height\" class=\"headerlink\" title=\"obj.style.width 和 obj.style.height\"></a><strong>obj.style.width 和 obj.style.height</strong></h3><p>对于一个 <code>DOM</code> 元素，它的 <code>style</code> 属性返回的是一个对象，这个对象的任意一个属性是可读写的，<code>style.width</code> 等于 <code>css</code> 属性中的宽度。<code>style.height</code> 等于 <code>css</code> 属性中的高度</p>\n<h2 id=\"documentElement-和-body-的关系\"><a href=\"#documentElement-和-body-的关系\" class=\"headerlink\" title=\"documentElement 和 body 的关系\"></a>documentElement 和 body 的关系</h2><p>是父子级的关系</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>); <span class=\"comment\">//document</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.documentElement); <span class=\"comment\">//html</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.body); <span class=\"comment\">//body</span></span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"/images/hexo_post_29.png\" alt=\"\" width=\"600\"></div>\n\n<ul>\n<li>兼容问题推荐使用，获取浏览器窗口可视区域大小：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.clientWidth || <span class=\"built_in\">document</span>.documentElement.clientWidth;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.clientHeight || <span class=\"built_in\">document</span>.documentElement.clientHeight;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-对象的-5-种坐标\"><a href=\"#Event-对象的-5-种坐标\" class=\"headerlink\" title=\"Event 对象的 5 种坐标\"></a>Event 对象的 5 种坐标</h2><ul>\n<li>clientX 和 clientY：相对于浏览器（可视区左上角0,0）的坐标</li>\n<li>screenX 和 screenY：相对于设备屏幕左上角（0,0）的坐标</li>\n<li>offsetX 和 offsetY：相对于事件源左上角（0,0）的坐标</li>\n<li>pageX 和 pageY：相对于整个网页左上角（0,0）的坐标</li>\n<li>X 和 Y：本来是 IE 属性，相对于用CSS动态定位的最内层包容元素</li>\n</ul>\n<div align=\"center\"><img src=\"/images/hexo_post_27.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"JS各种宽高的应用\"><a href=\"#JS各种宽高的应用\" class=\"headerlink\" title=\"JS各种宽高的应用\"></a>JS各种宽高的应用</h2><ul>\n<li><a href=\"http://codepen.io/poetries/pen/RoeJgG\" target=\"_blank\" rel=\"noopener\">可视区域加载</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/WoayJy\" target=\"_blank\" rel=\"noopener\">判断网页滚动到顶部或者底部</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/vyVrvm\" target=\"_blank\" rel=\"noopener\">DIV滚动到底部时加载剩余内容</a></li>\n<li><a href=\"http://codepen.io/poetries/pen/RoeBbL\" target=\"_blank\" rel=\"noopener\">计算滚动轴的宽高</a></li>\n</ul>\n<h2 id=\"JS中的宽高属性总结\"><a href=\"#JS中的宽高属性总结\" class=\"headerlink\" title=\"JS中的宽高属性总结\"></a>JS中的宽高属性总结</h2><div align=\"center\"><img src=\"/images/hexo_post_26.png\" alt=\"\" width=\"700\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_23.png\" alt=\"\" width=\"700\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_30.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://blog.poetries.top/2016/12/13/js-props/\" target=\"_blank\" rel=\"noopener\">JavaScript及jQuery中的各种宽高属性图解</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"}]},{"title":"一些实用的JS和jQuery方法","slug":"一些实用的JS和jQuery方法","date":"2017-03-15T07:56:27.000Z","updated":"2019-02-02T10:19:58.046Z","comments":true,"path":"api/articles/一些实用的JS和jQuery方法.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这里总结了一些常用的 JS/jQuery 方法，都是一些在项目中经常遇到的功能需求，如果你有更多的建议，欢迎留言</p>\n<blockquote>\n<p>更新于 2018-02-11：在我的github（<a href=\"https://github.com/merrier/common-js\" target=\"_blank\" rel=\"noopener\">common-js</a>）上对一些常用的方法进行了总结，都是一些短小精悍但是颇为实用的封装函数，欢迎 star 或 fork:)</p>\n</blockquote>\n<h2 id=\"1、简单的图片预览\"><a href=\"#1、简单的图片预览\" class=\"headerlink\" title=\"1、简单的图片预览\"></a>1、简单的图片预览</h2><p>这个方法就是普通的上传图片并预览功能，不包含进度条以及大小和格式的判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------------------获取图片url地址---------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getObjectURL</span>(<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.createObjectURL!=<span class=\"literal\">undefined</span>) &#123; <span class=\"comment\">// basic</span></span><br><span class=\"line\">    url = <span class=\"built_in\">window</span>.createObjectURL(file) ;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.URL!=<span class=\"literal\">undefined</span>) &#123; <span class=\"comment\">// mozilla(firefox)</span></span><br><span class=\"line\">    url = <span class=\"built_in\">window</span>.URL.createObjectURL(file) ;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.webkitURL!=<span class=\"literal\">undefined</span>) &#123; <span class=\"comment\">// webkit or chrome</span></span><br><span class=\"line\">    url = <span class=\"built_in\">window</span>.webkitURL.createObjectURL(file) ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> url ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//---------------上传图片按钮点击------------</span></span><br><span class=\"line\">$(<span class=\"string\">\".btn_upload_file\"</span>).change(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> picurl = getObjectURL(<span class=\"keyword\">this</span>.files[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(picurl)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">\".div_show_pic\"</span>).show().attr(<span class=\"string\">\"src\"</span>,picurl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、实现-sleep-函数\"><a href=\"#2、实现-sleep-函数\" class=\"headerlink\" title=\"2、实现 sleep 函数\"></a>2、实现 sleep 函数</h2><p>很多语言都有 sleep 函数，显然 js 没有，所以需要其他的方法“模拟”实现 sleep 函数</p>\n<h3 id=\"方法一：通过比较当前时间\"><a href=\"#方法一：通过比较当前时间\" class=\"headerlink\" title=\"方法一：通过比较当前时间\"></a>方法一：通过比较当前时间</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">numberMillis</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); </span><br><span class=\"line\">  <span class=\"keyword\">var</span> exitTime = now.getTime() + numberMillis; </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123; </span><br><span class=\"line\">    now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now.getTime() &gt; exitTime) </span><br><span class=\"line\">      <span class=\"keyword\">return</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：jQuery-中的-delay-方法\"><a href=\"#方法二：jQuery-中的-delay-方法\" class=\"headerlink\" title=\"方法二：jQuery 中的 $.delay() 方法\"></a>方法二：jQuery 中的 $.delay() 方法</h3><p>下面这个例子：在 slideUp() 和 .fadeIn() 之间延时 800 毫秒</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'#foo'</span>).slideUp(<span class=\"number\">300</span>).delay(<span class=\"number\">800</span>).fadeIn(<span class=\"number\">400</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法三：setTimeout\"><a href=\"#方法三：setTimeout\" class=\"headerlink\" title=\"方法三：setTimeout\"></a>方法三：setTimeout</h3><p>假设有三个步骤，步骤之间需要暂停一段时间；可以采用如下的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">firstStep</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something</span></span><br><span class=\"line\">  setTimeout(<span class=\"string\">\"secondStep()\"</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">secondStep</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something</span></span><br><span class=\"line\">  setTimeout(<span class=\"string\">\"thirdStep()\"</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">thirdStep</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法四：ES6-的-promise\"><a href=\"#方法四：ES6-的-promise\" class=\"headerlink\" title=\"方法四：ES6 的 promise\"></a>方法四：ES6 的 promise</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'world!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、复制内容后面附加额外内容\"><a href=\"#3、复制内容后面附加额外内容\" class=\"headerlink\" title=\"3、复制内容后面附加额外内容\"></a>3、复制内容后面附加额外内容</h2><p>复制网页上面内容时，自动在剪切板内容后面加上网站信息，这样也利于 SEO 优化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.oncopy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = clipboardData.getData(<span class=\"string\">\"text\"</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text) &#123;</span><br><span class=\"line\">      text = text + <span class=\"string\">\"\\\\r\\\\n本篇文章来源于 www.地址.COM 原文链接：\"</span>+location.href;   </span><br><span class=\"line\">      clipboardData.setData(<span class=\"string\">\"text\"</span>, text); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4、很简单的省略字数\"><a href=\"#4、很简单的省略字数\" class=\"headerlink\" title=\"4、很简单的省略字数\"></a>4、很简单的省略字数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\".omit_word_class\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ntext = $(<span class=\"keyword\">this</span>).text();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nlen = $(<span class=\"keyword\">this</span>).text().length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nlen&gt; <span class=\"number\">7</span>)&#123;</span><br><span class=\"line\">    $(<span class=\"keyword\">this</span>).text(ntext.substring(<span class=\"number\">0</span>,<span class=\"number\">7</span>) + <span class=\"string\">\"...\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"5、JS-的动画帧\"><a href=\"#5、JS-的动画帧\" class=\"headerlink\" title=\"5、JS 的动画帧\"></a>5、JS 的动画帧</h2><p>关于 requestAnimationFrame，我对它的理解也很浅层，推荐这篇<a href=\"http://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">张鑫旭对于requestAnimationFrame的讲解</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.requestAnimFrame = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>  <span class=\"built_in\">window</span>.requestAnimationFrame       ||</span><br><span class=\"line\">          <span class=\"built_in\">window</span>.webkitRequestAnimationFrame ||</span><br><span class=\"line\">          <span class=\"built_in\">window</span>.mozRequestAnimationFrame    ||</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> callback </span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.setTimeout(callback, <span class=\"number\">1000</span> / <span class=\"number\">60</span>);</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"6、JS-判断字符串长度\"><a href=\"#6、JS-判断字符串长度\" class=\"headerlink\" title=\"6、JS 判断字符串长度\"></a>6、JS 判断字符串长度</h2><p>方法一，给 String 的 prototype 添加方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.gblen = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">var</span> len = <span class=\"number\">0</span>;    </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"keyword\">this</span>.length; i++) &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.charCodeAt(i)&gt;<span class=\"number\">127</span> || <span class=\"keyword\">this</span>.charCodeAt(i)==<span class=\"number\">94</span>) &#123;    </span><br><span class=\"line\">      len += <span class=\"number\">2</span>;    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;    </span><br><span class=\"line\">      len ++;    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> len;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二，利用-ASCII-码\"><a href=\"#方法二，利用-ASCII-码\" class=\"headerlink\" title=\"方法二，利用 ASCII 码\"></a>方法二，利用 ASCII 码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strlen</span>(<span class=\"params\">str</span>)</span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> len = <span class=\"number\">0</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;str.length; i++) &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = str.charCodeAt(i);   </span><br><span class=\"line\">    <span class=\"comment\">//单字节加1   </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((c &gt;= <span class=\"number\">0x0001</span> &amp;&amp; c &lt;= <span class=\"number\">0x007e</span>) || (<span class=\"number\">0xff60</span>&lt;=c &amp;&amp; c&lt;=<span class=\"number\">0xff9f</span>)) &#123;   </span><br><span class=\"line\">      len++;   </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;   </span><br><span class=\"line\">      len+=<span class=\"number\">2</span>;   </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">  <span class=\"keyword\">return</span> len;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法三：把双字节的替换成两个单字节的然后再获得长度\"><a href=\"#方法三：把双字节的替换成两个单字节的然后再获得长度\" class=\"headerlink\" title=\"方法三：把双字节的替换成两个单字节的然后再获得长度\"></a>方法三：把双字节的替换成两个单字节的然后再获得长度</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getBLen = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (str == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> str != <span class=\"string\">\"string\"</span>)&#123;  </span><br><span class=\"line\">    str += <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(<span class=\"regexp\">/[^\\\\x00-\\\\xff]/g</span>,<span class=\"string\">\"01\"</span>).length;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7、jQuery-控制超出规定长度显示省略号\"><a href=\"#7、jQuery-控制超出规定长度显示省略号\" class=\"headerlink\" title=\"7、jQuery 控制超出规定长度显示省略号\"></a>7、jQuery 控制超出规定长度显示省略号</h2><p>给需要显示省略号的标签设置 class 为 displayPart，然后设置自定义属性 displayLength，该属性为可显示长度（不包含…），该方法会区分中英文，中文字符相当于两个字节</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.fn.extend(&#123; </span><br><span class=\"line\">  displayPart:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> displayLength = <span class=\"number\">100</span>; </span><br><span class=\"line\">    displayLength = <span class=\"keyword\">this</span>.attr(<span class=\"string\">\"displayLength\"</span>) || displayLength; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"keyword\">this</span>.text(); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!text) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"string\">\"\"</span>; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; displayLength; i++) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">var</span> _char = text.charAt(i); </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt;= displayLength) <span class=\"keyword\">break</span>; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"regexp\">/[^x00-xff]/</span>.test(_char)) count++; <span class=\"comment\">//双字节字符，//[u4e00-u9fa5]中文 </span></span><br><span class=\"line\">      result += _char; </span><br><span class=\"line\">      count++; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result.length &lt; text.length) &#123; </span><br><span class=\"line\">      result += <span class=\"string\">\"...\"</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text(result); </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">\".displayPart\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  $(<span class=\"keyword\">this</span>).displayPart();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"8、去除字符串首尾的空白字符\"><a href=\"#8、去除字符串首尾的空白字符\" class=\"headerlink\" title=\"8、去除字符串首尾的空白字符\"></a>8、去除字符串首尾的空白字符</h2><p>如果引入了 jQuery，可以直接利用 $.trim() 方法，如果没有就需要用到下面的正则表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trim</span>(<span class=\"params\">ostr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ostr.replace(<span class=\"regexp\">/^\\\\s+|\\\\s+$/g</span>,<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"9、判断数组中是否包含某个元素\"><a href=\"#9、判断数组中是否包含某个元素\" class=\"headerlink\" title=\"9、判断数组中是否包含某个元素\"></a>9、判断数组中是否包含某个元素</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [ <span class=\"string\">\"xml\"</span>, <span class=\"string\">\"html\"</span>, <span class=\"string\">\"css\"</span>, <span class=\"string\">\"js\"</span> ];  </span><br><span class=\"line\">$.inArray(<span class=\"string\">\"js\"</span>, arr);  <span class=\"comment\">// 返回 3, 如果不包含在数组中, 则返回 -1;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"10、获取日期并格式化\"><a href=\"#10、获取日期并格式化\" class=\"headerlink\" title=\"10、获取日期并格式化\"></a>10、获取日期并格式化</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDateStr</span>(<span class=\"params\">AddDayCount</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dd = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  dd.setDate(dd.getDate()+AddDayCount);<span class=\"comment\">//获取AddDayCount天后的日期</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = dd.getFullYear();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m = dd.getMonth()+<span class=\"number\">1</span>;<span class=\"comment\">//获取当前月份的日期</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> d = dd.getDate();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y+<span class=\"string\">\"-\"</span>+m+<span class=\"string\">\"-\"</span>+d;</span><br><span class=\"line\">&#125;)(<span class=\"number\">-2</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"11、根据屏幕宽度改变-html-的-font-size-大小\"><a href=\"#11、根据屏幕宽度改变-html-的-font-size-大小\" class=\"headerlink\" title=\"11、根据屏幕宽度改变 html 的 font-size 大小\"></a>11、根据屏幕宽度改变 html 的 font-size 大小</h2><p>结合 REM 可以很轻松的实现移动端的响应式大小效果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">win</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setUnitA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.documentElement.style.fontSize = <span class=\"built_in\">document</span>.documentElement.clientWidth / <span class=\"number\">16</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> h = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"resize\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(h);</span><br><span class=\"line\">    h = setTimeout(setUnitA, <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  setUnitA();</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"12、JS-jQuery-获取-url-参数\"><a href=\"#12、JS-jQuery-获取-url-参数\" class=\"headerlink\" title=\"12、JS/jQuery 获取 url 参数\"></a>12、JS/jQuery 获取 url 参数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//---------------javaseript获取url中的参数----------------</span></span><br><span class=\"line\"><span class=\"comment\">//\\* 用法：</span></span><br><span class=\"line\"><span class=\"comment\">//\\* var args = getArgs( ); // 从 URL 解析出参数</span></span><br><span class=\"line\"><span class=\"comment\">//\\* var q = args.q || \"\"; // 如果定义了某参数，则使用其值，否则给它一个默认值</span></span><br><span class=\"line\"><span class=\"comment\">//\\* var n = args.n ? parseInt(args.n) : 10;</span></span><br><span class=\"line\"><span class=\"comment\">//*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getArgs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>( ); <span class=\"comment\">//声明一个空对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> query = <span class=\"built_in\">window</span>.location.search.substring(<span class=\"number\">1</span>); <span class=\"comment\">// 取查询字符串，如从 http://www.snowpeak.org/testjs.htm?a1=v1&amp;a2=&amp;a3=v3#anchor 中截出 a1=v1&amp;a2=&amp;a3=v3。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pairs = query.split(<span class=\"string\">\"&amp;\"</span>); <span class=\"comment\">// 以 &amp; 符分开成数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; pairs.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> pos = pairs[i].indexOf(<span class=\"string\">'='</span>); <span class=\"comment\">// 查找 \"name=value\" 对</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos == <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">// 若不成对，则跳出循环继续下一对</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> argname = pairs[i].substring(<span class=\"number\">0</span>,pos); <span class=\"comment\">// 取参数名</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> value = pairs[i].substring(pos+<span class=\"number\">1</span>); <span class=\"comment\">// 取参数值</span></span><br><span class=\"line\">        value = <span class=\"built_in\">decodeURIComponent</span>(value); <span class=\"comment\">// 若需要，则解码</span></span><br><span class=\"line\">        args[argname] = value; <span class=\"comment\">// 存成对象的一个属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> args; <span class=\"comment\">// 返回此对象</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"13、返回一个最小值与最大值中间的随机值\"><a href=\"#13、返回一个最小值与最大值中间的随机值\" class=\"headerlink\" title=\"13、返回一个最小值与最大值中间的随机值\"></a>13、返回一个最小值与最大值中间的随机值</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">random</span>(<span class=\"params\">min,max</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> min + (max - min) * <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"14、限制上传文件格式和大小\"><a href=\"#14、限制上传文件格式和大小\" class=\"headerlink\" title=\"14、限制上传文件格式和大小\"></a>14、限制上传文件格式和大小</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fileChange</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name=target.value;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fileType = name.substring(name.lastIndexOf(<span class=\"string\">\".\"</span>)+<span class=\"number\">1</span>).toLowerCase();     <span class=\"comment\">// 获取文件格式</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fileArr=name.split(<span class=\"string\">\"\\\\\\\");</span></span><br><span class=\"line\"><span class=\"string\">    var fileName=fileArr[fileArr.length-1];     // 获取文件名称</span></span><br><span class=\"line\"><span class=\"string\">    if(fileType !=\"</span>jpg<span class=\"string\">\" &amp;&amp; fileType !=\"</span>png<span class=\"string\">\")&#123;</span></span><br><span class=\"line\"><span class=\"string\">        alert(\"</span>请选择jpg或者png格式图片文件上传！<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">        target.value=\"</span><span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\">        return false;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;else&#123;</span></span><br><span class=\"line\"><span class=\"string\">        var fileSize = target.files[0].size/1024;           // 获取文件大小，单位为kb</span></span><br><span class=\"line\"><span class=\"string\">        console.log(fileSize);</span></span><br><span class=\"line\"><span class=\"string\">        if (fileSize &gt; 40) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            alert(\"</span>图片文件大小不得超过<span class=\"number\">40</span>kb!<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">            target.value=\"</span><span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\">            return false;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;else&#123;</span></span><br><span class=\"line\"><span class=\"string\">            var url=getObjectURL(target.files[0]);           // 获取图片url</span></span><br><span class=\"line\"><span class=\"string\">            console.log(url);</span></span><br><span class=\"line\"><span class=\"string\">            $(\"</span>.modal_brand .upload_img<span class=\"string\">\").attr(\"</span>src<span class=\"string\">\",url);      // 显示上传图片</span></span><br><span class=\"line\"><span class=\"string\">            console.log($(\"</span>.modal_brand .upload_img<span class=\"string\">\").attr(\"</span>src<span class=\"string\">\"));</span></span><br><span class=\"line\"><span class=\"string\">            $(\"</span>.modal_brand .img_name p<span class=\"string\">\").text(fileName);          // 显示上传图片文件名</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"15、一个-HTML-转义函数\"><a href=\"#15、一个-HTML-转义函数\" class=\"headerlink\" title=\"15、一个 HTML 转义函数\"></a>15、一个 HTML 转义函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escapeHTML</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> replacements= &#123;<span class=\"string\">\"&lt;\"</span>: <span class=\"string\">\"&lt;\"</span>, <span class=\"string\">\"&gt;\"</span>: <span class=\"string\">\"&gt;\"</span>,<span class=\"string\">\"&amp;\"</span>: <span class=\"string\">\"&amp;\"</span>, <span class=\"string\">\"\\\\\"</span><span class=\"string\">\": \"</span><span class=\"string\">\"\"</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/[&lt;&gt;&amp;\"]/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">character</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> replacements[character];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"jQuery","path":"api/tags/jQuery.json"}]},{"title":"函数声明VS函数表达式","slug":"函数声明VS函数表达式","date":"2017-08-02T07:16:07.000Z","updated":"2019-02-02T10:19:58.050Z","comments":true,"path":"api/articles/函数声明VS函数表达式.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>本篇文章译自某大牛的文章：<a href=\"https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/\" target=\"_blank\" rel=\"noopener\">Function Declarations vs. Function Expressions</a>，推荐英语不是很差的童鞋点击前面链接看原文。首先先做个小测验，下面四个例子的 alert 输出分别是什么？</p>\n<p><strong>例子一：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>例子二：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>例子三：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(foo());</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>例子四：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p>我就直接公布答案了：8，3，3 和 [Type Error:bar is not a function]。如果你没有完全答对或者直接翻到这里看答案，那你可以继续往下看了。</p>\n<h2 id=\"什么是函数声明-function-declaration\"><a href=\"#什么是函数声明-function-declaration\" class=\"headerlink\" title=\"什么是函数声明(function declaration)\"></a>什么是函数声明(function declaration)</h2><p>函数声明定义了一个命名的函数变量，而不需要变量赋值。函数声明是一种独特的结构，并且不能嵌套在非函数体中。我们可以将函数声明看做是变量声明的另一种形式，就像变量声明必须以 “var” 开头一样，函数声明必须以 “function” 关键字开头。下面就是一个很简单的函数声明实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ECMA 5(13.0) 中对于函数声明的定义：</p>\n<blockquote>\n<p>function_Identifier_ ( _FormalParameterList_opt ) { <em>FunctionBody</em> }</p>\n</blockquote>\n<p>需要注意的是，函数名在它本身的作用于以及它的父级作用域都是可见的（这是一个很不错的规则，因为不然的话在外面将无法访问到该函数）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">bar() <span class=\"comment\">//3</span></span><br><span class=\"line\">bar  <span class=\"comment\">//function</span></span><br><span class=\"line\">bar === <span class=\"built_in\">window</span>.bar  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是函数表达式-function-expression\"><a href=\"#什么是函数表达式-function-expression\" class=\"headerlink\" title=\"什么是函数表达式(function expression)\"></a>什么是函数表达式(function expression)</h2><p>函数表达式将一个函数定义为一个很长的表达式的一部分（通常是一个变量赋值表达式）。以“函数表达式”方式命名的函数可以是命名的也可以是匿名函数。<strong>函数表达式不能以 “function” 关键字开头</strong>（所以下面的第三个表达式需要用 “()” 包裹）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//匿名函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//命名函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//自调用函数表达式</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"hello!\"</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>和函数声明相反，<strong>函数表达式的函数名（如果有的话）在它的作用域之外是不可见的</strong></p>\n<h2 id=\"那函数语句-function-statement-又是什么呢？\"><a href=\"#那函数语句-function-statement-又是什么呢？\" class=\"headerlink\" title=\"那函数语句(function statement)又是什么呢？\"></a>那函数语句(function statement)又是什么呢？</h2><p>函数语句有时候只是函数声明的另一种叫法。然而，按照<a href=\"http://yura.thinkweb2.com/named-function-expressions/#function-statements\" target=\"_blank\" rel=\"noopener\">Kangax的说法</a>，Mozilla 认为函数语句是对于函数声明的扩展，它允许在任何允许使用语句的地方使用函数声明这种语法。但是，这是非行业标准，所以不推荐用于生产环境。</p>\n<h2 id=\"好像忘了上面四个例子\"><a href=\"#好像忘了上面四个例子\" class=\"headerlink\" title=\"好像忘了上面四个例子\"></a>好像忘了上面四个例子</h2><p>让我们回到文章开头那四个例子 首先，<strong>例子一是两个函数声明，所以这两个函数声明被“提升”了</strong></p>\n<h3 id=\"等一下，什么叫做被“提升”？\"><a href=\"#等一下，什么叫做被“提升”？\" class=\"headerlink\" title=\"等一下，什么叫做被“提升”？\"></a>等一下，什么叫做被“提升”？</h3><p>援引 <a href=\"http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting\" target=\"_blank\" rel=\"noopener\">Ben Cherry文章</a>中的一段话：</p>\n<blockquote>\n<p>Function declarations and function variables are always moved (‘hoisted’) to the top of their JavaScript scope by the JavaScript interpreter</p>\n</blockquote>\n<p>翻译一下就是：函数声明和函数变量总会被 Javascript 解释器移动（提升）到它们的 JavaScript 作用域的顶端（我希望你能够认认真真的理解一下上面这句话，如果还是不理解，没关系，继续向下看）;当函数声明被提升时，整个函数体都将随之提升。所以在解释器对例子一中的代码进行解析过后，它其实是这样的（建议回过头看一下例子一的代码，对比着看会更容易理解）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例子一实际执行时的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//\b第一次定义函数bar</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//第二次定义函数bar，将之前的定义覆盖</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//return调用结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar(); <span class=\"comment\">//8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<p><strong>但是，我们一直以来的“常识”是return语句后面的代码是不会执行的啊？</strong></p>\n<p>这就涉及到“执行上下文”和“执行过程”的概念了，ECMA5 将“执行上下文”分为“词法环境”、“变量环境 ”和“绑定 this”，而“执行过程”是指最终的代码执行过程。当执行到声明语句的时候，此时的声明语句就会进入到“变量环境”，它们与语句（比如说 return 语句）是不同的，是不受所谓的“前面代码先执行，后面代码后执行”的约束的。 （“执行上下文”这一概念对于本篇文章来说是个重点，如果依然不理解的话，可以读一下<a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/13/2308101.html\" target=\"_blank\" rel=\"noopener\">汤姆大叔</a>和<a href=\"http://www.jianshu.com/p/a6d37c77e8db\" target=\"_blank\" rel=\"noopener\">简书-波同学</a>的文章加深理解）</p>\n<h3 id=\"那么，函数表达式也会提升吗\"><a href=\"#那么，函数表达式也会提升吗\" class=\"headerlink\" title=\"那么，函数表达式也会提升吗\"></a>那么，函数表达式也会提升吗</h3><p>这取决于表达式本身，让我们继续看以下例子二中的第一个表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>左边的 var bar 是一个变量声明。根据上面的规则，变量声明会被提升，但是赋值表达式却没有（和函数声明不同，函数声明会将整个函数体提升）。因此当 bar 这个变量被提升时，解释器会将 bar 初始化为 <code>undefined：var bar = undefined</code>。所以例子二中的代码实际上以下面的顺序执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例子二实际执行时的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//函数表达式的变量声明（被提升，同时被解释器赋初始值undefined）</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"comment\">//第一个函数表达式被执行</span></span><br><span class=\"line\">    bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//第一个函数表达式创建的函数被执行了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar();</span><br><span class=\"line\">    <span class=\"comment\">//第二个函数表达式将不会执行（但是变量声明被提升了，就在上面）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo()); <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"目前你应该已经理解的差不多了，但是如果你在-Firebug-中运行例子三的代码会不符合预期，这又是为什么呢？\"><a href=\"#目前你应该已经理解的差不多了，但是如果你在-Firebug-中运行例子三的代码会不符合预期，这又是为什么呢？\" class=\"headerlink\" title=\"目前你应该已经理解的差不多了，但是如果你在 Firebug 中运行例子三的代码会不符合预期，这又是为什么呢？\"></a>目前你应该已经理解的差不多了，但是如果你在 Firebug 中运行例子三的代码会不符合预期，这又是为什么呢？</h3><p>你可以试着将例子三的代码保存在一个 HTML 文件中，然后用 firefox 浏览器打开，或者在 IE 8，Chrome 或者 Safari 的 console 中执行。你就会发现，Firebug 的 console 并没有像其他浏览器一样在全局作用域（其实并不是全局作用域，而是特殊的 “Firebug” 作用域。。可以试着在 firebug 的控制台中打印一下 “this == window” 你就明白了）中有函数体提升的表现 所以，抛开 firefox 的“灵异表现”不管，例子三和例子一其实是相同的道理，只不过是函数 foo 被提升了而已。</p>\n<h3 id=\"现在我们可以看一下例子四了\"><a href=\"#现在我们可以看一下例子四了\" class=\"headerlink\" title=\"现在我们可以看一下例子四了\"></a>现在我们可以看一下例子四了</h3><p>很明显，例子四是没有函数提升的，但是变量提升是存在的（而且是两个），那么此时 bar 的声明就会提升，但是它的值没有定义（undefined），所以最后相当于执行 undefined()。最后当然就会报错了：<code>bar is not a function</code>。</p>\n<h2 id=\"那还应该注意些什么呢？\"><a href=\"#那还应该注意些什么呢？\" class=\"headerlink\" title=\"那还应该注意些什么呢？\"></a>那还应该注意些什么呢？</h2><p>目前，你应该能完全理解上面的四个例子了。还需要注意的一点是，函数声明在非函数体（如 if）中是被明令禁止的。然而，所有的浏览器其实都允许这样做，并且更可怕的是，<strong>每个浏览器对这种不符合规定的语法的解释还不同！</strong>，举个栗子，下面的代码片断在 firefox 3.6 中会抛出一个错误，因为它将函数声明解析为函数语句（函数语句已经在上面介绍过了），所以 x is not defined。然而在 IE8，Chrome5 和 Safari5 中，函数 x 被正常 return 了（就像标准的函数声明一样）。当然，鉴于这篇文章的原文年代比较久远，具体的还是要自己在 dev tool 中运行一下才能得出结论（可以试着将 if 中的 true 替换为 false 再运行一下看看）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(foo());</span><br></pre></td></tr></table></figure>\n<h2 id=\"既然函数声明会造成混论，那它的好处在哪里？\"><a href=\"#既然函数声明会造成混论，那它的好处在哪里？\" class=\"headerlink\" title=\"既然函数声明会造成混论，那它的好处在哪里？\"></a>既然函数声明会造成混论，那它的好处在哪里？</h2><p>通过上面的讨论，你会发现函数声明是“宽松”的——如果你在某个函数声明之前就调用它，“函数提升”的机制将使函数得到正常调用而不会报错。但是这种“宽松”缺乏严谨性，同时从长远来看，禁止“声明前调用”将更有利于开发者的编程习惯的养成（就像所谓的“弱类型”）。毕竟，开发者需要养成以特定的顺序编写代码的习惯。</p>\n<h2 id=\"函数表达式的优势呢？\"><a href=\"#函数表达式的优势呢？\" class=\"headerlink\" title=\"函数表达式的优势呢？\"></a>函数表达式的优势呢？</h2><p>说出来你可能不信:）首先，函数声明的方式好像在模仿 Java 中的方法声明，然而 Java 的方法和 JS 中的函数是两码事啊（原文是：<strong>Java methods are very different animals</strong>）：在 JavaScript 中，函数是具有值的 living object，而 Java 中的方法只是元数据存储结构。下面的两段代码片断都定义了函数但是只有函数表达式表明我们在创建一个对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b&#125;;</span><br><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b&#125;;</span><br></pre></td></tr></table></figure>\n<p>其次，<strong>函数表达式的用途更多</strong>。一个函数声明只能解释为一段孤立的语句。它能做的仅仅是创建一个以当前作用域为父域的变量对象。与之相反，函数表达式是一种更复杂的结构。如果你想创建一个匿名函数或者将某个函数分配给一个原型对象亦或作为某个其他对象的属性的话，你就可以用函数表达式来实现。每当你使用高阶应用程序（比如 curry 或 compose）创建一个函数时，你其实都是在应用函数表达式。所以，<strong>函数表达式和函数编程其实是密不可分的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHello = alert.curry(<span class=\"string\">\"hello!\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数表达式有缺点吗？\"><a href=\"#函数表达式有缺点吗？\" class=\"headerlink\" title=\"函数表达式有缺点吗？\"></a>函数表达式有缺点吗？</h2><p>一般情况下，通过函数表达式方式创建的函数都是匿名的。比如下面这段代码创建的函数是匿名的，today 只是对于匿名函数的引用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;</span><br></pre></td></tr></table></figure>\n<p>那匿名不匿名关系大吗？大多数情况下是没有的，但是正如 <a href=\"http://fitzgeraldnick.com/weblog/\" target=\"_blank\" rel=\"noopener\">Nick Fitzgerald</a> 所说，使用匿名函数进行调试有可能会很痛苦。所以他建议使用命名函数表达式（NFEs）作为一种替代方案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">today</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，正如 Asen Bozhilov 所说（以及 <a href=\"http://yura.thinkweb2.com/named-function-expressions/#jscript-bugs\" target=\"_blank\" rel=\"noopener\">Kangax 的文章</a>），NFEs 在 IE9 以下的浏览器中无法正常运行（在我看来，这并不是个大问题）</p>\n<h2 id=\"MD终于到结尾了\"><a href=\"#MD终于到结尾了\" class=\"headerlink\" title=\"MD终于到结尾了\"></a>MD终于到结尾了</h2><p>在错误的位置进行函数声明会误导别人，而且很少有（如果有）这种情况，就是你不能通过函数表达式的方法创建函数而必须用函数声明。当然，如果你必须要用函数声明，请将它们放在作用域顶端，这样可以减小误导性。同时，我绝不会在 if 语句中进行函数声明（这是明令禁止的）。 说了这么多（译者注：确实很多，翻译了好几个小时），你可能依然觉得有时候还是宁愿用函数声明。这其实很正常，盲目的遵守某些规则是愚蠢的，而且有时候会导致自己的代码很“丑陋”。最重要的是，你理解了上面介绍的这些概念和知识点，从而能够让你做出明智的决定。我希望这篇文章在这个方面能够对你有所帮助。 欢迎评论，如果你觉得我哪里说得不对（或者翻译的不对:））以及还有哪里需要补充的，欢迎留言或者通过其他方式联系我。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"函数","path":"api/tags/函数.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（10）——JS中的闭包","slug":"前端面试系列（10）——JS中的闭包","date":"2017-04-05T13:12:15.000Z","updated":"2019-02-02T10:19:58.050Z","comments":true,"path":"api/articles/前端面试系列（10）——JS中的闭包.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>闭包这个概念其实并不是 JS 中独有的，很多开发者将其理解为 JS 的特有产物，其实是大错特错的；只不过 JS 中的闭包有着其他语言没有的特性和产生机理，所以对于闭包的理解成为了很多面试官垂青的问题，而真正理解闭包并且知道在什么时候用闭包、在什么时候避免闭包对于前端码农来说是一个不小的挑战，本篇文章就将深入剖析闭包的工作原理，以及如何使用和避免使用闭包</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>要理解闭包，首先必须理解 Javascript 特殊的变量作用域；在 JS 中，变量的作用域无非就是两种：全局变量和局部变量：</p>\n<ul>\n<li>全局变量，顾名思义，在函数内部也可以直接读取全局变量</li>\n<li>局部变量，在函数外部是无法读取函数内的局部变量的（<strong>函数内声明变量的时候，一定要使用 var / let 命令，否则相当于声明了一个全局变量</strong>）</li>\n</ul>\n<p>我们有时候需要得到函数内的局部变量，但是从上面的讲解可以看到，正常情况下是办不到的，所以只能变通：<strong>在函数的内部，再定义一个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(n);  <span class=\"comment\">//999</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就引出了另外一个概念，就是 Javascript 语言特有的“<strong>链式作用域</strong>”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量；援引<a href=\"http://www.yanshiba.com/\" target=\"_blank\" rel=\"noopener\">燕十八</a>老师的话，只要在一对大括号之内声明的变量，在这个大括号里面的任何地方都可以访问到该变量。<br>根据上面的代码，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们就可以在 f1 外部读取它的内部变量了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(n); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result=f1();</span><br><span class=\"line\">result(); <span class=\"comment\">// 999</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>上面代码中的 f2 函数，就是闭包。 闭包是 JavaScript（以及其他大多数编程语言）的一个极其强大的属性。正如在 MDN (Mozilla Developer Network) 中定义的那样：</p>\n<blockquote>\n<p>闭包是指能够访问自由变量的函数。换句话说，在闭包中定义的函数可以“记忆”它被创建的环境。</p>\n</blockquote>\n<p>自由变量是既不是在本地声明又不作为参数传递的一类变量。（如果一个作用域中使用的变量并不是在该作用域中声明的，那么这个变量对于该作用域来说就是自由变量），上面例子中的 n 在 f2 中 alert，但是 f2 中并没有声明 n，所以 n 对于 f2 这个大括号形成的作用域来说就是自由变量；更通俗来讲的话，闭包是能够读取其他函数内部变量的函数，所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>\n<h2 id=\"闭包的用途\"><a href=\"#闭包的用途\" class=\"headerlink\" title=\"闭包的用途\"></a>闭包的用途</h2><p>闭包一个非常重要的用途：保留外部作用域对一个变量的私有引用（仅通过唯一途径例如某一个特定函数来访问一个变量），来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 5, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 5, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 5, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 5, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 5, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>这里之所以会打印 5 个 “5”，是因为这五个函数的作用域全部相同（var i = 0 这一句可以提到 for 循环外面，对于 5 个函数来说，只有一个 i，就是循环结束时的那个 i）；也就是说，每次变量 i 增加时，作用域都会更新–这个作用域被所有函数共享。一个解决办法就是为每个函数创建一个额外的封闭环境，使得它们各自都有自己的执行上下文 / 作用域：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// additional enclosing context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 0, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 1, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 2, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 3, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 4, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>另外，因为 ES6 的缘故，所以我们可以使用 let 来代替 var，因为 let 声明的是块级作用域（在 ES5 中，是没有块级作用域的），因此每次迭代都会创建一个新的标示符绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  result[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result[<span class=\"number\">0</span>](); <span class=\"comment\">// 0, expected 0</span></span><br><span class=\"line\">result[<span class=\"number\">1</span>](); <span class=\"comment\">// 1, expected 1</span></span><br><span class=\"line\">result[<span class=\"number\">2</span>](); <span class=\"comment\">// 2, expected 2</span></span><br><span class=\"line\">result[<span class=\"number\">3</span>](); <span class=\"comment\">// 3, expected 3</span></span><br><span class=\"line\">result[<span class=\"number\">4</span>](); <span class=\"comment\">// 4, expected 4</span></span><br></pre></td></tr></table></figure>\n<p>再来看一个例子（MDN 给出的一个闭包的例子）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>));  <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>我们定义了一个方法 makeAdder(x)，这个方法只有一个变量 x，然后返回了一个新的方法；返回的方法呢只有一个变量 y，然后 return 的结果是 x + y；所以，makeAdder(x) 就被我们打造成了一个“方法工厂”，在上面的例子中我们利用这个“工厂”生产了两个新的方法，一个返回的结果是 5 加上变量，另外一个返回 10 加上传进来的变量；不出所料，add5 和 add10 这两个方法都是闭包，他们共享同样的方法体定义，但是存储了不同的词法环境（关于词法环境，本文将不详细探讨，感兴趣的可以自行查阅资料，暂时可以简单的理解为变量所在的环境）；在 add5 的词法环境，x 是 5；而在 add10 的词法环境中，x 是 10；通过这个例子，我们可以看到闭包可以用来打造“方法工厂”，而这个特性也成为了我们避免使用闭包的理由</p>\n<h2 id=\"避免使用闭包\"><a href=\"#避免使用闭包\" class=\"headerlink\" title=\"避免使用闭包\"></a>避免使用闭包</h2><p>曾经我被闭包强大的特性所吸引，直到我看到一些关于“避免使用闭包”的博客，才知道闭包带来的麻烦会比其提供的方便更值得重视；JS 的内存释放和 Java 类似，有一个内存回收机制，没有被引用的对象都会被自动释放，而出现闭包的时候会导致变量无法被释放，下面看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> closure1 = closure();</span><br></pre></td></tr></table></figure>\n<p>closure 方法返回的这个方法，在 closure1 方法每次调用的时候，都可以访问 data 对象，所以由此可见，data 对象的引用没有被释放，否则的话 closure1 方法将无法访问到data对象。这里可以明显的看出来闭包是会把局部变量引用起来导致无法释放的“副作用”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> closure2 = closure();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(closure1 === closure2); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(closure1() === closure2()); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出来，closure 方法执行两次得到两个方法，这两个方法不是一个方法，两个方法可以访问的 data 对象也不是同一个对象。也就是说 closure 执行一次，就有一个新对象 data 产生，同时生成一个新的方法，返回出去。每次 closure 方法的执行就导致内存中多了一个 data 对象，多了一个 function(return data)，很明显<strong>这会导致内存的膨胀。使用不当就会导致内存的泄露</strong>。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><p>关于闭包就介绍到这里了，但是为了更容易让初学者理解，本文省略掉了很多相关概念的介绍（执行上下文、词法环境、静态作用域），感兴趣的话可以查阅相关资料，如果有机会的话，我会再查阅更多资料，详细的介绍一下和闭包有关的其他概念，下面是我推荐的一些关于闭包讲解的链接：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener\">MDN-Lexical scoping</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\" target=\"_blank\" rel=\"noopener\">学习Javascript闭包（Closure）</a></li>\n<li><a href=\"http://web.jobbole.com/88167/\" target=\"_blank\" rel=\"noopener\">让我们一起学习JavaScript闭包吧</a></li>\n<li><a href=\"http://www.jb51.net/article/83524.htm\" target=\"_blank\" rel=\"noopener\">一分钟理解js闭包</a></li>\n<li><a href=\"http://rainfall.blog.51cto.com/8402174/1344225\" target=\"_blank\" rel=\"noopener\">理解js闭包是为了避免使用闭包</a></li>\n<li><a href=\"https://stackoverflow.com/questions/111102/how-do-javascript-closures-work\" target=\"_blank\" rel=\"noopener\">Stackoverflow-How do JavaScript closures work?</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"前端面试系列（11）——window.onload和document.ready的区别","slug":"前端面试系列（11）——window.onload和document.ready的区别","date":"2017-04-12T09:14:30.000Z","updated":"2019-02-02T10:19:58.050Z","comments":true,"path":"api/articles/前端面试系列（11）——window.onload和document.ready的区别.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_11.png","content":"<p>这个问题虽然比较简单，但是依然是前端面试中经常会问到的一道题，所以为了让自己“与众不同”，必须全面了解这两者的区别，才能从众多候选人中脱颖而出</p>\n<h2 id=\"一张表格\"><a href=\"#一张表格\" class=\"headerlink\" title=\"一张表格\"></a>一张表格</h2><p>下面这张表格简单的介绍了两者的区别：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>window.onload()</th>\n<th>$(document).ready()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>执行时机</td>\n<td>在页面所有元素（包括图片，引用文件）加载完后执行</td>\n<td>页面中所有HTML DOM，CSS DOM结构加载完之后就会执行，其他图片等内容可能没有加载完</td>\n</tr>\n<tr>\n<td>编写个数</td>\n<td>不能同时写多个，后面的将会覆盖前面的</td>\n<td>可以同时写多个</td>\n</tr>\n<tr>\n<td>简写</td>\n<td>无</td>\n<td>$().ready(function(){}) // $()不带参数默认是document；$(function(){})</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"jQ-的-document-ready-实现\"><a href=\"#jQ-的-document-ready-实现\" class=\"headerlink\" title=\"jQ 的 document.ready() 实现\"></a>jQ 的 document.ready() 实现</h2><p>在 jQuery 脚本加载的时候，会监听 DOMContentLoaded 事件。当事件触发时候，会执行 ready 事件的回调；（document.readyState === “complete” 时相当于 dom 加载完毕<br>由于用的是原生的 DOMContentLoaded 事件，所以<strong>目前的 ready 函数仅能用于当前 document，无需选择器</strong></p>\n<h2 id=\"谁更快\"><a href=\"#谁更快\" class=\"headerlink\" title=\"谁更快\"></a>谁更快</h2><p>jQuery 的 document.ready 就一定比 window.onload 快吗？下面是一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en-US\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>加载时机<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">onload</span>=<span class=\"string\">\"console.log('jquery.js loaded')\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">'define functions'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\">type, info</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"built_in\">console</span>.log(type + <span class=\"string\">' onload '</span> + (info || <span class=\"string\">\"\"</span>), <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">     $(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'document ready'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">document</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'document'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;;    </span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'window'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"load\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'window addEventListener'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"built_in\">document</span>.addEventListener( <span class=\"string\">\"DOMContentLoaded\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          load(<span class=\"string\">'DOMContentLoaded'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('body')\"</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('text')\"</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('img',1)\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.deskcar.com/desktop/else/2013714232149/17.jpg\"</span> /&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('img',2)\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.deskcar.com/desktop/else/2013714232149/16.jpg\"</span> /&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"load('js')\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/react/15.2.0/react.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"执行之后有两种结果：\"><a href=\"#执行之后有两种结果：\" class=\"headerlink\" title=\"执行之后有两种结果：\"></a>执行之后有两种结果：</h3><h4 id=\"首次加载：\"><a href=\"#首次加载：\" class=\"headerlink\" title=\"首次加载：\"></a>首次加载：</h4><div align=\"center\"><img src=\"/images/hexo_post_11.png\" alt=\"\" width=\"400\"></div>\n\n<h4 id=\"二次加载：\"><a href=\"#二次加载：\" class=\"headerlink\" title=\"二次加载：\"></a>二次加载：</h4><div align=\"center\"><img src=\"/images/hexo_post_12.png\" alt=\"\" width=\"400\"></div>\n\n<p>第一种情况非常符合我们的想法，ready 比 onload 快，顺序也比较合理。而第二种情况就有些怪异，应该依照上面 jquery ready 事件的实现，那 ready 应该要 DOMContentLoaded 后面啊。我思来想去，我觉得这是个误会，由于二次加载时利用到缓存，导致文件资源都很快加载，各个事件触发的时间非常相近，顺序也不定，就给人一种 ready 顺序不对之感，大家应该发现这几个事件都是在几十毫秒之内触发。PS：js 执行需要时间，几十毫秒不同的顺序我觉得很正常。另外尝试几次，二次加载顺序确实会有变化，但时间都很相近。所以，jQuery 的 document ready 不一定比 window.onload 快执行。</p>\n<h2 id=\"为什么外部-script-文件放页面内容后面好？\"><a href=\"#为什么外部-script-文件放页面内容后面好？\" class=\"headerlink\" title=\"为什么外部 script 文件放页面内容后面好？\"></a>为什么外部 script 文件放页面内容后面好？</h2><h3 id=\"script-执行顺序\"><a href=\"#script-执行顺序\" class=\"headerlink\" title=\"script 执行顺序\"></a>script 执行顺序</h3><blockquote>\n<p>无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照 <code>&lt;script&gt;</code> 元素在页面中出现的先后顺序对它们依次进行解析。——《JavaScript高级程序设计》</p>\n</blockquote>\n<p>换句话说，在第一个 <code>&lt;script&gt;</code> 元素包含的代码解析完成后，第二个 <code>&lt;script&gt;</code> 包含代码才会被解析，然后才是第三个…..<br>如果在 head 元素里包含所有 JavaScript 文件，就必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能呈现页面的内容（浏览器在遇到 <code>&lt;body&gt;</code> 标签时才开始呈现内容）。在有 JavaScript 文件时候，浏览器呈现页面会出现明显的延迟，延时期间浏览器是一片空白。所以，外部 script 文件放页面内容后面。这样，在解析 JavaScript 代码之前，页面内容将完全呈现出来。</p>\n<h3 id=\"一定是放页面内容后面吗？\"><a href=\"#一定是放页面内容后面吗？\" class=\"headerlink\" title=\"一定是放页面内容后面吗？\"></a>一定是放页面内容后面吗？</h3><p>有种情况是 JavaScript 放哪里都一样的，那就是内容是依赖 JavaScript 的执行渲染时候，放哪都一样。所以我们需要尽量避免在 JS 中对 dom 进行修改，对于性能优化有比较大的帮助。</p>\n<h2 id=\"Load-方法\"><a href=\"#Load-方法\" class=\"headerlink\" title=\"Load() 方法\"></a>Load() 方法</h2><p>由于在 $(document).ready() 方法内注册的事件，只要 DOM 就绪就会被执行，因此可能此时元素的关联文件未下载完。例如与图片有关的 html 下载完毕，并且已经解析为 DOM 树了，但很有可能图片还没有加载完毕，所以例如图片的高度和宽度这样的属性此时不一定有效。要解决这个问题，可以使用 Jquery 中另一个关于页面加载的方法—— load() 方法。Load() 方法会在元素的 onload 事件中绑定一个处理函数。如果处理函数绑定给 window 对象，则会在所有内容（包括窗口、框架、对象和图像等）加载完毕后触发，如果处理函数绑定在元素上，则会在元素的内容加载完毕后触发。</p>\n<h2 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h2><ul>\n<li>$(window).load()：等价于 window.onload()</li>\n<li>$(window).unload()：页面关闭时触发</li>\n</ul>\n<h2 id=\"坑爹的-IE-or-jQ？\"><a href=\"#坑爹的-IE-or-jQ？\" class=\"headerlink\" title=\"坑爹的 IE or jQ？\"></a>坑爹的 IE or jQ？</h2><p>最近在改一个嵌入在 iframe 中的页面的时候，使用了 jquery 做效果，而页面本身也绑定了 onload 事件。改完后，Firefox 下测试正常流畅，IE 下就要等个十几秒 jquery 的效果才出现，黄花菜都凉了。起初以为是和本身 onload 加载的方法冲突。网上普遍的说法是 $(document).ready() 是在页面 DOM 解析完成后执行，而 onload 事件是在所有资源都准备完成之后才执行，也就是说 $(document).ready() 是要在 onload 之前执行的，尤其当页面图片较大较多的时候，这个时间差可能更大。可是我这页面分明是图片都显示出来十几秒了，还不见 jquery 的效果出来。 删了 onload 加载的方法试试，结果还是一样，看来没有必要把原本的 onload 事件绑定也改用 $(document).ready() 来写。那是什么原因使得 Firefox 正常而 IE 就能呢？接着调试，发现 IE 下原来绑定的 onload 方法竟然先于 $(document).ready() 的内容执行，而 Firefox 则是先执行 $(document).ready() 的内容，再执行原来的 onload 方法。这个和网上的说法似乎不完全一致啊，走投无路的时候就看看源码，翻翻 jQuery 的源码看看 $(document).ready() 是如何实现的吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( jQuery.browser.msie &amp;&amp; <span class=\"built_in\">window</span> == top ) (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">if</span> (jQuery.isReady) <span class=\"keyword\">return</span>; </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\"><span class=\"built_in\">document</span>.documentElement.doScroll(<span class=\"string\">\"left\"</span>); </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>( error ) &#123; </span><br><span class=\"line\">　　　　　　setTimeout( <span class=\"built_in\">arguments</span>.callee, <span class=\"number\">0</span> ); </span><br><span class=\"line\">　　　　　　 <span class=\"keyword\">return</span>; </span><br><span class=\"line\">　　　　&#125; </span><br><span class=\"line\">　　 <span class=\"comment\">// and execute any waiting functions </span></span><br><span class=\"line\">　　　jQuery.ready(); </span><br><span class=\"line\">&#125;)(); </span><br><span class=\"line\">jQuery.event.add( <span class=\"built_in\">window</span>, <span class=\"string\">\"load\"</span>, jQuery.ready );</span><br></pre></td></tr></table></figure>\n<p>结果很明了了，IE 只有在页面不是嵌入 iframe 中的情况下才和 Firefox 等一样，先执行 $(document).ready() 的内容，再执行原来的 onload 方法。对于嵌入 iframe 中的页面，也只是绑定在 load 事件上执行，所以自然是在原来的 onload 绑定的方法执行之后才轮到。而这个页面中正好在测试环境下有一个访问不到的资源，那十几秒的延迟正是它放大出的时间差。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.jb51.net/article/50185.htm\" target=\"_blank\" rel=\"noopener\">一张表格告诉你windows.onload()与$(document).ready()的区别</a></li>\n<li><a href=\"http://www.cnblogs.com/lovesong/p/5641834.html\" target=\"_blank\" rel=\"noopener\">jQuery的document ready与 onload事件——你真的思考过吗？</a></li>\n</ul>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"读书笔记系列（7）——JavaScript半知半解","slug":"读书笔记系列（7）——JavaScript半知半解","date":"2017-04-25T15:33:09.000Z","updated":"2019-02-02T10:19:58.054Z","comments":true,"path":"api/articles/读书笔记系列（7）——JavaScript半知半解.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这本书是我无意中看到的一本电子版书籍，但是第一章就吸引到了我，然后就对作者展开了深入“挖掘”，通过作者的<a href=\"http://ghmagical.com/\" target=\"_blank\" rel=\"noopener\">个人博客</a>发现作者是一个很厉害的技术开发人员，不管是前端还是后台都有所涉猎，所以推荐大家去他的个人博客逛逛，同时推荐他的两本书籍：《JavaScript半知半解》和《Web实战》，一定会有所收获</p>\n<h2 id=\"1-完整的-JavaScript\"><a href=\"#1-完整的-JavaScript\" class=\"headerlink\" title=\"1. 完整的 JavaScript\"></a>1. 完整的 JavaScript</h2><p>完整的 JavaScript 实现由下列三个不同的部分组成：</p>\n<ul>\n<li>核心（<strong>ECMAScript</strong>）</li>\n<li>文档对象模型（<strong>DOM</strong>）</li>\n<li>浏览器对象模型（<strong>BOM</strong>）</li>\n</ul>\n<h2 id=\"2-lt-script-gt-元素\"><a href=\"#2-lt-script-gt-元素\" class=\"headerlink\" title=\"2. &lt;script&gt; 元素\"></a>2. <code>&lt;script&gt;</code> 元素</h2><p>向 HTML 页面中插入 JavaScript 的主要方法，就是使用 <code>&lt;script&gt;</code> 元素。<code>&lt;script&gt;</code> 中定义了下列 6 个属性：</p>\n<ul>\n<li><strong><code>async</code></strong>：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效</li>\n<li><strong><code>charset</code></strong>：可选，表示通过 src 属性指定的代码的字符集，比较少用。</li>\n<li><strong><code>defer</code></strong>：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li>\n<li><strong><code>language</code></strong>：已废弃</li>\n<li><strong><code>src</code></strong>：可选，表示包含要执行代码的外部文件</li>\n<li><strong><code>type</code></strong>：可选，表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。在 HTML5 中，默认是 text/javascript，所以不需要设置。</li>\n</ul>\n<h2 id=\"3-在使用-lt-script-gt-嵌入-JavaScript-代码时，切记不要在代码中的任何地方出现-lt-script-gt\"><a href=\"#3-在使用-lt-script-gt-嵌入-JavaScript-代码时，切记不要在代码中的任何地方出现-lt-script-gt\" class=\"headerlink\" title=\"3. 在使用 &lt;script&gt; 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 &lt;/script&gt;\"></a>3. 在使用 <code>&lt;script&gt;</code> 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 <code>&lt;/script&gt;</code></h2><p>执行下面的代码时，会产生一个错误：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  alert('</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-JavaScript-代码的执行顺序\"><a href=\"#4-JavaScript-代码的执行顺序\" class=\"headerlink\" title=\"4. JavaScript 代码的执行顺序\"></a>4. JavaScript 代码的执行顺序</h2><p>只要不存在 defer 和 async 属性，JavaScript 代码就会从上至下依次解析。带有 src 属性的 <code>&lt;script&gt;</code> 元素不应该在其 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签之间再包含额外的 JavaScript 代码，嵌入代码会被忽略。<strong>只要不存在 defer 和 async 属性，浏览器都会按照 <code>&lt;script&gt;</code> 出现的先后顺序对它们依次进行解析。</strong> 一般将全部 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中页面的内容后面。</p>\n<h2 id=\"5-延迟脚本\"><a href=\"#5-延迟脚本\" class=\"headerlink\" title=\"5. 延迟脚本\"></a>5. 延迟脚本</h2><p>当给 <code>&lt;script&gt;</code> 元素添加了 <code>defer</code> 属性时，src 指向的外部文件会立即下载，但包含的脚本会延迟到浏览器遇到 <code>&lt;/html&gt;</code> 标签（整个页面解析完毕）后再执行（按添加顺序执行），会先于 DOMContentLoaded 事件执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span>=<span class=\"string\">\"defer\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>会先执行 example.js，然后执行 example2.js。</p>\n<blockquote>\n<p>注意：defer 只适合外部脚本文件。</p>\n</blockquote>\n<h2 id=\"6-异步脚本\"><a href=\"#6-异步脚本\" class=\"headerlink\" title=\"6. 异步脚本\"></a>6. 异步脚本</h2><p><code>async</code> 与 <code>defer</code> 属性类似，都用于改变处理脚本的行为，适用于外部脚本文件，并告诉浏览器立即下载，但标记为 <code>async</code> 的脚本并不保证按照指定它们的先后顺序执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">\"example2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>两个执行顺序不定</strong>。指定 <code>async</code> 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p>\n<blockquote>\n<p>注意：异步脚本不要在加载期间修改 DOM。 <strong>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行</strong>。</p>\n</blockquote>\n<h2 id=\"7-元素\"><a href=\"#7-元素\" class=\"headerlink\" title=\"7. 元素\"></a>7. <noscript>元素</noscript></h2><p>当浏览器不支持 JavaScript 或被禁用时，显示里面的内容。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\"> 本页面需要浏览器支持（启用）JavaScript</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"8-关键字和保留字\"><a href=\"#8-关键字和保留字\" class=\"headerlink\" title=\"8. 关键字和保留字\"></a>8. 关键字和保留字</h2><p>ECMA-262 描述了一组具有特定用途的<strong>关键字</strong>，这些关键字可用于控制语句的开始或结束，或者用于执行特定操作等，不能用作标识符。</p>\n<blockquote>\n<p>break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try</p>\n</blockquote>\n<p>ECMA-262 还描述了一组不能用作标识符的<strong>保留字</strong>：</p>\n<blockquote>\n<p>abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public</p>\n</blockquote>\n<p>如果使用关键字作标识符，会导致 “Identifier Expected” 错误。 有些时候，我们不得不用到保留字货关键字的，比如 CSS 样式中的 float，这时就需要这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style.cssFloat</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-隐式全局变量\"><a href=\"#9-隐式全局变量\" class=\"headerlink\" title=\"9. 隐式全局变量\"></a>9. 隐式全局变量</h2><p>在下面的代码中，由于从右至左的操作符优先级，所以表达式 “b=0” 是先执行的，而此时b未经过声明，所以它会成为全局变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>\n<p>关于全局变量：</p>\n<ul>\n<li>使用 var 创建的全局变量不能删除。</li>\n<li>不是 var 创建的隐含全局变量可以使用 delete 删除（因为它并不是真正的变量，而是全局对象 window 的属性）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> b;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">//  0</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// ReferenceError: b is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-变量提升\"><a href=\"#10-变量提升\" class=\"headerlink\" title=\"10. 变量提升\"></a>10. 变量提升</h2><p><strong>变量提升</strong>是指所有变量的声明语句，都会被提升到代码的头部。 在函数内也一样，函数中的所有变量声明会在函数执行时被“提升”至函数体顶端：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>结果是不是有点出乎你的意料。其实 JavaScript 的执行环境分为<strong>声明阶段</strong>和<strong>执行阶段</strong>，因此对于上面的代码，JavaScript 会这样解释代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-typeof-操作符\"><a href=\"#11-typeof-操作符\" class=\"headerlink\" title=\"11. typeof 操作符\"></a>11. typeof 操作符</h2><p><strong><code>typeof</code></strong>操作符用来检测给定变量的数据类型，可能的返回值：</p>\n<ul>\n<li>“undefined” –&gt; 这个值未定义</li>\n<li>“boolean” –&gt; 这个值是布尔值</li>\n<li>“string” –&gt; 这个值是字符串</li>\n<li>“number” –&gt; 这个值是数值</li>\n<li>“object” –&gt; 这个值是对象或 <strong>null</strong></li>\n<li>“function” –&gt; 这个值是函数</li>\n</ul>\n<h2 id=\"12-undefined-和-null-类型\"><a href=\"#12-undefined-和-null-类型\" class=\"headerlink\" title=\"12. undefined 和 null 类型\"></a>12. undefined 和 null 类型</h2><p><code>Undefined</code> 类型只有一个值，即特殊的 <code>undefined</code>；<code>Null</code> 类型也是只有一个值的数据类型，这个特殊值就是 <code>null</code>；null 和 undefined 没有属性，甚至连 toString() 这种标准方法都没有；undefined 其实是派生自 null 值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"13-Boolean\"><a href=\"#13-Boolean\" class=\"headerlink\" title=\"13. Boolean()\"></a>13. Boolean()</h2><p>要将一个值转换为其对应的 Boolean 值，可以使用转型函数 Boolean()；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'tg'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Boolean</span>(name);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>可以对任何类型的值调用 Boolean 函数，而且总会返回一个 Boolean 值（true 或 false）<strong>转换规则</strong>：</p>\n<ul>\n<li>对于 true 或 false，返回原值（true 或 false）</li>\n<li>对于 String 类型的值，任何非空字符串返回 true，空字符串（””）返回 false</li>\n<li>对于 Number 类型的值，任何非零数字值（包括无穷大），返回 true；0 和 NaN 返回 false</li>\n<li>对于 Object 类型的值，任何对象返回 true，null 返回 false</li>\n<li>对于 Undefined 类型，undefined 返回 false（只有一个值）</li>\n</ul>\n<h2 id=\"14-浮点数值\"><a href=\"#14-浮点数值\" class=\"headerlink\" title=\"14. 浮点数值\"></a>14. 浮点数值</h2><p>保存浮点数值需要的内存空间是保存整数值的两倍。 默认情况下，ECMAScript 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示的数值。 浮点数的最高精度是 17 位小数（所以浮点数的比较比较麻烦）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> = <span class=\"number\">0.3000000000000004</span>; <span class=\"comment\">// 不是等于0.3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"15-数值范围\"><a href=\"#15-数值范围\" class=\"headerlink\" title=\"15. 数值范围\"></a>15. 数值范围</h2><p>ECMAScript 能够表示的最小数值保存在 <code>Number.MIN_VALUE</code>（最小值）中，这个值是 5e-324；能够表示的最大数值保存在 <code>Number.MAX_VALUE</code>（最大值）中，这个值是 1.7976931348623157e+308</p>\n<blockquote>\n<p>注意：Infinity 是不能参与计算的数值。用 <code>isFinite()</code> 来判断这个值是否无穷，该函数接受一个参数。如果参数位于最小与最大数值之间，返回 true。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isFinite</span>(<span class=\"number\">1</span>));  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isFinite</span>(<span class=\"literal\">Infinity</span>));  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"16-NaN\"><a href=\"#16-NaN\" class=\"headerlink\" title=\"16. NaN\"></a>16. NaN</h2><p>NaN（Not a Number）表示非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 注意点：</p>\n<ul>\n<li>任何涉及 NaN 的操作都会返回 NaN。</li>\n<li>NaN 与任何值都不相等，包括 NaN 本身。</li>\n<li>任何操作数与 NaN 比较，都会返回 false</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>);  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>我们可以用 <code>isNaN()</code> 函数来判断是否非数值，该函数接受一个参数，可以是任何类型。<code>isNaN()</code> 在接收到\b这个参数之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，比如：字符串 “10” 或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"number\">10</span>));  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(<span class=\"string\">'blue'</span>));  <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"17-Number\"><a href=\"#17-Number\" class=\"headerlink\" title=\"17. Number()\"></a>17. Number()</h2><p><strong>Number() 函数的转换规则</strong>：</p>\n<ul>\n<li>如果是 Boolean 值，true 和 false 将分别转换为 1 和 0</li>\n<li>如果是数字值，只是简单的传入和返回</li>\n<li>如果是 null 值，返回 0</li>\n<li>如果是 undefined，返回 NaN</li>\n<li>如果是字符串，遵循下列规则： （<ul>\n<li>如果是字符串中只包含数字（包括前面带正负号），则将其转换为十进制数值（前导的零会被忽略）</li>\n<li>如果字符串中包含有效的浮点格式，如 1.1，则将其转换为对应的浮点数值</li>\n<li>如果字符串中包含有效的十六进制，如 0xf，则将其转换为相同大小的十进制数值</li>\n<li>如果字符串是空的，返回0</li>\n<li>如果字符串中包含上述格式以外的字符，返回 NaN ）</li>\n</ul>\n</li>\n<li>如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回字符串值</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">'tg'</span>));   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">''</span>));   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"string\">'0011'</span>));  <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"literal\">true</span>));   <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>一元加操作符的操作与 Number 函数规则相同</p>\n<h2 id=\"18-parseInt-和-parseFloat\"><a href=\"#18-parseInt-和-parseFloat\" class=\"headerlink\" title=\"18. parseInt() 和 parseFloat()\"></a>18. parseInt() 和 parseFloat()</h2><p><code>parseInt()</code> 会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回 NaN。如果第一个字符是数字字符，就会继续解析，直到解析完所有后续字符或者遇到了一个非数字字符。 <code>parseInt()</code> 也能识别八进制（在 ECMAScript 5 中无法识别，将开头的 0 当作 0）和十六进制，最后会转换成十进制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'123tg'</span>));  <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">''</span>));   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'070'</span>));  <span class=\"comment\">// 70</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'0xf'</span>));  <span class=\"comment\">//15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"number\">22.5</span>));  <span class=\"comment\">// 22</span></span><br></pre></td></tr></table></figure>\n<p>我们还可以为 <code>parseInt()</code> 提供第二个参数，指定需要转换的进制（刷算法题的时候经常用到）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'0xAF'</span>,<span class=\"number\">16</span>));  <span class=\"comment\">// 175</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'AF'</span>,<span class=\"number\">16</span>));  <span class=\"comment\">// 175</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'AF'</span>));  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'070'</span>,<span class=\"number\">8</span>));  <span class=\"comment\">// 56</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"string\">'70'</span>,<span class=\"number\">8</span>));  <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n<p><code>parseFloat()</code> 和 <code>parseInt()</code> 类似，也是从第一个字符（位置 0）开始解析每个字符，而且一直解析到字符串末尾，或者解析到遇到一个无效的浮点数字字符为止，换句话说，字符串中的第一个小数点是有效的，后面的小数点是无效的，它还会忽略前导的零，只会解析十进制值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'123tg'</span>));  <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'22.12.4'</span>));   <span class=\"comment\">// 22.12</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'070'</span>));  <span class=\"comment\">// 70</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"string\">'0xf'</span>));  <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseFloat</span>(<span class=\"number\">22.5</span>));  <span class=\"comment\">// 22.5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"19-Object-类型\"><a href=\"#19-Object-类型\" class=\"headerlink\" title=\"19. Object 类型\"></a>19. Object 类型</h2><p>在 ECMAScript 中，<code>Object</code> 类型是所有对象的基础。<code>Object</code> 的每个实例都具有下列属性和方法：</p>\n<ul>\n<li><strong><code>Constructor</code></strong>：保存着用于创建当前对象的函数，比如上面的例子，构造函数就是 Object()</li>\n<li><strong><code>hasOwnProperty(propertyName)</code></strong>：用于检查给定的属性在当前对象实例中是否存在（而不是在实例的原型中），参数必须是字符串形式</li>\n<li><strong><code>isPrototypeOf(object)</code></strong>：用于检查传入的对象是否是另一个对象的原型</li>\n<li><strong><code>propertyIsEnumerable(propertyName)</code></strong>：用于检查给定的属性是否能够使用 for-in 语句来枚举，参数必须是字符串形式</li>\n<li><strong><code>toLocaleString()</code></strong>：返回对象的字符串表示，该字符串与执行环境的地区对应</li>\n<li><strong><code>toString()</code></strong>：返回对象的字符串表</li>\n<li><strong><code>valueOf()</code></strong>：返回对象的字符串、数值或布尔值表示，通常和 toString() 返回的值相同</li>\n</ul>\n<h2 id=\"20-递增和递减\"><a href=\"#20-递增和递减\" class=\"headerlink\" title=\"20. 递增和递减\"></a>20. 递增和递减</h2><p>递减和递增操作符会遵循下列规则：</p>\n<ul>\n<li>当操作数是一个包含有效数字字符的字符串，系统会将其转换为数字值，再执行递减或递增。</li>\n<li>当操作数是一个不包含有效数字字符的字符串，系统将变量的值设置为 NaN</li>\n<li>当操作数是布尔值，会将其转为数值（true 转为 1，false 转为 0）再操作。</li>\n<li>当操作数是浮点数值，直接执行递减或递增</li>\n<li>当操作数是对象，先调用对象的 valueOf() 方法取得一个可供操作的值，然后再遵循上面的三条规则。如果结果是 NaN，则在调用 toString() 方法后再遵循上面的规则转换。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'2'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  valueOf: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a++;  <span class=\"comment\">// 3</span></span><br><span class=\"line\">b++;  <span class=\"comment\">// NaN</span></span><br><span class=\"line\">c--;  <span class=\"comment\">// -1</span></span><br><span class=\"line\">d--;  <span class=\"comment\">// 0.10000000000000009 （浮点数操作结果，类似0.1+0.2 != 0.3）</span></span><br><span class=\"line\">o--;  <span class=\"number\">-2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"21-按位非（NOT）\"><a href=\"#21-按位非（NOT）\" class=\"headerlink\" title=\"21. 按位非（NOT）\"></a>21. 按位非（NOT）</h2><p>位运算符并不直接操作 64 位的值，而是先将 64 位的值转换为 32 位，然后执行操作，最后将结果转换回 64 位。按位非（否运算）就是<strong>一个数与自身的取反值相加，等于 -1</strong>。</p>\n<p>~3 + 3 = -1 =&gt; -1 - 3 = -4 == ~3</p>\n<h2 id=\"22-位运算符\"><a href=\"#22-位运算符\" class=\"headerlink\" title=\"22. 位运算符\"></a>22. 位运算符</h2><p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。</p>\n<p>##23. 逻辑与（&amp;&amp;）</p>\n<p>逻辑与（&amp;&amp;）有两个操作数，如果是布尔值，只有两个都是 true 时，才会返回 true，否则返回 false；逻辑与操作属于短路操作，也就是说如果第一个操作数能够决定结果（等于 false 时），就不会再对第二个操作数求值，如果不是布尔值，它遵循下面的规则：</p>\n<ul>\n<li>如果第一个操作数是对象，则返回第二个操作数</li>\n<li>如果第二个操作数是对象，则只有在第一个操作数的求值为 true 时才会返回第二个操作数</li>\n<li>如果有一个操作数是 null，则返回 null</li>\n<li>如果有一个操作数是 NaN，则返回 NaN</li>\n<li>如果有一个操作数是 undefined，则返回 undefined</li>\n</ul>\n<p>逻辑与操作符也就是先将第一个操作数转换为 Boolean 类型判断是 true 或 false，再根据结果决定是否执行第二个操作数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> &amp;&amp; <span class=\"string\">'tg'</span> ;  <span class=\"comment\">//  0</span></span><br><span class=\"line\">&#123;&#125; &amp;&amp; <span class=\"string\">'tg'</span>;  <span class=\"comment\">// \"tg\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"24-乘法运算符\"><a href=\"#24-乘法运算符\" class=\"headerlink\" title=\"24. 乘法运算符\"></a>24. 乘法运算符</h2><p>乘法运算符(<code>*</code>)，用于计算两个数值的乘积。 处理特殊值时，乘法运算符会遵循下列规则：</p>\n<ul>\n<li>如果操作数都是数值，但乘积超过了 ECMAScript 数值范围，则返回 Infinity 或 -Infinity</li>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果是 Infinity 乘以 0，结果是 NaN</li>\n<li>如果是 Infinity 与非 0 数值相乘，结果是 Infinity 或 -Infinity，取决于非0数值的符号</li>\n<li>如果是 Infinity 与 Infinity 相乘，结果是 Infinity</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> * <span class=\"literal\">NaN</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"literal\">Infinity</span> * <span class=\"number\">2</span>);  <span class=\"comment\">// Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> * <span class=\"number\">0</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> * <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"24-除法运算符\"><a href=\"#24-除法运算符\" class=\"headerlink\" title=\"24. 除法运算符\"></a>24. 除法运算符</h2><p>除法运算符（/），执行第二个操作数除第一个操作数计算。 处理特殊值，规则如下：</p>\n<ul>\n<li>如果操作数都是数值，但商超过了 ECMAScript 的表示范围，则返回 Infinity 或 -Infinity</li>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果是 Infinity 被 Infinity 除，结果是 NaN</li>\n<li>如果是零被零除，结果是 NaN</li>\n<li>如果是非零的有限数被零除，结果是 Infinity 或 -Infinity，取决于有符号的操作数</li>\n<li>如果是 Infinity 被任何非零数值除，结果是 Infinity 或 -Infinity</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> / <span class=\"number\">1</span>); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0</span> / <span class=\"number\">0</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> / <span class=\"number\">0</span>);  <span class=\"comment\">//  Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> / <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> / <span class=\"literal\">Infinity</span>);  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">Infinity</span> / <span class=\"number\">2</span>);   <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"25-求模\"><a href=\"#25-求模\" class=\"headerlink\" title=\"25. 求模\"></a>25. 求模</h2><p>求模（余数）运算符（%） 处理特殊值，规则如下：</p>\n<ul>\n<li>如果被除数是无穷大值而除数是有限大的数值，结果是 NaN</li>\n<li>如果被除数是有限大的数值而除数是零，结果是 NaN</li>\n<li>如果是 Infinity 被 Infinity 除，结果是 NaN</li>\n<li>如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数</li>\n<li>如果被除数是零，结果是零</li>\n<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">5</span> % <span class=\"number\">3</span>);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"26-减法\"><a href=\"#26-减法\" class=\"headerlink\" title=\"26. 减法\"></a>26. 减法</h2><p>减法运算符（-） 对于特殊值，减法操作会遵循下列规则：</p>\n<ul>\n<li>如果有一个操作数是 NaN，结果是 NaN</li>\n<li>如果 Infinity 减 Infinity，结果是 NaN</li>\n<li>如果是 -Infinity 减 -Infinity，结果是 NaN</li>\n<li>如果是 Infinity 减 -Infinity，结果是 Infinity</li>\n<li>如果是 -Infinity 减 Infinity，结果是 -Infinity</li>\n<li>如果是 +0 减 +0，结果是 +0</li>\n<li>如果是 -0 加 -0，结果是 +0</li>\n<li>如果是 +0 减 -0，结果是 -0</li>\n<li>如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 将其转换为数值，然后遵循上面的规则进行计算。</li>\n<li>如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值；如果该对象没有 valueOf() 方法，则调用其 toString() 方法将得到的字符串转换为数值，然后遵循上面的规则进行计算。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> - <span class=\"literal\">true</span>;  <span class=\"comment\">// 4 （true转换成1）</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"string\">'2'</span>    <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"literal\">null</span>;  <span class=\"comment\">// 5（null转换成0）</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"27-逗号运算符\"><a href=\"#27-逗号运算符\" class=\"headerlink\" title=\"27. 逗号运算符\"></a>27. 逗号运算符</h2><p>逗号运算符多用于声明多个变量。逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = (<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>);  <span class=\"comment\">// num的值为3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"28-标签语句\"><a href=\"#28-标签语句\" class=\"headerlink\" title=\"28. 标签语句\"></a>28. 标签语句</h2><p>语句是可以添加标签的，标签是由语句前的标识符和冒号组成：</p>\n<blockquote>\n<p><strong>label</strong> : statement</p>\n</blockquote>\n<p>label 语句定义的标签一般由 break 或 continue 语句引用。加标签的语句一般要与 for 等循环语句配合使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">tip : <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">  num += i;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);  <span class=\"comment\">//  轮流输出：0、1、2、3、4、5</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i ==<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span> tip;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num);  <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>当执行到 i = 5 时，会跳出循环，也就是 tip 对应的层，然后执行其下方的代码。</p>\n<h2 id=\"29-with-语句\"><a href=\"#29-with-语句\" class=\"headerlink\" title=\"29. with 语句\"></a>29. with 语句</h2><p><code>with</code> 语句用于临时扩展作用域链，也就是将代码的作用域设置到一个特定的对象中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span>(object)&#123;   </span><br><span class=\"line\">  statement  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将 object 添加到作用域链的头部，然后执行 statement，最后把作用域链恢复到原生状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'tg'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">24</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span>(o)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'name：'</span> + name);  <span class=\"comment\">// name：tg</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'age：'</span> + age);  <span class=\"comment\">// age：24</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>with 里面的 name 相当于 o.name。</p>\n<blockquote>\n<p>注意：在严格模式中是禁止使用 with 语句的，因为 with 语句性能非常差，不推荐使用。</p>\n</blockquote>\n<h2 id=\"30-debugger-语句\"><a href=\"#30-debugger-语句\" class=\"headerlink\" title=\"30. debugger 语句\"></a>30. debugger 语句</h2><p>debugger 语句用来产生一个断点（breakpoint），JavaScript 代码的执行会停止在断点的位置。一般用来调试代码。</p>\n<h2 id=\"31-对象\"><a href=\"#31-对象\" class=\"headerlink\" title=\"31. 对象\"></a>31. 对象</h2><p><strong>键名</strong>：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  <span class=\"string\">'1a'</span> : <span class=\"string\">'a'</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，如果键名 ‘1a’ 不用引号引起来，就会报错。注意：为了避免这种歧义，JavaScript 规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。</p>\n<h2 id=\"32-创建对象\"><a href=\"#32-创建对象\" class=\"headerlink\" title=\"32. 创建对象\"></a>32. 创建对象</h2><p>在 JavaScript 中，有三种方法创建对象</p>\n<ul>\n<li>对象直接量： var o={};</li>\n<li>关键字new： var o=new Object();</li>\n<li>Object.create() 函数： var o=Object.create(null)</li>\n</ul>\n<h3 id=\"提取方法\"><a href=\"#提取方法\" class=\"headerlink\" title=\"提取方法\"></a>提取方法</h3><p>如果对对象中的方法进行提取，则会失去与对象的连接。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.get());  <span class=\"comment\">//  \"a\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = obj.get;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func());  <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，object 对象中有一个方法 get()，用来获取 obj 对象中的 name，而当 get() 方法赋值给一个变量 func，再调用 func() 函数时，此时的 this 是指向 window 的，而非 obj 的。注意：如果在严格模式下，this 会是 undefined。</p>\n<h3 id=\"属性特性\"><a href=\"#属性特性\" class=\"headerlink\" title=\"属性特性\"></a>属性特性</h3><ul>\n<li>可写（writable attribute）：可设置该属性的值。</li>\n<li>可枚举（enumerable attribute）：可通过 for / in 循环返回该属性。</li>\n<li>可配置（configurable attribute）：可删除或修改属性。</li>\n</ul>\n<h3 id=\"查看所有属性\"><a href=\"#查看所有属性\" class=\"headerlink\" title=\"查看所有属性\"></a>查看所有属性</h3><p>查看一个对象本身的所有属性，可以使用 Object.keys 方法，返回一个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  age : <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(o)  <span class=\"comment\">// ['name','age']</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h3><p>delete 运算符可以删除对象的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.name  <span class=\"comment\">//true</span></span><br><span class=\"line\">o.name  <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：delete 运算符只能删除自有属性，不能删除继承属性。 删除一个不存在的属性，delete 不报错，而且返回 true。只有一种情况，delete 命令会返回 false，那就是该属性存在，且不得删除。</p>\n</blockquote>\n<h2 id=\"33-序列化对象\"><a href=\"#33-序列化对象\" class=\"headerlink\" title=\"33. 序列化对象\"></a>33. 序列化对象</h2><p>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 在 JavaScript 中，提供了内置函数 <strong>JSON.stringify()</strong> 和 <strong>JSON.parse()</strong> 用来序列化和还原 JavaScript 对象。NaN、Infinity 和 -Infinity 序列化的结果是 null</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  age : <span class=\"number\">12</span>,</span><br><span class=\"line\">  intro : \\[<span class=\"literal\">false</span>,<span class=\"literal\">null</span>,<span class=\"string\">''</span>\\]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s= <span class=\"built_in\">JSON</span>.stringify(o)  <span class=\"comment\">// s &#123;\"name\":\"a\",\"age\":12,\"intro\":[false,null,\"\"]&#125;</span></span><br><span class=\"line\">p=<span class=\"built_in\">JSON</span>.parse(s)  <span class=\"comment\">// p是o的深拷贝</span></span><br></pre></td></tr></table></figure>\n<p>注意：JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。</p>\n<h2 id=\"34-原型\"><a href=\"#34-原型\" class=\"headerlink\" title=\"34. 原型\"></a>34. 原型</h2><p>每一个 JavaScript 对象（null 除外）都和另一个对象相关联，也可以说，继承另一个对象。另一个对象就是我们熟知的“原型”（prototype），每一个对象都从原型继承属性。只有 null 除外，它没有自己的原型对象。所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。比如：通过 new Object() 创建的对象继承自 Object.prototype；通过 new Array() 创建的对象的原型就是 Array.prototype。没有原型的对象为数不多，Object.prototype 就是其中之一，它不继承任何属性。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。</p>\n<h2 id=\"35-空位\"><a href=\"#35-空位\" class=\"headerlink\" title=\"35. 空位\"></a>35. 空位</h2><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在<strong>空位</strong>（hole）。如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [,,];</span><br><span class=\"line\">arr.length  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"36-类数组对象\"><a href=\"#36-类数组对象\" class=\"headerlink\" title=\"36. 类数组对象\"></a>36. 类数组对象</h2><p>在 JavaScript 中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用 length 属性，但是它们并不是数组，无法使用一些数组的方法。<code>类数组对象</code>有一个特征，就是具有 length 属性。换句话说，只要有 length 属性，就可以认为这个对象类似于数组。但是，对象的 length 属性不是动态值，不会随着成员的变化而变化。典型的类似数组的对象是函数的 <strong>arguments 对象</strong>，以及<strong>大多数 DOM 元素集</strong>，还有<strong>字符串</strong>。</p>\n<h2 id=\"37-函数表达式\"><a href=\"#37-函数表达式\" class=\"headerlink\" title=\"37. 函数表达式\"></a>37. 函数表达式</h2><p>采用函数表达式声明函数时，function 命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"38-函数被提前\"><a href=\"#38-函数被提前\" class=\"headerlink\" title=\"38. 函数被提前\"></a>38. 函数被提前</h2><p>就像变量的“被提前”一样，函数声明语句也会“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。在函数提升中，函数体也会跟着提升（不像变量一样，只会提升变量声明），这也是我们可以引用后面声明的函数的原因。 此外，<strong>以表达式定义的函数并没有“被提前”，而是以变量的形式“被提前”</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f();  </span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>\n<p>变量其实是分为声明，赋值两部分的，上面的代码等同于下面的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f;</span><br><span class=\"line\">f();</span><br><span class=\"line\">f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"39-实参对象\"><a href=\"#39-实参对象\" class=\"headerlink\" title=\"39. 实参对象\"></a>39. 实参对象</h2><p><code>arguments</code> 类数组中每一个元素的值会与对应的命名参数的值保持同步，这种影响是单向的，也可以这样说，<strong>如果是修改 <code>arguments</code> 中的值，会影响到命名参数的值，但是修改命名参数的值，并不会改变 <code>arguments</code> 中对应的值</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);    <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] = <span class=\"literal\">null</span>;   </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);    <span class=\"comment\">// null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p><code>arguments</code> 并不是真正的数组，它只是类数组对象（有 length 属性且可使用索引来访问子项）。但我们可以借助 Array 类的原型对象的 slice 方法，将其转为真正的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 更简洁的写法</span></span><br><span class=\"line\">[].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"40-函数的属性、方法\"><a href=\"#40-函数的属性、方法\" class=\"headerlink\" title=\"40. 函数的属性、方法\"></a>40. 函数的属性、方法</h2><h3 id=\"name-属性\"><a href=\"#name-属性\" class=\"headerlink\" title=\"name 属性\"></a>name 属性</h3><p>name 属性返回紧跟在 function 关键字之后的那个函数名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">f.name   <span class=\"comment\">// f</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"length-属性\"><a href=\"#length-属性\" class=\"headerlink\" title=\"length 属性\"></a>length 属性</h3><p>函数的 length 属性是只读属性，代表函数形参的数量，也就是在函数定义时给出的形参个数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x,y</span>)</span>&#123;&#125;</span><br><span class=\"line\">f.length  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"41-立即调用的函数表达式（IIFE）\"><a href=\"#41-立即调用的函数表达式（IIFE）\" class=\"headerlink\" title=\"41. 立即调用的函数表达式（IIFE）\"></a>41. 立即调用的函数表达式（IIFE）</h2><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：</p>\n<ul>\n<li>一是不必为函数命名，避免了污染全局变量；</li>\n<li>二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li>\n</ul>\n<h2 id=\"42-Object-对象的静态方法\"><a href=\"#42-Object-对象的静态方法\" class=\"headerlink\" title=\"42. Object 对象的静态方法\"></a>42. Object 对象的静态方法</h2><p><code>Object.keys()</code> 方法和 <code>Object.getOwnPropertyNames()</code> 方法一般用来遍历对象的属性，它们的参数都是一个对象，返回一个数组，该数组的项都是对象自身的（不是继续原型的）的所有属性名。两者的区别在于， <code>Object.keys()</code> 只返回可枚举的属性，<code>Object.getOwnPropertyNames()</code> 方法还返回不可枚举的属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(arr));  <span class=\"comment\">// [\"0\", \"1\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(arr)); <span class=\"comment\">// [\"0\", \"1\", \"length\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"43-splice\"><a href=\"#43-splice\" class=\"headerlink\" title=\"43. splice()\"></a>43. splice()</h2><p><code>splice()</code> 用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素，该方法会改变原数组。第一个参数是删除的起始位置，如果是负数，就表示从倒数位置开始删除 第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如只是单纯地插入元素，splice 方法的第二个参数可以设为 0。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>));  <span class=\"comment\">// [\"b\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"c\", \"d\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'f'</span>));   <span class=\"comment\">// [\"b\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"f\", \"c\", \"d\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"string\">'h'</span>));  <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);  <span class=\"comment\">// [\"a\", \"h\", \"b\", \"c\", \"d\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"44-some-、every\"><a href=\"#44-some-、every\" class=\"headerlink\" title=\"44. some()、every()\"></a>44. some()、every()</h2><p><code>some()</code> 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是 true，则整个 some 方法的返回值就是 true，否则 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v == <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>every()</code> 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是 true，才返回 true，否则 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v == <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool);  <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bool2 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (v &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool2);  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>some 和 every 方法还可以接受第二个参数，用来绑定函数中的 this 关键字。</p>\n<h2 id=\"45-基本包装类型\"><a href=\"#45-基本包装类型\" class=\"headerlink\" title=\"45. 基本包装类型\"></a>45. 基本包装类型</h2><p>ECMAScript 提供了三个基本包装类型：<code>Boolean</code>、<code>Number</code>、<code>String</code>。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能过调用一些方法来操作这些数据。执行步骤如下：</p>\n<ol>\n<li>创建那个类型的一个实例</li>\n<li>在实例上调用指定的方法</li>\n<li>销毁这个实例</li>\n</ol>\n<p>引用类型与基本包装类型的区别在于对象的生存期：使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁，这也是我们不能再运行时为基本类型值添加属性和方法的原因。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'tg'</span>;</span><br><span class=\"line\">s.age =<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.age);  <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码执行输出的是 undefined，这是音乐第二行创建的 String 对象在执行第三行代码时已经被销毁了，第三行又创建自己的 String 对象，而该对象没有 age 属性。</p>\n<h2 id=\"46-Boolean-类型\"><a href=\"#46-Boolean-类型\" class=\"headerlink\" title=\"46. Boolean 类型\"></a>46. Boolean 类型</h2><p>即使你使用 false 创建一个 Boolean 实例对象，当进行逻辑运算时，它会被转为 true，因为它是一个对象，而所有对象在逻辑运算中都会返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(bool)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"47-document-referrer\"><a href=\"#47-document-referrer\" class=\"headerlink\" title=\"47. document.referrer\"></a>47. document.referrer</h2><p>document.referrer 属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。 注：HTTPS 默认会关闭 referrer，需要通过 meta 来设置，设置方法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"referrer\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"always\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"48-数据集（dataset）属性\"><a href=\"#48-数据集（dataset）属性\" class=\"headerlink\" title=\"48. 数据集（dataset）属性\"></a>48. 数据集（dataset）属性</h2><p>在 HTML5 文档中，任意以 “data-” 为前缀的小写的属性名字都是合法的。 HTML5 还在 Element 对象上定义了 dataset 属性。该属性指代一个对象，它的各个属性对应于去掉前缀的 data-属性。因此 dataset.x 应该保存 data-x 属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test 属性就变成 dataset.jqueryTest 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"top\"</span> <span class=\"attr\">data-tip</span>=<span class=\"string\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'top'</span>);</span><br><span class=\"line\">t.dataset.tip  <span class=\"comment\">//title</span></span><br><span class=\"line\">t.dataset.tip = <span class=\"string\">'title2'</span></span><br></pre></td></tr></table></figure>\n<p>注意：dataset 属性是元素的 data-属性 的实时、双向接口。设置或删除 dataset 的一个属性就等同于设置或移除对应元素的 data-属性。</p>\n<h2 id=\"49-addEventListener\"><a href=\"#49-addEventListener\" class=\"headerlink\" title=\"49. addEventListener()\"></a>49. addEventListener()</h2><p>调用 addEventListener() 并不会影响 onclick 属性的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mybutton\"</span>&gt;</span>点击<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mybutton'</span>);</span><br><span class=\"line\">v.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;alert(<span class=\"string\">'1'</span>);&#125;</span><br><span class=\"line\">v.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">'2'</span>);&#125;,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，单击按钮会产生两个 alert() 对话框。 能通过多次调用 addEventListener() 方法为同一个对象注册同一事件类型的多个处理程序函数。</p>\n<h2 id=\"50-调用顺序\"><a href=\"#50-调用顺序\" class=\"headerlink\" title=\"50. 调用顺序\"></a>50. 调用顺序</h2><p>文档元素或其他对象可以指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照下面的规则调用所有的事件处理程序：</p>\n<ul>\n<li>通过设置对象属性或 HTML 属性注册的处理程序一直优先调用。</li>\n<li>使用 addEventListener() 注册的处理程序按照它们的注册顺序调用。</li>\n<li>使用 attachEvent() 注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。</li>\n</ul>\n<h2 id=\"51-进度事件\"><a href=\"#51-进度事件\" class=\"headerlink\" title=\"51. 进度事件\"></a>51. 进度事件</h2><p>进度事件用来描述一个事件进展的过程。比如 XMLHttpRequest 对象发出的 HTTP 请求的过程，<code>&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;</code> 加载外部资源的过程。下载和上传都会发生进度事件。进度事件有以下几种：</p>\n<ul>\n<li>abort 事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。</li>\n<li>error 事件：由于错误导致资源无法加载时触发。</li>\n<li>load 事件：进度成功结束时触发。</li>\n<li>loadstart 事件：进度开始时触发。</li>\n<li>loaden d事件：进度停止时触发，发生顺序排在 error 事件 / abort 事件 / load 事件后面。</li>\n<li>progress 事件：当操作处于进度之中，由传输的数据块不断触发。</li>\n<li>timeout 事件：进度超过限时触发。</li>\n</ul>\n<h2 id=\"52-JSON-语法\"><a href=\"#52-JSON-语法\" class=\"headerlink\" title=\"52. JSON 语法\"></a>52. JSON 语法</h2><p>JSON 对值的类型和格式有严格的规定：</p>\n<ul>\n<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li>\n<li>简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和 null（不能使用 NaN, Infinity, -Infinity 和 undefined）。</li>\n<li>字符串必须使用双引号表示，不能使用单引号。</li>\n<li>对象的键名必须放在双引号里面。</li>\n<li>数组或对象最后一个成员的后面，不能加逗号。</li>\n</ul>\n<h2 id=\"53-上传文件\"><a href=\"#53-上传文件\" class=\"headerlink\" title=\"53. 上传文件\"></a>53. 上传文件</h2><p>如果要允许选择多个文件，可设置 file 控件的 multiple 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">multiple</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"54-同源策略\"><a href=\"#54-同源策略\" class=\"headerlink\" title=\"54. 同源策略\"></a>54. 同源策略</h2><p>同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 <code>&lt;iframe&gt;</code> 元素或打开其他浏览器窗口的时候，这一策略通常就会发挥作用。所谓“同源”指的是”三个相同“。</p>\n<ul>\n<li><strong>协议</strong>相同</li>\n<li><strong>域名</strong>相同</li>\n<li><strong>端口</strong>相同</li>\n</ul>\n<p>从不同 Web 服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用 http:协议 载入的文档和使用 https:协议 载入的文档具有不同的来源，即使它们来自同一个服务器。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<h2 id=\"55-获取表单元素\"><a href=\"#55-获取表单元素\" class=\"headerlink\" title=\"55. 获取表单元素\"></a>55. 获取表单元素</h2><p>获取表单元素一般有两种方式：</p>\n<ul>\n<li>通过 id 来获取，比如获取一个 id 名为 form1 的表单元素：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'form1'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 docuemnt.forms 获取 name 名为 form1 的表单元素：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.forms[<span class=\"string\">\"form1\"</span>]</span><br></pre></td></tr></table></figure>\n<p><code>document.forms</code> 可以获取到当前页面中所有的表单元素，我们又可以通过方括号表示法获取某个属性，传入数值索引或 <code>name</code> 值。</p>\n<h2 id=\"56-重置表单\"><a href=\"#56-重置表单\" class=\"headerlink\" title=\"56. 重置表单\"></a>56. 重置表单</h2><p>重置表单也有两种方式：</p>\n<h3 id=\"重置按钮\"><a href=\"#重置按钮\" class=\"headerlink\" title=\"重置按钮\"></a>重置按钮</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"reset\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"reset\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当点击重置按钮时，会触发 reset 事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form1.onreset = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过-reset-方法\"><a href=\"#通过-reset-方法\" class=\"headerlink\" title=\"通过 reset() 方法\"></a>通过 reset() 方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form1.reset();</span><br></pre></td></tr></table></figure>\n<p>与调用 submit() 不同，调用 reset() 方法时也会触发 reset 事件。</p>\n<h2 id=\"57-离线检测\"><a href=\"#57-离线检测\" class=\"headerlink\" title=\"57. 离线检测\"></a>57. 离线检测</h2><p>HTML5 定义了一个 <code>navigator.onLine</code> 属性，用来检测设备是在线还是离线，为 true 时表示设备能上网，否则表示设备离线。 检测代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.onLine)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正常工作</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设备已离线</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了 <code>navigator.onLine</code> 属性，HTML5 还为检测网络是否可用提供了两个事件：<code>online</code> 和 <code>offline</code>。</p>\n<ul>\n<li><code>online</code>：当网络从离线变为在线时触发</li>\n<li><code>offline</code>：当网络从在线变为离线时触发</li>\n</ul>\n<h2 id=\"58-应用缓存\"><a href=\"#58-应用缓存\" class=\"headerlink\" title=\"58. 应用缓存\"></a>58. 应用缓存</h2><p>HTML5 的应用缓存（application cache），简称：appcache，是专门为开发离线 Web 应用而设计的。 Appcache 就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。<code>manifest</code> 文件可分为三个部分：</p>\n<ul>\n<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>\n<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>\n<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"># 需要缓存的列表</span><br><span class=\"line\">test.css</span><br><span class=\"line\">test.jpg</span><br><span class=\"line\">test.js</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\"># 不需要缓存的</span><br><span class=\"line\">test2.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\"># 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件 *.html /offline.html</span><br><span class=\"line\">2.jpg/3.jpg</span><br></pre></td></tr></table></figure>\n<p>注意：manifest 文件的 <code>MIME</code> 类型必须是 “text/cache-manifest”。</p>\n<blockquote>\n<p>描述文件的扩展名以前推荐用 manifest，现在推荐用 appcache</p>\n</blockquote>\n<h2 id=\"59-localStorage-和-sessionStorage\"><a href=\"#59-localStorage-和-sessionStorage\" class=\"headerlink\" title=\"59. localStorage 和 sessionStorage\"></a>59. localStorage 和 sessionStorage</h2><p><code>localStorage</code> 和 <code>sessionStorage</code>这两个属性都代表同一个 Storage 对象（一个持久化关联数组，数组使用字符串来索引，存储的值都是字符串形式的）。</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>通过 <code>localStorage</code> 存储的数据是永久性的，除非Web应用刻意删除存储的数据或用户通过设置浏览器设置来删除，否则数据将一直保留在用户的电脑里，永不过期。<code>localStorage</code> 的作用域是限定在文档源（document origin）级别。 同源的文档间共享同样的 <code>localStorage</code> 数据。</p>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p><code>sessionStorage</code> 的作用域同样是限定在文档源中，不过它被限定在窗口中。也就是说，如果同源的文档在不同的浏览器标签页中，那它们互相之间拥有的是各自的 <code>sessionStorage</code> 数据，无法共享。</p>\n<p>注意：基于窗口作用域的 <code>sessionStorage</code> 指的窗口只是顶级窗口。如果一个浏览器标签页包含多个 <code>&lt;iframe&gt;</code> 元素，它们包含的文档是同源的，两者之间的 sessionStorage 是可共享的。</p>\n<h2 id=\"60-finally-子句\"><a href=\"#60-finally-子句\" class=\"headerlink\" title=\"60. finally 子句\"></a>60. finally 子句</h2><p>当使用 <code>finally</code> 子句时，其代码无论如何都会执行，也就是说，不管是正常执行还是出错了，<code>finally</code> 子句都会执行。甚至 <code>return</code> 语句，也不会阻止 <code>finally</code> 子句的执行。看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(error)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test()); </span><br><span class=\"line\"><span class=\"comment\">//结果</span></span><br><span class=\"line\">a</span><br><span class=\"line\">c</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>从运行结果，我们可以看到，<code>return</code> 语句并没有阻止 <code>finally</code> 子句的执行，而且是在 <code>finally</code> 子句执行后才会返回 <code>return</code> 语句的值。</p>\n","raw":null,"categories":[{"name":"js","path":"api/categories/js.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"笔记","path":"api/tags/笔记.json"}]}]}