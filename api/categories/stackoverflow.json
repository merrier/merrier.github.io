{"name":"stackoverflow","postlist":[{"title":"SSH connect to github fail解决方案","slug":"SSH connect to github fail解决方案","date":"2017-08-20T13:22:16.000Z","updated":"2019-02-28T12:34:16.856Z","comments":true,"path":"api/articles/SSH connect to github fail解决方案.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_280.png","content":"<p>来自于<a href=\"https://stackoverflow.com/questions/21488137/ssh-connect-to-github-fail\" target=\"_blank\" rel=\"noopener\">stackoverflow上的一个问题</a>，有位仁兄在命令行中输入了如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>然而报错了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh: Could not resolve hostname github.com: nodename nor servname provided, or not known</span><br></pre></td></tr></table></figure>\n<p>其实，之前就有人碰到过 ssh fail 的问题，报错的原因是 <strong>DNS 服务器设置</strong>的问题，将 DNS 地址设置为 OpenDNS 或者 Google DNS 就可以了：</p>\n<blockquote>\n<p>OpenDNS 208.67.222.222 208.67.220.220 GoogleDNS 8.8.8.8 8.8.4.4</p>\n</blockquote>\n<p>下面就介绍一下在 Mac 中如何设置 DNS（来自文章<a href=\"http://www.howtogeek.com/howto/38793/how-to-switch-mac-os-x-to-use-opendns-or-google-dns/\" target=\"_blank\" rel=\"noopener\">How to Switch Mac OS X to Use OpenDNS or Google DNS</a>）：</p>\n<h2 id=\"首先，系统偏好设置-网络\"><a href=\"#首先，系统偏好设置-网络\" class=\"headerlink\" title=\"首先，系统偏好设置-网络\"></a>首先，系统偏好设置-网络</h2><div align=\"center\"><img src=\"/images/hexo_post_280.png\" alt=\"\" width=\"400\"></div>\n\n<h2 id=\"点击高级选项\"><a href=\"#点击高级选项\" class=\"headerlink\" title=\"点击高级选项\"></a>点击高级选项</h2><div align=\"center\"><img src=\"/images/hexo_post_281.png\" alt=\"\" width=\"400\"></div>\n\n\n<h2 id=\"DNS-添加按钮\"><a href=\"#DNS-添加按钮\" class=\"headerlink\" title=\"DNS-添加按钮\"></a>DNS-添加按钮</h2><div align=\"center\"><img src=\"/images/hexo_post_282.png\" alt=\"\" width=\"400\"></div>\n\n<p>设置为上面我们提到的 OpenDNS 或 GoogleDNS 地址中的一个就可以啦~</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"Github","path":"api/tags/Github.json"},{"name":"dns","path":"api/tags/dns.json"},{"name":"ssh","path":"api/tags/ssh.json"}]},{"title":"let和var到底有什么区别？","slug":"let和var到底有什么区别？","date":"2017-08-04T08:10:14.000Z","updated":"2019-02-28T12:34:16.856Z","comments":true,"path":"api/articles/let和var到底有什么区别？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>问题来自于stackoverflow：<a href=\"https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var-to-declare-a-variable\" target=\"_blank\" rel=\"noopener\">What’s the difference between using “let” and “var” to declare a variable?</a> 我们都知道 ES6 中引入了 let 声明，而 let 也一直被认为是声明“局部变量”，那么 let 和 var 到底有什么区别呢？</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>首先，从其定义本身，其区别之一是起作用的范围： var 起作用的范围是其最近的方法体，而 let 起作用的范围是其最近的包围块，所谓的“包围块”是有可能比方法体小的。但是<strong>如果都是全局作用域上声明的话，var 和 let 起作用的范围其实是一样的</strong> 除此之外，用 let 声明的变量在它们被声明之前是无法访问到的（有点类似于严格模式），举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'globalVar: '</span> + globalVar);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'globalLet: '</span> + globalLet);</span><br><span class=\"line\"><span class=\"keyword\">var</span> globalVar = <span class=\"string\">'globalVar'</span>;  <span class=\"comment\">//globalVar: undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> globalLet = <span class=\"string\">'globalLet'</span>;  <span class=\"comment\">//Uncaught ReferenceError: globalLet is not defined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"作为全局变量\"><a href=\"#作为全局变量\" class=\"headerlink\" title=\"作为全局变量\"></a>作为全局变量</h2><p>和 var 不同，用 let 声明的“全局变量”将不会作为属性赋给 window，简单的栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'go'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"string\">'able'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.me); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.i); <span class=\"comment\">// 'able'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在函数中声明\"><a href=\"#在函数中声明\" class=\"headerlink\" title=\"在函数中声明\"></a>在函数中声明</h2><p>当它们在函数体中声明时是一样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ingWithinEstablishedParameters</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> funclet = <span class=\"string\">'funclet'</span>; <span class=\"comment\">//作用域为函数体内部</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> funcvar = <span class=\"string\">'funcvar'</span>; <span class=\"comment\">//作用域为函数体内部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在循环体中声明\"><a href=\"#在循环体中声明\" class=\"headerlink\" title=\"在循环体中声明\"></a>在循环体中声明</h2><p>当我们在循环体中声明变量（例如 for）时，var 和 let 是有显著区别的：let 只在循环体内部可访问，而 var 在整个方法体中都可访问。还是个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allyIlliterate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//tuce在这里不可访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> tuce = <span class=\"number\">0</span>; tuce &lt; <span class=\"number\">5</span>; tuce++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//tuce只能在这里访问得到</span></span><br><span class=\"line\">        <span class=\"comment\">//所以每次循环之后tuce的值都会变</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//tuce在这里也不可访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">byE40</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//nish在这里可以访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">var</span> nish = <span class=\"number\">0</span>; nish &lt; <span class=\"number\">5</span>; nish++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//nish在整个方法体中都可以访问得到</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//nish在这里也可以访问</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明覆盖\"><a href=\"#声明覆盖\" class=\"headerlink\" title=\"声明覆盖\"></a>声明覆盖</h2><p>在严格模式下，var 允许你重新给一个变量赋值，但是 let 不允许：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> me = <span class=\"string\">'bar'</span>; <span class=\"comment\">// SyntaxError: Identifier 'me' has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"string\">'bar'</span>; <span class=\"comment\">// 没毛病，现在me就是bar了</span></span><br></pre></td></tr></table></figure>\n<p>虽然 let 和 var 在某些情况下是一样的行为表现，但还是推荐大家多使用 let，逐渐放弃 var 的使用。</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"ES6","path":"api/tags/ES6.json"}]},{"title":"为什么随机字符串“chucknorris”会被识别为红色？","slug":"为什么随机字符串“chucknorris”会被识别为红色？","date":"2017-08-01T10:35:30.000Z","updated":"2019-02-28T12:34:16.856Z","comments":true,"path":"api/articles/为什么随机字符串“chucknorris”会被识别为红色？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_274.png","content":"<p>这个问题来源于 <a href=\"https://stackoverflow.com/questions/8318911/why-does-html-think-chucknorris-is-a-color\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>，就是有位学者无意中发现随机字符串会被 html 识别为特定的一些颜色，于是就在 stackoverflow 发起了讨论，这个问题也引起了我的兴趣，虽然是一个比较偏的知识点，但是了解一下还是没坏处的。</p>\n<h2 id=\"题目解释\"><a href=\"#题目解释\" class=\"headerlink\" title=\"题目解释\"></a>题目解释</h2><p>从下图我们可以看到，“chucknorris” 是一个随机的字符串，但是 body 却被渲染成了红色，是不是很有趣？</p>\n<div align=\"center\"><img src=\"/images/hexo_post_274.png\" alt=\"\" width=\"600\"></div>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先你需要知道 css 中的颜色值是十六进制的（比如最通常的白色：”#FFFFFF”，黑色：”#000000”），所以对于随机的字符串来说，其中有可能会包含不属于十六进制字母的那些字母（比如 h、u、k 等等），那么就会有如下的规则对“随机字符串颜色”进行替换（以随机字符串 “chucknorris” 为例）：</p>\n<h3 id=\"首先，用’0’替换所有的非十六进制字母\"><a href=\"#首先，用’0’替换所有的非十六进制字母\" class=\"headerlink\" title=\"首先，用’0’替换所有的非十六进制字母\"></a>首先，用’0’替换所有的非十六进制字母</h3><p>chucknorris -&gt; c00c0000000  </p>\n<h3 id=\"然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加-‘0’，比如上面的-“c00c0000000”-就只有-11-个字母，需要在尾部添加一个-‘0’）\"><a href=\"#然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加-‘0’，比如上面的-“c00c0000000”-就只有-11-个字母，需要在尾部添加一个-‘0’）\" class=\"headerlink\" title=\"然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加 ‘0’，比如上面的 “c00c0000000” 就只有 11 个字母，需要在尾部添加一个 ‘0’）\"></a>然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加 ‘0’，比如上面的 “c00c0000000” 就只有 11 个字母，需要在尾部添加一个 ‘0’）</h3><p>c00c 0000 0000  </p>\n<h3 id=\"最后，对于每一组内的字符串，只取前两位字母作为最终的-“R”、“G”、“B”-的值\"><a href=\"#最后，对于每一组内的字符串，只取前两位字母作为最终的-“R”、“G”、“B”-的值\" class=\"headerlink\" title=\"最后，对于每一组内的字符串，只取前两位字母作为最终的 “R”、“G”、“B” 的值\"></a>最后，对于每一组内的字符串，只取前两位字母作为最终的 “R”、“G”、“B” 的值</h3><p>c00c 0000 0000 -&gt; RGB(c0, 00, 00)</p>\n<p>所以，最终的结果是 #c00000/rgb(192,0,0),就是最开始那张图显示的深红色。</p>\n<h2 id=\"还没完\"><a href=\"#还没完\" class=\"headerlink\" title=\"还没完\"></a>还没完</h2><p>所以这个问题的答案就是一个歇后语：王八的屁股——规定！当然了，对于那种不足六个字母的颜色值来说，就会有额外的处理规则了：#aaa -&gt; #aaaaaa、#aaa3 -&gt; #aaa300、#aaa35 -&gt; #aaa350，有一个“很有想法”的哥们专门为这个转换做了一个网页，可以<a href=\"http://randomstringtocsscolor.com/\" target=\"_blank\" rel=\"noopener\">点击这里</a>试玩一下，输入任意的字符串可以看到背景颜色的变化，同时可以看到最终的颜色值</p>\n<div align=\"center\"><img src=\"/images/hexo_post_275.png\" alt=\"\" width=\"500\"></div>","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"CSS","path":"api/tags/CSS.json"},{"name":"计算机基础","path":"api/tags/计算机基础.json"}]},{"title":"在JS中如何清空一个数组？","slug":"在JS中如何清空一个数组？","date":"2017-08-04T07:30:29.000Z","updated":"2019-02-28T12:34:16.860Z","comments":true,"path":"api/articles/在JS中如何清空一个数组？.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_277.png","content":"<p>问题来源于stackoverflow：<a href=\"https://stackoverflow.com/questions/1232040/how-do-i-empty-an-array-in-javascript\" target=\"_blank\" rel=\"noopener\">How do I empty an array in JavaScript?</a>。更多关于JS中数组的相关操作参见：<a href=\"/20170322/summary-of-array-method-in-js.html\">JS中数组方法总结</a> 比如我有如下数组：<code>A = [1, 2, 3, 4]</code>; 我如何清空它？</p>\n<h2 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A = [];\"></a>A = [];</h2><p>这个答案应该很好想到，因为很符合“从问题本身出发”的逻辑，既然我们想清空数组 A，那就清空喽~ 但是这个方法有一个弊端：如果你之前通过引用的方式 copy 了数组A，那么即使通过 <code>A = []</code> 将数组 A 清空了，你的引用变量也还是 A 原来的值，理论知识总是难理解，举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1;  <span class=\"comment\">//arr2是arr1的一个引用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2 === arr1)  <span class=\"comment\">//arr2和arr1共享内存地址</span></span><br><span class=\"line\">arr1 = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);  <span class=\"comment\">//['a', 'b', 'c', 'd', 'e', 'f']，此时arr2和arr1就互相不认识了</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"A-length-0\"><a href=\"#A-length-0\" class=\"headerlink\" title=\"A.length = 0\"></a>A.length = 0</h2><p>因为在 JS 中数组其实也是一个对象（所谓的“数组对象”），而每个数组都有一个 length 属性，这是一个可读写的属性，将其置为 0 之后就可以清空数组。同时它的引用变量也将被清空：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'f'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1;  <span class=\"comment\">// 我胡汉三又来引用了</span></span><br><span class=\"line\">arr1.length = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);  <span class=\"comment\">//[]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);  <span class=\"comment\">//[]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1 === arr2)  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"A-splice-0-A-length\"><a href=\"#A-splice-0-A-length\" class=\"headerlink\" title=\"A.splice(0, A.length)\"></a>A.splice(0, A.length)</h2><p>和上面的通过 length 清空类似，该方法也将同时清空数组 arr2。不同点在于，.splice() 方法将返回一个数组</p>\n<h2 id=\"while-和-pop\"><a href=\"#while-和-pop\" class=\"headerlink\" title=\"while 和 .pop()\"></a>while 和 .pop()</h2><p>这是一个比较“愚蠢”的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(A.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    A.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法同样会清空数组 arr2，但是也是效率最低的一种方法</p>\n<h2 id=\"while和-shift\"><a href=\"#while和-shift\" class=\"headerlink\" title=\"while和.shift()\"></a>while和.shift()</h2><p>一般“愚蠢”的方法不止一种。。：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(A.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    A.shift();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h2><p>可以<a href=\"http://jsben.ch/hyj65\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看这四种方法的性能测试结果，或者直接看下图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_277.png\" alt=\"\" width=\"500\"></div>\n\n<p>从图中可以很明显的看出来，<code>A.length = 0;</code> 这种方法是效率最高的，效率最低的是 pop 和 shift（不出所料啊。。）</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"数组","path":"api/tags/数组.json"}]},{"title":"jQuery事件：不要再(滥)用return false了","slug":"jQuery事件：不要再(滥)用return false了","date":"2017-08-03T10:25:21.000Z","updated":"2019-02-28T12:34:16.856Z","comments":true,"path":"api/articles/jQuery事件：不要再(滥)用return false了.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>无意中在 stackoverflow 上看到一个<a href=\"https://stackoverflow.com/questions/1357118/event-preventdefault-vs-return-false\" target=\"_blank\" rel=\"noopener\">关于jQuery中event.preventDefault()和return false的提问</a>，后来从评论中发现一篇<a href=\"https://web.archive.org/web/20160614140933/http://fuelyourcoding.com/jquery-events-stop-misusing-return-false/\" target=\"_blank\" rel=\"noopener\">关于这个问题的很不错的文章</a>，遂翻译了一下，希望能够帮助大家更好的理解 jQuery 中的 return false；当你刚开始学习 jQuery 中的事件时，也许你首先碰到的知识点就是“取消浏览器的默认行为”这一概念。比如，一个讲 click 的初级教程里可能会有如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a.toggle\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">\"#mydiv\"</span>).toggle();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 禁止浏览器访问'#'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面这个方法动态的控制 #mydiv 的显示与隐藏，然后取消了浏览器的默认行为——访问锚标签的 href，这是一个非常简单的例子，同时也让很多前端小白养成了使用 return false 取消浏览器默认行为的习惯。关于取消浏览器事件这一问题，我将从以下两个主题重点讲解：</p>\n<ul>\n<li>使用正确的方法：return false、preventDefault、stopPropagation 和 stopImmediatePropagation</li>\n<li>头部、底部或中间某个位置：我们应该在事件回调函数的哪个位置取消默认行为？</li>\n</ul>\n<h2 id=\"使用正确的方法\"><a href=\"#使用正确的方法\" class=\"headerlink\" title=\"使用正确的方法\"></a>使用正确的方法</h2><p>之所以 return false 被大量滥用，是因为它确实满足了我们的需求——超链接不再跳转，表单也不再提交等等，那么为什么我说好多人都误用了呢？</p>\n<h3 id=\"return-false-到底做了什么\"><a href=\"#return-false-到底做了什么\" class=\"headerlink\" title=\"return false 到底做了什么\"></a>return false 到底做了什么</h3><p>首先，大部分人都没有搞明白的是，jQuery 中的 return false 其实做了下面三件事：</p>\n<ol>\n<li><strong>event.preventDefault();</strong></li>\n<li><strong>event.stopPropagation();</strong></li>\n<li><strong>阻止剩下的代码执行，同时立即返回</strong></li>\n</ol>\n<p>“等一下”。你是不是很惊讶，大部分人用 return false 其实只是为了阻止默认行为，也就是上面的第一件事，另外两件其实根本不需要。上面3件事中，只有 event.preventDefault() 会取消默认行为。除非你真的打算阻止事件冒泡，否则使用 return false 将大大增加你的代码的脆弱性。让我们来看看现实应用中这种滥用是如何产生的： 我们有如下HTML代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"post\"</span>&gt;</span><br><span class=\"line\">    &lt;h2&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path/to/page\"</span>&gt;</span>My Page<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"content\"</span>&gt;</span><br><span class=\"line\">        Teaser text...</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>div&gt;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"post\"</span>&gt;</span><br><span class=\"line\">    &lt;h2&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path/to/other_page\"</span>&gt;</span>My Other Page<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"content\"</span>&gt;</span><br><span class=\"line\">        Teaser text...</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>现在我们想实现这样的功能：当用户点击标题链接时，跳转到相应的 div.content 上面，我们可能会写出这样的 jQuery 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$</span>) </span>&#123;</span><br><span class=\"line\">   $(<span class=\"string\">\"div.post h2 a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> a = $(<span class=\"keyword\">this</span>),</span><br><span class=\"line\">          href = a.attr(<span class=\"string\">'href'</span>), <span class=\"comment\">// \b获取href,</span></span><br><span class=\"line\">          content  = a.parent().next();</span><br><span class=\"line\">      content.load(href + <span class=\"string\">\" #content\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 取消链接跳转这种默认行为</span></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>目前，我们的页面一切正常。然后，我们又想要添加一个功能：当 div.post（或者它的子元素）被点击时，给当前被点击的 div.post 添加一个 “active” 类。所以，我们需要添加一个 click 事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> posts = $(<span class=\"string\">\"div.post\"</span>);</span><br><span class=\"line\">posts.click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    posts.removeClass(<span class=\"string\">\"active\"</span>);  <span class=\"comment\">// \b移除所有div.post的active类</span></span><br><span class=\"line\">    $(<span class=\"keyword\">this</span>).addClass(<span class=\"string\">\"active\"</span>);  <span class=\"comment\">// 给当前的div.post添加active类</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在测试一下，当我们点击标题链接的时候，它会起作用吗？不会！它不能起作用的原因是我们在点击事件中 return false 了。而 return false 实际上意味着执行了 event.preventDefault() 和 event.stopPropagation()。所以点击事件不会冒泡到 div.post 上，从而我们新添加的事件将不起作用。 当我们将正常绑定的事件和 live 以及 delegate 绑定的事件混用时，它也会出现问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).live(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的代码将不起作用</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"我们真正想要实现什么？\"><a href=\"#我们真正想要实现什么？\" class=\"headerlink\" title=\"我们真正想要实现什么？\"></a>我们真正想要实现什么？</h3><h4 id=\"preventDefault\"><a href=\"#preventDefault\" class=\"headerlink\" title=\"preventDefault()\"></a>preventDefault()</h4><p>在大多数场景下，当我们使用 return false 的时候，我们真正想要的其实是 e.preventDefault()。使用 preventDefault 的前提是你允许在你的函数中访问事件对象（在后面的例子中以 e 表示事件对象）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// e代表我们的事件对象</span></span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个方法就可以是实现取消默认行为，但是它不能阻止事件冒泡。但是，代码的功能越单一，它的可维护性就更强</p>\n<h4 id=\"stopPropagation\"><a href=\"#stopPropagation\" class=\"headerlink\" title=\"stopPropagation()\"></a>stopPropagation()</h4><p>有些时候我们只是想阻止事件冒泡，比如下面的栗子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"post\"</span>&gt;</span></span><br><span class=\"line\">    Normal text and then a <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/path\"</span>&gt;</span>link<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> and then more text.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在，比如我们有一个非常“奇特”的需求：我们想让用户点击 div 中除了链接之外的任何地方都干一件事（可能是重定向到其他页面），然后还想让用户点击链接的时候可以正常跳转（从可用性的角度来看，这是一个非常糟糕的 idea。因为如果用户本意想点击链接却点到了其他地方，接下来发生的事情可能会让用户很吃惊，影响用户体验）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"div.post\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div.post a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在这里不要取消默认行为</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要阻止事件冒泡</span></span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，如果我们用 return false，那 div 的点击事件将永远不会触发，这样用户就不会被引导到正确的页面。</p>\n<h4 id=\"stopImmediatePropagation\"><a href=\"#stopImmediatePropagation\" class=\"headerlink\" title=\"stopImmediatePropagation()\"></a>stopImmediatePropagation()</h4><p>这个函数将阻止事件的进一步执行，即使是同一对象上绑定的不同事件。因为绑定到一个 dom 元素的所有事件都将按照它们被绑定的顺序执行。下面是一个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Do something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Do something else</span></span><br><span class=\"line\">   e.stopImmediatePropagation();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 这里将不会执行</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">$(<span class=\"string\">\"div\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 这里也不会执行</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你认为这个例子看起来太假了，不得不说，是很假。然而，有时候这种情况确实会发生。当你构造更加复杂的代码时，代码结构会变得比较混乱，不同的组件和插件可能会给同一个 dom 元素添加事件。在这种情况下，正确的理解和使用 stopImmediatePropagation() 就显得尤为重要了。</p>\n<h4 id=\"return-false\"><a href=\"#return-false\" class=\"headerlink\" title=\"return false\"></a>return false</h4><p>只有当你同时需要 preventDefault() 和 stopPaopagation() 时，才需要使用 return false。与此同时，你的代码应该保证只有到回调函数的尾部才取消默认行为。我强烈反对您在为 jQuery 小白编写的实例中使用这个 return false。它会误导一些入门开发者，因为只有很清楚它的功能你才能正确的使用它。</p>\n<h2 id=\"头部，底部还是中间的某个地方？\"><a href=\"#头部，底部还是中间的某个地方？\" class=\"headerlink\" title=\"头部，底部还是中间的某个地方？\"></a>头部，底部还是中间的某个地方？</h2><p>之前，当你(滥)用 return false 时，它总是出现在函数的底部，或者至少在某个特定逻辑行的结尾处，因为它会组织后面的代码执行。但是我们有 e.preventDefault，所以我们有了更多选择。e.preventDefault 可以在函数执行过程中的任何时候调用。那么应该把它放在哪里呢？</p>\n<h3 id=\"在开发环境，它应该总是放在第一行\"><a href=\"#在开发环境，它应该总是放在第一行\" class=\"headerlink\" title=\"在开发环境，它应该总是放在第一行\"></a>在开发环境，它应该总是放在第一行</h3><p>对于一个表单，你想做的最后一件事往往是，你希望通过 ajax 的方式将表单提交到另一个网页，同时你尝试在回调函数中调试 JavaScript 产生的 bug</p>\n<h3 id=\"在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\"><a href=\"#在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\" class=\"headerlink\" title=\"在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾\"></a>在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾</h3><p>如果你是在一个开发完的页面上添加功能，那么你的链接点击事件或者表单提交事件需要对于不支持 JS 的浏览器的服务器端的反馈。这里的好处在于，与不支持 JS 的浏览器无关，而是你的代码在那些浏览器中会抛出错误。下面有一个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.preventDefault(); <span class=\"comment\">// 取消默认行为</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 抛出一个错误，因为my是undefined</span></span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append(data.my.link);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 链接将不起作用</span></span><br><span class=\"line\">    <span class=\"comment\">// JS的执行将终端，用户将不知所措</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在，让我们看一下同样的问题出现在 preventDefault 放在末尾时候的表现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;&#125;;</span><br><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// \b抛出错误，因为my是undefined</span></span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append(data.my.link);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 这里将不会执行，此时你的网页将使用“href”</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    e.preventDefault(); <span class=\"comment\">// 取消默认行为</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个例子同样适用于表单提交事件，可以让你有适当的回退选择。所以，千万不要指望你的代码永远都会正确执行。计划好回退方案比盼望着不会报错要好得多！</p>\n<h3 id=\"在生产环境中，如果你的功能只与-JS-有关，请放在第一行\"><a href=\"#在生产环境中，如果你的功能只与-JS-有关，请放在第一行\" class=\"headerlink\" title=\"在生产环境中，如果你的功能只与 JS 有关，请放在第一行\"></a>在生产环境中，如果你的功能只与 JS 有关，请放在第一行</h3><p>它不一定是函数中的第一行，但是它应该在你的程序逻辑中的最开始位置。原因是这样的：如果功能的这一部分一开始是与 JS 相关的，那么回退就不是那么必要了。在这种情况下，回退只是会造成一个随机的“#”出现在 URL 中或者页面跳转的区别。很明显，我们需要做的事提供尽可能多的错误处理方案，从而确保用户不会觉得它们的努力是白费的。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我希望这篇文章在你对于取消事件进行选择时提供了足够多的信息。记住只有在你真正需要 return false 时采去使用它，同时确保在你的回调函数的正确位置取消了默认行为。程序员的目标就是让你的代码尽可能的灵活，所以不要再用 return false 了！</p>\n","raw":null,"categories":[{"name":"stackoverflow","path":"api/categories/stackoverflow.json"}],"tags":[{"name":"stackoverflow","path":"api/tags/stackoverflow.json"},{"name":"jQuery","path":"api/tags/jQuery.json"}]}]}