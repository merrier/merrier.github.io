{"name":"computer-base","postlist":[{"title":"罗马数字转换成整数（JS）","slug":"罗马数字转换成整数（JS）","date":"2017-03-24T14:40:12.000Z","updated":"2019-03-29T10:17:04.620Z","comments":true,"path":"api/articles/罗马数字转换成整数（JS）.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>在刷 Leetcode 时碰到了一道题，题目的大致意图就是将罗马数字转换成整数，但是我竟然连罗马数字是什么都不知道，所以就打算写一篇关于这道题的文章</p>\n<h2 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h2><p>给定一个罗马数字 s，(I &lt;= s &lt;= MMMCMXCIX)（即1 到 3999），将罗马数字转换成整数。<br>输入：一个罗马数字<br>输出：对应的整数</p>\n<h2 id=\"知识储备\"><a href=\"#知识储备\" class=\"headerlink\" title=\"知识储备\"></a>知识储备</h2><p>首先要来了解一下罗马数字表示法，基本字符有 7 个：I，V，X，L，C，D，M，分别表示 1，5，10，50，100，500，1000。并且在构成数字的时候，有下列规则：</p>\n<ul>\n<li>相同的数字连写，所表示的数等于这些数字相加得到的数，如：Ⅲ= 3；</li>\n<li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：Ⅷ= 8；Ⅻ= 12；</li>\n<li>小的数字，（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如：Ⅳ=4；Ⅸ=9；</li>\n<li>正常使用时，连写的数字重复不得超过三次。</li>\n</ul>\n<p>所以，根据以上规则，可以发现其中的规律，就是只需要比较前后元素的大小，如果前面比后面大，这两个罗马字母代表的数字就相加；如果前面比后面小，就后面的减去前面的；如果相等也相加。再把每一对都相加，最后结果就是转换后的整数了（需要注意的是，最后一个字母是肯定要相加的）</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; s</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> romanToInt = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> opt = &#123;<span class=\"string\">'M'</span>: <span class=\"number\">1000</span>,<span class=\"string\">'D'</span>: <span class=\"number\">500</span> ,<span class=\"string\">'C'</span>: <span class=\"number\">100</span>,<span class=\"string\">'L'</span>: <span class=\"number\">50</span>,<span class=\"string\">'X'</span>: <span class=\"number\">10</span>,<span class=\"string\">'V'</span>: <span class=\"number\">5</span>,<span class=\"string\">'I'</span>: <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">        z = <span class=\"number\">0</span>,</span><br><span class=\"line\">        n = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(opt[s[i]] &lt; opt[s[i+<span class=\"number\">1</span>]])&#123;</span><br><span class=\"line\">            z -= opt[s[i]];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            z += opt[s[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z + opt[s[n<span class=\"number\">-1</span>]];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目来源\"><a href=\"#题目来源\" class=\"headerlink\" title=\"题目来源\"></a>题目来源</h2><p>Leetcode第 13 题：<a href=\"https://leetcode.com/problems/roman-to-integer/#/description\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/roman-to-integer/#/description</a></p>\n","raw":null,"categories":[{"name":"computer-base","path":"api/categories/computer-base.json"}],"tags":[{"name":"罗马数字","path":"api/tags/罗马数字.json"}]},{"title":"前端面试系列（8）——TCP的三次握手与四次分手","slug":"前端面试系列（8）——TCP的三次握手与四次分手","date":"2017-04-05T08:07:21.000Z","updated":"2019-03-29T10:17:04.620Z","comments":true,"path":"api/articles/前端面试系列（8）——TCP的三次握手与四次分手.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_123.jpg","content":"<h2 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h2><h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><p><a href=\"http://baike.baidu.com/link?url=eNyUOgDeOV5z-03dVd8M1Y2jazNBA9n_eeqpsGs6DROKf_Eezztf31POgn2yMVtzxhX1BIcma9hIT2lzwaeswKAUZHNBSzFasHHI6SsZKnGJJVu2fKrPkMh3byyFTt1j4VqBV4re8SYTBTMDXY_L7clee5XEglKSOAWJqr5E_QRD6INjs03VMQNOUstxguVR-oOfOPGi4cah5m0VFukOkpT6STLUEGHWUIUUYFv0aAgMRFovp5EWN7V3iMdEZQ0a6ikGU90BRIYMLLIKsVNjP8Szj4c6SexwpfRM6D5CjjG\" target=\"_blank\" rel=\"noopener\">开放系统互连参考模型</a> (Open System Interconnect 简称 OSI）是国际标准化组织（ISO）和国际电报电话咨询委员会（CCITT）联合制定的开放系统互连参考模型，为开放式互连信息系统提供了一种功能结构的框架。它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每一层的功能是独立的。它利用其下一层提供的服务并为其上一层提供服务，而与其他层的具体实现无关。这里所谓的“服务”就是下一层向上一层提供的通信功能和层之间的会话规定，一般用通信原语实现。两个开放系统中的同等层之间的通信规则和约定称之为协议。通常把1～4层协议称为下层协议，5～7 层协议称为上层协议。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_123.jpg\" alt=\"\" width=\"400\"></div>\n\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP / IP\"></a>TCP / IP</h3><p>TCP 工作在网络 OSI 的七层模型中的第四层——Transport 层，IP 在第三层——Network 层，ARP 在第二层——Data Link 层；在第二层上的数据，我们把它叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。在 OSI 七层模型中，每一层的作用和对应的协议如下：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_58.jpeg\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h2><p>TCP 是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记 TCP 协议中每个字段的含义。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_223.jpg\" alt=\"\" width=\"700\"></div>\n\n<p>上面就是 TCP 协议头部的格式，下面就将每个字段的信息都详细的说明一下。</p>\n<ul>\n<li><strong>Source Port</strong>和<strong>Destination Port</strong>：分别占用 16 位，表示源端口号和目的端口号；用于区别主机中的不同进程，而 IP 地址是用来区分不同的主机的，源端口号和目的端口号配合上 IP 首部中的源 IP 地址和目的 IP 地址就能唯一的确定一个 TCP 连接；</li>\n<li><strong>Sequence Number</strong>：用来标识从 TCP 发端向 TCP 收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</li>\n<li><strong>Acknowledgment Number</strong>：32 位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加 1。不过，只有当标志位中的 ACK 标志（下面介绍）为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题；</li>\n<li><strong>Offset</strong>：给出首部中 32 bit 字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占 4bit（最多能表示 15 个 32bit 的的字，即 4*15=60 个字节的首部长度），因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节；</li>\n<li><strong>TCP Flags</strong>：TCP 首部中有 6 个标志比特，它们中的多个可同时被设置为 1，主要是用于操控 TCP 的状态机的，依次为 <code>URG</code>，<code>ACK</code>，<code>PSH</code>，<code>RST</code>，<code>SYN</code>，<code>FIN</code>。每个标志位的意思如下：<ul>\n<li>URG：此标志表示 TCP 包的紧急指针域（后面马上就要说到）有效，用来保证 TCP 连接不被中断，并且督促中间层设备要尽快处理这些数据；</li>\n<li><strong>ACK</strong>：此标志表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0；</li>\n<li>PSH：这个标志位表示 Push 操作。所谓 Push 操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li>\n<li>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li>\n<li><strong>SYN</strong>：表示同步序号，用来建立连接。<code>SYN</code> 标志位和 <code>ACK</code> 标志位搭配使用，当连接请求的时候，<code>SYN</code> = 1，<code>ACK</code> = 0；连接被响应的时候，<code>SYN</code> = 1，<code>ACK</code> = 1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 <code>SYN</code> 的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行 TCP 三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行 TCP 的三次握手；</li>\n<li>FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送 <code>FIN</code> 标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li>\n</ul>\n</li>\n<li><strong>Window</strong>：窗口大小，也就是有名的滑动窗口，用来进行流量控制；这是一个复杂的问题，这篇博文中并不会进行总结的；</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p>TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP / IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。这就是面试中经常会被问到的 <strong>TCP 三次握手</strong>。\b下图很形象的展示了三次握手和四次分手的数据交换：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_74.jpg\" alt=\"\" width=\"400\"></div>\n\n<ol>\n<li>第一次握手：建立连接。客户端发送连接请求报文段，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为 x；然后，客户端进入 <code>SYN_SEND</code> 状态，等待服务器的确认；</li>\n<li>第二次握手：服务器收到 <code>SYN</code> 报文段。服务器收到客户端的 <code>SYN</code> 报文段，需要对这个 <code>SYN</code> 报文段进行确认，设置 <code>Acknowledgment Number</code> 为 x+1(<code>Sequence Number</code> + 1)；同时，自己自己还要发送 <code>SYN</code> 请求信息，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为 y；服务器端将上述所有信息放到一个报文段（即 <code>SYN + ACK</code> 报文段）中，一并发送给客户端，此时服务器进入 <code>SYN_RECV</code> 状态；</li>\n<li>第三次握手：客户端收到服务器的<code>SYN + ACK</code> 报文段。然后将 <code>Acknowledgment Number</code> 设置为 y+1，向服务器发送 <code>ACK</code> 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <code>ESTABLISHED</code> 状态，完成 TCP 三次握手。</li>\n</ol>\n<p>完成了三次握手，客户端和服务器端就可以开始传送数据。</p>\n<h2 id=\"四次分手\"><a href=\"#四次分手\" class=\"headerlink\" title=\"四次分手\"></a>四次分手</h2><p>当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的啊。那对于 TCP 的断开连接，这里就有了神秘的“四次分手”。</p>\n<ol>\n<li>第一次分手：主机 1（可以是客户端，也可以是服务器端），设置 <code>Sequence Number</code> 和 <code>Acknowledgment Number</code>，向主机 2 发送一个 <code>FIN</code> 报文段；此时，主机 1 进入 <code>FIN_WAIT_1</code> 状态；这表示主机1没有数据要发送给主机 2 了；</li>\n<li>第二次分手：主机 2 收到了主机1发送的 <code>FIN</code> 报文段，向主机 1 回一个 <code>ACK</code> 报文段，<code>Acknowledgment Number</code> 为 <code>Sequence Number</code> 加 1；主机 1 进入 <code>FIN_WAIT_2</code> 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；</li>\n<li>第三次分手：主机 2 向主机 1 发送 <code>FIN</code> 报文段，请求关闭连接，同时主机 2 进入 <code>LAST_ACK</code> 状态；</li>\n<li>第四次分手：主机 1 收到主机 2 发送的 <code>FIN</code> 报文段，向主机 2 发送 <code>ACK</code> 报文段，然后主机 1 进入 <code>TIME_WAIT</code> 状态；主机 2 收到主机 1 的 <code>ACK</code> 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。</li>\n</ol>\n<p>至此，TCP 的四次分手就这么愉快的完成了。</p>\n<h3 id=\"为什么要握手三次\"><a href=\"#为什么要握手三次\" class=\"headerlink\" title=\"为什么要握手三次\"></a>为什么要握手三次</h3><p>既然总结了 TCP 的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那 TCP 为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p>\n<blockquote>\n<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>\n</blockquote>\n<p>在书中同时举了一个例子：</p>\n<blockquote>\n<p>“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p>\n</blockquote>\n<p>总结一下就是为了<strong>防止服务器端一直等待而浪费资源。</strong></p>\n<h2 id=\"为什么要分手四次\"><a href=\"#为什么要分手四次\" class=\"headerlink\" title=\"为什么要分手四次\"></a>为什么要分手四次</h2><p>那四次分手又是为何呢？TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 <code>FIN</code> 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 <code>ACK</code> 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 <code>FIN</code> 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>\n<ul>\n<li><code>FIN_WAIT_1</code>：这个状态要好好解释一下，其实 <code>FIN_WAIT_1</code> 和 <code>FIN_WAIT_2</code> 状态的真正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是：<code>FIN_WAIT_1</code> 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 <code>FIN</code> 报文，此时该 SOCKET 即进入到 <code>FIN_WAIT_1</code> 状态。而当对方回应 ACK 报文后，则进入到 <code>FIN_WAIT_2</code> 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 <code>FIN_WAIT_1</code> 状态一般是比较难见到的，而 <code>FIN_WAIT_2</code> 状态还有时常常可以用 netstat 看到。（主动方）</li>\n<li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上 <code>FIN_WAIT_2</code> 状态下的 SOCKET，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK 信息)，稍后再关闭连接。（主动方）</li>\n<li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 <code>FIN</code> 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 <code>CLOSE_WAIT</code> 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 <code>FIN</code> 报文给对方，也即关闭连接。所以你在 <code>CLOSE_WAIT</code> 状态下，需要完成的事情是等待你去关闭连接。（被动方）</li>\n<li><code>LAST_ACK</code>：这个状态还是比较容易好理解的，它是被动关闭一方在发送 <code>FIN</code> 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 CLOSED 可用状态了。（被动方）</li>\n<li><code>TIME_WAIT</code>：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 <code>TIME_WAIT</code> 状态，而无须经过 <code>FIN_WAIT_2</code> 状态。（主动方）</li>\n<li><code>CLOSED</code>：表示连接中断。</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h3 id=\"1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\"><a href=\"#1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\" class=\"headerlink\" title=\"1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\"></a>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h3><p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p>\n<h3 id=\"2．为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态？\"><a href=\"#2．为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态？\" class=\"headerlink\" title=\"2．为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？\"></a>2．为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？</h3><p>这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/20879359\" target=\"_blank\" rel=\"noopener\">怎样生动描述TCP的「三次握手」？</a></li>\n</ul>\n","raw":null,"categories":[{"name":"computer-base","path":"api/categories/computer-base.json"}],"tags":[{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"一些位操作的技巧","slug":"一些位操作的技巧","date":"2017-03-21T14:11:27.000Z","updated":"2019-03-29T10:17:04.616Z","comments":true,"path":"api/articles/一些位操作的技巧.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>这篇文章大部分是从英文翻译过来的，是在刷 leetcode 的时候看到的一个 solution，感觉作者讲的很好，只不过英文的读起来有点费劲，在网上搜了一下，发现也没有翻译的版本，于是就想做第一个吃螃蟹的人，然后再加一些其他文章中的位操作技巧进行总结，最终形成了这个版本（文末有原文链接，英文好的可以去看一下，毕竟看原文才不会被误导）</p>\n<h2 id=\"位操作介绍\"><a href=\"#位操作介绍\" class=\"headerlink\" title=\"位操作介绍\"></a>位操作介绍</h2><p>位操作是对少于一个字母的数据段或位数进行算法层面的计算。在计算机工程领域，用到位操作任务有低等级设备控制、误差检测和校正算法，数据压缩、加密算法和优化算法。对于大多数任务而言，现在编程语言允许程序员直接用高级语言而不是位操作。位操作的源码使用位运算：<strong>AND、OR、XOR、NOT 和移位</strong> 由于位操作是可以并行处理的，所以在某些情况下可以减少甚至避免对于某数据结构的循环操作，从而在速度上会有较大提升，但是代码将变得很难书写和理解。</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>位操作的核心是位运算符 &amp;（和）、|（或）、~（不）、^（异或）以及移位运算符 a &lt;&lt; b 和 a &gt;&gt; b（异或通常缩写为 XOR）。</p>\n<ul>\n<li>取并集：A | B</li>\n<li>取交集：A &amp; B</li>\n<li>取补集：A &amp; ~B</li>\n<li>所有位数取反：^A 或者~A</li>\n<li>设置某位：A | = 1 &lt;&lt; bit</li>\n<li>清除某位：A &amp; = ~（1 &lt;&lt; bit）</li>\n<li>检验某位：(A &amp; 1 &lt;&lt; bit) != 0</li>\n<li>提取最后一位：A &amp; -A 或者 A &amp; ~ (A-1) 或者x ^ (x &amp; (x-1))</li>\n<li>移除最后一位：A &amp; (A-1)</li>\n<li>所有位数为1：~0</li>\n</ul>\n<h2 id=\"位操作的基本技巧\"><a href=\"#位操作的基本技巧\" class=\"headerlink\" title=\"位操作的基本技巧\"></a>位操作的基本技巧</h2><ul>\n<li>用异或操作符 ^ 可以删除完全相同的数字然后保存剩余的，或者保存不同位然后移除相同位</li>\n<li>用 | 操作符可以留存尽可能多的 1</li>\n<li>用 &amp; 可以筛选出指定位</li>\n</ul>\n<h3 id=\"1-检查整数是奇数还是偶数\"><a href=\"#1-检查整数是奇数还是偶数\" class=\"headerlink\" title=\"1. 检查整数是奇数还是偶数\"></a>1. 检查整数是奇数还是偶数</h3><p>只要整数的最后一位比特是 1，那它就是奇数，反之就是偶数。即最低位要么是 1 要么是 0，x 和 1 与（&amp;）运算，保留最低位，如果最低位是 1，x 是奇数，如果最低位是 0 ，x 是偶数。<br>例如 43，二进制表示为 00101011，注意\b它的最低位为 1，我们将 43 与 1 做 &amp; 运算：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    00101011</span><br><span class=\"line\">&amp;   00000001   (note: 1 is the same as 00000001)</span><br><span class=\"line\">    --------</span><br><span class=\"line\">    00000001</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-测试第-n-位比特\"><a href=\"#2-测试第-n-位比特\" class=\"headerlink\" title=\"2. 测试第 n 位比特\"></a>2. 测试第 n 位比特</h3><p>只要将与运算的 1 向左平移相应的位数即可。假设向左平移 n 位，接下来的与运算就是只保留第 n 位，其它位都清零了。<br>比如：122 的第三位比特是 1 吗？（从 0 开始数）可以这样做：122 &amp; (1 &lt;&lt; 3)，122 的二进制表示是 01111010，(1 &lt;&lt; 3)即 1 向左平移 3 比特 00001000。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    01111010</span><br><span class=\"line\">&amp;   00001000</span><br><span class=\"line\">    --------</span><br><span class=\"line\">    00001000</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-将第-n-位设为-1-或不变\"><a href=\"#3-将第-n-位设为-1-或不变\" class=\"headerlink\" title=\"3. 将第 n 位设为 1 或不变\"></a>3. 将第 n 位设为 1 或不变</h3><p>和前面的技巧一样，只是把与运算（&amp;）换成了或运算（|）。与 1 进行或运算将参与运算的位置设为 1，与 0 进行或运算参与预算的位不变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x | (1 &lt;&lt; n)</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-将第-n-位设为-0\"><a href=\"#4-将第-n-位设为-0\" class=\"headerlink\" title=\"4. 将第 n 位设为 0\"></a>4. 将第 n 位设为 0</h3><p>这个方法的关键就是 ~(1 &lt;&lt; n)，它将第 n 位设为 0，其它位全部为 1。看下面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x &amp; ~(1 &lt;&lt; n)</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-将第-n-位取反\"><a href=\"#5-将第-n-位取反\" class=\"headerlink\" title=\"5. 将第 n 位取反\"></a>5. 将第 n 位取反</h3><p>这次使用的是异或运算，如果异或运算的两个操作数相同，运算结果是 0，两个操作数不同，结果是 1。怎样将第 n 位取反呢？如果第 n 位比特为 1，将它与 1 进行异或运算结果就是 0，如果它是 0，那么它与 1 异或运算的结果就是 1。于是这一位就取反了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x ^ (1 &lt;&lt; n)</span><br></pre></td></tr></table></figure>\n<h2 id=\"位操作在数字运算中的应用\"><a href=\"#位操作在数字运算中的应用\" class=\"headerlink\" title=\"位操作在数字运算中的应用\"></a>位操作在数字运算中的应用</h2><h3 id=\"1-计算某二进制数中的-1-的数量\"><a href=\"#1-计算某二进制数中的-1-的数量\" class=\"headerlink\" title=\"1. 计算某二进制数中的 1 的数量\"></a>1. 计算某二进制数中的 1 的数量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count_one</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">        n = n&amp;(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-判断某数字是否为-4-的-n-次方-n-≥-0-，是就返回该数，不是就返回-0-或-false\"><a href=\"#2-判断某数字是否为-4-的-n-次方-n-≥-0-，是就返回该数，不是就返回-0-或-false\" class=\"headerlink\" title=\"2. 判断某数字是否为 4 的 n 次方(n ≥ 0)，是就返回该数，不是就返回 0 或 false\"></a>2. 判断某数字是否为 4 的 n 次方(n ≥ 0)，是就返回该数，不是就返回 0 或 false</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">bool <span class=\"title\">isPowerOfFour</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(n&amp;(n-<span class=\"number\">1</span>)) &amp;&amp; (n&amp;<span class=\"number\">0x55555555</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-使用-和-amp-来求两个数字的和\"><a href=\"#3-使用-和-amp-来求两个数字的和\" class=\"headerlink\" title=\"3. 使用 ^ 和 &amp; 来求两个数字的和\"></a>3. 使用 ^ 和 &amp; 来求两个数字的和</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b==<span class=\"number\">0</span>? a:getSum(a^b, (a&amp;b)&lt;&lt;<span class=\"number\">1</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-寻找丢失数字：给你一个包括从-0-到-n-的各不相同的-n-元数组，从中找出丢失的那个数字，比如给你的数组为-0-1-3-，那么应该返回-2（当然，你也可以用数学方法解决）\"><a href=\"#4-寻找丢失数字：给你一个包括从-0-到-n-的各不相同的-n-元数组，从中找出丢失的那个数字，比如给你的数组为-0-1-3-，那么应该返回-2（当然，你也可以用数学方法解决）\" class=\"headerlink\" title=\"4. 寻找丢失数字：给你一个包括从 0 到 n 的各不相同的 n 元数组，从中找出丢失的那个数字，比如给你的数组为 [0, 1, 3]，那么应该返回 2（当然，你也可以用数学方法解决）\"></a>4. 寻找丢失数字：给你一个包括从 0 到 n 的各不相同的 n 元数组，从中找出丢失的那个数字，比如给你的数组为 [0, 1, 3]，那么应该返回 2（当然，你也可以用数学方法解决）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">        ret ^= i;</span><br><span class=\"line\">        ret ^= nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret^=nums.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-给定一个自然数-N，找到小于等于-N-的-2-的最大倍数\"><a href=\"#5-给定一个自然数-N，找到小于等于-N-的-2-的最大倍数\" class=\"headerlink\" title=\"5. 给定一个自然数 N，找到小于等于 N 的 2 的最大倍数\"></a>5. 给定一个自然数 N，找到小于等于 N 的 2 的最大倍数</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">largest_power</span><span class=\"params\">(<span class=\"keyword\">long</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将所有右侧位变为1.</span></span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">4</span>);</span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">8</span>);</span><br><span class=\"line\">    N = N | (N&gt;&gt;<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (N+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-将一个-32-位的无符号数进行反转\"><a href=\"#6-将一个-32-位的无符号数进行反转\" class=\"headerlink\" title=\"6. 将一个 32 位的无符号数进行反转\"></a>6. 将一个 32 位的无符号数进行反转</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint32_t <span class=\"title\">reverseBits</span><span class=\"params\">(uint32_t n)</span> </span>&#123;</span><br><span class=\"line\">    unsigned <span class=\"keyword\">int</span> mask = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &amp; <span class=\"number\">1</span>) res |= mask;</span><br><span class=\"line\">        mask &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">uint32_t <span class=\"title\">reverseBits</span><span class=\"params\">(uint32_t n)</span> </span>&#123;</span><br><span class=\"line\">\tuint32_t mask = <span class=\"number\">1</span>, ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i)&#123;</span><br><span class=\"line\">\t\tret &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(mask &amp; n) ret |= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tmask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-给定一个范围-m-n-，其中-0-lt-m-lt-n-lt-2147483647，返回在这个范围内的所有数的按位进行-AND-操作之后的数字，比如范围为-5-7-，那返回的应该是按位进行计算的-5-6-7，结果是-4（100）\"><a href=\"#7-给定一个范围-m-n-，其中-0-lt-m-lt-n-lt-2147483647，返回在这个范围内的所有数的按位进行-AND-操作之后的数字，比如范围为-5-7-，那返回的应该是按位进行计算的-5-6-7，结果是-4（100）\" class=\"headerlink\" title=\"7. 给定一个范围[m, n]，其中 0&lt;=m&lt;=n&lt;=2147483647，返回在这个范围内的所有数的按位进行 AND 操作之后的数字，比如范围为 [5, 7]，那返回的应该是按位进行计算的 5+6+7，结果是 4（100）\"></a>7. 给定一个范围[m, n]，其中 0&lt;=m&lt;=n&lt;=2147483647，返回在这个范围内的所有数的按位进行 AND 操作之后的数字，比如范围为 [5, 7]，那返回的应该是按位进行计算的 5+6+7，结果是 4（100）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeBitwiseAnd</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m != n) &#123;</span><br><span class=\"line\">        m &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m&lt;&lt;a; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-求一个无符号数的汉明距离（即二进制表示中的-1-的个数）\"><a href=\"#8-求一个无符号数的汉明距离（即二进制表示中的-1-的个数）\" class=\"headerlink\" title=\"8. 求一个无符号数的汉明距离（即二进制表示中的 1 的个数）\"></a>8. 求一个无符号数的汉明距离（即二进制表示中的 1 的个数）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(uint32_t n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">\t\tn = n&amp;(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tcount++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(uint32_t n)</span> </span>&#123;</span><br><span class=\"line\">    ulong mask = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mask &amp; n) count++;</span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-用位操作交换变量\"><a href=\"#9-用位操作交换变量\" class=\"headerlink\" title=\"9. 用位操作交换变量\"></a>9. 用位操作交换变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = a ^ b; </span><br><span class=\"line\">b = a ^ b;  <span class=\"comment\">// 实际上是(a^b)^b 也就是a异或了b两次，等号右边是a的值</span></span><br><span class=\"line\">a = a ^ b;  <span class=\"comment\">// 此时b里面已经是“果汁”，实际上是(a^b)^a，也就是b异或了a两次，是b</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"位操作更复杂的应用\"><a href=\"#位操作更复杂的应用\" class=\"headerlink\" title=\"位操作\b更复杂的应用\"></a>位操作\b更复杂的应用</h2><h3 id=\"1-查找-DNA-重复序列\"><a href=\"#1-查找-DNA-重复序列\" class=\"headerlink\" title=\"1. 查找 DNA 重复序列\"></a>1. 查找 DNA 重复序列</h3><p>所有的 DNA 是由一系列简写为 A、C、G 和 T 核苷酸组成的，比如 “ACGAATTCCG”，当我们研究 DNA 时，有时候识别 DNA 中的重复序列是有用的，设计一个方法可以找出所有在 DNA 分子中出现不止一次的 10 字母长的序列（或子序列）</p>\n<p>举个例子：<br>Given s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT” Return: [“AAAAACCCCC”, “CCCCCAAAAA”]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">findRepeatedDnaSequences</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sLen = s.length();</span><br><span class=\"line\">        vector&lt;string&gt; v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sLen &lt; <span class=\"number\">11</span>) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> keyMap[<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">21</span>]&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hashKey = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; ++i) hashKey = (hashKey&lt;&lt;<span class=\"number\">2</span>) | (s[i]-<span class=\"string\">'A'</span>+<span class=\"number\">1</span>)%<span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">9</span>; i &lt; sLen; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(keyMap[hashKey = ((hashKey&lt;&lt;<span class=\"number\">2</span>)|(s[i]-<span class=\"string\">'A'</span>+<span class=\"number\">1</span>)%<span class=\"number\">5</span>)&amp;<span class=\"number\">0xfffff</span>]++ == <span class=\"number\">1</span>)</span><br><span class=\"line\">                v.push_back(s.substr(i-<span class=\"number\">9</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-多数单元\"><a href=\"#2-多数单元\" class=\"headerlink\" title=\"2. 多数单元\"></a>2. 多数单元</h3><p>给定一个 n 元数组，多数单元式在该数组中出现次数多于 ⌊n/2⌋ 次的数（一般采用位运算，但是在这里我们也可以采用分组和穆尔投票算法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = sizeof(<span class=\"keyword\">int</span>)*<span class=\"number\">8</span>, size = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>, mask = <span class=\"number\">1</span>, ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; size; ++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mask &amp; nums[j]) count++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count &gt; size/<span class=\"number\">2</span>) ret |= mask;</span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-找数字\"><a href=\"#3-找数字\" class=\"headerlink\" title=\"3. 找数字\"></a>3. 找数字</h3><p>给定整数数组，每个元素都出现了三次，除了一个元素，找到这个元素（这种问题通过位运算可以迎刃而解）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inspired by logical circuit design and boolean algebra;</span></span><br><span class=\"line\"><span class=\"comment\">// counter - unit of 3;</span></span><br><span class=\"line\"><span class=\"comment\">// current   incoming  next</span></span><br><span class=\"line\"><span class=\"comment\">// a b            c    a b</span></span><br><span class=\"line\"><span class=\"comment\">// 0 0            0    0 0</span></span><br><span class=\"line\"><span class=\"comment\">// 0 1            0    0 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1 0            0    1 0</span></span><br><span class=\"line\"><span class=\"comment\">// 0 0            1    0 1</span></span><br><span class=\"line\"><span class=\"comment\">// 0 1            1    1 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1 0            1    0 0</span></span><br><span class=\"line\"><span class=\"comment\">// a = a&amp;~b&amp;~c + ~a&amp;b&amp;c;</span></span><br><span class=\"line\"><span class=\"comment\">// b = ~a&amp;b&amp;~c + ~a&amp;~b&amp;c;</span></span><br><span class=\"line\"><span class=\"comment\">// return a|b since the single number can appear once or twice;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"number\">0</span>, a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">        t = (a&amp;~b&amp;~nums[i]) | (~a&amp;b&amp;nums[i]);</span><br><span class=\"line\">        b = (~a&amp;b&amp;~nums[i]) | (~a&amp;~b&amp;nums[i]);</span><br><span class=\"line\">        a = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a | b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-字符长度的最大积\"><a href=\"#4-字符长度的最大积\" class=\"headerlink\" title=\"4. 字符长度的最大积\"></a>4. 字符长度的最大积</h3><p>给定一个包含几个字符串的数组，找到 length(word[i])*length(word[j]) 的最大值，其中这两个字符串没有共同的字符。假定每个字符串的字符均为小写，如果没有这样的两个字符，返回 0</p>\n<h4 id=\"实例：\"><a href=\"#实例：\" class=\"headerlink\" title=\"实例：\"></a>实例：</h4><ol>\n<li>Example 1: Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”] Return 16 The two words can be “abcw”, “xtfn”. </li>\n<li>Example 2: Given [“a”, “ab”, “abc”, “d”, “cd”, “bcd”, “abcd”] Return 4 The two words can be “ab”, “cd”.</li>\n<li>Example 3: Given [“a”, “aa”, “aaa”, “aaaa”] Return 0 No such pair of words.</li>\n</ol>\n<h4 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h4><p>因为我们要非常频繁的用到字符串的长度，并且我们要比较两个字符串中的字符来检测他们是否有相同的字符，所以：</p>\n<ul>\n<li>使用一个 int 型数组来保存每个字符串的长度</li>\n<li>因为 int 型数字有 4 比特，可以有 32 位，而字母只有 26 中，所以我们仅仅使用一位就可以代表字母在字符串中的存在与否</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">mask</span><span class=\"params\">(words.size()</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">lens</span><span class=\"params\">(words.size()</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; words.size(); ++i) lens[i] = words[i].length();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;words.size(); ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : words[i])</span><br><span class=\"line\">            mask[i] |= <span class=\"number\">1</span> &lt;&lt; (c - <span class=\"string\">'a'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;i; ++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(mask[i] &amp; mask[j]))</span><br><span class=\"line\">                result = max(result, lens[i]*lens[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二进制在趣味数学中的应用\"><a href=\"#二进制在趣味数学中的应用\" class=\"headerlink\" title=\"二进制在趣味数学中的应用\"></a>二进制在趣味数学中的应用</h2><h3 id=\"1-一工人工作-7-天，老板有一段黄金，每天要给工人-1-7-的黄金作为工资，老板只能切这段黄金-2-刀，请问怎样切才能每天都给工人-1-7-的黄金？\"><a href=\"#1-一工人工作-7-天，老板有一段黄金，每天要给工人-1-7-的黄金作为工资，老板只能切这段黄金-2-刀，请问怎样切才能每天都给工人-1-7-的黄金？\" class=\"headerlink\" title=\"1. 一工人工作 7 天，老板有一段黄金，每天要给工人 1/7 的黄金作为工资，老板只能切这段黄金 2 刀，请问怎样切才能每天都给工人 1/7 的黄金？\"></a>1. 一工人工作 7 天，老板有一段黄金，每天要给工人 1/7 的黄金作为工资，老板只能切这段黄金 2 刀，请问怎样切才能每天都给工人 1/7 的黄金？</h3><p>因为 7 &lt; 2^3 = 8，所以只要使用 2^0，2^1，2^2 三个数，就可以表示 1 到 7 之间的所有数。那么我们只要把金条分成三份，比例为 1:2:4，也就是第一刀切下金条的七分之一（设为黄金 A），第二刀切下金条的七分之二（设为黄金 B），剩下的部分刚好为金条的七分之四（设为黄金 C）。我们只要按照如下的方法发放工资，就解决问题了：</p>\n<ol>\n<li>第一天：给长工黄金 A；（1 = 2^0）</li>\n<li>第二天：给长工黄金 B，并把黄金 A 拿回来；（2 = 2^1）</li>\n<li>第三天：给长工黄金 A；（3 = 2^0 + 2^1）</li>\n<li>第四天：给长工黄金 C，并把黄金 A 和黄金 B 拿回来；（4 = 2^2）</li>\n<li>第五天：给长工黄金 A；（5 = 2^0 + 2^2）</li>\n<li>第六天：给长工黄金 B，并把黄金 A 拿回来；（6 = 2^1 + 2^2）</li>\n<li>第七天：给长工黄金 A。（5 = 2^0 + 2^1 + 2^2）</li>\n</ol>\n<h3 id=\"2-用天平称-1-63-克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？\"><a href=\"#2-用天平称-1-63-克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？\" class=\"headerlink\" title=\"2. 用天平称 1~63 克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？\"></a>2. 用天平称 1~63 克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？</h3><p>没有学过二进制的人是很难想到答案的，可是如果你知道二进制数，那就不难了。我们知道二进制中只有 0 和 1 两个数字，它的各位数字的权值从小到大依次为 2^0，2^1，2^2，2^3。。。。我们用一个数的每位数字乘以其权值所得到的乘积之和来表示这个数。对于一个具有 8 位的二进制数来说，它可以表示的数据范围是 0~2^8。63 = 2^6 – 1 = 2^0 + 2^1 + 2^2 + 2^3 + 2^4 + 2^5 所以，我们只需配备 2^0 =1，2^1 = 2，2^2 = 4，2^3 = 8，2^4 = 16，2^5 = 32 五种不同克数的砝码各一个。</p>\n<h3 id=\"3-药瓶问题\"><a href=\"#3-药瓶问题\" class=\"headerlink\" title=\"3. 药瓶问题\"></a>3. 药瓶问题</h3><p>一家药店收到运来的某种药品十瓶。每瓶装药丸 1000 粒。药剂师怀特先生刚把药瓶送上架子，一封电报接踵而来。怀特先生把电报念给药店经理布莱克小姐听。怀特先生：“特急！所有药瓶须检查后方能出售。由于失误，其中有一瓶药丸每粒超重 10 毫克。请即退回分量有误的那瓶药。怀特先生很气恼。怀特先生：“倒霉极了，我只好从每瓶中取出一粒来称一下。真是胡闹。怀特先生刚要动手，布莱克小姐拦住了他。布莱克小姐：“等一下，没必要称十次，只需称一次就够了。”这怎么可能呢？<br>布莱克小姐的妙主意是从第一瓶中取出1粒，从第二瓶中取出 2 粒，第三瓶中取出 3 粒，以此类推，直至从第十瓶中取出 10 粒。把这 55 粒药丸放在秤上，记下总重量。如果重 5510 毫克，也就是超过规格 10 毫克，她当即明白其中只有一粒是超重的，并且是从第一瓶中取出的。如果总重量超过规格 20 毫克，则其中有 2 粒超重，并且是从第二瓶中取出的，以此类推进行判断。所以布莱克小姐只要称一次，不是吗？<br>六个月后，药店又收到此种药品十瓶。一封加急电报又接踵而至，指出发生了一个更糟糕的错误。这一次，药丸每粒超重仍然是 10 毫克，但是对超重药丸的瓶数无可奉告，也就是说可能有好几个药瓶超重。怀特先生气恼极了。怀特先生：“布莱克小姐，怎么办？我们上次的方法不中用了。布莱克小姐没有立即回答，她在思索这个问题。布莱克小姐：“不错。但如果把那个方法改变一下，我们仍然只需称一次就能把分量有误的药品识别出来。这回布莱克小姐又有什么好主意？<br>为了解决第二个问题，我们必须用一个数字序列把每瓶药单独标上某个数字，且此序列中的每一个子集必须有一个单独的和。有没有这样的序列？有的，最简单的就是下列二重序列：1，2，4，8，16，。。。这些数字是 2 的连续次幂，这一序列为二进制记数法奠定了基础。在这个问题中，解法是把药瓶排成一行，从第一瓶中取出 1 粒，从第二瓶中取出 2 粒，从第三瓶中取出 4 粒，以此类推。取出的药丸放在秤上称一下。假设总重量超重 270 毫克，由于每粒分量有误的药丸超重 10 毫克，所以我们把 270 除以 10，得到 27，即为超重药丸的粒数。把 27 化成二进制数：11011 。在 11011 中自右至左，第一，二，四，五位上的“1”表示其权值分别为 1，2，8，16。因此分量有误的药瓶是第一，二，四，五瓶。</p>\n<h3 id=\"4-简单的扑克魔术\"><a href=\"#4-简单的扑克魔术\" class=\"headerlink\" title=\"4. 简单的扑克魔术\"></a>4. 简单的扑克魔术</h3><p>请别人把一副牌洗过，然后放进你的口袋，再请人说出一个 1 至 15 以内的数字。然后你把手插进你的口袋里，一伸手就取出一组牌，其数值相加正好等于他所说的数字。<br>此秘密简单的很。在耍魔术之前，预先取出 A，2，4，8 各一张放入口袋。这副牌缺少区区四张，不大可能为人察觉。洗过的牌放入口袋后，暗中将其排置于原先已经放在口袋中的四张牌的后面。请别人说出一个数字，你用心算将此数表示成 2 的幂的和。如果是 10，那你就应想到：8+2=10，随即伸手入袋，取出 2 和 8 的牌示众。</p>\n<h3 id=\"5-心灵感应游戏\"><a href=\"#5-心灵感应游戏\" class=\"headerlink\" title=\"5. 心灵感应游戏\"></a>5. 心灵感应游戏</h3><p>心灵感应游戏的依据也是二进制原理，准备五张卡片，分别记为 A，B，C，D，E，上面写着 1~31 之间的一些整数。请一位观众想好此范围内的一个数字（例如某个人的年龄），然后请他把所有上面有此数字的卡片都交给你。你随即说出他心中所想的那个数字。<br>卡片如下： </p>\n<ul>\n<li>A：1   3   5   7  9   11  13  15  17  19  21  23  25  27  29  31</li>\n<li>B：2   3   6   7  10  11  14  15  18  19  22  23  26  27  30  31</li>\n<li>C：4   5   6   7  12  13  14  15  20  21  22  23  28  29  30  31</li>\n<li>D：8   9  10   11  12  13  14  15  24  25  26  27  28  29  30  31</li>\n<li>E：16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31</li>\n</ul>\n<p>秘诀就是把每张卡片上 2 的幂的第一个数字相加。例如，如果把卡片 C 和 E 交给你，你只要将上面第一个数字 4 和 16 相加，便知道别人心中所想的数字是 20。这是为什么呢？<br>我们观察卡片上的数字，可以发现这样一个规律：<br>第一张卡片 (A) 上的数字如果用五位二进制表示，则分别为：<br>00001，00011，00101，00111，01001，01011，01101，01111，10001，10011，10101，10111，11001，11011，11101，11111。<br>第二张卡片 (B) 上的数字如果用五位二进制表示，则分别为：<br>00010，00011，00110，00111，01010，01011，01110，01111，10010，10011，10110，10111，11010，11011，11110，11111。<br>第三张卡片 (C) 上的数字如果用五位二进制表示，则分别为：<br>00100，00101，00110，00111，01100，01101，01110，01111，10100，10101，10110，10111，11100，11101，11110，11111。<br>请大家注意观察，第一张卡片上每个二进制数的右起第一位都是 “1”，第二张卡片上每个二进制数的右起第二位都是 “1”，第三张卡片上每个二进制数的右起第三位都是 “1”。依此类推，我们可以发现第 n 张卡片上每个二进制数的右起第 n 位都是 “1”。观众所想的数字和卡片的关系只有“有”和“无”两种状态，正好与二进制数码 0 与 1 一一对应。“有”我们就记为 “1”，“无”我们就记为 “0”，这样观众交给我们的卡片组合，就对应一个二进制数，如把卡片 C 和 E 交给你，那卡片组合就是“有无有无无”，对应二进制数为 10100”，即十进制数 “20”。又如把卡片A，B 和 E 交给你，那卡片组合就是“有无无有有”，对应二进制数为 “10011”，即十进制数 “19”。 二进制数的位数越多，能够表示的数值就越大，如果有 6 张卡片，则表示的数字范围扩大到 1~63，7 张卡片则可以表示 1~127。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently\" target=\"_blank\" rel=\"noopener\">A summary: how to use bit manipulation to solve problems easily and efficiently</a></li>\n</ul>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"https://graphics.stanford.edu/~seander/bithacks.html\" target=\"_blank\" rel=\"noopener\">Bit Twiddling Hacks</a></li>\n<li><a href=\"http://lab.polygonal.de/2007/05/10/bitwise-gems-fast-integer-math/\" target=\"_blank\" rel=\"noopener\">Bitwise gems – fast integer math</a></li>\n</ul>\n","raw":null,"categories":[{"name":"computer-base","path":"api/categories/computer-base.json"}],"tags":[{"name":"计算机基础","path":"api/tags/计算机基础.json"},{"name":"位操作","path":"api/tags/位操作.json"}]}]}