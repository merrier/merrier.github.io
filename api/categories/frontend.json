{"name":"frontend","postlist":[{"title":"前端面试系列（12）——前端性能优化","slug":"前端面试系列（12）——前端性能优化","date":"2017-04-16T14:20:57.000Z","updated":"2019-02-06T03:20:41.981Z","comments":true,"path":"api/articles/前端面试系列（12）——前端性能优化.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>近几年的前端发展异常火爆，各种框架各种技术层出不穷，而所有的前端框架面临着同一个问题：怎样才能缩短首屏时间，让用户以最快的速度看到页面最想展现的内容；所以，前端性能优化这一问题成为所有前端开发人员需要考虑的需求。下面我将从 html、css、js 等方面介绍前端性能优化的一些方式，考虑到篇幅原因，只会以列表的形式进行简单概括，具体做法可以自行查阅，在这里强烈推荐<a href=\"https://developer.yahoo.com/performance/rules.html\" target=\"_blank\" rel=\"noopener\">雅虎军规</a>，Yahoo Rules 是对于前端性能优化的全面总结，有时间一定要看一看</p>\n<h2 id=\"HTML-的优化\"><a href=\"#HTML-的优化\" class=\"headerlink\" title=\"HTML 的优化\"></a>HTML 的优化</h2><h3 id=\"使用相对-URL\"><a href=\"#使用相对-URL\" class=\"headerlink\" title=\"使用相对 URL\"></a>使用相对 URL</h3><p>某些 href、src 属性如果与当前页面处于同一域名下，则使用相对 URL 能够节省至少一个域名的长度。</p>\n<h3 id=\"删除-HTTP-或者-HTTPS\"><a href=\"#删除-HTTP-或者-HTTPS\" class=\"headerlink\" title=\"删除 HTTP 或者 HTTPS\"></a>删除 HTTP 或者 HTTPS</h3><p>绝对 URL 都以 HTTP 或 HTTPS 等协议头开始，如果能确定 URL 的协议与当前页面 URL 的协议是一致的，或者说该 URL 在多种协议下均是可用的，则可以考虑删除这个协议头。</p>\n<h3 id=\"删除注释\"><a href=\"#删除注释\" class=\"headerlink\" title=\"删除注释\"></a>删除注释</h3><p>考虑不必要的 IE 条件注释和 CDATA 注释及自定义注释。</p>\n<h3 id=\"压缩空白符\"><a href=\"#压缩空白符\" class=\"headerlink\" title=\"压缩空白符\"></a>压缩空白符</h3><p>对于多数标签，可以通过删除多余的空白符来减少 HTML 体积，但是对于 pre 等是例外。</p>\n<h3 id=\"压缩-inline-css-amp-Javascript\"><a href=\"#压缩-inline-css-amp-Javascript\" class=\"headerlink\" title=\"压缩 inline css &amp; Javascript\"></a>压缩 inline css &amp; Javascript</h3><p>不管 inline 还是 external，都需要压缩，这是减小体积的最直接的方式。</p>\n<h3 id=\"CSS-amp-Javascript-尽量外链\"><a href=\"#CSS-amp-Javascript-尽量外链\" class=\"headerlink\" title=\"CSS &amp; Javascript 尽量外链\"></a>CSS &amp; Javascript 尽量外链</h3><p>不仅可以减少体积，还能够充分利用浏览器的缓存机制。</p>\n<h3 id=\"删除元素默认属性\"><a href=\"#删除元素默认属性\" class=\"headerlink\" title=\"删除元素默认属性\"></a>删除元素默认属性</h3><p>在 HTML 规范中，很多 HTML 元素的属性是有默认值的，对于这些默认值可以抹去不写。</p>\n<h3 id=\"避免使用-Iframe\"><a href=\"#避免使用-Iframe\" class=\"headerlink\" title=\"避免使用 Iframe\"></a>避免使用 Iframe</h3><p>创建 iframe 元素的开销要比创建其他类型的 DOM 元素高 1~2 个数量级</p>\n<h3 id=\"避免空链接属性\"><a href=\"#避免空链接属性\" class=\"headerlink\" title=\"避免空链接属性\"></a>避免空链接属性</h3><p>可以看做是上面“删除元素默认属性”的特例，即使图片的地址为空，浏览器依旧会以默认的规则去请求空地址</p>\n<h3 id=\"避免节点深层级嵌套\"><a href=\"#避免节点深层级嵌套\" class=\"headerlink\" title=\"避免节点深层级嵌套\"></a>避免节点深层级嵌套</h3><p>由于浏览器构建 DOM 文档的机制，深层级嵌套的节点在初始化构建时往往需要更多的内存占用，并且在遍历节点时也会更慢些</p>\n<h3 id=\"避免-Table-布局\"><a href=\"#避免-Table-布局\" class=\"headerlink\" title=\"避免 Table 布局\"></a>避免 Table 布局</h3><p>构建 table 的开销也很大</p>\n<h3 id=\"显示指定文档字符集\"><a href=\"#显示指定文档字符集\" class=\"headerlink\" title=\"显示指定文档字符集\"></a>显示指定文档字符集</h3><p>如果浏览器不能获知页面的编码字符集，一般都会在执行脚本和渲染页面前，把字节流缓存，然后再搜索可进行解析的字符集，或以默认的字符集来解析页面代码，这会导致消耗不必要的时间。为了避免浏览器把时间花费在搜寻合适的字符集来进行解码，所以最好在文档中总是显式的指定页面字符集。</p>\n<h2 id=\"CSS-的优化\"><a href=\"#CSS-的优化\" class=\"headerlink\" title=\"CSS 的优化\"></a>CSS 的优化</h2><h3 id=\"把-CSS-放到代码页上端\"><a href=\"#把-CSS-放到代码页上端\" class=\"headerlink\" title=\"把 CSS 放到代码页上端\"></a>把 CSS 放到代码页上端</h3><p>加快渲染</p>\n<h3 id=\"避免-CSS-表达式\"><a href=\"#避免-CSS-表达式\" class=\"headerlink\" title=\"避免 CSS 表达式\"></a>避免 CSS 表达式</h3><p>表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给 CSS 表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到 10000 次以上的计算量。</p>\n<h3 id=\"使用-lt-link-gt-而不是-import\"><a href=\"#使用-lt-link-gt-而不是-import\" class=\"headerlink\" title=\"使用 &lt;link&gt; 而不是 @import\"></a>使用 <code>&lt;link&gt;</code> 而不是 <code>@import</code></h3><p>在外部的 CSS 文件中使用 @import 会使得页面在加载时增加额外的延迟。虽然规则允许在样式中调用 @import 来导入其它的 CSS，但浏览器不能并行下载样式，就会导致页面增添了额外的往返耗时。比如，第一个 CSS 文件 first.css 包含了以下内容：@import url(“second.css”)。那么浏览器就必须先把 first.css 下载、解析和执行后，才发现及处理第二个文件 second.css。</p>\n<h3 id=\"避免通配选择器\"><a href=\"#避免通配选择器\" class=\"headerlink\" title=\"避免通配选择器\"></a>避免通配选择器</h3><p>CSS 选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免需要消耗更多匹配时间的选择器。比如这种反例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.selected</span> * &#123;<span class=\"attribute\">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 <strong>CSS 选择器从右到左匹配的机制</strong>，浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 selected 的元素，直到文档的根节点，因此其匹配开销是非常大的，通常比开销最小的 ID 选择器高出 1~3 个数量级，所以应避免使用关键选择器是通配选择器的规则。</p>\n<h3 id=\"避免单规则的属性选择器\"><a href=\"#避免单规则的属性选择器\" class=\"headerlink\" title=\"避免单规则的属性选择器\"></a>避免单规则的属性选择器</h3><p>属性选择器根据元素的属性是否存在或其属性值进行匹配，如下例规则会把 herf 属性值等于 ”#index” 的链接元素设置为红色：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.selected</span> <span class=\"selector-attr\">[href=”#index”]</span> &#123;<span class=\"attribute\">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>\n<p>但其匹配开销是非常大的，浏览器先匹配所有的元素，检查其是否有 href 属性并且 herf 属性值等于 ”#index”， 然后分别向上逐级匹配 class 为 selected 的元素，直到文档的根节点。所以应避免使用关键选择器是单规则属性选择器的规则。</p>\n<h3 id=\"避免类正则的属性选择器\"><a href=\"#避免类正则的属性选择器\" class=\"headerlink\" title=\"避免类正则的属性选择器\"></a>避免类正则的属性选择器</h3><p>CSS3 添加了复杂的属性选择器，可以通过类正则表达式的方式对元素的属性值进行匹配。当然这些类型的选择器定是会影响性能的，正则表达式匹配会比基于类别的匹配会慢很多。大部分情况下我们应尽量避免使用 *=， |=， ^=， $=，和 ~= 语法的属性选择器。</p>\n<h2 id=\"JavaScript-的优化\"><a href=\"#JavaScript-的优化\" class=\"headerlink\" title=\"JavaScript 的优化\"></a>JavaScript 的优化</h2><h3 id=\"脚本放到-HTML-代码页底部\"><a href=\"#脚本放到-HTML-代码页底部\" class=\"headerlink\" title=\"脚本放到 HTML 代码页底部\"></a>脚本放到 HTML 代码页底部</h3><p>加快渲染，当然如果你的 js 会影响 dom 建立，那放在哪都是一样的了</p>\n<h3 id=\"移除重复脚本\"><a href=\"#移除重复脚本\" class=\"headerlink\" title=\"移除重复脚本\"></a>移除重复脚本</h3><p>封装方法是一个前端开发人员最基本的技能</p>\n<h3 id=\"减少-DOM-访问\"><a href=\"#减少-DOM-访问\" class=\"headerlink\" title=\"减少 DOM 访问\"></a>减少 DOM 访问</h3><p>使用 JavaScript 访问 DOM 元素是比较慢的，因此为了提升性能，应该做到：</p>\n<ul>\n<li>缓存已经查询过的元素；</li>\n<li>线下更新完节点之后再将它们添加到文档树中；</li>\n<li>避免使用 JavaScript 来修改页面布局；</li>\n</ul>\n<h3 id=\"使用事件代理\"><a href=\"#使用事件代理\" class=\"headerlink\" title=\"使用事件代理\"></a>使用事件代理</h3><p>有时候我们会感觉到页面反应迟钝，这是因为 DOM 树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用事件代理是一种好方法了。如果你在一个 div 中有 10 个按钮，你只需要在 div 上附加一次事件句柄就可以了，而不用去为每一个按钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。</p>\n<h3 id=\"缓存选择器查询结果\"><a href=\"#缓存选择器查询结果\" class=\"headerlink\" title=\"缓存选择器查询结果\"></a>缓存选择器查询结果</h3><p>选择器查询是开销很大的方法。所以，使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。 不要使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery(<span class=\"string\">'#top'</span>).find(<span class=\"string\">'p.classA'</span>);</span><br><span class=\"line\">jQuery(<span class=\"string\">'#top'</span>).find(<span class=\"string\">'p.classB'</span>);</span><br></pre></td></tr></table></figure>\n<p>而是使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cached = jQuery(<span class=\"string\">'#top'</span>);</span><br><span class=\"line\">cached.find(<span class=\"string\">'p.classA'</span>);</span><br><span class=\"line\">cached.find(<span class=\"string\">'p.classB'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用微类库\"><a href=\"#使用微类库\" class=\"headerlink\" title=\"使用微类库\"></a>使用微类库</h3><p>通常开发者都会使用 JavaScript 类库，如 jQuery、Mootools、YUI、Dojo 等，但是开发者往往只是使用 JavaScript 类库中的部分功能。为了更大的提升性能，应尽量避免使用这类大而全的类库，而是按需使用微类库来辅助开发。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li>[Absolute HTML Compressor](<a href=\"http://www.alentum.com/ahc/\" target=\"_blank\" rel=\"noopener\">http://www.alentum.com/ahc/</a> “Absolute HTML Compressor”）：HTML 的优化工具，压缩效果比较理想</li>\n<li><a href=\"https://book.douban.com/subject/3686503/\" target=\"_blank\" rel=\"noopener\">Even Faster Web Sites</a>：关于前端优化的书，本人没看过，但是豆瓣评分 8.6 的它应该还不错吧</li>\n</ul>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/news/2010/05/baidu-html-optimize\" target=\"_blank\" rel=\"noopener\">不应忽视的HTML优化</a> </li>\n<li><a href=\"https://developer.yahoo.com/performance/rules.html\" target=\"_blank\" rel=\"noopener\">Yahoo Rules</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000007677580\" target=\"_blank\" rel=\"noopener\">前端性能优化黄金法则</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002418920\" target=\"_blank\" rel=\"noopener\">网站性能优化工具大全</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008829958\" target=\"_blank\" rel=\"noopener\">WEB前端性能优化常见方法</a></li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"性能优化","path":"api/tags/性能优化.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"浏览器中输入url后发生了什么","slug":"浏览器中输入url后发生了什么","date":"2017-04-24T13:18:56.000Z","updated":"2019-02-06T03:20:41.981Z","comments":true,"path":"api/articles/浏览器中输入url后发生了什么.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_34.png","content":"<p>本文转载自<a href=\"http://www.jianshu.com/p/c1dfc6caa520\" target=\"_blank\" rel=\"noopener\">简书-浏览器中输入url后发生了什么</a>，其实这个问题在前端面试中经常遇到，所以网上有很多关于这个问题的文章，但是我感觉这篇文章是表达的最清晰的，感兴趣的童鞋可以点击上面的链接查看原文，不过在本文中，我又补充了一些其他文章中的相关内容，同时加入了一些我自己的理解，争取让初学者更容易看懂 先上一张思维导图：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_34.png\" alt=\"\" width=\"900\"></div>\n\n<p>上面这张图用非常简练的语言总结了浏览器中输入 url 后发生的事情以及顺序，下面按照执行顺序分为六步进行描述：</p>\n<h2 id=\"1-DNS-域名解析\"><a href=\"#1-DNS-域名解析\" class=\"headerlink\" title=\"1. DNS 域名解析\"></a>1. DNS 域名解析</h2><ul>\n<li>在浏览器 DNS 缓存中搜索</li>\n<li>在操作系统 DNS 缓存中搜索</li>\n<li>读取系统 hosts 文件，查找其中是否有对应的 ip</li>\n<li>向本地配置的首选 DNS 服务器发起域名解析请求</li>\n</ul>\n<p>以上四个步骤其实都是 DNS 的解析过程，总结一下就是先看有没有缓存，如果没有就发起DNS域名解析请求，具体过程其实比较复杂，可以查看<a href=\"http://www.cnblogs.com/vincently/p/4670597.html\" target=\"_blank\" rel=\"noopener\">DNS原理及解析过程</a>进行更深入的了解</p>\n<h2 id=\"2-建立-TCP-连接\"><a href=\"#2-建立-TCP-连接\" class=\"headerlink\" title=\"2.建立 TCP 连接\"></a>2.建立 TCP 连接</h2><p>为了准确地传输数据，TCP 协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有 SYN/ACK(acknowledegment) 标志的数据包以示传达确认信息。最后发送方再回传一个带 ACK 标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP 会再次发送相同的数据包。TCP 是一个端到端的可靠的面向连接的协议，所以 HTTP 基于传输层 TCP 协议不用担心数据的传输的各种问题。当然，TCP 三次握手也是一个可以展开的问题，而且为什么使用三次握手也是大有学问，可以去我的另外一篇文章：<a href=\"/20170405/tcp-three-handshakes-and-four-breakups.html\">前端面试系列（8）——TCP的三次握手与四次分手</a>中寻找答案</p>\n<h2 id=\"3-发起-HTTP-请求\"><a href=\"#3-发起-HTTP-请求\" class=\"headerlink\" title=\"3. 发起 HTTP 请求\"></a>3. 发起 HTTP 请求</h2><p>HTTP 的请求方法（method）有以下几种：</p>\n<ul>\n<li>GET: 获取资源</li>\n<li>POST: 传输实体主体</li>\n<li>HEAD: 获取报文首部</li>\n<li>PUT: 传输文件</li>\n<li>DELETE: 删除文件</li>\n<li>OPTIONS: 询问支持的方法</li>\n<li>TRACE: 追踪路径</li>\n</ul>\n<p>其中最常用的就是 GET 和 POST 了，请求报文格式如下所示（HTTP/1.1）：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_33.png\" alt=\"\" width=\"900\"></div>\n\n<h2 id=\"4-接受响应结果\"><a href=\"#4-接受响应结果\" class=\"headerlink\" title=\"4. 接受响应结果\"></a>4. 接受响应结果</h2><p>客户端在发出请求之后，服务器会在接收到请求之后返回客户端响应结果，该结果就是服务器告知客户端的当前状态，下面是状态码的分类，更多关于状态码的详细内容请移步<a href=\"/20170404/status-code-of-http-request.html\">前端面试系列（6）——HTTP请求的状态码</a>：</p>\n<ul>\n<li>1**：信息性状态码</li>\n<li>2**：成功状态码</li>\n<li>3**：重定向状态码</li>\n<li>4**：客户端错误状态码</li>\n<li>5**：服务器错误状态码</li>\n</ul>\n<p>响应报文：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_35.png\" alt=\"\" width=\"900\"></div>\n\n<h2 id=\"5-浏览器解析-html\"><a href=\"#5-浏览器解析-html\" class=\"headerlink\" title=\"5. 浏览器解析 html\"></a>5. 浏览器解析 html</h2><p>浏览器按顺序解析 html 文件，构建 DOM 树，在解析到外部的 css 和 js 文件时，向服务器发起请求下载资源，若是下载 css 文件，则解析器会在下载的同时继续解析后面的 html 来构建 DOM 树，但是在下载 js 文件和执行它时，解析器会停止对 html 的解析。这便出现了 js 阻塞问题。</p>\n<h3 id=\"预加载器：\"><a href=\"#预加载器：\" class=\"headerlink\" title=\"预加载器：\"></a>预加载器：</h3><p>当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的 html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索 HTML 标签中的 URL，无法检测到使用脚本添加的 URL，这些资源要等脚本代码执行时才会获取。（注: 预解析并不改变 Dom 树，它将这个工作留给主解析过程），浏览器解析 css，形成 CSSOM 树，当 DOM 树构建完成后，浏览器引擎通过 DOM 树和 CSSOM 树构造出渲染树（Render 树）。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head 元素和 display 值为 none 的元素）</p>\n<blockquote>\n<p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n</blockquote>\n<h2 id=\"6-浏览器布局渲染\"><a href=\"#6-浏览器布局渲染\" class=\"headerlink\" title=\"6. 浏览器布局渲染\"></a>6. 浏览器布局渲染</h2><ul>\n<li>布局（Layout）：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。</li>\n<li>绘制（Paint）：将计算好的每个像素点信息绘制在屏幕上</li>\n</ul>\n<p>在页面显示的过程中会多次进行 Reflow 和 Repaint 操作，而 Reflow 的成本比 Repaint 的成本高得多的多。因为 Repaint 只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的 display 属性由 block 改为 none 则需要 Reflow。如何减少 rpaint 和 reflow 也是<a href=\"/20170416/front-end-performance-optimization.html\">前端优化</a>需要考虑的问题：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_36.png\" alt=\"\" width=\"700\"></div>\n\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/c1dfc6caa520\" target=\"_blank\" rel=\"noopener\">浏览器中输入url后发生了什么</a></li>\n<li><a href=\"http://coolshell.cn/articles/9666.html\" target=\"_blank\" rel=\"noopener\">浏览器的渲染原理简介</a></li>\n<li><a href=\"http://www.cnblogs.com/yuezk/archive/2013/01/11/2855698.html\" target=\"_blank\" rel=\"noopener\">了解html页面的渲染过程</a></li>\n<li><a href=\"https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/\" target=\"_blank\" rel=\"noopener\">老生常谈-从输入url到页面展示到底发生了什么</a></li>\n<li><a href=\"http://harttle.com/2016/05/18/async-javascript-loading.html\" target=\"_blank\" rel=\"noopener\">异步脚本载入提高页面性能</a></li>\n</ul>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://blog.codingplayboy.com/2017/03/29/webpage_render/\" target=\"_blank\" rel=\"noopener\">浅谈前端页面渲染机制</a></li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"简单聊一下服务端渲染","slug":"简单聊一下服务端渲染","date":"2018-09-18T08:07:53.000Z","updated":"2019-02-06T03:20:41.981Z","comments":true,"path":"api/articles/简单聊一下服务端渲染.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p><code>Server Slide Rendering</code> 服务端渲染,又简写为 <code>SSR</code>，他一般被用在我们的 <code>SPA（Single-Page Application）</code> 中，即单页应用。</p>\n<h2 id=\"为什么要用SSR？\"><a href=\"#为什么要用SSR？\" class=\"headerlink\" title=\"为什么要用SSR？\"></a>为什么要用SSR？</h2><p>首先我们需要知道 SSR 对于 SPA 的<code>好处</code>，<code>优势</code>是什么。</p>\n<ul>\n<li>更好的 <code>SEO（Search Engine Optimization）</code>，<code>SEO</code> 是搜索引擎优化，简而言之就是针对百度这些搜索引擎，可以让他们搜索到我们的应用。这里可能会有误区，就是我也可以在 <code>index.html</code> 上写 <code>SEO</code> ，为什么会不起作用。因为 React、Vue 的原理是<strong>客户端渲染</strong>，通过浏览器去加载 js、css，有一个时间上的<code>延迟</code>，而搜索引擎不会管你的<code>延迟</code>，他就觉得你如果没加载出来就是没有的，所以是搜不到的。</li>\n<li>解决一开始的<code>白屏渲染</code>，上面讲了 React 的渲染原理，而<strong>SSR服务端渲染</strong>是通过服务端请求数据，因为服务端内网的请求快，性能好所以会更快的加载所有的文件，最后把下载渲染后的页面返回给客户端。</li>\n</ul>\n<h2 id=\"服务端渲染VS客户端渲染\"><a href=\"#服务端渲染VS客户端渲染\" class=\"headerlink\" title=\"服务端渲染VS客户端渲染\"></a>服务端渲染VS客户端渲染</h2><h3 id=\"客户端渲染路线：\"><a href=\"#客户端渲染路线：\" class=\"headerlink\" title=\"客户端渲染路线：\"></a>客户端渲染路线：</h3><ol>\n<li>请求一个 html</li>\n<li>服务端返回一个 html</li>\n<li>浏览器下载 html 里面的 js/css 文件</li>\n<li>等待 js 文件下载完成</li>\n<li>等待 js 加载并初始化完成</li>\n<li>js 代码终于可以运行，由js代码向后端请求数据( ajax/fetch )</li>\n<li>等待后端数据返回</li>\n<li>react-dom ( 客户端 )从无到完整地，把数据渲染为响应页面</li>\n</ol>\n<h3 id=\"服务端渲染路线：\"><a href=\"#服务端渲染路线：\" class=\"headerlink\" title=\"服务端渲染路线：\"></a>服务端渲染路线：</h3><ol>\n<li>请求一个 html</li>\n<li>服务端请求数据( 内网请求快 )</li>\n<li>服务器初始渲染（服务端性能好，较快）</li>\n<li>服务端返回已经有正确内容的页面</li>\n<li>客户端请求 js/css 文件</li>\n<li>等待 js 文件下载完成</li>\n<li>等待 js 加载并初始化完成</li>\n<li>react-dom ( 客户端 )把剩下一部分渲染完成( 内容小，渲染快 )</li>\n</ol>\n<p>从上面两者的渲染路线可以看到，其主要区别就在于，客户端从<code>无到有的</code>渲染，服务端是先在服务端<code>渲染一部分</code>，在再客户端<code>渲染一小部分</code>。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://juejin.im/post/5b55e6a96fb9a04fcf59d754\" target=\"_blank\" rel=\"noopener\">React服务端渲染+pm2自动化部署</a></p>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"渲染","path":"api/tags/渲染.json"}]},{"title":"今日头条前端散招内推面试经验总结","slug":"今日头条前端散招内推面试经验总结","date":"2017-05-17T07:33:40.000Z","updated":"2019-02-06T03:20:41.977Z","comments":true,"path":"api/articles/今日头条前端散招内推面试经验总结.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<h2 id=\"笔试题\"><a href=\"#笔试题\" class=\"headerlink\" title=\"笔试题\"></a>笔试题</h2><p>可能是内推的缘故，在面试之前前台工作人员给了一套前端的笔试题，然后就分配了一个小房间开始做题，虽然没有指明不可以手机搜索，但是为了保证最起码的诚信，我全程都没有看手机，完全凭自己的水平答题，虽然最后面试官把原题拿走了，但是我还是能靠记忆回想起一些题目，总结如下：</p>\n<h3 id=\"1-替换元素和非替换元素有哪些，它们的差异是什么？\"><a href=\"#1-替换元素和非替换元素有哪些，它们的差异是什么？\" class=\"headerlink\" title=\"1. 替换元素和非替换元素有哪些，它们的差异是什么？\"></a>1. 替换元素和非替换元素有哪些，它们的差异是什么？</h3><h4 id=\"替换元素\"><a href=\"#替换元素\" class=\"headerlink\" title=\"替换元素\"></a>替换元素</h4><p>替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。 比如：<code>&lt;input type=&quot;text&quot;/&gt;</code>，这是一个文本输入框，换一个其他 type 的时候，浏览器显示就不一样，HTML 中的 <code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;object&gt;</code> 都是替换元素，这些元素都没有实际的内容。</p>\n<h4 id=\"非替换元素\"><a href=\"#非替换元素\" class=\"headerlink\" title=\"非替换元素\"></a>非替换元素</h4><p>HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。 比如 <code>&lt;p&gt;merrier.wang&lt;/p&gt;</code>、<code>&lt;label&gt;Merrier&lt;/label&gt;</code> 浏览器将把这段内容直接显示出来。</p>\n<h3 id=\"2-offsetWidth、clientWidth、scrollWidth-如何计算？\"><a href=\"#2-offsetWidth、clientWidth、scrollWidth-如何计算？\" class=\"headerlink\" title=\"2. offsetWidth、clientWidth、scrollWidth 如何计算？\"></a>2. offsetWidth、clientWidth、scrollWidth 如何计算？</h3><h4 id=\"offsetWidth\"><a href=\"#offsetWidth\" class=\"headerlink\" title=\"offsetWidth\"></a>offsetWidth</h4><ul>\n<li>无 <code>padding</code> 无滚动无 <code>border</code><ul>\n<li>offsetWidth = clientWidth = 盒子的宽度</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 无滚动有 <code>border</code><ul>\n<li>offsetWidth = 盒子的宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 边框宽度*2</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 有滚动，且滚动是显示的，有 <code>border</code><ul>\n<li>offsetWidth = 盒子宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"clientWidth\"><a href=\"#clientWidth\" class=\"headerlink\" title=\"clientWidth\"></a>clientWidth</h4><ul>\n<li>无 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code></li>\n<li>有 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code> + 盒子的 <code>padding * 2</code></li>\n<li>有 <code>padding</code> 有滚动 ：<code>clientWidth</code> = 盒子和 <code>width</code> + 盒子的 <code>padding * 2</code> - 滚动轴宽度</li>\n</ul>\n<h4 id=\"scrollWidth\"><a href=\"#scrollWidth\" class=\"headerlink\" title=\"scrollWidth\"></a>scrollWidth</h4><p>无滚动轴时：</p>\n<ul>\n<li>scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2</li>\n</ul>\n<p>有滚动轴时：</p>\n<ul>\n<li>scrollWidth = 实际内容的宽度 + padding * 2</li>\n<li>scrollHeight = 实际内容的高度 + padding * 2</li>\n</ul>\n<p>更多关于 JS 中的宽高可以狠狠的点击这里：<a href=\"/20170501/js-width-and-height.html\">JS 宽高的理解和应用</a></p>\n<h3 id=\"3-JS-中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\"><a href=\"#3-JS-中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\" class=\"headerlink\" title=\"3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\"></a>3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例</h3><p>DOM2 标准事件模型：每一个 DOM 元素所触发的事件都要经历三个阶段：</p>\n<ol>\n<li>捕获阶段</li>\n<li>目标对象本身的事件处理程序调用阶段</li>\n<li>冒泡阶段</li>\n</ol>\n<p>在 IE8 以上的版本以及其他的浏览器中通过 e.stopPropagation() 方式阻止事件的冒泡；在 IE8  以下的浏览器中通过 e.cancleBubble = true 阻止事件冒泡；jQ 中的 mouseenter 和 mouseleave 也是默认不冒泡</p>\n<h3 id=\"4-CSS-选择器的优先级是什么？\"><a href=\"#4-CSS-选择器的优先级是什么？\" class=\"headerlink\" title=\"4. CSS 选择器的优先级是什么？\"></a>4. CSS 选择器的优先级是什么？</h3><p>!important &gt; 内联 &gt; id &gt; class &gt; 标签(p、a、div) &gt; 通配符(*) &gt; 浏览器自定义</p>\n<p>更多关于 CSS 选择器的的内容：<a href=\"/20170403/css-selector.html\">前端面试系列（4）——CSS选择器</a></p>\n<h3 id=\"5-IFC-是什么？它的作用是什么？\"><a href=\"#5-IFC-是什么？它的作用是什么？\" class=\"headerlink\" title=\"5. IFC 是什么？它的作用是什么？\"></a>5. IFC 是什么？它的作用是什么？</h3><h4 id=\"What’s-FC？\"><a href=\"#What’s-FC？\" class=\"headerlink\" title=\"What’s FC？\"></a>What’s FC？</h4><p>FC 的全称是：Formatting Contexts，是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<h4 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a>IFC</h4><p>IFC(Inline Formatting Contexts) 直译为”内联格式化上下文”，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding / margin 影响)，IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。IFC 中是不可能有块级元素的，当插入块级元素时（如 p 中插入 div），会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。</p>\n<p><strong>那么IFC一般有什么用呢？</strong></p>\n<ul>\n<li>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</li>\n<li>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>\n</ul>\n<h4 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h4><p>BFC(Block Formatting Contexts) 直译为”块级格式化上下文”。Block Formatting Contexts 就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。 </p>\n<p><strong>如何产生 BFC？</strong></p>\n<ol>\n<li>float 的值不为 none。</li>\n<li>overflow 的值不为 visible。</li>\n<li>position 的值不为 relative 和 static。</li>\n<li>display 的值为 table-cell, table-caption, inline-block 中的任何一个。</li>\n</ol>\n<p><strong>那BFC 一般有什么用呢？</strong> </p>\n<p>比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 CSS2.1 中只有 BFC 和 IFC，CSS3 中才有 GFC 和 FFC，更多关于这些 FC 的内容可以查看：<a href=\"http://www.jshacker.com/note/3608\" target=\"_blank\" rel=\"noopener\">小科普：到底什么是BFC、IFC、GFC和FFC，次奥？</a></p>\n<h3 id=\"6-如何实现一个自适应正方形\"><a href=\"#6-如何实现一个自适应正方形\" class=\"headerlink\" title=\"6. 如何实现一个自适应正方形\"></a>6. 如何实现一个自适应正方形</h3><p>这个问题在我前不久的一篇文章里有总结过，可以<a href=\"/20170516/realization-of-adaptive-square-in-pure-css.html\">点击这里</a>查看</p>\n<h3 id=\"7-http-mp-toutiao-com-向-http-toutiao-com-发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\"><a href=\"#7-http-mp-toutiao-com-向-http-toutiao-com-发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\" class=\"headerlink\" title=\"7. http://mp.toutiao.com 向 http://toutiao.com 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\"></a>7. <a href=\"http://mp.toutiao.com\" target=\"_blank\" rel=\"noopener\">http://mp.toutiao.com</a> 向 <a href=\"http://toutiao.com\" target=\"_blank\" rel=\"noopener\">http://toutiao.com</a> 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？</h3><p>判断跨域的指标：域名、协议、端口，只要有其中一项不一致就会发生跨域</p>\n<h3 id=\"8-请介绍一下-XSS-和-CSRF-的区别，如何防御？\"><a href=\"#8-请介绍一下-XSS-和-CSRF-的区别，如何防御？\" class=\"headerlink\" title=\"8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？\"></a>8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？</h3><h4 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h4><p>XSS 全称“跨站脚本”（Cross-site scripting），是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>\n<h4 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h4><p>CSRF 的全称是“跨站请求伪造”（Cross-site request forgery），而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。 严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。</p>\n<h4 id=\"防御-XSS-攻击可以通过以下两方面操作：\"><a href=\"#防御-XSS-攻击可以通过以下两方面操作：\" class=\"headerlink\" title=\"防御 XSS 攻击可以通过以下两方面操作：\"></a>防御 XSS 攻击可以通过以下两方面操作：</h4><ol>\n<li>对用户表单输入的数据进行过滤，对 javascript 代码进行转义，然后再存入数据库；</li>\n<li>在信息的展示页面，也要进行转义，防止 javascript 在页面上执行。</li>\n</ol>\n<h4 id=\"CSRF-攻击的防御可以通过以下两方面操作：\"><a href=\"#CSRF-攻击的防御可以通过以下两方面操作：\" class=\"headerlink\" title=\"CSRF 攻击的防御可以通过以下两方面操作：\"></a>CSRF 攻击的防御可以通过以下两方面操作：</h4><ol>\n<li>所有需要用户登录之后才能执行的操作属于重要操作，这些操作传递参数应该使用 post 方式，更加安全；</li>\n<li>为防止跨站请求伪造，我们在某次请求的时候都要带上一个 csrf_token 参数，用于标识请求来源是否合法，csrf_token 参数由系统生成，存储在 SESSION 中。</li>\n</ol>\n<h4 id=\"更多关于-XSS-和-CSRF-的解释：\"><a href=\"#更多关于-XSS-和-CSRF-的解释：\" class=\"headerlink\" title=\"更多关于 XSS 和 CSRF 的解释：\"></a>更多关于 XSS 和 CSRF 的解释：</h4><ul>\n<li><a href=\"http://blog.csdn.net/koastal/article/details/52905358\" target=\"_blank\" rel=\"noopener\">浅析XSS和CSRF攻击及防御</a></li>\n<li><a href=\"https://www.zhihu.com/question/34445731?sort=created\" target=\"_blank\" rel=\"noopener\">如何用简洁生动的语言理清XSS和CSRF的区别？</a></li>\n</ul>\n<h3 id=\"9-JSBridge-是什么，它的作用是什么？\"><a href=\"#9-JSBridge-是什么，它的作用是什么？\" class=\"headerlink\" title=\"9. JSBridge 是什么，它的作用是什么？\"></a>9. JSBridge 是什么，它的作用是什么？</h3><p>在开发中我们经常需要 web 和 native 进行交互，也就是要用到经常听到的 “JSBridge”。由于我对这个东西也是停留在概念层面，所以推荐其他人的一篇文章吧：<a href=\"http://blog.csdn.net/jjx0224/article/details/52788922\" target=\"_blank\" rel=\"noopener\">理解JSBridge</a></p>\n<h3 id=\"10-TCP-和-UDP-的区别，以及如何进行拥塞控制？\"><a href=\"#10-TCP-和-UDP-的区别，以及如何进行拥塞控制？\" class=\"headerlink\" title=\"10. TCP 和 UDP 的区别，以及如何进行拥塞控制？\"></a>10. TCP 和 UDP 的区别，以及如何进行拥塞控制？</h3><ol>\n<li>TCP 面向连接（如打电话要先拨号建立连接）；UDP 是无连接的，即发送数据之前不需要建立连接</li>\n<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li>\n<li>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>\n<li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li>\n<li>TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节</li>\n<li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li>\n</ol>\n<p>更多关于 TCP 和 UDP 的区别：<a href=\"http://blog.csdn.net/li_ning_/article/details/52117463\" target=\"_blank\" rel=\"noopener\">TCP和UDP的最完整的区别</a></p>\n<h4 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h4><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br><strong>几种拥塞控制方法</strong>：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 更多关于拥塞控制：<a href=\"http://blog.csdn.net/kinger0/article/details/48206999\" target=\"_blank\" rel=\"noopener\">TCP/IP详解–拥塞控制 &amp; 慢启动 快恢复 拥塞避免</a></p>\n<h3 id=\"11-有一无序数组，数组个数为-m，如何从这-m-个数里面找到-N-个数，使这-N-个数的和为-M；并阐述时间复杂度和空间复杂度\"><a href=\"#11-有一无序数组，数组个数为-m，如何从这-m-个数里面找到-N-个数，使这-N-个数的和为-M；并阐述时间复杂度和空间复杂度\" class=\"headerlink\" title=\"11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度\"></a>11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度</h3><p>这个属于比较经典的 <a href=\"http://baike.baidu.com/item/01%E8%83%8C%E5%8C%85\" target=\"_blank\" rel=\"noopener\">01背包问题</a>，网上有很多关于这种问题的求解方式，基本上包括递归、动态规划、无脑循环等方法，推荐以下比较靠谱的解法：<a href=\"http://www.cnblogs.com/iyangyuan/p/3908498.html\" target=\"_blank\" rel=\"noopener\">动态规划（JS）</a>、<a href=\"http://blog.csdn.net/min_jie/article/details/3966867\" target=\"_blank\" rel=\"noopener\">无脑循环</a></p>\n<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><p>一面的时间很长，大概有将近一个小时的感觉，所以问的问题涉及的领域和方面也比较多，所以我就想到什么写下什么了，另外也不赋答案了，实在有点多。。</p>\n<ol>\n<li>__proto__ 是什么意思</li>\n<li>JS 实现继承的方式</li>\n<li>object.defineproprety() 方法的参数和含义</li>\n<li>setTimeout(func,0) 中设置延时为 “0” 的目的</li>\n<li>jQuery 中对 Promise() 的 when() 方法的实现原理</li>\n<li>HTTP 和 TCP 的关系</li>\n<li>TCP 三次握手</li>\n<li>HTTP 如何达到在下一次连接时不用再 TCP 三次握手的</li>\n<li>如何实现一个自适应正方形</li>\n<li>浏览器渲染的过程</li>\n<li>重排和重绘的触发时机和区别</li>\n<li>层叠上下文起作用的前提</li>\n<li>前端路由和后端路由的区别</li>\n<li>首屏加载完毕之后 <code>&lt;script&gt;&lt;/script&gt;</code> 代码的加载顺序</li>\n<li>vue.js 的设计思想</li>\n<li>如果用 jQuery 实现双向数据绑定，应该如何实现</li>\n<li>当 content-length 过长时，应该如何传输数据</li>\n<li>JS 文件中的代码执行顺序</li>\n<li>详细讲解一下 JS 中宏任务和微任务的判断机制</li>\n<li>如果有别的库中也用到了 “$”，如何解决和 jQuery 的冲突</li>\n</ol>\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><p>二面相对于一面来说，就简单随意了很多，问了一些项目的事情，还问了技术选型方面的问题，最后出了一道算法题让我做，我思考了大概 15 分钟，感觉真心写不出代码，就和面试官简单的讲了一下思路，面试官思考了一段时间之后就告诉我二面结束了，可以 hr 面了；至此，技术面就全部结束了。</p>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"搜狐研究院前端散招面试题总结","slug":"搜狐研究院前端散招面试题总结","date":"2017-05-19T02:06:37.000Z","updated":"2019-02-06T03:20:41.981Z","comments":true,"path":"api/articles/搜狐研究院前端散招面试题总结.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":null,"content":"<p>首先，搜狐媒体大厦还是蛮阔气的，但是门口的保安让我在沙发区稍等一会儿的时候，我看到那里有 5 个类似员工的人在打王者荣耀。。果然“大公司”的员工氛围就是不一样啊。。后来等了大概 10 分钟左右，一个挂有实习工作牌的女士把我带到了 9 楼，这里应该是搜狐员工办公的地方，两边都有比较大的办公区，然后中间有一块稍微小一点的地方用来面试和聊天，hr 姐姐首先让我做了一下搜狐的笔试题，然后说大概一个小时，如果做完了就给她打电话，然后就自己走开了（连杯水都没有倒，实习生就是这样的吗。。）， 做完了之后就有一位男士拿着我的简历过来了，整个面试的过程堪称尴尬，因为我的简历上写有“关注ES6”，所以这位年轻的面试官就开始各种问 ES6 相关的东西，还问我和 react 相关的东西，比如让我讲一下 react 的设计思想啊什么的。。难道这就是“关注ES6”想要表达的意思吗？后来他可能感觉也比较尴尬了，就问了一些 JS 相关的东西，比如 self 和 this 的区别啊什么的，但是我的水平实在有限，这位面试官的前端水平实在是在我之上太多，所以我也是基本上全程蒙蔽，更别提让我用 jQuery 实现一个 promise 对象了（对了，这位面试官连 jQ 的 when() 方法都不知道。。），就这样结束了一面，当然由于我的水平实在太低，所以就直接让我走人了（不过我也比较饿了，想回学校吃点东西了。。）</p>\n<h2 id=\"笔试题\"><a href=\"#笔试题\" class=\"headerlink\" title=\"笔试题\"></a>笔试题</h2><h3 id=\"一、不定项选择题\"><a href=\"#一、不定项选择题\" class=\"headerlink\" title=\"一、不定项选择题\"></a>一、不定项选择题</h3><p>我不知道笔试题能不能拍照，但是我还是冒着被批评和留下不好印象的风险拍了一下，总体来说难度还是适中的，其中有些题还是蛮经典的，大家可以自行消化</p>\n<h4 id=\"1-以下元素为块级元素的有：\"><a href=\"#1-以下元素为块级元素的有：\" class=\"headerlink\" title=\"1. 以下元素为块级元素的有：\"></a>1. 以下元素为块级元素的有：</h4><ul>\n<li>p</li>\n<li>strong</li>\n<li>span</li>\n<li>section</li>\n</ul>\n<h4 id=\"2-以下可以使元素不可见的有：\"><a href=\"#2-以下可以使元素不可见的有：\" class=\"headerlink\" title=\"2. 以下可以使元素不可见的有：\"></a>2. 以下可以使元素不可见的有：</h4><ul>\n<li>display: none</li>\n<li>width:0; height:0; overflow:hidden</li>\n<li>visibility: hidden</li>\n<li>display: inline</li>\n</ul>\n<h4 id=\"3-以下正确的有：\"><a href=\"#3-以下正确的有：\" class=\"headerlink\" title=\"3. 以下正确的有：\"></a>3. 以下正确的有：</h4><ul>\n<li>Number.MIN_VALUE &gt; 0</li>\n<li>Number(1) == new Number(1)</li>\n<li>null == undefined</li>\n<li>NaN == NaN</li>\n</ul>\n<h4 id=\"4-以下会有错误发生的有：\"><a href=\"#4-以下会有错误发生的有：\" class=\"headerlink\" title=\"4. 以下会有错误发生的有：\"></a>4. 以下会有错误发生的有：</h4><ul>\n<li>9..toString()  //“9”</li>\n<li>alert(a)  //a is not defined</li>\n<li>eval(‘a’)  //a is not defined</li>\n<li>console.log(Number)</li>\n</ul>\n<h4 id=\"5-以下哪些情况会促发-BFC？\"><a href=\"#5-以下哪些情况会促发-BFC？\" class=\"headerlink\" title=\"5. 以下哪些情况会促发 BFC？\"></a>5. 以下哪些情况会促发 BFC？</h4><ul>\n<li>float 不为 none</li>\n<li>position 为 fixed</li>\n<li>display 为 static</li>\n<li>overflow 为 scroll</li>\n</ul>\n<h4 id=\"6-哪些元素会生成-BFC：\"><a href=\"#6-哪些元素会生成-BFC：\" class=\"headerlink\" title=\"6. 哪些元素会生成 BFC：\"></a>6. 哪些元素会生成 BFC：</h4><ol>\n<li>根元素</li>\n<li>float 属性不为 none</li>\n<li>position 为 absolute 或 fixed</li>\n<li>display 为 inline-block, table-cell, table-caption, flex, inline-flex</li>\n<li>overflow 不为 visible</li>\n</ol>\n<h3 id=\"二、填空题\"><a href=\"#二、填空题\" class=\"headerlink\" title=\"二、填空题\"></a>二、填空题</h3><h4 id=\"1-一个-div-垂直居中于整个-body-的-css-代码：\"><a href=\"#1-一个-div-垂直居中于整个-body-的-css-代码：\" class=\"headerlink\" title=\"1. 一个 div 垂直居中于整个 body 的 css 代码：\"></a>1. 一个 div 垂直居中于整个 body 的 css 代码：</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-以下代码的打印结果为：10-10-10-10-10-10-10-10-10-10\"><a href=\"#2-以下代码的打印结果为：10-10-10-10-10-10-10-10-10-10\" class=\"headerlink\" title=\"2. 以下代码的打印结果为：10 10 10 10 10 10 10 10 10 10\"></a>2. 以下代码的打印结果为：10 10 10 10 10 10 10 10 10 10</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-匹配邮箱的正则表达式：\"><a href=\"#3-匹配邮箱的正则表达式：\" class=\"headerlink\" title=\"3. 匹配邮箱的正则表达式：\"></a>3. 匹配邮箱的正则表达式：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^\\[a-z0<span class=\"number\">-9</span>\\]+(\\[._\\\\\\-\\]*\\[a-z0<span class=\"number\">-9</span>\\])*@(\\[a-z0<span class=\"number\">-9</span>\\]+\\[-a-z0<span class=\"number\">-9</span>\\]*\\[a-z0<span class=\"number\">-9</span>\\]+.)&#123;<span class=\"number\">1</span>,<span class=\"number\">63</span>&#125;\\[a-z0<span class=\"number\">-9</span>\\]+$</span><br></pre></td></tr></table></figure>\n<p>对于该正则表达式的解释：<a href=\"http://www.jb51.net/article/31182.htm\" target=\"_blank\" rel=\"noopener\">比较正宗的验证邮箱的正则表达式js代码详解</a></p>\n<h4 id=\"4-对纯数字数组中每个元素进行乘以-2-后再取数组中的最小值\"><a href=\"#4-对纯数字数组中每个元素进行乘以-2-后再取数组中的最小值\" class=\"headerlink\" title=\"4. 对纯数字数组中每个元素进行乘以 2 后再取数组中的最小值\"></a>4. 对纯数字数组中每个元素进行乘以 2 后再取数组中的最小值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doubleMin</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.min.apply(<span class=\"literal\">null</span>,arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item*<span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于数组 map() 方法的讲解：<a href=\"http://www.cnblogs.com/xuan52rock/p/4460949.html\" target=\"_blank\" rel=\"noopener\">js 数组 map方法</a></p>\n<h4 id=\"5-对以下数组按照拼音首字母排序-arr-‘研发中心’-’视频中心’-’焦点部门’-’新闻部门’\"><a href=\"#5-对以下数组按照拼音首字母排序-arr-‘研发中心’-’视频中心’-’焦点部门’-’新闻部门’\" class=\"headerlink\" title=\"5. 对以下数组按照拼音首字母排序 arr: [‘研发中心’,’视频中心’,’焦点部门’,’新闻部门’]\"></a>5. 对以下数组按照拼音首字母排序 arr: [‘研发中心’,’视频中心’,’焦点部门’,’新闻部门’]</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> af = a.charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> bf = b.charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(af.localeCompare(bf) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(af.localeCompare(bf) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、简答题\"><a href=\"#三、简答题\" class=\"headerlink\" title=\"三、简答题\"></a>三、简答题</h3><h4 id=\"1-实现：var-a-add-10-3-2-a打印结果为15\"><a href=\"#1-实现：var-a-add-10-3-2-a打印结果为15\" class=\"headerlink\" title=\"1. 实现：var a = add(10)(3)(2) // a打印结果为15\"></a>1. 实现：var a = add(10)(3)(2) // a打印结果为15</h4><p>这是一道关于类型转换的问题：<a href=\"http://web.jobbole.com/90654/\" target=\"_blank\" rel=\"noopener\">一道面试题引发的对 javascript 类型转换的思考</a></p>\n<h4 id=\"2-实现一个加载的动画-该动画有至少三个小圆，分别变大变小富有层次感-（只能使用-css）\"><a href=\"#2-实现一个加载的动画-该动画有至少三个小圆，分别变大变小富有层次感-（只能使用-css）\" class=\"headerlink\" title=\"2. 实现一个加载的动画(该动画有至少三个小圆，分别变大变小富有层次感)（只能使用 css）\"></a>2. 实现一个加载的动画(该动画有至少三个小圆，分别变大变小富有层次感)（只能使用 css）</h4><p>利用关键帧动画 @keyframes 就可以达到，网上有好多关于加载动画实现的文章，推荐一下类似这道题想要的效果的文章：<a href=\"http://www.cnblogs.com/zourong/p/4022729.html\" target=\"_blank\" rel=\"noopener\">CSS 实现加载动画之八-圆点旋转</a>、<a href=\"http://www.jq22.com/yanshi12864\" target=\"_blank\" rel=\"noopener\">6种CSS3加载动画</a></p>\n<h4 id=\"3-HTTP-是一个无状态的协议，那网站是如何记住用户信息的呢？请写出详细过程；同时谈谈-localStorage-和-sessionStorage-的区别，对离线缓存，甚至是-indexDB-的理解\"><a href=\"#3-HTTP-是一个无状态的协议，那网站是如何记住用户信息的呢？请写出详细过程；同时谈谈-localStorage-和-sessionStorage-的区别，对离线缓存，甚至是-indexDB-的理解\" class=\"headerlink\" title=\"3. HTTP 是一个无状态的协议，那网站是如何记住用户信息的呢？请写出详细过程；同时谈谈 localStorage 和 sessionStorage 的区别，对离线缓存，甚至是 indexDB 的理解\"></a>3. HTTP 是一个无状态的协议，那网站是如何记住用户信息的呢？请写出详细过程；同时谈谈 localStorage 和 sessionStorage 的区别，对离线缓存，甚至是 indexDB 的理解</h4><p>网站是如何记住用户信息的：<a href=\"http://xdxd.love/2016/01/07/%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%E4%B8%AD%E8%AE%A4%E8%AF%81%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/\" target=\"_blank\" rel=\"noopener\">无状态协议中认证状态保持方案的一些思考</a></p>\n<h4 id=\"4-请用-JS-实现一个简单的列表-List-类，使得其具有-show-展示该-list-的所有元素-，add-向-list-添加一个元素，无返回-，delete-删除指定位置的元素，并返回删除成功否-，clear-清空-list-；\"><a href=\"#4-请用-JS-实现一个简单的列表-List-类，使得其具有-show-展示该-list-的所有元素-，add-向-list-添加一个元素，无返回-，delete-删除指定位置的元素，并返回删除成功否-，clear-清空-list-；\" class=\"headerlink\" title=\"4. 请用 JS 实现一个简单的列表(List)类，使得其具有 show(展示该 list 的所有元素)，add(向 list 添加一个元素，无返回)，delete(删除指定位置的元素，并返回删除成功否)，clear(清空 list)；\"></a>4. 请用 JS 实现一个简单的列表(List)类，使得其具有 show(展示该 list 的所有元素)，add(向 list 添加一个元素，无返回)，delete(删除指定位置的元素，并返回删除成功否)，clear(清空 list)；</h4><p>在 JS 中是没有类的，所以其实是用 function 来间接实现，这类实现在我的另一篇文章里大量提到：<a href=\"/20170326/complex-data-structure-implemented-by-js.html\">JS 实现复杂数据结构</a></p>\n<h4 id=\"5-请分别实现一个菱形，一个倒三角，一个椭圆形的答案（只能使用-css-和-html，不考虑兼容性）\"><a href=\"#5-请分别实现一个菱形，一个倒三角，一个椭圆形的答案（只能使用-css-和-html，不考虑兼容性）\" class=\"headerlink\" title=\"5. 请分别实现一个菱形，一个倒三角，一个椭圆形的答案（只能使用 css 和 html，不考虑兼容性）\"></a>5. 请分别实现一个菱形，一个倒三角，一个椭圆形的答案（只能使用 css 和 html，不考虑兼容性）</h4><p>在 css 中，通过 border 和旋转可以实现很多种图形，我在这个方面也是比较白痴的，所以推荐以下文章：<a href=\"http://www.2cto.com/kf/201604/500811.html\" target=\"_blank\" rel=\"noopener\">CSS3实现32种基本图形</a>、<a href=\"http://www.cnblogs.com/pigtail/archive/2013/02/17/2914119.html\" target=\"_blank\" rel=\"noopener\">利用css样式画各种图形–初步、进阶、高级（一）</a>（感觉这两篇文章的排版和图片都不是很好，找时间我会自己再总结一下）</p>\n<h4 id=\"6-简要回答你对跨域的理解，为什么要跨域，如何跨域\"><a href=\"#6-简要回答你对跨域的理解，为什么要跨域，如何跨域\" class=\"headerlink\" title=\"6. 简要回答你对跨域的理解，为什么要跨域，如何跨域\"></a>6. 简要回答你对跨域的理解，为什么要跨域，如何跨域</h4><p>跨域这种问题应该是老生常谈了，其实就是浏览器的一种“同源策略”，为了保证安全而采取的措施，具体大家自行搜索吧，关于跨域的文章实在是太多了</p>\n<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"1-localStorage-和-sessionStorage-的区别\"><a href=\"#1-localStorage-和-sessionStorage-的区别\" class=\"headerlink\" title=\"1. localStorage 和 sessionStorage 的区别\"></a>1. localStorage 和 sessionStorage 的区别</h3><ul>\n<li>localStorage 和 sessionStorage 一样都是用来存储客户端临时信息的对象。</li>\n<li>他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。</li>\n<li>localStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的 UI 上清除 localStorage 信息，否则这些信息将永远存在。</li>\n<li>sessionStorage 生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过 sessionStorage 存储的数据也就被清空了。</li>\n<li>不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。</li>\n</ul>\n<h3 id=\"2-JS中self和this的区别\"><a href=\"#2-JS中self和this的区别\" class=\"headerlink\" title=\"2. JS中self和this的区别\"></a>2. JS中self和this的区别</h3><p>不知道为什么面试官会问这个问题，因为 self 好像在 react 才会经常用到吧？。。但是我还是查了一下，网上对这两个的区别的解释很少，大致就是：self 指向本窗口，this 指向就比较广泛了</p>\n<h3 id=\"3-如何实现-JS-中的防抖动和节流阀\"><a href=\"#3-如何实现-JS-中的防抖动和节流阀\" class=\"headerlink\" title=\"3. 如何实现 JS 中的防抖动和节流阀\"></a>3. 如何实现 JS 中的防抖动和节流阀</h3><p>这个功能其实经常用到，但是面试官给我的答案是 underscore.js 源码中有，然后说 jQuery 的第三方库应该也有。。估计是这位面试官经常用 underscore.js 解决重复点击的问题，然后至于怎么实现的自己也不知道。。（我就没好意思再问了，以免造成尴尬的局面），推荐一下解释的很清楚的文章（这是一篇中文译文，英文原文可以点击下面这篇文章中的原文链接）：<a href=\"http://www.tuicool.com/articles/VfyMBrI\" target=\"_blank\" rel=\"noopener\">实例解析防抖动（Debouncing）和节流阀（Throttling）</a></p>\n<h3 id=\"4-HTML5-使任何元素变为可编辑的属性\"><a href=\"#4-HTML5-使任何元素变为可编辑的属性\" class=\"headerlink\" title=\"4. HTML5 使任何元素变为可编辑的属性\"></a>4. HTML5 使任何元素变为可编辑的属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contenteditable=&quot;true&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-当给-line-height-设置为-5rem、5em、5px、5pt、500-、5-时的计算公式\"><a href=\"#5-当给-line-height-设置为-5rem、5em、5px、5pt、500-、5-时的计算公式\" class=\"headerlink\" title=\"5. 当给 line-height 设置为 5rem、5em、5px、5pt、500%、5 时的计算公式\"></a>5. 当给 line-height 设置为 5rem、5em、5px、5pt、500%、5 时的计算公式</h3><p>在张鑫旭的慕课网讲解视频（深入理解 CSS 系列）中曾经讲到过这些单位的含义和作用，具体可以点击下面链接查看我对他的讲解的总结：<a href=\"/20170421/line-height-of-css.html\">CSS 深入理解之 line-height</a>，具体计算公式和作用如下：</p>\n<ul>\n<li>5rem：按照 html 的 font-size 进行计算</li>\n<li>5em：按照自身的 font-size 进行计算</li>\n<li>5px：相对长度单位，像素</li>\n<li>5pt：绝对长度单位，点 Points (1点 = 1/72英寸)</li>\n<li>500%：按照自身的 font-size 进行计算</li>\n<li>5：同样按照自身的 font-size 进行计算</li>\n</ul>\n<p>可以看出，line-height 的值如果不是具体数值，都是按照 font-size 进行计算的，同时 500%/5em/5 有什么区别呢？在张鑫旭的讲解中也提到了，500%/5em 会根据自身的 font-size 进行计算，得到具体数值后将行高继承给后代元素，而 5 只会将比例继承给后代元素，后代元素会根据自己的 font-size 重新计算行高</p>\n<blockquote>\n<p>更新自2017-10-11：突然发现小程序中有一个很有趣的长度单位 rpx，具体参见这篇文章：<a href=\"http://huang-jerryc.com/2017/05/21/talk-about-pixel-and-rpx/\" target=\"_blank\" rel=\"noopener\">谈谈像素以及微信小程序的 rpx</a></p>\n</blockquote>\n<h3 id=\"6-oninput-事件和-onchange-事件的区别\"><a href=\"#6-oninput-事件和-onchange-事件的区别\" class=\"headerlink\" title=\"6. oninput 事件和 onchange 事件的区别\"></a>6. oninput 事件和 onchange 事件的区别</h3><p>onchange 事件经常用到（图片、文件上传），但是 oninput 事件却没有用过了，推荐：<a href=\"http://blog.csdn.net/freshlover/article/details/39050609\" target=\"_blank\" rel=\"noopener\">总结oninput、onchange与onpropertychange事件的用法和区别</a></p>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"面试","path":"api/tags/面试.json"}]},{"title":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","slug":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","date":"2017-04-06T08:42:13.000Z","updated":"2019-02-06T03:20:41.985Z","comments":true,"path":"api/articles/读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道.json","excerpt":null,"keywords":"merrier 博客 前端 北邮人","cover":"/images/hexo_post_300.png","content":"<h2 id=\"1-Web-标准——结构、样式和行为的分离\"><a href=\"#1-Web-标准——结构、样式和行为的分离\" class=\"headerlink\" title=\"1. Web 标准——结构、样式和行为的分离\"></a>1. Web 标准——结构、样式和行为的分离</h2><p>Web 标准由一系列标准组合而成，其核心理念就是将网页的结构，样式和行为分离开来，所以它可以分为三大部分：结构标准，央视标准和行为标准。<br>结构标准包括 XML 标准，XHTML 标准，HTML 标准；<br>样式标准主要是指 CSS 标准；<br>行为标准主要包括 DOM 标准和 ECMAScript 标准。</p>\n<h2 id=\"2-打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\"><a href=\"#2-打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\" class=\"headerlink\" title=\"2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序\"></a>2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序</h2><p>精简的代码可以让文件变小，有利于客户端快速下载；重用可以让代码更易于精简，同时有助于提升开发速度；有序可以让我们更清晰地组织代码，使代码易于维护，有效应对变化。</p>\n<h2 id=\"3-欲精一行，必先通十行\"><a href=\"#3-欲精一行，必先通十行\" class=\"headerlink\" title=\"3. 欲精一行，必先通十行\"></a>3. 欲精一行，必先通十行</h2><p>在前端开发领域，不通十行就无法精一行。专精很难，甚至不可能，一专多能才是现实的。在前端开发这个领域，一专多能更是非常必要的。</p>\n<h2 id=\"4-增加代码可读性——注释\"><a href=\"#4-增加代码可读性——注释\" class=\"headerlink\" title=\"4.增加代码可读性——注释\"></a>4.增加代码可读性——注释</h2><p>一个好的代码，注释要占 1/3 的篇幅</p>\n<h2 id=\"5-磨刀不误砍柴工——前期的构思很重要\"><a href=\"#5-磨刀不误砍柴工——前期的构思很重要\" class=\"headerlink\" title=\"5. 磨刀不误砍柴工——前期的构思很重要\"></a>5. 磨刀不误砍柴工——前期的构思很重要</h2><p>构思的内容主要包括规范的指定，公共组件的设计和复杂功能的技术方案等。一般来说，前期构思占整个项目 30% ~ 60% 的时间都算是正常的.</p>\n<h2 id=\"6-标签的语义\"><a href=\"#6-标签的语义\" class=\"headerlink\" title=\"6. 标签的语义\"></a>6. 标签的语义</h2><p>HTML 标签的设计都是有语义考虑的。下表是部分标签的全称和中文翻译：</p>\n<div align=\"center\"><img src=\"/images/hexo_post_300.png\" alt=\"\" width=\"600\"></div><br><div align=\"center\"><img src=\"/images/hexo_post_301.png\" alt=\"\" width=\"600\"></div>\n\n<p>其中，<strong>div 和 span 其实是没有语义的</strong>，它们只是分别用作块级元素和行内元素的区域分隔符。事实上，CSS 布局只是 Web 标准的一部分。在 HTML，CSS，JavaScript 这三大元素中，HTML 才是最重要的，结构才是重点，样式是用来修饰结构的。正确的做法是，先确定 HTML，确定语义的标签，再来选用合适的 CSS。</p>\n<h2 id=\"7-如何确定你的标签是否语义良好\"><a href=\"#7-如何确定你的标签是否语义良好\" class=\"headerlink\" title=\"7. 如何确定你的标签是否语义良好\"></a>7. 如何确定你的标签是否语义良好</h2><p>判断网页标签语义是否良好的一个简单方法就是：<strong>去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性</strong>。除了去样式后的可读性外，值得重点提及的还有 h 标签。h 标签的含义是”标题”，搜索引擎对这个标签比较敏感，尤其是 h1 和 h2。一个语义良好的页面，h 标签应该是完整有序没有断层的。也就是说，<strong>要按照 h1，h2，h3，h4 这样依次排列下来，不要出现类似 h1，h2，h3，h4，漏掉 h2 的情况</strong>。</p>\n<h2 id=\"8-常见模块\"><a href=\"#8-常见模块\" class=\"headerlink\" title=\"8. 常见模块\"></a>8. 常见模块</h2><h3 id=\"标题和内容\"><a href=\"#标题和内容\" class=\"headerlink\" title=\"标题和内容\"></a>标题和内容</h3><p>当页面内标签无法满足设计需要时，才会适当添加 div 和 span 等无语义标签来辅助实现。</p>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>登录表单<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"name\"</span>&gt;</span>账号：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"pw\"</span>&gt;</span>密码：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pw\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"登录\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"subBtn\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>一般来说，表单域要用 fieldset 标签包起来，并用 legend 标签说明表单的用途。因为 fieldset 默认有边框，而 legend 也有默认的样式，为满足设计需要，我们可以将 fieldset 的 “border” 设为 “none”，把 legend 的 “display” 设为 “none”，以此来兼顾语义和设计两方面的要求。每个 input 标签对应的说明文本都需要 label1 标签，并且通过为 input 设置 id 属性，在 label 标签中设置 “for=someld” 来让说明文本和相应的 input 关联起来.</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>表格标题要用 caption，表头要用 thead 包围，主体部分用 tbody 包围，尾部要用 tfoot 包围，表头和一般单元格要区分开，表头用 th，一般单元格用 td。</p>\n<h2 id=\"9-语义化标签应注意的一些其他问题\"><a href=\"#9-语义化标签应注意的一些其他问题\" class=\"headerlink\" title=\"9. 语义化标签应注意的一些其他问题\"></a>9. 语义化标签应注意的一些其他问题</h2><p>为了保证网页去样式后的可读性，并且又符合 Web 标准，我们应注意以下几点：</p>\n<ul>\n<li>尽可能少的使用无语义标签 div 和 span；</li>\n<li>在语义不明显，既可以用 p 也可以用 div 的地方，尽量用 p，因为 p 默认情况下有上下间距，去样式后的可读性更好，对兼容特殊终端有利；</li>\n<li>不要使用纯样式标签，例如 b，font 和 u 等，改用 CSS 设置。语义上需要强调的文本可以包在 strong 或 em 标签里，strong 和 em 有”强调”的语意，其中 strong 的默认样式是加粗，而 em 的默认样式是斜体。</li>\n</ul>\n<h2 id=\"10-如何组织-CSS\"><a href=\"#10-如何组织-CSS\" class=\"headerlink\" title=\"10. 如何组织 CSS\"></a>10. 如何组织 CSS</h2><p>一种组织 CSS 的方法：<strong>base.css+common.css+page.css</strong>。将网站内的所有样式，按照职能分成三大类：base，common 和 page。</p>\n<h3 id=\"base-层\"><a href=\"#base-层\" class=\"headerlink\" title=\"base 层\"></a>base 层</h3><p>这一层位于三者的最底层，提供 CSS reset 功能和粒度最小的通用类——原子类。这一层会被所有页面引用，是页面样式所需依赖的最底层。这一层与具体 UI 无关，无论何种风格的设计都可以引用它，所以 base 层要力求精简和通用。base 层具有高度可移植性，不同设计风格的网站可以使用同一个 base 层. base 层相对稳定，基本上不需要维护。</p>\n<h3 id=\"common-层\"><a href=\"#common-层\" class=\"headerlink\" title=\"common 层\"></a>common 层</h3><p>这一层位于中间，提供组件级的 CSS 类。我们可以将页面内的元素拆分成一小块一小块功能和样式相对独立的小”模块”，这些”模块”有些是很少重复的，有些是会大量重复的，我们可以将大量重复的”模块”视为一个组件。我们从页面里尽可能多的将组件提取出来，放在 common 层里。common 层就相当于 MVC 模式中的 M(Model，模型)。为了保证重用性和灵活性，M 需要尽可能将内部实现封装，对可能会经常变化的部分提供灵活的接口。common 层是网站级的，不同的网站有不同的 common 层，同一个网站只有一个 common 层。在团队合作中，common 层最好由一个人负责，统一管理。</p>\n<h3 id=\"page-层\"><a href=\"#page-层\" class=\"headerlink\" title=\"page 层\"></a>page 层</h3><p>网站中高度重用的模块，我们把它们视为组件，放在 common 层；非高度重用的模块，可以把它们放在 page 层。page 层位于最高层，提供页面级的样式，对重用性没有要求。base 层基本上不需要维护，common 层修改的幅度不会很大，通常只由一个人负责维护，但到了 page 层，代码可能由多人开发，如何避免冲突是个需要注意的问题。通常我们通过命名规则来避免这种冲突。</p>\n<h2 id=\"11-推荐的-base-css\"><a href=\"#11-推荐的-base-css\" class=\"headerlink\" title=\"11. 推荐的 base.css\"></a>11. 推荐的 base.css</h2><p>通常情况下，为了让浮动元素的父容器能够根据浮动元素的高度而自适应高度，有三种做法：</p>\n<ul>\n<li>让父容器同时浮动起来，例如：<code>&lt;div class=&quot;fl&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>；</li>\n<li>让浮动元素后面紧跟一个用于清楚浮动的空标签，例如 <code>&lt;div&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;div class=&quot;cb&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>；</li>\n<li><strong>给父容器挂一个特殊 class，直接从父容器清除浮动元素的浮动，例如 <code>&lt;div class=&quot;clearfix&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></strong></li>\n</ul>\n<p><strong>第一种方法会让父容器也浮动起来，影响父元素后面的元素的布局，有副作用；第二种方法增加了一个空标签，破坏了语义化。第三种方法没有任何副作用，推荐使用。</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span> &#123; </span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  <span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:inline-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-拆分模块\"><a href=\"#12-拆分模块\" class=\"headerlink\" title=\"12. 拆分模块\"></a>12. 拆分模块</h2><ul>\n<li>模块与模块之间尽量不要包含相同的部分，如果有相同部分，应将它们提取出来，拆分成一个独立的模块.</li>\n<li>模块应在保证数量尽可能少的原则下，做到尽可能简单，以提高重用性.</li>\n</ul>\n<p>##13. CSS 的命名</p>\n<p>推荐使用英语，不要使用汉语拼音。我们可以根据内容来选用合适的英文单词命名 CSS。比如头部用 head，底部用 foot，主体部分用 main，导航用 nav，菜单用 menu 等，page 层 css 命名不可过短，可以将开发人员名字缩写作为前缀，以免发生冲突。</p>\n<h2 id=\"14-挂多个-class-还是新建-class——多用组合，少用继承\"><a href=\"#14-挂多个-class-还是新建-class——多用组合，少用继承\" class=\"headerlink\" title=\"14. 挂多个 class 还是新建 class——多用组合，少用继承\"></a>14. 挂多个 class 还是新建 class——多用组合，少用继承</h2><p>在面向对象编程里，有个很重要的原则就是”多用组合，少用继承”. HTML 的 class 与程序中”类”有相同的”味道”，class 可以挂多个，从技术上支持了”组合”的用法。我们在使用 CSS 时，如果能灵活运用这点就可以大大减少类的数量，一方面减少了代码量，提高了可维护性，另一方面时类的职责更单一，弹性更强，增加了类的重用性，提高了开发效率。</p>\n<h2 id=\"15-组件的-margin\"><a href=\"#15-组件的-margin\" class=\"headerlink\" title=\"15 .组件的 margin\"></a>15 .组件的 margin</h2><p>如果对相邻的模块同时使用了 margin-top 和 margin-bottom，边距会重合带来不必要的麻烦，所以最好统一使用 margin-top 或者 margin-bottom，不要混合使用，从而降低出现问题的风险。<br>总结：如果不确定模块的上下 margin 特别稳定，最好不要将它写到模块的类里，而是使用类的祝贺，单独为上下 margin 挂用于边距的原子类(例如 mt10，mb20)。模块最好不要混用 margin-top 和 margin-bottom，统一使用 margin-top 或 margin-bottom。</p>\n<h2 id=\"16-低权重原则——避免滥用子选择器\"><a href=\"#16-低权重原则——避免滥用子选择器\" class=\"headerlink\" title=\"16. 低权重原则——避免滥用子选择器\"></a>16. 低权重原则——避免滥用子选择器</h2><p>除非确定 HTML 结构非常稳定，一定不会再修改了，否则尽量不要使用子选择器。为了保证样式容易被覆盖，提高可维护性，CSS 选择符需保证权重尽可能低。</p>\n<h2 id=\"17-CSS-sprit-技术\"><a href=\"#17-CSS-sprit-技术\" class=\"headerlink\" title=\"17. CSS sprit 技术\"></a>17. CSS sprit 技术</h2><p>CSS sprite 技术看似简单，其实不容易掌握，主要有如下原因:</p>\n<ul>\n<li>它能合并的只能是用于背景的图片，对于 <code>&lt;img src=&quot;&quot; /&gt;</code> 设置的图片，是不能合并到 CSS sprite 大图中的，如果合并这些图片会影响页面可读性。</li>\n<li>对于横向和纵向都平铺的图片，也不能使用 CSS sprite；如果是横向平铺的，只能将所有横向平铺的图合并成一张大图，只能竖直排列，不能水平排列；如果是纵向平铺的，我们只能将所有纵向平铺的图合并成一张大图，只能水平排列，不能竖直排列。</li>\n<li>图片如何排列能够尽量紧凑，同时保证不会影响扩展性。这点是 CSS sprite 技术最困难也是最具挑战性的地方。</li>\n</ul>\n<h2 id=\"18-CSS-hack\"><a href=\"#18-CSS-hack\" class=\"headerlink\" title=\"18. CSS hack\"></a>18. CSS hack</h2><h3 id=\"IE-条件注释法\"><a href=\"#IE-条件注释法\" class=\"headerlink\" title=\"IE 条件注释法\"></a>IE 条件注释法</h3><h4 id=\"只在IE下生效\"><a href=\"#只在IE下生效\" class=\"headerlink\" title=\"只在IE下生效\"></a>只在IE下生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE6-下生效\"><a href=\"#只在-IE6-下生效\" class=\"headerlink\" title=\"只在 IE6 下生效\"></a>只在 IE6 下生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE6-以上版本生效\"><a href=\"#只在-IE6-以上版本生效\" class=\"headerlink\" title=\"只在 IE6 以上版本生效\"></a>只在 IE6 以上版本生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if gt IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只在-IE7-上不生效\"><a href=\"#只在-IE7-上不生效\" class=\"headerlink\" title=\"只在 IE7 上不生效\"></a>只在 IE7 上不生效</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if ! IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注释和-style-标签\"><a href=\"#条件注释和-style-标签\" class=\"headerlink\" title=\"条件注释和 style 标签\"></a>条件注释和 style 标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;style type=\"text/CSS\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">.test&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注释和-script-标签\"><a href=\"#条件注释和-script-标签\" class=\"headerlink\" title=\"条件注释和 script 标签\"></a>条件注释和 script 标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;script type=\"text/JavaScript\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">alert(\"我是 IE 6\");</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"选择符前缀法\"><a href=\"#选择符前缀法\" class=\"headerlink\" title=\"选择符前缀法\"></a>选择符前缀法</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/CSS\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">80px</span>; &#125;               <span class=\"comment\">/* IE 6,IE 7,IE 8 */</span></span></span><br><span class=\"line\"><span class=\"css\">*<span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">60px</span>; &#125;         <span class=\"comment\">/* only for IE 6 */</span></span></span><br><span class=\"line\"><span class=\"css\">*+<span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">70px</span>; &#125;        <span class=\"comment\">/* only for IE 7 */</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>选择符前缀法相较于 IE 条件注释法来说，可维护性强了很多，但在向后兼容性上存在一点风险。另外，选择符前缀法不能用于内联样式上。</p>\n<h3 id=\"样式属性前缀法\"><a href=\"#样式属性前缀法\" class=\"headerlink\" title=\"样式属性前缀法\"></a>样式属性前缀法</h3><p>样式属性前缀法的原理是在样式的属性名前加前缀，这些前缀只在特定浏览器下才生效.例如 “_” 只在 IE6 下生效，”*” 在 IE6 和 IE7 下生效。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/CSS\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.test</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 80px;</span></span><br><span class=\"line\"><span class=\"undefined\">  *width: 70px;</span></span><br><span class=\"line\"><span class=\"undefined\">  _width: 60px;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"19-a-标签的四种状态\"><a href=\"#19-a-标签的四种状态\" class=\"headerlink\" title=\"19. a 标签的四种状态\"></a>19. a 标签的四种状态</h2><p>关于 a 标签的四种状态的排序问题，有个简单好记的原则，叫做 love hate 原则，即 l(link)ov(visited)e h(hover)a(active)te</p>\n<h2 id=\"20-hasLayout\"><a href=\"#20-hasLayout\" class=\"headerlink\" title=\"20. hasLayout\"></a>20. hasLayout</h2><p>hasLayout 是 IE 浏览器专有的一个属性，用于 CSS 的解析引擎。有时候在 IE 下一些复杂的 CSS 设置解析起来会出现 Bug，其原因可能与 hasLayout 没有被自动触发有关，我们通过一些技巧，手动触发 hasLayout 属性就可以解决Bug了。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_302.png\" alt=\"\" width=\"550\"></div>\n\n<div align=\"center\"><img src=\"/images/hexo_post_303.png\" alt=\"\" width=\"550\"></div>\n\n<h2 id=\"21-块级元素和行内元素的区别\"><a href=\"#21-块级元素和行内元素的区别\" class=\"headerlink\" title=\"21. 块级元素和行内元素的区别\"></a>21. 块级元素和行内元素的区别</h2><ul>\n<li>块级元素会独占一行，默认情况下，其宽度自动填满其父元素宽度，行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化；</li>\n<li>块级元素可以设置 width，height 属性。行内元素设置 width，height 属性无效。块级元素即使设置了宽度，仍然是独占一行的；</li>\n<li>块级元素可以设置 margin 和 padding 属性。行内元素的 margin 和 padding 属性很奇怪，水平方向的 padding 和 margin 都产生边距效果，但竖直方向的 padding，margin 却不会产生边距效果。</li>\n</ul>\n<h2 id=\"22-display-inline-block\"><a href=\"#22-display-inline-block\" class=\"headerlink\" title=\"22. display:inline-block\"></a>22. display:inline-block</h2><p>它是行内的块级元素，它拥有块级元素的特点，可以设置长宽，可以设置 margin 和 padding 值，但它却不是独占一行，它的宽度并不占满父元素，而是和行内元素一样，可以和其他行内元素排在同一行里.</p>\n<h2 id=\"23-relative，absolute-和-float\"><a href=\"#23-relative，absolute-和-float\" class=\"headerlink\" title=\"23. relative，absolute 和 float\"></a>23. relative，absolute 和 float</h2><p>设置 position: relative 或 position: absolute 都可以让元素激活 left，top，right，bottom 和 z-index 属性(默认情况下，这些属性未激活，设置了也无效) 设置 position:relative 或 position:absolute 会让元素”浮”起来，也就是 z-index 值大于 0，它会改变正常情况下的文档流。float 也能改变文档流，不同的是，float 属性不会让元素”上浮”到另一个 z-index 层，它仍然让元素在 z-index: 0 层排列。另外，不论之前什么类型的元素(display: none 除外)，只要设置了 position: absolute，float: left 或 float: right 中的任意一个，都会让元素以 display: inline-block 的方式显示，可以设置长宽，默认宽度并不占满父元素。就算我们显示地设置 display: inline 或者 display: block，也仍然无效。position: relative 不会隐式改变 display 的类型。</p>\n<h2 id=\"24-居中\"><a href=\"#24-居中\" class=\"headerlink\" title=\"24. 居中\"></a>24. 居中</h2><h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3><h4 id=\"文本，图片等行内元素的水平居中\"><a href=\"#文本，图片等行内元素的水平居中\" class=\"headerlink\" title=\"文本，图片等行内元素的水平居中\"></a>文本，图片等行内元素的水平居中</h4><p>父元素设置text-align:center</p>\n<h4 id=\"确定宽度的块级元素的水平居中\"><a href=\"#确定宽度的块级元素的水平居中\" class=\"headerlink\" title=\"确定宽度的块级元素的水平居中\"></a>确定宽度的块级元素的水平居中</h4><p>margin:0 auto</p>\n<h4 id=\"不确定宽度的块级元素的水平居中\"><a href=\"#不确定宽度的块级元素的水平居中\" class=\"headerlink\" title=\"不确定宽度的块级元素的水平居中\"></a>不确定宽度的块级元素的水平居中</h4><ul>\n<li>第一种方法：将 ul 包含在 table 标签内，对 table 设置 margin: 0 auto 就可以使 table 水平居中，间接地使 ul 实现了水平居中；</li>\n<li>第二种方法：改变块级元素的 display 为 inline 类型，然后使用 text-align: center 来实现居中；</li>\n<li>第三种方法：给父元素设置 float，然后父元素设置 position: relative 和 left: 50%，子元素设置 position: relative 和 left: -50% 来实现水平居中</li>\n</ul>\n<h3 id=\"竖直居中\"><a href=\"#竖直居中\" class=\"headerlink\" title=\"竖直居中\"></a>竖直居中</h3><h4 id=\"父元素高度不确定的文本，图片，块级元素的竖直居中\"><a href=\"#父元素高度不确定的文本，图片，块级元素的竖直居中\" class=\"headerlink\" title=\"父元素高度不确定的文本，图片，块级元素的竖直居中\"></a>父元素高度不确定的文本，图片，块级元素的竖直居中</h4><p>给父容器设置相同上下边距实现的</p>\n<h4 id=\"父元素高度确定的单行文本的竖直居中\"><a href=\"#父元素高度确定的单行文本的竖直居中\" class=\"headerlink\" title=\"父元素高度确定的单行文本的竖直居中\"></a>父元素高度确定的单行文本的竖直居中</h4><p>通过给父元素设置 line-height 来实现的，line-height 值和父元素的高度值相同。</p>\n<h4 id=\"父元素高度确定的多行文本，图片，块级元素的竖直居中\"><a href=\"#父元素高度确定的多行文本，图片，块级元素的竖直居中\" class=\"headerlink\" title=\"父元素高度确定的多行文本，图片，块级元素的竖直居中\"></a>父元素高度确定的多行文本，图片，块级元素的竖直居中</h4><p>块级元素的 display:table-cell，vertical-align:center。</p>\n<h2 id=\"25-使用匿名函数控制变量的作用域\"><a href=\"#25-使用匿名函数控制变量的作用域\" class=\"headerlink\" title=\"25. 使用匿名函数控制变量的作用域\"></a>25. 使用匿名函数控制变量的作用域</h2><p><code>(function(){ var a，c=&quot;abc&quot;; })();</code> 这种形式很巧妙，先定义一个匿名的 function，然后立即执行它.包在这个匿名 function 里的变量，作用域就不再是 window，而是局限在函数内部。用匿名函数将脚本包起来，可以有效控制全局变量，避免冲突隐患。让 JS 不产生冲突，需要避免全局变量的泛滥，合理使用命名空间以及为代码添加必要的注释。</p>\n<h2 id=\"26-window-onload-和-DOMReady\"><a href=\"#26-window-onload-和-DOMReady\" class=\"headerlink\" title=\"26. window.onload 和 DOMReady\"></a>26. window.onload 和 DOMReady</h2><p>window.onload 需要当页面完全加载完成时才会触发，包括图片，Flash 等富媒体，DOMReady 只判断页面内所有的 DOM 节点是否已经全部生成，至于节点的内容是否加载完成，它并不关心. DOMReady 比 window.onload 更适合用来调用初始化函数。值得注意的是，DOMReady 并不是原生 JavaScript 支持的事件，它不能像 window.load 那样直接调用，一般我们都是结合 JS 框架来使用它。</p>\n<h2 id=\"27-CSS-放在页头，JavaScript-放在页尾\"><a href=\"#27-CSS-放在页头，JavaScript-放在页尾\" class=\"headerlink\" title=\"27. CSS 放在页头，JavaScript 放在页尾\"></a>27. CSS 放在页头，JavaScript 放在页尾</h2><p>将 CSS 放在页头，在载入 HTML 元素之前，先载入它们的样式，这样可以避免 HTML 出现无样式状态；将 JavaScript 放在页尾，先将网页呈现给用户，再来加载页面内的脚本，避免 JavaScirpt 阻塞网页的呈现，减少页面空白的时间。</p>\n<h2 id=\"28-引入编译的概念——文件压缩\"><a href=\"#28-引入编译的概念——文件压缩\" class=\"headerlink\" title=\"28. 引入编译的概念——文件压缩\"></a>28. 引入编译的概念——文件压缩</h2><p>为了减小网页的大小，缩短网页的下载时间，在正式发布 JavaScript 之前，我们可以先对它进行一下压缩。JS 压缩通常的做法是去掉空格和换行，去掉注释，将复杂变量名替换成简单的变量名。</p>\n<h2 id=\"29-JavaScript-如何分层\"><a href=\"#29-JavaScript-如何分层\" class=\"headerlink\" title=\"29. JavaScript 如何分层\"></a>29. JavaScript 如何分层</h2><p>把 JavaScript 也分成三层，从下往上依次是 base 层，common 层和 page 层</p>\n<h3 id=\"base-层-1\"><a href=\"#base-层-1\" class=\"headerlink\" title=\"base 层\"></a>base 层</h3><p>有两个职责，职责一是封装不同浏览器下 JavaScript 的差异，提供统一的接口，我们可以依靠它来完成跨浏览器兼容的工作。职责二是扩展 JavaScript 语言底层提供的接口，让它提供更多更为易用的接口。</p>\n<h3 id=\"common-层-1\"><a href=\"#common-层-1\" class=\"headerlink\" title=\"common 层\"></a>common 层</h3><p>依赖于 base 层提供的接口。common 层提供可供复用的组件，它是典型的 mvc 模式中的 m，和页面内的具体功能没有直接关系。common 层的功能是给 page 层提供组件。</p>\n<h3 id=\"page-层-1\"><a href=\"#page-层-1\" class=\"headerlink\" title=\"page 层\"></a>page 层</h3><p>这一层和页面里的具体功能需求直接相关，是 mvc 模式中的 c。page 层的功能是完成页面内的功能需求。</p>\n<h2 id=\"30-JavaScript-中的参数\"><a href=\"#30-JavaScript-中的参数\" class=\"headerlink\" title=\"30. JavaScript 中的参数\"></a>30. JavaScript 中的参数</h2><p>如果一个函数内某个因素很不稳定，我们可以将它从函数内部分离出来，以参数的形式传入，从而将不稳定因素和函数解耦。在编程里有一个很出名的规则叫做 DRY——don’t repeat yourself，强调在程序中不要将相同的代码重复编写多次，更好的做法是只写一次，然后在多处引用。</p>\n<h2 id=\"31-JavaScript-与面向对象\"><a href=\"#31-JavaScript-与面向对象\" class=\"headerlink\" title=\"31. JavaScript 与面向对象\"></a>31. JavaScript 与面向对象</h2><p>JavaScript 很奇怪，它没有 Class 关键字，在 JavaScript 中是用函数来充当类的。函数在 JavaScript 中既可以当作普通函数使用，也可以当作类来使用，在充当类的时候，它本身又担负着构造函数的责任。函数作为普通函数使用时，通常直接使用 “()” 进行调用，而作为类使用时，通常使用 new 来实例化。通常情况下，作为函数时我们更倾向于用动词来命名，而作为类时用名词来命名。按照习惯，类名的首字母大写。JavaScript 是基于原型的语言，通过 new 实例化出来的对象，其属性和行为来自于两部分，一部分来自于构造函数，另一部分来自于原型。当我们声明一个类时，其实同时生成了一个对应的原型，例如我们定义 Animal 这个类时，会生成一个与 Animal 类对应的原型，通过 Animal.prototype 可以指向这个原型，原型可以通过 constructor 指向 Animal 类，更确切地说，是指向 Animal 类的构造函数。构造函数中定义的属性和行为的优先级比原型中定义的属性和行为优先级高，如果构造函数和原型定义了同名的属性和行为，构造函数中的属性和行为会覆盖原型中的同名的属性和行为。 this 关键字无论出现在构造函数中，还是出现在原型中，指向的都是实例对象，通过 this 关键字，可以让属性和方法在构造函数和原型间通信。正统的面向对象语言会提供 public，protect，private 等关键字来声明属性和行为的可访问性是公有还是私有。但 JavaScript 并不提供这些关键字，在 JavaScript 中公有还是私有是通过作用域实现的。</p>\n<div align=\"center\"><img src=\"/images/hexo_post_304.png\" alt=\"\" width=\"550\"></div>\n\n<p>把行为写在原型里可以减少内存消耗，没有特殊原因，推荐尽量把行为写在原型里。写在原型中的行为一定是公有的，而且无法访问私有属性。</p>\n<h2 id=\"32-传值与传址\"><a href=\"#32-传值与传址\" class=\"headerlink\" title=\"32. 传值与传址\"></a>32. 传值与传址</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;             <span class=\"comment\">// 基本数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;              <span class=\"comment\">// 将变量 a 保存的值复制一份，传给变量 b，a 和 b 各保存一份数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = [<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>];       <span class=\"comment\">// 复杂数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = c;              <span class=\"comment\">// 将变量 c 指向的数据的内存地址传给变量d，c 和 b 指向同一份数据</span></span><br><span class=\"line\">b++;</span><br><span class=\"line\">d.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">alert(a);     <span class=\"comment\">// 10 </span></span><br><span class=\"line\">alert(b);     <span class=\"comment\">// 11        变量 b 保存的数据更改不会影响到变量 a</span></span><br><span class=\"line\">alert(c);     <span class=\"comment\">// 1，2，3，4 变量 c 和 d 指向同一份数据，数据更改会互相影响</span></span><br><span class=\"line\">alert(d);     <span class=\"comment\">// 1，2，3，4</span></span><br></pre></td></tr></table></figure>\n<p>在原生 JavaScript中，选择传值还是传址是根据数据类型自动判定的，但传址有时候会给我们带来意想不到的麻烦，所以我们需要对复杂类型数据的赋值进行控制，让复杂数据类型也可以进行传值。</p>\n<h2 id=\"33-UML-描述类\"><a href=\"#33-UML-描述类\" class=\"headerlink\" title=\"33. UML 描述类\"></a>33. UML 描述类</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">PhonebookManager</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">+getTel():string</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+addItem():void</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+removeItem():void</td>\n</tr>\n</tbody>\n</table>\n<p>一个方框代表一个类，将方框划分成上中下三栏，第一栏填入类名，第二栏填入类的属性，第三栏填入类的行为，其中公有属性和公有行为需要在属性和行为名前加上 “+” 号，而私有属性和私有行为需要在属性和行为名前加上 “-” 号。</p>\n<h2 id=\"34-prototype-和内置类\"><a href=\"#34-prototype-和内置类\" class=\"headerlink\" title=\"34. prototype 和内置类\"></a>34. prototype 和内置类</h2><div align=\"center\"><img src=\"/images/hexo_post_305.png\" alt=\"\" width=\"600\"></div>\n\n<p>只要是类就会有原型，不管它是自定义类还是 JavaScript 的内置类，我们可以通过修改内置类的原型，让 JavaScript 基本类型的对象获得一些有趣的功能。无论在类的构造函数中还是在原型中，this 都指向实例化的对象。内置类的方法可以重写，但属性却不能重写。在 JavaScript 中，包括内置类和自定义类，所有类的祖先类都是 Object，所以如果想对所有对象都扩展方法，可以通过修改 Object 类的原型实现。</p>\n<h2 id=\"35-修改内置类\"><a href=\"#35-修改内置类\" class=\"headerlink\" title=\"35. 修改内置类\"></a>35. 修改内置类</h2><p>使用自定义类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myArray</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getArray=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myArray.prototype=&#123;</span><br><span class=\"line\">  each:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fun</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o=<span class=\"keyword\">this</span>.getArray();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=-，n=o.length;i&lt;n;i++)&#123;</span><br><span class=\"line\">      fun(o\\[i\\]，i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"keyword\">new</span> nyArray(\\[<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>\\])，str=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">a.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v，k</span>)</span>&#123;</span><br><span class=\"line\">  str += k+<span class=\"string\">\":\"</span>+v+<span class=\"string\">\"\\\\n\"</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">alert(str);    <span class=\"comment\">// 0:1 1:2 2:3</span></span><br></pre></td></tr></table></figure>\n<p>代替直接修改内置类原型的做法，定义一个自定义类，将内置类的实例作为参数传给构造函数，在自定义类里定义扩展方法。这种做法的思路是将内置类再封装一层，以此保护内置类的原型不被污染。两种方法都各有优缺点，修改内置类的原型非常方便，缺点是可能会带来冲突隐患；自定义类可以保护原型不被修改，但它需要用 new 来实例化自定义类，相对麻烦一点。如果是小应用，不用过多考虑可维护性，推荐使用前者，如果是大中型应用，需要考虑可维护性，推荐使用后者。</p>\n<h2 id=\"36-自定义属性\"><a href=\"#36-自定义属性\" class=\"headerlink\" title=\"36. 自定义属性\"></a>36. 自定义属性</h2><p>对于常规属性，统一使用 node.XXX 的方式读取，对于自定义属性，统一使用 node.getAttribute(“XXX”) 读取。将复杂类型的数据转化成字符串，称为数据的序列化，其逆操作叫做数据的反序列化。字符串的反序列化是通过 eval 函数实现的。只要字符串长的像 JavaScript 支持的数据格式，就可以进行反序列化。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">\"a\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://www.adanghome.com\"</span> <span class=\"attr\">blogInfo</span>=<span class=\"string\">\"&#123;name:'阿当的博客'，</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">type:'前端开发'&#125;\"</span>&gt;</span>my blog<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/JavaScript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> node=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"a\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> info=node.getAttribute(<span class=\"string\">\"blogInfo\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  alert(<span class=\"keyword\">typeof</span> info);    <span class=\"comment\">//string</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.name);      <span class=\"comment\">//undefined</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.type);      <span class=\"comment\">//undefined</span></span></span><br><span class=\"line\"><span class=\"javascript\">  info=<span class=\"built_in\">eval</span>(<span class=\"string\">\"(\"</span> + info + <span class=\"string\">\")\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  alert(<span class=\"keyword\">typeof</span> info);    <span class=\"comment\">//object</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.name);      <span class=\"comment\">//阿当的博客</span></span></span><br><span class=\"line\"><span class=\"javascript\">  alert(info.type);      <span class=\"comment\">//前端开发</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"37-代码可维护性\"><a href=\"#37-代码可维护性\" class=\"headerlink\" title=\"37. 代码可维护性\"></a>37. 代码可维护性</h2><p>好的可维护性可以从四个方面获得：</p>\n<ul>\n<li>代码的松耦合，高度模块化，将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从 HTML、CSS、JavaScript 三个层面考虑模块化。</li>\n<li>良好的注释。</li>\n<li>注意代码的弹性，在性能和弹性的选择上，一般情况下以弹性为优先考虑条件，在保证弹性的基础上，适当优化性能。</li>\n<li>严格按照规范编写代码。</li>\n</ul>\n","raw":null,"categories":[{"name":"frontend","path":"api/categories/frontend.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"}]}]}