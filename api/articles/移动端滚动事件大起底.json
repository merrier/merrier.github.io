{"title":"移动端滚动事件大起底","slug":"移动端滚动事件大起底","date":"2017-08-20T13:43:33.000Z","updated":"2019-11-12T04:57:03.928Z","comments":true,"path":"api/articles/移动端滚动事件大起底.json","excerpt":null,"covers":null,"content":"<p>最近在做移动端的项目，其中有个需求就是滚动监听标签页，实现用户滚动到不同位置时点亮相应 tab 按钮；这其实是个很简单的需求，但是根据之前的项目经验，移动端的滚动事件会有各种坑，所以就花时间做了一些功课，对移动端滚动事件中的坑进行了总结，同时提供了一些解决方案。</p>\n<h2 id=\"移动端滚动事件介绍\"><a href=\"#移动端滚动事件介绍\" class=\"headerlink\" title=\"移动端滚动事件介绍\"></a>移动端滚动事件介绍</h2><p>我们这里要讲的是 onscroll 事件，具体参见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onscroll\" target=\"_blank\" rel=\"noopener\">MDN文档</a></p>\n<h2 id=\"滚动事件应用\"><a href=\"#滚动事件应用\" class=\"headerlink\" title=\"滚动事件应用\"></a>滚动事件应用</h2><p>我做了几个简单的 demo，可以直接点击下面的链接查看（在手机上效果更佳~），关于移动端滚动事件的简单 demo 我上传到了我的 github，可以<a href=\"https://github.com/merrier/mobile-scroll-events\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看源码：</p>\n<ul>\n<li><a href=\"https://merrier.github.io/mobile-scroll-events/drop-and-refresh.html\" target=\"_blank\" rel=\"noopener\">下拉刷新</a></li>\n<li><a href=\"https://merrier.github.io/mobile-scroll-events/ceiling.html\" target=\"_blank\" rel=\"noopener\">吸顶效果</a></li>\n<li><a href=\"https://merrier.github.io/mobile-scroll-events/lazy-load.html\" target=\"_blank\" rel=\"noopener\">图片懒加载</a></li>\n<li>无限加载</li>\n<li><a href=\"https://merrier.github.io/mobile-scroll-events/side-nav-bar.html\" target=\"_blank\" rel=\"noopener\">侧边浮动导航栏</a></li>\n</ul>\n<h2 id=\"滚动事件分类和兼容性\"><a href=\"#滚动事件分类和兼容性\" class=\"headerlink\" title=\"滚动事件分类和兼容性\"></a>滚动事件分类和兼容性</h2><p>按照实际滚动的 dom 类型分为全局滚动和局部滚动</p>\n<h3 id=\"全局滚动\"><a href=\"#全局滚动\" class=\"headerlink\" title=\"全局滚动\"></a>全局滚动</h3><p>滚动条在 body 节点或者更顶层，一般是这样调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bHeight = <span class=\"built_in\">document</span>.body.clientHeight,  <span class=\"comment\">// body对象高度，如果有滚动高度也包括</span></span><br><span class=\"line\">        wHeight = <span class=\"built_in\">window</span>.innerHeight,  <span class=\"comment\">// 浏览器窗口的视口</span></span><br><span class=\"line\">        sTop = <span class=\"built_in\">document</span>.body.scrollTop;  <span class=\"comment\">// body距离滚动顶部的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isScrollBottom = bHeight - (wHeight + sTop) === <span class=\"number\">0</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isScrollBottom) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行相关代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以通过 addEventListener 的方式</p>\n<h3 id=\"局部滚动\"><a href=\"#局部滚动\" class=\"headerlink\" title=\"局部滚动\"></a>局部滚动</h3><p>滚动条在 body 下某一个 dom 节点，在移动端如果使用局部滚动，意思就是我们的滚动在一个固定宽高的 div 内触发，将该 div 设置成 overflow:scroll/auto; 来形成 div 内部的滚动，这时我们监听 div 的 onscroll 发现触发的时机；调用方式和全局滚动类似：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'div1'</span>).onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;）</span><br></pre></td></tr></table></figure>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>整体来看，<strong>全局滚动的兼容性要不如局部滚动，安卓比 IOS 兼容性更好：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">body 滚动</th>\n<th style=\"text-align:center\">局部滚动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">iOS</td>\n<td style=\"text-align:center\">不能实时触发</td>\n<td style=\"text-align:center\">不能实时触发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">android</td>\n<td style=\"text-align:center\">实时触发</td>\n<td style=\"text-align:center\">实时触发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iOS WKWebview 内核</td>\n<td style=\"text-align:center\">实时触发</td>\n<td style=\"text-align:center\">实时触发</td>\n</tr>\n</tbody>\n</table>\n<p>为什么 IOS 下的滚动事件会有各种 bug 呢，通过查阅资料，得出如下结论： iOS 的 webview 内核设定了其在进行 momentum scrolling (弹性滚动， 设置 -webkit-overflow-scrolling:touch 可以达到弹性滚动效果，安卓无效)时，会停止所有的 <strong>事件响应</strong> 及 <strong>DOM操作引起的页面渲染，</strong>故 onscroll 不能实时响应，具体可以<a href=\"https://www.tjvantoll.com/2012/08/19/onscroll-event-issues-on-mobile-browsers/\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看某位大牛写的实例 这里说明一下关于 iOS 的 wkwebview 内核是 iOS 从 iOS8 开始提供的新型 webview 内核，和之前的 uiwebview 相比，性能要好，具体大家可以自行查看关于 wkwebview 的相关概念</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>既然 onscroll 事件在 iOS 和安卓上的表现并不统一，同时根据浏览器内核的不同会有潜在的 bug 出现，就出现了针对于移动端滚动事件的各种兼容方案，总结如下：</p>\n<ol>\n<li>使用 ontouchmove 去替代 onscroll，虽然能更频繁的触发事件，但是这边的项目需求是实时响应滚动事件的同时，还要对页面元素进行重定位的 DOM 操作，由上述原因可知，在滚动过程中，页面会停止一切关于 DOM 方面的操作，所以若使用 ontouchmove 去实现的话，在按住屏幕进行滑动的时候，屏幕会出现元素抖动的情况(事件触发与 DOM 操作间具有几十毫秒的时间差)，兼容失败</li>\n<li>使用 <a href=\"https://iiunknown.gitbooks.io/iscroll-5-api-cn/content/versions.html\" target=\"_blank\" rel=\"noopener\">iscroll</a> 的 probe 版本，该版本能实时探查到滚动的距离，但该钩子函数是实时去关注 requestAnimationFrame 下的状态，所以对浏览器的版本性能消耗很大，安卓机根本动不了，兼容失败</li>\n<li>使用 <a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">swiper</a> 插件，在启动 freeMode 模式时模拟原生的弹性滚动( swiper 模拟原生滚动的方案能兼容较多的安卓机型不出现bug，推荐), 因为 swiper 没有实时监听滚动位置的功能,故我监听滚动开始及结束后的事件，通过 setInterval 及一些计算去实现滚动条的监听，但因为 react 元素的变化量比较大，导致 swiper 在移动端时对父容器的计算速率达到了一个瓶颈，依旧出现很卡顿的现象，兼容失败</li>\n</ol>\n<p>通过以上的兼容性尝试，可以发现其实<strong>并没有一个完美的解决方案</strong>，所以如果真的需要达到某些移动端滚动效果的话，可以采取 fallback 方案：</p>\n<ul>\n<li>Android 用 scroll 方案，因为兼容性很可观；</li>\n<li>IOS 如果不需要兼容 8 以下版本的话，就也直接用 scroll 方案，因为 wkwebview 已经对滚动事件进行了优化，而如果需要兼容8以下版本的话，可以考虑 isroll 或 JRroll 这两种插件，<strong>同时需要真机测试查看效果是否达到要求（尤其是 QQ 浏览器和搜狗浏览器）</strong>。</li>\n</ul>\n<p>由于查询到的资料比较老旧，对于滚动事件的兼容性描述可能已经过时了，我就在最近（2017-8-24）用各种浏览器测试了一下iOS中的滚动事件的兼容性，总结如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">是否可以弹性滚动</th>\n<th style=\"text-align:center\">是否需要设置 overflow:scrolling 才能弹性滚动</th>\n<th style=\"text-align:center\">设置 overflow:scrolling 之后，滚动期间是否监听事件</th>\n<th style=\"text-align:center\">未设置 overflow:scrolling，滚动期间是否监听事件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">safari(v10.0)</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chrome(v60.0)</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">firefox(v8.2)</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">weixin(v6.5.14)</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">QQ(v7.7.2)</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">搜狗(v5.8.1)</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n</tr>\n</tbody>\n</table>\n<p>从上面的表格可以看到，最新版的 iOS 浏览器其实并不需要 <code>overflow:scrolling</code> 就可以实现弹性滚动，同时除了搜狗浏览器之外，其他浏览器在滚动期间都会监听事件，由此可见截止到目前（2017-8-24），iOS 和浏览器对滚动事件的兼容性已经做了很多优化和改进了，之后有时间的话再在 android 手机上做一下测试……</p>\n<h2 id=\"滚动事件性能优化\"><a href=\"#滚动事件性能优化\" class=\"headerlink\" title=\"滚动事件性能优化\"></a>滚动事件性能优化</h2><p>除了兼容性问题以外，由于滚动事件和 resize 事件同属于<strong>会频繁触发的事件。</strong>如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。</p>\n<h3 id=\"防抖和节流\"><a href=\"#防抖和节流\" class=\"headerlink\" title=\"防抖和节流\"></a>防抖和节流</h3><p>scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。 针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），下面介绍两种常用的解决方法，防抖和节流（underscore和lodash里面有封装好的这两种方法，感兴趣的话可以研究一下源码）。</p>\n<h4 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h4><p>防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。</p>\n<h4 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h4><p>防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的 ajax 请求加载也是同理。 这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。 节流函数，只允许一个函数在 X 毫秒内执行一次。 与防抖相比，节流函数最主要的不同在于它保证在 X 毫秒内至少执行一次我们希望触发的事件 handler。</p>\n<h3 id=\"使用-rAF（requestAnimationFrame）触发滚动事件\"><a href=\"#使用-rAF（requestAnimationFrame）触发滚动事件\" class=\"headerlink\" title=\"使用 rAF（requestAnimationFrame）触发滚动事件\"></a>使用 rAF（requestAnimationFrame）触发滚动事件</h3><p>上面介绍的抖动与节流实现的方式都是借助了定时器 setTimeout ，但是如果页面只需要兼容高版本浏览器或应用在移动端，又或者页面需要追求高精度的效果，那么可以使用浏览器的原生方法 rAF（requestAnimationFrame）。 window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数。这个方法接受一个函数为参，该函数会在重绘前调用。 rAF 常用于 web 动画的制作，用于准确控制页面的帧刷新渲染，让动画效果更加流畅，当然它的作用不仅仅局限于动画制作，我们可以利用它的特性将它视为一个定时器。（当然它不是定时器） 通常来说，rAF 被调用的频率是每秒 60 次，也就是 1000 / 60 ，触发频率大概是 16.7ms 。（当执行复杂操作时，当它发现无法维持 60fps 的频率时，它会把频率降低到 30fps 来保持帧数的稳定。）</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><ul>\n<li>防抖动：防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。</li>\n<li>节流函数：只允许一个函数在 X 毫秒内执行一次，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。</li>\n<li>rAF：16.7ms 触发一次 handler，降低了可控性，但是提升了性能和精确度。</li>\n</ul>\n<p>从本质上而言，我们应该尽量去精简 scroll 事件的 handler ，将一些变量的初始化、不依赖于滚动位置变化的计算等都应当在 scroll 事件外提前就绪。建议：<strong>避免在 scroll 事件中修改样式属性 / 将样式操作从 scroll 事件中剥离</strong></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.ayqy.net/blog/%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">吸顶效果解决方案</a></li>\n<li><a href=\"https://www.tjvantoll.com/2012/08/19/onscroll-event-issues-on-mobile-browsers/\" target=\"_blank\" rel=\"noopener\">onscroll Event Issues on Mobile Browsers</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000004453730\" target=\"_blank\" rel=\"noopener\">前端: 移动端onscroll事件在部分浏览器内不能实时触发</a></li>\n<li><a href=\"http://www.alloyteam.com/2017/04/secrets-of-mobile-web-scroll-bars-and-drop-refresh/\" target=\"_blank\" rel=\"noopener\">移动web之滚动篇</a>* <a href=\"http://web.jobbole.com/86158/\" target=\"_blank\" rel=\"noopener\">高性能滚动 scroll 及页面渲染优化</a></li>\n</ul>\n","more":"<p>最近在做移动端的项目，其中有个需求就是滚动监听标签页，实现用户滚动到不同位置时点亮相应 tab 按钮；这其实是个很简单的需求，但是根据之前的项目经验，移动端的滚动事件会有各种坑，所以就花时间做了一些功课，对移动端滚动事件中的坑进行了总结，同时提供了一些解决方案。</p>\n<h2 id=\"移动端滚动事件介绍\"><a href=\"#移动端滚动事件介绍\" class=\"headerlink\" title=\"移动端滚动事件介绍\"></a>移动端滚动事件介绍</h2><p>我们这里要讲的是 onscroll 事件，具体参见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onscroll\" target=\"_blank\" rel=\"noopener\">MDN文档</a></p>\n<h2 id=\"滚动事件应用\"><a href=\"#滚动事件应用\" class=\"headerlink\" title=\"滚动事件应用\"></a>滚动事件应用</h2><p>我做了几个简单的 demo，可以直接点击下面的链接查看（在手机上效果更佳~），关于移动端滚动事件的简单 demo 我上传到了我的 github，可以<a href=\"https://github.com/merrier/mobile-scroll-events\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看源码：</p>\n<ul>\n<li><a href=\"https://merrier.github.io/mobile-scroll-events/drop-and-refresh.html\" target=\"_blank\" rel=\"noopener\">下拉刷新</a></li>\n<li><a href=\"https://merrier.github.io/mobile-scroll-events/ceiling.html\" target=\"_blank\" rel=\"noopener\">吸顶效果</a></li>\n<li><a href=\"https://merrier.github.io/mobile-scroll-events/lazy-load.html\" target=\"_blank\" rel=\"noopener\">图片懒加载</a></li>\n<li>无限加载</li>\n<li><a href=\"https://merrier.github.io/mobile-scroll-events/side-nav-bar.html\" target=\"_blank\" rel=\"noopener\">侧边浮动导航栏</a></li>\n</ul>\n<h2 id=\"滚动事件分类和兼容性\"><a href=\"#滚动事件分类和兼容性\" class=\"headerlink\" title=\"滚动事件分类和兼容性\"></a>滚动事件分类和兼容性</h2><p>按照实际滚动的 dom 类型分为全局滚动和局部滚动</p>\n<h3 id=\"全局滚动\"><a href=\"#全局滚动\" class=\"headerlink\" title=\"全局滚动\"></a>全局滚动</h3><p>滚动条在 body 节点或者更顶层，一般是这样调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bHeight = <span class=\"built_in\">document</span>.body.clientHeight,  <span class=\"comment\">// body对象高度，如果有滚动高度也包括</span></span><br><span class=\"line\">        wHeight = <span class=\"built_in\">window</span>.innerHeight,  <span class=\"comment\">// 浏览器窗口的视口</span></span><br><span class=\"line\">        sTop = <span class=\"built_in\">document</span>.body.scrollTop;  <span class=\"comment\">// body距离滚动顶部的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isScrollBottom = bHeight - (wHeight + sTop) === <span class=\"number\">0</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isScrollBottom) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行相关代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以通过 addEventListener 的方式</p>\n<h3 id=\"局部滚动\"><a href=\"#局部滚动\" class=\"headerlink\" title=\"局部滚动\"></a>局部滚动</h3><p>滚动条在 body 下某一个 dom 节点，在移动端如果使用局部滚动，意思就是我们的滚动在一个固定宽高的 div 内触发，将该 div 设置成 overflow:scroll/auto; 来形成 div 内部的滚动，这时我们监听 div 的 onscroll 发现触发的时机；调用方式和全局滚动类似：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'div1'</span>).onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;）</span><br></pre></td></tr></table></figure>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>整体来看，<strong>全局滚动的兼容性要不如局部滚动，安卓比 IOS 兼容性更好：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">body 滚动</th>\n<th style=\"text-align:center\">局部滚动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">iOS</td>\n<td style=\"text-align:center\">不能实时触发</td>\n<td style=\"text-align:center\">不能实时触发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">android</td>\n<td style=\"text-align:center\">实时触发</td>\n<td style=\"text-align:center\">实时触发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iOS WKWebview 内核</td>\n<td style=\"text-align:center\">实时触发</td>\n<td style=\"text-align:center\">实时触发</td>\n</tr>\n</tbody>\n</table>\n<p>为什么 IOS 下的滚动事件会有各种 bug 呢，通过查阅资料，得出如下结论： iOS 的 webview 内核设定了其在进行 momentum scrolling (弹性滚动， 设置 -webkit-overflow-scrolling:touch 可以达到弹性滚动效果，安卓无效)时，会停止所有的 <strong>事件响应</strong> 及 <strong>DOM操作引起的页面渲染，</strong>故 onscroll 不能实时响应，具体可以<a href=\"https://www.tjvantoll.com/2012/08/19/onscroll-event-issues-on-mobile-browsers/\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看某位大牛写的实例 这里说明一下关于 iOS 的 wkwebview 内核是 iOS 从 iOS8 开始提供的新型 webview 内核，和之前的 uiwebview 相比，性能要好，具体大家可以自行查看关于 wkwebview 的相关概念</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>既然 onscroll 事件在 iOS 和安卓上的表现并不统一，同时根据浏览器内核的不同会有潜在的 bug 出现，就出现了针对于移动端滚动事件的各种兼容方案，总结如下：</p>\n<ol>\n<li>使用 ontouchmove 去替代 onscroll，虽然能更频繁的触发事件，但是这边的项目需求是实时响应滚动事件的同时，还要对页面元素进行重定位的 DOM 操作，由上述原因可知，在滚动过程中，页面会停止一切关于 DOM 方面的操作，所以若使用 ontouchmove 去实现的话，在按住屏幕进行滑动的时候，屏幕会出现元素抖动的情况(事件触发与 DOM 操作间具有几十毫秒的时间差)，兼容失败</li>\n<li>使用 <a href=\"https://iiunknown.gitbooks.io/iscroll-5-api-cn/content/versions.html\" target=\"_blank\" rel=\"noopener\">iscroll</a> 的 probe 版本，该版本能实时探查到滚动的距离，但该钩子函数是实时去关注 requestAnimationFrame 下的状态，所以对浏览器的版本性能消耗很大，安卓机根本动不了，兼容失败</li>\n<li>使用 <a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">swiper</a> 插件，在启动 freeMode 模式时模拟原生的弹性滚动( swiper 模拟原生滚动的方案能兼容较多的安卓机型不出现bug，推荐), 因为 swiper 没有实时监听滚动位置的功能,故我监听滚动开始及结束后的事件，通过 setInterval 及一些计算去实现滚动条的监听，但因为 react 元素的变化量比较大，导致 swiper 在移动端时对父容器的计算速率达到了一个瓶颈，依旧出现很卡顿的现象，兼容失败</li>\n</ol>\n<p>通过以上的兼容性尝试，可以发现其实<strong>并没有一个完美的解决方案</strong>，所以如果真的需要达到某些移动端滚动效果的话，可以采取 fallback 方案：</p>\n<ul>\n<li>Android 用 scroll 方案，因为兼容性很可观；</li>\n<li>IOS 如果不需要兼容 8 以下版本的话，就也直接用 scroll 方案，因为 wkwebview 已经对滚动事件进行了优化，而如果需要兼容8以下版本的话，可以考虑 isroll 或 JRroll 这两种插件，<strong>同时需要真机测试查看效果是否达到要求（尤其是 QQ 浏览器和搜狗浏览器）</strong>。</li>\n</ul>\n<p>由于查询到的资料比较老旧，对于滚动事件的兼容性描述可能已经过时了，我就在最近（2017-8-24）用各种浏览器测试了一下iOS中的滚动事件的兼容性，总结如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">是否可以弹性滚动</th>\n<th style=\"text-align:center\">是否需要设置 overflow:scrolling 才能弹性滚动</th>\n<th style=\"text-align:center\">设置 overflow:scrolling 之后，滚动期间是否监听事件</th>\n<th style=\"text-align:center\">未设置 overflow:scrolling，滚动期间是否监听事件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">safari(v10.0)</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chrome(v60.0)</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">firefox(v8.2)</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">weixin(v6.5.14)</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">QQ(v7.7.2)</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">搜狗(v5.8.1)</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n</tr>\n</tbody>\n</table>\n<p>从上面的表格可以看到，最新版的 iOS 浏览器其实并不需要 <code>overflow:scrolling</code> 就可以实现弹性滚动，同时除了搜狗浏览器之外，其他浏览器在滚动期间都会监听事件，由此可见截止到目前（2017-8-24），iOS 和浏览器对滚动事件的兼容性已经做了很多优化和改进了，之后有时间的话再在 android 手机上做一下测试……</p>\n<h2 id=\"滚动事件性能优化\"><a href=\"#滚动事件性能优化\" class=\"headerlink\" title=\"滚动事件性能优化\"></a>滚动事件性能优化</h2><p>除了兼容性问题以外，由于滚动事件和 resize 事件同属于<strong>会频繁触发的事件。</strong>如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。</p>\n<h3 id=\"防抖和节流\"><a href=\"#防抖和节流\" class=\"headerlink\" title=\"防抖和节流\"></a>防抖和节流</h3><p>scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。 针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），下面介绍两种常用的解决方法，防抖和节流（underscore和lodash里面有封装好的这两种方法，感兴趣的话可以研究一下源码）。</p>\n<h4 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h4><p>防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。</p>\n<h4 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h4><p>防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的 ajax 请求加载也是同理。 这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。 节流函数，只允许一个函数在 X 毫秒内执行一次。 与防抖相比，节流函数最主要的不同在于它保证在 X 毫秒内至少执行一次我们希望触发的事件 handler。</p>\n<h3 id=\"使用-rAF（requestAnimationFrame）触发滚动事件\"><a href=\"#使用-rAF（requestAnimationFrame）触发滚动事件\" class=\"headerlink\" title=\"使用 rAF（requestAnimationFrame）触发滚动事件\"></a>使用 rAF（requestAnimationFrame）触发滚动事件</h3><p>上面介绍的抖动与节流实现的方式都是借助了定时器 setTimeout ，但是如果页面只需要兼容高版本浏览器或应用在移动端，又或者页面需要追求高精度的效果，那么可以使用浏览器的原生方法 rAF（requestAnimationFrame）。 window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数。这个方法接受一个函数为参，该函数会在重绘前调用。 rAF 常用于 web 动画的制作，用于准确控制页面的帧刷新渲染，让动画效果更加流畅，当然它的作用不仅仅局限于动画制作，我们可以利用它的特性将它视为一个定时器。（当然它不是定时器） 通常来说，rAF 被调用的频率是每秒 60 次，也就是 1000 / 60 ，触发频率大概是 16.7ms 。（当执行复杂操作时，当它发现无法维持 60fps 的频率时，它会把频率降低到 30fps 来保持帧数的稳定。）</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><ul>\n<li>防抖动：防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。</li>\n<li>节流函数：只允许一个函数在 X 毫秒内执行一次，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。</li>\n<li>rAF：16.7ms 触发一次 handler，降低了可控性，但是提升了性能和精确度。</li>\n</ul>\n<p>从本质上而言，我们应该尽量去精简 scroll 事件的 handler ，将一些变量的初始化、不依赖于滚动位置变化的计算等都应当在 scroll 事件外提前就绪。建议：<strong>避免在 scroll 事件中修改样式属性 / 将样式操作从 scroll 事件中剥离</strong></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.ayqy.net/blog/%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">吸顶效果解决方案</a></li>\n<li><a href=\"https://www.tjvantoll.com/2012/08/19/onscroll-event-issues-on-mobile-browsers/\" target=\"_blank\" rel=\"noopener\">onscroll Event Issues on Mobile Browsers</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000004453730\" target=\"_blank\" rel=\"noopener\">前端: 移动端onscroll事件在部分浏览器内不能实时触发</a></li>\n<li><a href=\"http://www.alloyteam.com/2017/04/secrets-of-mobile-web-scroll-bars-and-drop-refresh/\" target=\"_blank\" rel=\"noopener\">移动web之滚动篇</a>* <a href=\"http://web.jobbole.com/86158/\" target=\"_blank\" rel=\"noopener\">高性能滚动 scroll 及页面渲染优化</a></li>\n</ul>\n","categories":[{"name":"移动端","path":"api/categories/移动端.json"}],"tags":[{"name":"移动端","path":"api/tags/移动端.json"}]}