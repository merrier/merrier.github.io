{"title":"今日头条前端散招内推面试经验总结","slug":"今日头条前端散招内推面试经验总结","date":"2017-05-17T07:33:40.000Z","updated":"2019-01-27T10:07:12.320Z","comments":true,"path":"api/articles/今日头条前端散招内推面试经验总结.json","excerpt":null,"covers":null,"content":"<h2 id=\"笔试题\"><a href=\"#笔试题\" class=\"headerlink\" title=\"笔试题\"></a>笔试题</h2><p>可能是内推的缘故，在面试之前前台工作人员给了一套前端的笔试题，然后就分配了一个小房间开始做题，虽然没有指明不可以手机搜索，但是为了保证最起码的诚信，我全程都没有看手机，完全凭自己的水平答题，虽然最后面试官把原题拿走了，但是我还是能靠记忆回想起一些题目，总结如下：</p>\n<h3 id=\"1-替换元素和非替换元素有哪些，它们的差异是什么？\"><a href=\"#1-替换元素和非替换元素有哪些，它们的差异是什么？\" class=\"headerlink\" title=\"1. 替换元素和非替换元素有哪些，它们的差异是什么？\"></a>1. 替换元素和非替换元素有哪些，它们的差异是什么？</h3><h4 id=\"替换元素\"><a href=\"#替换元素\" class=\"headerlink\" title=\"替换元素\"></a>替换元素</h4><p>替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。 比如：<code>&lt;input type=&quot;text&quot;/&gt;</code>，这是一个文本输入框，换一个其他 type 的时候，浏览器显示就不一样，HTML 中的 <code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;object&gt;</code> 都是替换元素，这些元素都没有实际的内容。</p>\n<h4 id=\"非替换元素\"><a href=\"#非替换元素\" class=\"headerlink\" title=\"非替换元素\"></a>非替换元素</h4><p>HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。 比如 <code>&lt;p&gt;merrier.wang&lt;/p&gt;</code>、<code>&lt;label&gt;Merrier&lt;/label&gt;</code> 浏览器将把这段内容直接显示出来。</p>\n<h3 id=\"2-offsetWidth、clientWidth、scrollWidth-如何计算？\"><a href=\"#2-offsetWidth、clientWidth、scrollWidth-如何计算？\" class=\"headerlink\" title=\"2. offsetWidth、clientWidth、scrollWidth 如何计算？\"></a>2. offsetWidth、clientWidth、scrollWidth 如何计算？</h3><h4 id=\"offsetWidth\"><a href=\"#offsetWidth\" class=\"headerlink\" title=\"offsetWidth\"></a>offsetWidth</h4><ul>\n<li>无 <code>padding</code> 无滚动无 <code>border</code><ul>\n<li>offsetWidth = clientWidth = 盒子的宽度</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 无滚动有 <code>border</code><ul>\n<li>offsetWidth = 盒子的宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 边框宽度*2</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 有滚动，且滚动是显示的，有 <code>border</code><ul>\n<li>offsetWidth = 盒子宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"clientWidth\"><a href=\"#clientWidth\" class=\"headerlink\" title=\"clientWidth\"></a>clientWidth</h4><ul>\n<li>无 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code></li>\n<li>有 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code> + 盒子的 <code>padding * 2</code></li>\n<li>有 <code>padding</code> 有滚动 ：<code>clientWidth</code> = 盒子和 <code>width</code> + 盒子的 <code>padding * 2</code> - 滚动轴宽度</li>\n</ul>\n<h4 id=\"scrollWidth\"><a href=\"#scrollWidth\" class=\"headerlink\" title=\"scrollWidth\"></a>scrollWidth</h4><p>无滚动轴时：</p>\n<ul>\n<li>scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2</li>\n</ul>\n<p>有滚动轴时：</p>\n<ul>\n<li>scrollWidth = 实际内容的宽度 + padding * 2</li>\n<li>scrollHeight = 实际内容的高度 + padding * 2</li>\n</ul>\n<p>更多关于 JS 中的宽高可以狠狠的点击这里：<a href=\"/20170501/js-width-and-height.html\">JS 宽高的理解和应用</a></p>\n<h3 id=\"3-JS-中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\"><a href=\"#3-JS-中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\" class=\"headerlink\" title=\"3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\"></a>3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例</h3><p>DOM2 标准事件模型：每一个 DOM 元素所触发的事件都要经历三个阶段：</p>\n<ol>\n<li>捕获阶段</li>\n<li>目标对象本身的事件处理程序调用阶段</li>\n<li>冒泡阶段</li>\n</ol>\n<p>在 IE8 以上的版本以及其他的浏览器中通过 e.stopPropagation() 方式阻止事件的冒泡；在 IE8  以下的浏览器中通过 e.cancleBubble = true 阻止事件冒泡；jQ 中的 mouseenter 和 mouseleave 也是默认不冒泡</p>\n<h3 id=\"4-CSS-选择器的优先级是什么？\"><a href=\"#4-CSS-选择器的优先级是什么？\" class=\"headerlink\" title=\"4. CSS 选择器的优先级是什么？\"></a>4. CSS 选择器的优先级是什么？</h3><p>!important &gt; 内联 &gt; id &gt; class &gt; 标签(p、a、div) &gt; 通配符(*) &gt; 浏览器自定义</p>\n<p>更多关于 CSS 选择器的的内容：<a href=\"/20170403/css-selector.html\">前端面试系列（4）——CSS选择器</a></p>\n<h3 id=\"5-IFC-是什么？它的作用是什么？\"><a href=\"#5-IFC-是什么？它的作用是什么？\" class=\"headerlink\" title=\"5. IFC 是什么？它的作用是什么？\"></a>5. IFC 是什么？它的作用是什么？</h3><h4 id=\"What’s-FC？\"><a href=\"#What’s-FC？\" class=\"headerlink\" title=\"What’s FC？\"></a>What’s FC？</h4><p>FC 的全称是：Formatting Contexts，是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<h4 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a>IFC</h4><p>IFC(Inline Formatting Contexts) 直译为”内联格式化上下文”，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding / margin 影响)，IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。IFC 中是不可能有块级元素的，当插入块级元素时（如 p 中插入 div），会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。</p>\n<p><strong>那么IFC一般有什么用呢？</strong></p>\n<ul>\n<li>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</li>\n<li>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>\n</ul>\n<h4 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h4><p>BFC(Block Formatting Contexts) 直译为”块级格式化上下文”。Block Formatting Contexts 就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。 </p>\n<p><strong>如何产生 BFC？</strong></p>\n<ol>\n<li>float 的值不为 none。</li>\n<li>overflow 的值不为 visible。</li>\n<li>position 的值不为 relative 和 static。</li>\n<li>display 的值为 table-cell, table-caption, inline-block 中的任何一个。</li>\n</ol>\n<p><strong>那BFC 一般有什么用呢？</strong> </p>\n<p>比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 CSS2.1 中只有 BFC 和 IFC，CSS3 中才有 GFC 和 FFC，更多关于这些 FC 的内容可以查看：<a href=\"http://www.jshacker.com/note/3608\" target=\"_blank\" rel=\"noopener\">小科普：到底什么是BFC、IFC、GFC和FFC，次奥？</a></p>\n<h3 id=\"6-如何实现一个自适应正方形\"><a href=\"#6-如何实现一个自适应正方形\" class=\"headerlink\" title=\"6. 如何实现一个自适应正方形\"></a>6. 如何实现一个自适应正方形</h3><p>这个问题在我前不久的一篇文章里有总结过，可以<a href=\"/20170516/realization-of-adaptive-square-in-pure-css.html\">点击这里</a>查看</p>\n<h3 id=\"7-http-mp-toutiao-com-向-http-toutiao-com-发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\"><a href=\"#7-http-mp-toutiao-com-向-http-toutiao-com-发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\" class=\"headerlink\" title=\"7. http://mp.toutiao.com 向 http://toutiao.com 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\"></a>7. <a href=\"http://mp.toutiao.com\" target=\"_blank\" rel=\"noopener\">http://mp.toutiao.com</a> 向 <a href=\"http://toutiao.com\" target=\"_blank\" rel=\"noopener\">http://toutiao.com</a> 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？</h3><p>判断跨域的指标：域名、协议、端口，只要有其中一项不一致就会发生跨域</p>\n<h3 id=\"8-请介绍一下-XSS-和-CSRF-的区别，如何防御？\"><a href=\"#8-请介绍一下-XSS-和-CSRF-的区别，如何防御？\" class=\"headerlink\" title=\"8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？\"></a>8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？</h3><h4 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h4><p>XSS 全称“跨站脚本”（Cross-site scripting），是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>\n<h4 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h4><p>CSRF 的全称是“跨站请求伪造”（Cross-site request forgery），而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。 严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。</p>\n<h4 id=\"防御-XSS-攻击可以通过以下两方面操作：\"><a href=\"#防御-XSS-攻击可以通过以下两方面操作：\" class=\"headerlink\" title=\"防御 XSS 攻击可以通过以下两方面操作：\"></a>防御 XSS 攻击可以通过以下两方面操作：</h4><ol>\n<li>对用户表单输入的数据进行过滤，对 javascript 代码进行转义，然后再存入数据库；</li>\n<li>在信息的展示页面，也要进行转义，防止 javascript 在页面上执行。</li>\n</ol>\n<h4 id=\"CSRF-攻击的防御可以通过以下两方面操作：\"><a href=\"#CSRF-攻击的防御可以通过以下两方面操作：\" class=\"headerlink\" title=\"CSRF 攻击的防御可以通过以下两方面操作：\"></a>CSRF 攻击的防御可以通过以下两方面操作：</h4><ol>\n<li>所有需要用户登录之后才能执行的操作属于重要操作，这些操作传递参数应该使用 post 方式，更加安全；</li>\n<li>为防止跨站请求伪造，我们在某次请求的时候都要带上一个 csrf_token 参数，用于标识请求来源是否合法，csrf_token 参数由系统生成，存储在 SESSION 中。</li>\n</ol>\n<h4 id=\"更多关于-XSS-和-CSRF-的解释：\"><a href=\"#更多关于-XSS-和-CSRF-的解释：\" class=\"headerlink\" title=\"更多关于 XSS 和 CSRF 的解释：\"></a>更多关于 XSS 和 CSRF 的解释：</h4><ul>\n<li><a href=\"http://blog.csdn.net/koastal/article/details/52905358\" target=\"_blank\" rel=\"noopener\">浅析XSS和CSRF攻击及防御</a></li>\n<li><a href=\"https://www.zhihu.com/question/34445731?sort=created\" target=\"_blank\" rel=\"noopener\">如何用简洁生动的语言理清XSS和CSRF的区别？</a></li>\n</ul>\n<h3 id=\"9-JSBridge-是什么，它的作用是什么？\"><a href=\"#9-JSBridge-是什么，它的作用是什么？\" class=\"headerlink\" title=\"9. JSBridge 是什么，它的作用是什么？\"></a>9. JSBridge 是什么，它的作用是什么？</h3><p>在开发中我们经常需要 web 和 native 进行交互，也就是要用到经常听到的 “JSBridge”。由于我对这个东西也是停留在概念层面，所以推荐其他人的一篇文章吧：<a href=\"http://blog.csdn.net/jjx0224/article/details/52788922\" target=\"_blank\" rel=\"noopener\">理解JSBridge</a></p>\n<h3 id=\"10-TCP-和-UDP-的区别，以及如何进行拥塞控制？\"><a href=\"#10-TCP-和-UDP-的区别，以及如何进行拥塞控制？\" class=\"headerlink\" title=\"10. TCP 和 UDP 的区别，以及如何进行拥塞控制？\"></a>10. TCP 和 UDP 的区别，以及如何进行拥塞控制？</h3><ol>\n<li>TCP 面向连接（如打电话要先拨号建立连接）；UDP 是无连接的，即发送数据之前不需要建立连接</li>\n<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li>\n<li>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>\n<li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li>\n<li>TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节</li>\n<li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li>\n</ol>\n<p>更多关于 TCP 和 UDP 的区别：<a href=\"http://blog.csdn.net/li_ning_/article/details/52117463\" target=\"_blank\" rel=\"noopener\">TCP和UDP的最完整的区别</a></p>\n<h4 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h4><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br><strong>几种拥塞控制方法</strong>：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 更多关于拥塞控制：<a href=\"http://blog.csdn.net/kinger0/article/details/48206999\" target=\"_blank\" rel=\"noopener\">TCP/IP详解–拥塞控制 &amp; 慢启动 快恢复 拥塞避免</a></p>\n<h3 id=\"11-有一无序数组，数组个数为-m，如何从这-m-个数里面找到-N-个数，使这-N-个数的和为-M；并阐述时间复杂度和空间复杂度\"><a href=\"#11-有一无序数组，数组个数为-m，如何从这-m-个数里面找到-N-个数，使这-N-个数的和为-M；并阐述时间复杂度和空间复杂度\" class=\"headerlink\" title=\"11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度\"></a>11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度</h3><p>这个属于比较经典的 <a href=\"http://baike.baidu.com/item/01%E8%83%8C%E5%8C%85\" target=\"_blank\" rel=\"noopener\">01背包问题</a>，网上有很多关于这种问题的求解方式，基本上包括递归、动态规划、无脑循环等方法，推荐以下比较靠谱的解法：<a href=\"http://www.cnblogs.com/iyangyuan/p/3908498.html\" target=\"_blank\" rel=\"noopener\">动态规划（JS）</a>、<a href=\"http://blog.csdn.net/min_jie/article/details/3966867\" target=\"_blank\" rel=\"noopener\">无脑循环</a></p>\n<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><p>一面的时间很长，大概有将近一个小时的感觉，所以问的问题涉及的领域和方面也比较多，所以我就想到什么写下什么了，另外也不赋答案了，实在有点多。。</p>\n<ol>\n<li>__proto__ 是什么意思</li>\n<li>JS 实现继承的方式</li>\n<li>object.defineproprety() 方法的参数和含义</li>\n<li>setTimeout(func,0) 中设置延时为 “0” 的目的</li>\n<li>jQuery 中对 Promise() 的 when() 方法的实现原理</li>\n<li>HTTP 和 TCP 的关系</li>\n<li>TCP 三次握手</li>\n<li>HTTP 如何达到在下一次连接时不用再 TCP 三次握手的</li>\n<li>如何实现一个自适应正方形</li>\n<li>浏览器渲染的过程</li>\n<li>重排和重绘的触发时机和区别</li>\n<li>层叠上下文起作用的前提</li>\n<li>前端路由和后端路由的区别</li>\n<li>首屏加载完毕之后 <code>&lt;script&gt;&lt;/script&gt;</code> 代码的加载顺序</li>\n<li>vue.js 的设计思想</li>\n<li>如果用 jQuery 实现双向数据绑定，应该如何实现</li>\n<li>当 content-length 过长时，应该如何传输数据</li>\n<li>JS 文件中的代码执行顺序</li>\n<li>详细讲解一下 JS 中宏任务和微任务的判断机制</li>\n<li>如果有别的库中也用到了 “$”，如何解决和 jQuery 的冲突</li>\n</ol>\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><p>二面相对于一面来说，就简单随意了很多，问了一些项目的事情，还问了技术选型方面的问题，最后出了一道算法题让我做，我思考了大概 15 分钟，感觉真心写不出代码，就和面试官简单的讲了一下思路，面试官思考了一段时间之后就告诉我二面结束了，可以 hr 面了；至此，技术面就全部结束了。</p>\n","more":"<h2 id=\"笔试题\"><a href=\"#笔试题\" class=\"headerlink\" title=\"笔试题\"></a>笔试题</h2><p>可能是内推的缘故，在面试之前前台工作人员给了一套前端的笔试题，然后就分配了一个小房间开始做题，虽然没有指明不可以手机搜索，但是为了保证最起码的诚信，我全程都没有看手机，完全凭自己的水平答题，虽然最后面试官把原题拿走了，但是我还是能靠记忆回想起一些题目，总结如下：</p>\n<h3 id=\"1-替换元素和非替换元素有哪些，它们的差异是什么？\"><a href=\"#1-替换元素和非替换元素有哪些，它们的差异是什么？\" class=\"headerlink\" title=\"1. 替换元素和非替换元素有哪些，它们的差异是什么？\"></a>1. 替换元素和非替换元素有哪些，它们的差异是什么？</h3><h4 id=\"替换元素\"><a href=\"#替换元素\" class=\"headerlink\" title=\"替换元素\"></a>替换元素</h4><p>替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。 比如：<code>&lt;input type=&quot;text&quot;/&gt;</code>，这是一个文本输入框，换一个其他 type 的时候，浏览器显示就不一样，HTML 中的 <code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;object&gt;</code> 都是替换元素，这些元素都没有实际的内容。</p>\n<h4 id=\"非替换元素\"><a href=\"#非替换元素\" class=\"headerlink\" title=\"非替换元素\"></a>非替换元素</h4><p>HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。 比如 <code>&lt;p&gt;merrier.wang&lt;/p&gt;</code>、<code>&lt;label&gt;Merrier&lt;/label&gt;</code> 浏览器将把这段内容直接显示出来。</p>\n<h3 id=\"2-offsetWidth、clientWidth、scrollWidth-如何计算？\"><a href=\"#2-offsetWidth、clientWidth、scrollWidth-如何计算？\" class=\"headerlink\" title=\"2. offsetWidth、clientWidth、scrollWidth 如何计算？\"></a>2. offsetWidth、clientWidth、scrollWidth 如何计算？</h3><h4 id=\"offsetWidth\"><a href=\"#offsetWidth\" class=\"headerlink\" title=\"offsetWidth\"></a>offsetWidth</h4><ul>\n<li>无 <code>padding</code> 无滚动无 <code>border</code><ul>\n<li>offsetWidth = clientWidth = 盒子的宽度</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 无滚动有 <code>border</code><ul>\n<li>offsetWidth = 盒子的宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 边框宽度*2</li>\n</ul>\n</li>\n<li>有 <code>padding</code> 有滚动，且滚动是显示的，有 <code>border</code><ul>\n<li>offsetWidth = 盒子宽度 + 盒子 padding <em> 2 + 盒子边框 </em> 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"clientWidth\"><a href=\"#clientWidth\" class=\"headerlink\" title=\"clientWidth\"></a>clientWidth</h4><ul>\n<li>无 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code></li>\n<li>有 <code>padding</code> 无滚动 ：<code>clientWidth</code> = 盒子的 <code>width</code> + 盒子的 <code>padding * 2</code></li>\n<li>有 <code>padding</code> 有滚动 ：<code>clientWidth</code> = 盒子和 <code>width</code> + 盒子的 <code>padding * 2</code> - 滚动轴宽度</li>\n</ul>\n<h4 id=\"scrollWidth\"><a href=\"#scrollWidth\" class=\"headerlink\" title=\"scrollWidth\"></a>scrollWidth</h4><p>无滚动轴时：</p>\n<ul>\n<li>scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2</li>\n</ul>\n<p>有滚动轴时：</p>\n<ul>\n<li>scrollWidth = 实际内容的宽度 + padding * 2</li>\n<li>scrollHeight = 实际内容的高度 + padding * 2</li>\n</ul>\n<p>更多关于 JS 中的宽高可以狠狠的点击这里：<a href=\"/20170501/js-width-and-height.html\">JS 宽高的理解和应用</a></p>\n<h3 id=\"3-JS-中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\"><a href=\"#3-JS-中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\" class=\"headerlink\" title=\"3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例\"></a>3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例</h3><p>DOM2 标准事件模型：每一个 DOM 元素所触发的事件都要经历三个阶段：</p>\n<ol>\n<li>捕获阶段</li>\n<li>目标对象本身的事件处理程序调用阶段</li>\n<li>冒泡阶段</li>\n</ol>\n<p>在 IE8 以上的版本以及其他的浏览器中通过 e.stopPropagation() 方式阻止事件的冒泡；在 IE8  以下的浏览器中通过 e.cancleBubble = true 阻止事件冒泡；jQ 中的 mouseenter 和 mouseleave 也是默认不冒泡</p>\n<h3 id=\"4-CSS-选择器的优先级是什么？\"><a href=\"#4-CSS-选择器的优先级是什么？\" class=\"headerlink\" title=\"4. CSS 选择器的优先级是什么？\"></a>4. CSS 选择器的优先级是什么？</h3><p>!important &gt; 内联 &gt; id &gt; class &gt; 标签(p、a、div) &gt; 通配符(*) &gt; 浏览器自定义</p>\n<p>更多关于 CSS 选择器的的内容：<a href=\"/20170403/css-selector.html\">前端面试系列（4）——CSS选择器</a></p>\n<h3 id=\"5-IFC-是什么？它的作用是什么？\"><a href=\"#5-IFC-是什么？它的作用是什么？\" class=\"headerlink\" title=\"5. IFC 是什么？它的作用是什么？\"></a>5. IFC 是什么？它的作用是什么？</h3><h4 id=\"What’s-FC？\"><a href=\"#What’s-FC？\" class=\"headerlink\" title=\"What’s FC？\"></a>What’s FC？</h4><p>FC 的全称是：Formatting Contexts，是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<h4 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a>IFC</h4><p>IFC(Inline Formatting Contexts) 直译为”内联格式化上下文”，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding / margin 影响)，IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。IFC 中是不可能有块级元素的，当插入块级元素时（如 p 中插入 div），会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。</p>\n<p><strong>那么IFC一般有什么用呢？</strong></p>\n<ul>\n<li>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</li>\n<li>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>\n</ul>\n<h4 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h4><p>BFC(Block Formatting Contexts) 直译为”块级格式化上下文”。Block Formatting Contexts 就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。 </p>\n<p><strong>如何产生 BFC？</strong></p>\n<ol>\n<li>float 的值不为 none。</li>\n<li>overflow 的值不为 visible。</li>\n<li>position 的值不为 relative 和 static。</li>\n<li>display 的值为 table-cell, table-caption, inline-block 中的任何一个。</li>\n</ol>\n<p><strong>那BFC 一般有什么用呢？</strong> </p>\n<p>比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 CSS2.1 中只有 BFC 和 IFC，CSS3 中才有 GFC 和 FFC，更多关于这些 FC 的内容可以查看：<a href=\"http://www.jshacker.com/note/3608\" target=\"_blank\" rel=\"noopener\">小科普：到底什么是BFC、IFC、GFC和FFC，次奥？</a></p>\n<h3 id=\"6-如何实现一个自适应正方形\"><a href=\"#6-如何实现一个自适应正方形\" class=\"headerlink\" title=\"6. 如何实现一个自适应正方形\"></a>6. 如何实现一个自适应正方形</h3><p>这个问题在我前不久的一篇文章里有总结过，可以<a href=\"/20170516/realization-of-adaptive-square-in-pure-css.html\">点击这里</a>查看</p>\n<h3 id=\"7-http-mp-toutiao-com-向-http-toutiao-com-发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\"><a href=\"#7-http-mp-toutiao-com-向-http-toutiao-com-发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\" class=\"headerlink\" title=\"7. http://mp.toutiao.com 向 http://toutiao.com 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？\"></a>7. <a href=\"http://mp.toutiao.com\" target=\"_blank\" rel=\"noopener\">http://mp.toutiao.com</a> 向 <a href=\"http://toutiao.com\" target=\"_blank\" rel=\"noopener\">http://toutiao.com</a> 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？</h3><p>判断跨域的指标：域名、协议、端口，只要有其中一项不一致就会发生跨域</p>\n<h3 id=\"8-请介绍一下-XSS-和-CSRF-的区别，如何防御？\"><a href=\"#8-请介绍一下-XSS-和-CSRF-的区别，如何防御？\" class=\"headerlink\" title=\"8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？\"></a>8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？</h3><h4 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h4><p>XSS 全称“跨站脚本”（Cross-site scripting），是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>\n<h4 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h4><p>CSRF 的全称是“跨站请求伪造”（Cross-site request forgery），而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。 严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。</p>\n<h4 id=\"防御-XSS-攻击可以通过以下两方面操作：\"><a href=\"#防御-XSS-攻击可以通过以下两方面操作：\" class=\"headerlink\" title=\"防御 XSS 攻击可以通过以下两方面操作：\"></a>防御 XSS 攻击可以通过以下两方面操作：</h4><ol>\n<li>对用户表单输入的数据进行过滤，对 javascript 代码进行转义，然后再存入数据库；</li>\n<li>在信息的展示页面，也要进行转义，防止 javascript 在页面上执行。</li>\n</ol>\n<h4 id=\"CSRF-攻击的防御可以通过以下两方面操作：\"><a href=\"#CSRF-攻击的防御可以通过以下两方面操作：\" class=\"headerlink\" title=\"CSRF 攻击的防御可以通过以下两方面操作：\"></a>CSRF 攻击的防御可以通过以下两方面操作：</h4><ol>\n<li>所有需要用户登录之后才能执行的操作属于重要操作，这些操作传递参数应该使用 post 方式，更加安全；</li>\n<li>为防止跨站请求伪造，我们在某次请求的时候都要带上一个 csrf_token 参数，用于标识请求来源是否合法，csrf_token 参数由系统生成，存储在 SESSION 中。</li>\n</ol>\n<h4 id=\"更多关于-XSS-和-CSRF-的解释：\"><a href=\"#更多关于-XSS-和-CSRF-的解释：\" class=\"headerlink\" title=\"更多关于 XSS 和 CSRF 的解释：\"></a>更多关于 XSS 和 CSRF 的解释：</h4><ul>\n<li><a href=\"http://blog.csdn.net/koastal/article/details/52905358\" target=\"_blank\" rel=\"noopener\">浅析XSS和CSRF攻击及防御</a></li>\n<li><a href=\"https://www.zhihu.com/question/34445731?sort=created\" target=\"_blank\" rel=\"noopener\">如何用简洁生动的语言理清XSS和CSRF的区别？</a></li>\n</ul>\n<h3 id=\"9-JSBridge-是什么，它的作用是什么？\"><a href=\"#9-JSBridge-是什么，它的作用是什么？\" class=\"headerlink\" title=\"9. JSBridge 是什么，它的作用是什么？\"></a>9. JSBridge 是什么，它的作用是什么？</h3><p>在开发中我们经常需要 web 和 native 进行交互，也就是要用到经常听到的 “JSBridge”。由于我对这个东西也是停留在概念层面，所以推荐其他人的一篇文章吧：<a href=\"http://blog.csdn.net/jjx0224/article/details/52788922\" target=\"_blank\" rel=\"noopener\">理解JSBridge</a></p>\n<h3 id=\"10-TCP-和-UDP-的区别，以及如何进行拥塞控制？\"><a href=\"#10-TCP-和-UDP-的区别，以及如何进行拥塞控制？\" class=\"headerlink\" title=\"10. TCP 和 UDP 的区别，以及如何进行拥塞控制？\"></a>10. TCP 和 UDP 的区别，以及如何进行拥塞控制？</h3><ol>\n<li>TCP 面向连接（如打电话要先拨号建立连接）；UDP 是无连接的，即发送数据之前不需要建立连接</li>\n<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li>\n<li>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>\n<li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li>\n<li>TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节</li>\n<li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li>\n</ol>\n<p>更多关于 TCP 和 UDP 的区别：<a href=\"http://blog.csdn.net/li_ning_/article/details/52117463\" target=\"_blank\" rel=\"noopener\">TCP和UDP的最完整的区别</a></p>\n<h4 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h4><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br><strong>几种拥塞控制方法</strong>：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 更多关于拥塞控制：<a href=\"http://blog.csdn.net/kinger0/article/details/48206999\" target=\"_blank\" rel=\"noopener\">TCP/IP详解–拥塞控制 &amp; 慢启动 快恢复 拥塞避免</a></p>\n<h3 id=\"11-有一无序数组，数组个数为-m，如何从这-m-个数里面找到-N-个数，使这-N-个数的和为-M；并阐述时间复杂度和空间复杂度\"><a href=\"#11-有一无序数组，数组个数为-m，如何从这-m-个数里面找到-N-个数，使这-N-个数的和为-M；并阐述时间复杂度和空间复杂度\" class=\"headerlink\" title=\"11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度\"></a>11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度</h3><p>这个属于比较经典的 <a href=\"http://baike.baidu.com/item/01%E8%83%8C%E5%8C%85\" target=\"_blank\" rel=\"noopener\">01背包问题</a>，网上有很多关于这种问题的求解方式，基本上包括递归、动态规划、无脑循环等方法，推荐以下比较靠谱的解法：<a href=\"http://www.cnblogs.com/iyangyuan/p/3908498.html\" target=\"_blank\" rel=\"noopener\">动态规划（JS）</a>、<a href=\"http://blog.csdn.net/min_jie/article/details/3966867\" target=\"_blank\" rel=\"noopener\">无脑循环</a></p>\n<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><p>一面的时间很长，大概有将近一个小时的感觉，所以问的问题涉及的领域和方面也比较多，所以我就想到什么写下什么了，另外也不赋答案了，实在有点多。。</p>\n<ol>\n<li>__proto__ 是什么意思</li>\n<li>JS 实现继承的方式</li>\n<li>object.defineproprety() 方法的参数和含义</li>\n<li>setTimeout(func,0) 中设置延时为 “0” 的目的</li>\n<li>jQuery 中对 Promise() 的 when() 方法的实现原理</li>\n<li>HTTP 和 TCP 的关系</li>\n<li>TCP 三次握手</li>\n<li>HTTP 如何达到在下一次连接时不用再 TCP 三次握手的</li>\n<li>如何实现一个自适应正方形</li>\n<li>浏览器渲染的过程</li>\n<li>重排和重绘的触发时机和区别</li>\n<li>层叠上下文起作用的前提</li>\n<li>前端路由和后端路由的区别</li>\n<li>首屏加载完毕之后 <code>&lt;script&gt;&lt;/script&gt;</code> 代码的加载顺序</li>\n<li>vue.js 的设计思想</li>\n<li>如果用 jQuery 实现双向数据绑定，应该如何实现</li>\n<li>当 content-length 过长时，应该如何传输数据</li>\n<li>JS 文件中的代码执行顺序</li>\n<li>详细讲解一下 JS 中宏任务和微任务的判断机制</li>\n<li>如果有别的库中也用到了 “$”，如何解决和 jQuery 的冲突</li>\n</ol>\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><p>二面相对于一面来说，就简单随意了很多，问了一些项目的事情，还问了技术选型方面的问题，最后出了一道算法题让我做，我思考了大概 15 分钟，感觉真心写不出代码，就和面试官简单的讲了一下思路，面试官思考了一段时间之后就告诉我二面结束了，可以 hr 面了；至此，技术面就全部结束了。</p>\n","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"面试","path":"api/tags/面试.json"}]}