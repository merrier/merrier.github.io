{"title":"好文章推荐系列——前端框架","slug":"好文章推荐系列——前端框架","date":"2017-08-07T16:29:18.000Z","updated":"2025-01-03T12:32:52.482Z","comments":true,"path":"api/articles/好文章推荐系列——前端框架.json","excerpt":null,"covers":null,"content":"<h3 id=\"React-体系下关于-Mobx-与-Redux-的一些思考\"><a href=\"#React-体系下关于-Mobx-与-Redux-的一些思考\" class=\"headerlink\" title=\"React 体系下关于 Mobx 与 Redux 的一些思考\"></a><a href=\"https://zhuanlan.zhihu.com/p/461844358\">React 体系下关于 Mobx 与 Redux 的一些思考</a></h3><p>Redux VS Mbox（Immutable VS Mutable），这两种不同的思路会导致它们在与 React 这样的致力于 Immutable 数据的框架进行结合时，产生完全不同的结果。如果不去仔细区别，很容易被经过包装之后的各种五花八门的库迷惑。</p>\n<h3 id=\"小程序技术方案探讨\"><a href=\"#小程序技术方案探讨\" class=\"headerlink\" title=\"小程序技术方案探讨\"></a><a href=\"http://blog.cnbang.net/tech/3486/\">小程序技术方案探讨</a></h3><p>微信小程序上线大半年，大部分技术原理也有文章介绍了，本文尝试从需求出发探讨微信小程序技术方案的来源，以及最近公测的支付宝小程序技术方案的考量。</p>\n<h3 id=\"渔人和Rxjs的故事\"><a href=\"#渔人和Rxjs的故事\" class=\"headerlink\" title=\"渔人和Rxjs的故事\"></a><a href=\"https://github.com/jackiewillen/blog/issues/1\">渔人和Rxjs的故事</a></h3><p>你一定要坚持看完这个故事，看完你一定会懂Rxjs.千万不要觉得故事情节没有《盗墓笔记》好看而放弃。因为臣妾实在是只能把枯燥的程序写成这个很（挺）有（简）趣（陋）的故事了。</p>\n<h3 id=\"万字解析微前端、微前端框架qiankun以及源码\"><a href=\"#万字解析微前端、微前端框架qiankun以及源码\" class=\"headerlink\" title=\"万字解析微前端、微前端框架qiankun以及源码\"></a><a href=\"https://mp.weixin.qq.com/s?__biz=MzkwODIwMDY2OQ==&amp;mid=2247488282&amp;idx=1&amp;sn=459ba1ff1b4df2e9322f4c6e0f955d71&amp;source=41#wechat_redirect\">万字解析微前端、微前端框架qiankun以及源码</a></h3><p>本文将针对微前端框架 qiankun 的源码进行深入解析，在源码讲解之前，我们先来了解一下什么是 微前端。</p>\n<p>微前端 是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立开发、独立部署。同时，它们也可以在共享组件的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。</p>\n<p>qiankun（乾坤） 就是一款由蚂蚁金服推出的比较成熟的微前端框架，基于 single-spa 进行二次开发，用于将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。</p>\n<div align='center'><img src='/images/hexo_post_783.png' alt='' /></div>\n\n<h3 id=\"Vue-开发必须知道的-36-个技巧【近1W字】\"><a href=\"#Vue-开发必须知道的-36-个技巧【近1W字】\" class=\"headerlink\" title=\"Vue 开发必须知道的 36 个技巧【近1W字】\"></a><a href=\"https://juejin.cn/post/6844903959266590728\">Vue 开发必须知道的 36 个技巧【近1W字】</a></h3><p>Vue 3.x 的Pre-Alpha 版本。后面应该还会有 Alpha、Beta 等版本,预计至少要等到 2020 年第一季度才有可能发布 3.0 正式版;所以应该趁还没出来加紧打好 Vue2.x 的基础;<br>Vue 基本用法很容易上手,但是有很多优化的写法你就不一定知道了,本文列举了 36  个 vue 开发技巧;<br>后续 Vue 3.x 出来后持续更新.</p>\n<h3 id=\"React-开发必须知道的-34-个技巧【近1W字】\"><a href=\"#React-开发必须知道的-34-个技巧【近1W字】\" class=\"headerlink\" title=\"React 开发必须知道的 34 个技巧【近1W字】\"></a><a href=\"https://juejin.cn/post/6844903993278201870\">React 开发必须知道的 34 个技巧【近1W字】</a></h3><p>React 是前端三大框架之一,在开发中也是一项技能;本文从实际开发中总结了 React 开发的一些技巧技巧,适合 React 初学或者有一定项目经验的同学</p>\n<h3 id=\"React-框架运行时优化方案的演进\"><a href=\"#React-框架运行时优化方案的演进\" class=\"headerlink\" title=\"React 框架运行时优化方案的演进\"></a><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0MDMwMzQyOA==&amp;mid=2247490885&amp;idx=1&amp;sn=0501282f3b8f9a0e1f96caf8551b16ac&amp;source=41#wechat_redirect\">React 框架运行时优化方案的演进</a></h3><p>这篇文章的主要目的，就是根据 React 主要优化策略几个阶段的演进，来把这些概念梳理清楚，看看 React 这几年到底在搞什么东西，以及顺便解读一下最新更新的这些特性。在分享里面我们可能不会很详细的去分析具体的调度流程和细节，但是我们会在一些优化策略上节选一些源码进行解读。</p>\n<h3 id=\"微信小程序技术原理分析\"><a href=\"#微信小程序技术原理分析\" class=\"headerlink\" title=\"微信小程序技术原理分析\"></a><a href=\"https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html\">微信小程序技术原理分析</a></h3><p>互联网生态演进：超级 APP + 小程序成为「轻应用时代」下的新生态。</p>\n<div align='center'><img src='/images/hexo_post_781.png' alt='' width='900'/></div>\n\n<h3 id=\"React-memo-和-useMemo-的用法与区别\"><a href=\"#React-memo-和-useMemo-的用法与区别\" class=\"headerlink\" title=\"React.memo() 和 useMemo() 的用法与区别\"></a><a href=\"https://mp.weixin.qq.com/s/zxT2GfujdbQfvrCtRxkbiQ\">React.memo() 和 useMemo() 的用法与区别</a></h3><p>本文翻译自 Adebola Adeniran 在 LogRocket 论坛中关于 React.memo() 和 useMemo() 对比与用例分析。</p>\n<h3 id=\"React技术内幕-setState的秘密\"><a href=\"#React技术内幕-setState的秘密\" class=\"headerlink\" title=\"[React技术内幕]:setState的秘密\"></a><a href=\"https://segmentfault.com/a/1190000010785692\">[React技术内幕]:setState的秘密</a></h3><p>对于大多数的React开发者，setState可能是最常用的API之一。React作为View层，通过改变data从而引发UI的更新。React不像Vue这种MVVM库，直接修改data并不能视图的改变，更新状态(state)的过程必须使用setState。</p>\n<h3 id=\"刨根问底，揭开-Vue-中-Scope-CSS-实现的幕后（原理）\"><a href=\"#刨根问底，揭开-Vue-中-Scope-CSS-实现的幕后（原理）\" class=\"headerlink\" title=\"刨根问底，揭开 Vue 中 Scope CSS 实现的幕后（原理）\"></a><a href=\"https://mp.weixin.qq.com/s/MJScjoqGtKh9IuFpfMbbQg\">刨根问底，揭开 Vue 中 Scope CSS 实现的幕后（原理）</a></h3><p>我想大家应该都对 Vue 的 Scope CSS 耳熟能详了，但是说起 Vue 的 Scope CSS 实现的原理，很多人应该会说不就是给 HTML、CSS 添加属性吗 🙃️？</p>\n<p>确实是这样的，不过这只是最终 Scope CSS 呈现的结果。而这个过程又是如何实现的？我想能回答上一二的同学应该不多。</p>\n<p>那么，回到今天本文，我将会围绕以下 3 点，和大家一起从 Vue 的 Scope CSS 的最终呈现结果出发，深入浅出一番其实现的底层原理：</p>\n<ul>\n<li>什么是 Scope CSS</li>\n<li>vue-loader 处理组件（.vue 文件）</li>\n<li>Patch 阶段应用 ScopeId 生成 HTML 的属性</li>\n</ul>\n<h3 id=\"React组件到底什么时候render啊\"><a href=\"#React组件到底什么时候render啊\" class=\"headerlink\" title=\"React组件到底什么时候render啊\"></a><a href=\"https://juejin.cn/post/6886766652667461646\">React组件到底什么时候render啊</a></h3><p>React 到底什么时候才会 render？</p>\n<h3 id=\"在你写memo-之前\"><a href=\"#在你写memo-之前\" class=\"headerlink\" title=\"在你写memo()之前\"></a><a href=\"https://overreacted.io/zh-hans/before-you-memo/\">在你写memo()之前</a></h3><p>在这篇文章里，React 核心开发者 Dan 分享了关于 memo 的两种不同的技巧。它们十分基础，这也正是为什么人们很少会意识到它们可以提升渲染性能。这些技巧和你已经知道的内容是互补的，它们并不会替代 memo 或者 useMemo，但是先试一试它们还是不错的</p>\n<h3 id=\"轻松理解webpack热更新原理\"><a href=\"#轻松理解webpack热更新原理\" class=\"headerlink\" title=\"轻松理解webpack热更新原理\"></a><a href=\"https://juejin.cn/post/6844904008432222215\">轻松理解webpack热更新原理</a></h3><p>Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。HMR的好处，在日常开发工作中体会颇深：节省宝贵的开发时间、提升开发体验。</p>\n<h3 id=\"React技术揭秘\"><a href=\"#React技术揭秘\" class=\"headerlink\" title=\"React技术揭秘\"></a><a href=\"https://react.iamkasong.com/\">React技术揭秘</a></h3><p>本书的宗旨是打造一本严谨、易懂的React源码分析教程。为了达到这个目标，在行文上，本书会遵循：</p>\n<ul>\n<li>不预设观点 —— 所有观点来自React核心团队成员在公开场合的分享。</li>\n<li>丰富的参考资料 —— 包括在线Demo、文章、视频。</li>\n<li>保持更新 —— 在React版本更新后会及时补充。当前版本v17.0.0-alpha。</li>\n</ul>\n<h3 id=\"React-事件系统工作原理\"><a href=\"#React-事件系统工作原理\" class=\"headerlink\" title=\"React 事件系统工作原理\"></a><a href=\"https://juejin.cn/post/6909271104440205326\">React 事件系统工作原理</a></h3><p>React 为我们提供了一套虚拟的事件系统，这套虚拟事件系统是如何工作的，笔者对源码做了一次梳理，整理了下面的文档供大家参考。</p>\n<h3 id=\"vue3源码解析和最佳实践\"><a href=\"#vue3源码解析和最佳实践\" class=\"headerlink\" title=\"vue3源码解析和最佳实践\"></a><a href=\"https://vue3.w2deep.com/\">vue3源码解析和最佳实践</a></h3><p>这是一个收录 vue3 源码解析和关于 vue3 的最佳实践的网站，网站分为两部分，vue3 源码解析和vue3 最佳实践，你可以根据你的需要进行阅读。另外网站作者之前也做过一次 react 的源码解析，是基于 react 16.7 版本的，<a href=\"https://react.jokcy.me/\">网址在这里</a></p>\n<h3 id=\"React-Fiber-Architecture\"><a href=\"#React-Fiber-Architecture\" class=\"headerlink\" title=\"React Fiber Architecture\"></a><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a></h3><p>Fiber introduces several novel concepts that are difficult to grok solely by looking at code. This document began as a collection of notes I took as I followed along with Fiber’s implementation in the React project. As it grew, I realized it may be a helpful resource for others, too.</p>\n<h3 id=\"揭开-React-Hooks-的神秘面纱-数组解构融成魔法\"><a href=\"#揭开-React-Hooks-的神秘面纱-数组解构融成魔法\" class=\"headerlink\" title=\"揭开 React Hooks 的神秘面纱:数组解构融成魔法\"></a><a href=\"https://github.com/xitu/gold-miner/blob/master/TODO1/react-hooks-not-magic-just-arrays.md\">揭开 React Hooks 的神秘面纱:数组解构融成魔法</a></h3><p>我超喜欢 React 新出的这个 Hooks API。而在使用它时却有一些奇怪的规则。为了那些纠结于为什么要有这些规则的人，在这里我会以模型图的方式来向你们展示这个新的 API。</p>\n<h3 id=\"一文吃透-React-SSR-服务端渲染和同构原理\"><a href=\"#一文吃透-React-SSR-服务端渲染和同构原理\" class=\"headerlink\" title=\"一文吃透 React SSR 服务端渲染和同构原理\"></a><a href=\"https://segmentfault.com/a/1190000020417285\">一文吃透 React SSR 服务端渲染和同构原理</a></h3><p>全网最完整的 React SSR 同构技术原理解析与实践，从零开始手把手带你打造自己的同构应用开发骨架，帮助大家彻底深入理解服务端渲染及底层实现原理，学完本课程，你也可以打造自己的同构框架。</p>\n<h3 id=\"React-Fiber\"><a href=\"#React-Fiber\" class=\"headerlink\" title=\"React Fiber\"></a><a href=\"https://juejin.cn/post/6844903582622285831\">React Fiber</a></h3><p>react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差。<br>为了解决这个问题，react团队经过两年的工作，重写了react中核心算法——reconciliation。并在v16版本中发布了这个新的特性。为了区别之前和之后的reconciler，通常将之前的reconciler称为stack reconciler，重写后的称为fiber reconciler，简称为Fiber。</p>\n<h3 id=\"Why-React-Hooks\"><a href=\"#Why-React-Hooks\" class=\"headerlink\" title=\"Why React Hooks?\"></a><a href=\"https://dev.to/tylermcginnis/why-react-hooks-51lj\">Why React Hooks?</a></h3><p>通过代码非常详尽地解释了为什么会有 React Hooks，以及它的优缺点和注意事项，通俗易懂</p>\n<h3 id=\"【译】什么时候使用-useMemo-和-useCallback\"><a href=\"#【译】什么时候使用-useMemo-和-useCallback\" class=\"headerlink\" title=\"【译】什么时候使用 useMemo 和 useCallback\"></a><a href=\"https://jancat.github.io/post/2019/translation-usememo-and-usecallback/\">【译】什么时候使用 useMemo 和 useCallback</a></h3><p>性能优化总是会有成本，但并不总是带来好处。我们来谈谈 useMemo 和 useCallback 的成本和收益。</p>\n<h3 id=\"关于ref的一切\"><a href=\"#关于ref的一切\" class=\"headerlink\" title=\"关于ref的一切\"></a><a href=\"https://mp.weixin.qq.com/s/hYLlE_gfYrLkZebT7f6rwA\">关于ref的一切</a></h3><p>作为React开发者，你能回答如下几个问题么？</p>\n<ol>\n<li>为什么string类型的ref prop将会被废弃？</li>\n<li>function类型的ref prop会在什么时机被调用？</li>\n<li>React.createRef与useRef的返回值有什么不同？</li>\n</ol>\n<p>其实，这三个问题中的ref包含两个不同概念：</p>\n<ol>\n<li><p>不管是string、function类型或是React.createRef、useRef创建的ref，都是作为数据结构看待</p>\n</li>\n<li><p>问题2探讨的时机是将ref作为生命周期看待</p>\n</li>\n</ol>\n<p>该文会分别从数据结构、生命周期两个角度探讨ref。这，就是关于ref的一切。作者还写了关于 React 的其他文章共十篇：<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU0MDg4NDY2Mg==&amp;action=getalbum&amp;album_id=1497862391320068101&amp;scene=173#wechat_redirect\">#关于React的一切</a></p>\n<h3 id=\"为什么Vue3-0不再使用defineProperty实现数据监听？\"><a href=\"#为什么Vue3-0不再使用defineProperty实现数据监听？\" class=\"headerlink\" title=\"为什么Vue3.0不再使用defineProperty实现数据监听？\"></a><a href=\"https://www.infoq.cn/article/sPCMAcrdAZQfmLbGJeGr\">为什么Vue3.0不再使用defineProperty实现数据监听？</a></h3><p>Vue 3.0 中，响应式数据部分弃用了 Object.defineProperty，使用Proxy来代替它。本文将主要通过以下方面来分析为什么 Vue 选择弃用 Object.defineProperty。</p>\n<ol>\n<li>Object.defineProperty 真的无法监测数组下标的变化吗？</li>\n<li>分析 Vue2.x 中对数组 Observe 部分源码。</li>\n<li>对比Object.defineProperty和 Proxy。</li>\n</ol>\n<h3 id=\"从-IIFE-聊到-Babel-带你深入了解前端模块化发展体系\"><a href=\"#从-IIFE-聊到-Babel-带你深入了解前端模块化发展体系\" class=\"headerlink\" title=\"从 IIFE 聊到 Babel 带你深入了解前端模块化发展体系\"></a><a href=\"https://juejin.im/post/5cb9e563f265da03712999e8\">从 IIFE 聊到 Babel 带你深入了解前端模块化发展体系</a></h3><p>作者从十年前的 IIFE 开始介绍，一步步分析与介绍了前端模块化的演进与发展，文章很长，信息量很大。</p>\n<h3 id=\"这几个概念你可能还是没搞清require、import和export\"><a href=\"#这几个概念你可能还是没搞清require、import和export\" class=\"headerlink\" title=\"这几个概念你可能还是没搞清require、import和export\"></a><a href=\"https://juejin.im/post/5ccf98eae51d453a4a357e4a\">这几个概念你可能还是没搞清require、import和export</a></h3><p>作者从一开始的 Function 到后来的对象写法再到后来的闭包写法，介绍了模块写法的演进历程，同时还介绍了CommonJS规范、AMD规范、CMD规范和AMD与CMD的区别</p>\n<h3 id=\"useEffect-完整指南\"><a href=\"#useEffect-完整指南\" class=\"headerlink\" title=\"useEffect 完整指南\"></a><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">useEffect 完整指南</a></h3><p>该文篇幅较长，深入讲解了 React Hook 中的 useEffect，看完后可以帮你明白下面几个问题的答案：</p>\n<ol>\n<li>🤔 如何用useEffect模拟componentDidMount生命周期？</li>\n<li>🤔 如何正确地在useEffect里请求数据？[]又是什么？</li>\n<li>🤔 我应该把函数当做effect的依赖吗？</li>\n<li>🤔 为什么有时候会出现无限重复请求的问题？</li>\n<li>🤔 为什么有时候在effect里拿到的是旧的state或prop？</li>\n</ol>\n<h3 id=\"前端构建秘籍\"><a href=\"#前端构建秘籍\" class=\"headerlink\" title=\"前端构建秘籍\"></a><a href=\"https://juejin.im/post/5c9075305188252d5c743520\">前端构建秘籍</a></h3><p>你对 webpack 了解多少？如何针对业务集成最佳配置？如何优化开发体验？如何开足马力，实现极速的 webpack 的构建性能 🚀？又会有哪些坑 💣？该文带你解答这些问题</p>\n<h3 id=\"import、require、export、module-exports-混合使用详解\"><a href=\"#import、require、export、module-exports-混合使用详解\" class=\"headerlink\" title=\"import、require、export、module.exports 混合使用详解\"></a><a href=\"https://juejin.im/post/5a2e5f0851882575d42f5609\">import、require、export、module.exports 混合使用详解</a></h3><p>该文通过以下几个问题进行展开，详细介绍了模块化相关规范以及 webpack 和 babel 在这其中起到的作用：</p>\n<ol>\n<li>为何有的地方使用 require 去引用一个模块时需要加上 default？ require(‘xx’).default</li>\n<li>经常在各大UI组件引用的文档上会看到说明 import { button } from ‘xx-ui’ 这样会引入所有组件内容，需要添加额外的 babel 配置，比如 babel-plugin-component？</li>\n<li>为什么可以使用 es6 的 import 去引用 commonjs 规范定义的模块，或者反过来也可以又是为什么？</li>\n<li>我们在浏览一些 npm 下载下来的 UI 组件模块时（比如说 element-ui 的 lib 文件下），看到的都是 webpack 编译好的 js 文件，可以使用 import 或 require 再去引用。但是我们平时编译好的 js 是无法再被其他模块 import 的，这是为什么？</li>\n<li>babel 在模块化的场景中充当了什么角色？以及 webpack ？哪个启到了关键作用？</li>\n<li>听说 es6 还有 tree-shaking 功能，怎么才能使用这个功能？</li>\n</ol>\n<h3 id=\"基于-webpack-的持久化缓存方案\"><a href=\"#基于-webpack-的持久化缓存方案\" class=\"headerlink\" title=\"基于 webpack 的持久化缓存方案\"></a><a href=\"https://github.com/pigcan/blog/issues/9\">基于 webpack 的持久化缓存方案</a></h3><p>如何基于 webpack 做持久化缓存似乎一直处于没有最佳实践的状态。作为开发者最大的诉求是：在 entry 内部内容未发生变更的情况下构建之后也能稳定不变。而 pigcan 的这篇文章通过具体的场景层层深入，带你逐步揭晓 webpack 持久化缓存的实现方案</p>\n<h3 id=\"让虚拟DOM和DOM-diff不再成为你的绊脚石\"><a href=\"#让虚拟DOM和DOM-diff不再成为你的绊脚石\" class=\"headerlink\" title=\"让虚拟DOM和DOM-diff不再成为你的绊脚石\"></a><a href=\"https://juejin.im/post/5c8e5e4951882545c109ae9c\">让虚拟DOM和DOM-diff不再成为你的绊脚石</a></h3><p>作者通过实际代码一步步地对虚拟 DOM 实现和 Diff 算法进行了讲解和实现，讲解的很清楚，逻辑很清晰</p>\n<h3 id=\"为什么顺序调用对-React-Hooks-很重要？\"><a href=\"#为什么顺序调用对-React-Hooks-很重要？\" class=\"headerlink\" title=\"为什么顺序调用对 React Hooks 很重要？\"></a><a href=\"https://overreacted.io/zh-hans/why-do-hooks-rely-on-call-order/\">为什么顺序调用对 React Hooks 很重要？</a></h3><p>同事推荐，对 React Hooks 讲解的很清楚，而且非常贴心的把评论神马的都翻译成了中文</p>\n<h3 id=\"react-组件的生命周期\"><a href=\"#react-组件的生命周期\" class=\"headerlink\" title=\"react 组件的生命周期\"></a><a href=\"https://segmentfault.com/a/1190000003691119\">react 组件的生命周期</a></h3><p>作者详细介绍了和 react 生命周期的一些函数执行时机以及它们的作用，通过实例的方式进行了讲解，个人感觉讲解的非常清晰</p>\n<h3 id=\"Gulp-和-Webpack-对比\"><a href=\"#Gulp-和-Webpack-对比\" class=\"headerlink\" title=\"Gulp 和 Webpack 对比\"></a><a href=\"http://www.jianshu.com/p/b1022d224817\">Gulp 和 Webpack 对比</a></h3><p>作者通过实际的代码对比了 gulp 和 webpack 在功能、原理以及模块化方面的优缺点</p>\n<h3 id=\"webpack-常用插件及其作用\"><a href=\"#webpack-常用插件及其作用\" class=\"headerlink\" title=\"webpack 常用插件及其作用\"></a><a href=\"http://www.monster1935.site/blog/2017/08/24/webpack%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/\">webpack 常用插件及其作用</a></h3><p>介绍了 webpack 经常用到的一些插件和它们的作用，美中不足的是没有具体代码以及介绍的插件有点少</p>\n<h3 id=\"webpack-源码阅读——npm-脚本运行-webpack-与命令行输入-webpack-的区别\"><a href=\"#webpack-源码阅读——npm-脚本运行-webpack-与命令行输入-webpack-的区别\" class=\"headerlink\" title=\"webpack 源码阅读——npm 脚本运行 webpack 与命令行输入 webpack 的区别\"></a><a href=\"http://www.monster1935.site/blog/2017/09/07/webpack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-npm%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8Cwebpack%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5webpack%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/\">webpack 源码阅读——npm 脚本运行 webpack 与命令行输入 webpack 的区别</a></h3><p>虽然是一个小知识点，不过作者读源码的精神可嘉</p>\n<h3 id=\"webpack-收藏集-掘金\"><a href=\"#webpack-收藏集-掘金\" class=\"headerlink\" title=\"webpack - 收藏集 - 掘金\"></a><a href=\"https://segmentfault.com/a/1190000009435832\">webpack - 收藏集 - 掘金</a></h3><p>掘金上面的 webpack 相关文章，webpack 本身实在太复杂，还是需要一些文章差补缺漏的</p>\n<h3 id=\"Vue-js——60分钟快速入门\"><a href=\"#Vue-js——60分钟快速入门\" class=\"headerlink\" title=\"Vue.js——60分钟快速入门\"></a><a href=\"http://www.cnblogs.com/keepfool/p/5619070.html\">Vue.js——60分钟快速入门</a></h3><p>vue 入门教程，还有另外两篇文章，文章最后有链接，个人认为是目前为止看到的最舒服的 vue 入门教程，排版配色都很不错</p>\n<h3 id=\"深入到源码：解读-redux-的设计思路与用法\"><a href=\"#深入到源码：解读-redux-的设计思路与用法\" class=\"headerlink\" title=\"深入到源码：解读 redux 的设计思路与用法\"></a><a href=\"https://github.com/Lucifier129/Lucifier129.github.io/issues/9\">深入到源码：解读 redux 的设计思路与用法</a></h3><p>一直都没搞明白 redux，后来看了这篇文章，讲的很详细，而且讲解了一部分源码，推荐！（下面一段话取自该文章） 组织 <code>redux</code> 的流程莫过于：</p>\n<ul>\n<li>设计全局 state 的数据结构</li>\n<li>设计更改 state 数据的 actionTypes 常量以及其他跟视图展现相关的 actionTypes 常量</li>\n<li>根据 actionTypes 常量，书写 actionCreator 。</li>\n<li>根据各个 actionCreator 的返回值，涉及 reducer 做数据的最后处理</li>\n<li>在有了 reducer 函数之后，createStore(reducer, initState) 得到 store 对象</li>\n<li>用 bindActionCreators 函数将 actionCreators 和 store.dispatch 绑定起来，得到一组能修改全局状态的函数</li>\n<li>分发各个状态修改函数到各个 DOM 事件中。</li>\n</ul>\n<h3 id=\"Vue-生命周期深入\"><a href=\"#Vue-生命周期深入\" class=\"headerlink\" title=\"Vue 生命周期深入\"></a><a href=\"https://segmentfault.com/a/1190000014705819\">Vue 生命周期深入</a></h3><p>这篇博客会从下面四个常见的应用诠释了组件的生命周期，以及各个生命周期应该干什么事，博主写的很不错，直观易懂，很适合接触 vue 不深的童鞋。</p>\n<ol>\n<li>单组件的生命周期</li>\n<li>父子组件的生命周期</li>\n<li>兄弟组件的生命周期</li>\n<li>宏 mixin 的生命周期</li>\n</ol>\n<h3 id=\"2019-年-Vue-学习路线图\"><a href=\"#2019-年-Vue-学习路线图\" class=\"headerlink\" title=\"2019 年 Vue 学习路线图\"></a><a href=\"https://mp.weixin.qq.com/s/jGmJndL-oK3i5lYLiQROIg\">2019 年 Vue 学习路线图</a></h3><p>作者我将在这篇文章中展示了一个高级“知识地图”，它包含了与 Vue 开发相关的关键领域，你可以使用这张地图作为 2019 年学习 Vue 的图鉴。英文原文：<a href=\"https://vuejsdevelopers.com/2018/12/04/vue-js-2019-knowledge-map/\">https://vuejsdevelopers.com/2018/12/04/vue-js-2019-knowledge-map/</a></p>\n<h3 id=\"一口-很长的-气了解-babel\"><a href=\"#一口-很长的-气了解-babel\" class=\"headerlink\" title=\"一口(很长的)气了解 babel\"></a><a href=\"https://juejin.im/post/5c19c5e0e51d4502a232c1c6\">一口(很长的)气了解 babel</a></h3><p>作者详细介绍了 babel 究竟是做什么的，以及 babel 的一些配套工具的作用，同时还介绍了如何争取地进行配置和使用 babel。</p>\n<h3 id=\"Which-of-the-635000-npm-modules-do-I-choose\"><a href=\"#Which-of-the-635000-npm-modules-do-I-choose\" class=\"headerlink\" title=\"Which of the 635000 npm modules do I choose?\"></a><a href=\"https://www.coreycleary.me/which-of-the-635000-npm-modules-do-i-choose/\">Which of the 635000 npm modules do I choose?</a></h3><p>npm 现在已经有 60 多万个库，如何在如此繁杂的 module 中选择合适自己的感觉是件难事，而作者就基于此对一些比较大型使用比较多的库进行了横向比较，会对你在技术上的选择起到帮助作用。</p>\n<h3 id=\"2019-年-React-学习路线图\"><a href=\"#2019-年-React-学习路线图\" class=\"headerlink\" title=\"2019 年 React 学习路线图\"></a><a href=\"https://mp.weixin.qq.com/s/PWSeeqDwu8QOcamlo_FJrA\">2019 年 React 学习路线图</a></h3><p>和上面的 Vue 学习路线图类似，建议搭配食用，英文原文：<a href=\"https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02\">https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02</a></p>\n<h3 id=\"细说-webpack-之流程篇\"><a href=\"#细说-webpack-之流程篇\" class=\"headerlink\" title=\"细说 webpack 之流程篇\"></a><a href=\"http://taobaofed.org/blog/2016/09/09/webpack-flow/\">细说 webpack 之流程篇</a></h3><p>淘宝 FED 这篇博客，对 webpack 的整体流程梳理的非常清晰，以及 webpack 的基础架构讲解的很细致，对 compiler 和 complation 对象也做了很细致的剖析。</p>\n<h3 id=\"React-是怎样炼成的\"><a href=\"#React-是怎样炼成的\" class=\"headerlink\" title=\"React 是怎样炼成的\"></a><a href=\"https://segmentfault.com/a/1190000013365426\">React 是怎样炼成的</a></h3><p>文章主要讲述 React 的诞生过程和优化思路。内容整理自 2014 年的 <a href=\"https://speakerdeck.com/vjeux/oscon-react-architecture\">OSCON - React Architecture by vjeux</a>，虽然从今天来看可能会有点历史感，但仍然值得学习了解。以史为鉴，从中也可以管窥 Facebook 优秀的工程管理文化。</p>\n","more":"<h3 id=\"React-体系下关于-Mobx-与-Redux-的一些思考\"><a href=\"#React-体系下关于-Mobx-与-Redux-的一些思考\" class=\"headerlink\" title=\"React 体系下关于 Mobx 与 Redux 的一些思考\"></a><a href=\"https://zhuanlan.zhihu.com/p/461844358\">React 体系下关于 Mobx 与 Redux 的一些思考</a></h3><p>Redux VS Mbox（Immutable VS Mutable），这两种不同的思路会导致它们在与 React 这样的致力于 Immutable 数据的框架进行结合时，产生完全不同的结果。如果不去仔细区别，很容易被经过包装之后的各种五花八门的库迷惑。</p>\n<h3 id=\"小程序技术方案探讨\"><a href=\"#小程序技术方案探讨\" class=\"headerlink\" title=\"小程序技术方案探讨\"></a><a href=\"http://blog.cnbang.net/tech/3486/\">小程序技术方案探讨</a></h3><p>微信小程序上线大半年，大部分技术原理也有文章介绍了，本文尝试从需求出发探讨微信小程序技术方案的来源，以及最近公测的支付宝小程序技术方案的考量。</p>\n<h3 id=\"渔人和Rxjs的故事\"><a href=\"#渔人和Rxjs的故事\" class=\"headerlink\" title=\"渔人和Rxjs的故事\"></a><a href=\"https://github.com/jackiewillen/blog/issues/1\">渔人和Rxjs的故事</a></h3><p>你一定要坚持看完这个故事，看完你一定会懂Rxjs.千万不要觉得故事情节没有《盗墓笔记》好看而放弃。因为臣妾实在是只能把枯燥的程序写成这个很（挺）有（简）趣（陋）的故事了。</p>\n<h3 id=\"万字解析微前端、微前端框架qiankun以及源码\"><a href=\"#万字解析微前端、微前端框架qiankun以及源码\" class=\"headerlink\" title=\"万字解析微前端、微前端框架qiankun以及源码\"></a><a href=\"https://mp.weixin.qq.com/s?__biz=MzkwODIwMDY2OQ==&amp;mid=2247488282&amp;idx=1&amp;sn=459ba1ff1b4df2e9322f4c6e0f955d71&amp;source=41#wechat_redirect\">万字解析微前端、微前端框架qiankun以及源码</a></h3><p>本文将针对微前端框架 qiankun 的源码进行深入解析，在源码讲解之前，我们先来了解一下什么是 微前端。</p>\n<p>微前端 是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立开发、独立部署。同时，它们也可以在共享组件的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。</p>\n<p>qiankun（乾坤） 就是一款由蚂蚁金服推出的比较成熟的微前端框架，基于 single-spa 进行二次开发，用于将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。</p>\n<div align='center'><img src='/images/hexo_post_783.png' alt='' /></div>\n\n<h3 id=\"Vue-开发必须知道的-36-个技巧【近1W字】\"><a href=\"#Vue-开发必须知道的-36-个技巧【近1W字】\" class=\"headerlink\" title=\"Vue 开发必须知道的 36 个技巧【近1W字】\"></a><a href=\"https://juejin.cn/post/6844903959266590728\">Vue 开发必须知道的 36 个技巧【近1W字】</a></h3><p>Vue 3.x 的Pre-Alpha 版本。后面应该还会有 Alpha、Beta 等版本,预计至少要等到 2020 年第一季度才有可能发布 3.0 正式版;所以应该趁还没出来加紧打好 Vue2.x 的基础;<br>Vue 基本用法很容易上手,但是有很多优化的写法你就不一定知道了,本文列举了 36  个 vue 开发技巧;<br>后续 Vue 3.x 出来后持续更新.</p>\n<h3 id=\"React-开发必须知道的-34-个技巧【近1W字】\"><a href=\"#React-开发必须知道的-34-个技巧【近1W字】\" class=\"headerlink\" title=\"React 开发必须知道的 34 个技巧【近1W字】\"></a><a href=\"https://juejin.cn/post/6844903993278201870\">React 开发必须知道的 34 个技巧【近1W字】</a></h3><p>React 是前端三大框架之一,在开发中也是一项技能;本文从实际开发中总结了 React 开发的一些技巧技巧,适合 React 初学或者有一定项目经验的同学</p>\n<h3 id=\"React-框架运行时优化方案的演进\"><a href=\"#React-框架运行时优化方案的演进\" class=\"headerlink\" title=\"React 框架运行时优化方案的演进\"></a><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0MDMwMzQyOA==&amp;mid=2247490885&amp;idx=1&amp;sn=0501282f3b8f9a0e1f96caf8551b16ac&amp;source=41#wechat_redirect\">React 框架运行时优化方案的演进</a></h3><p>这篇文章的主要目的，就是根据 React 主要优化策略几个阶段的演进，来把这些概念梳理清楚，看看 React 这几年到底在搞什么东西，以及顺便解读一下最新更新的这些特性。在分享里面我们可能不会很详细的去分析具体的调度流程和细节，但是我们会在一些优化策略上节选一些源码进行解读。</p>\n<h3 id=\"微信小程序技术原理分析\"><a href=\"#微信小程序技术原理分析\" class=\"headerlink\" title=\"微信小程序技术原理分析\"></a><a href=\"https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html\">微信小程序技术原理分析</a></h3><p>互联网生态演进：超级 APP + 小程序成为「轻应用时代」下的新生态。</p>\n<div align='center'><img src='/images/hexo_post_781.png' alt='' width='900'/></div>\n\n<h3 id=\"React-memo-和-useMemo-的用法与区别\"><a href=\"#React-memo-和-useMemo-的用法与区别\" class=\"headerlink\" title=\"React.memo() 和 useMemo() 的用法与区别\"></a><a href=\"https://mp.weixin.qq.com/s/zxT2GfujdbQfvrCtRxkbiQ\">React.memo() 和 useMemo() 的用法与区别</a></h3><p>本文翻译自 Adebola Adeniran 在 LogRocket 论坛中关于 React.memo() 和 useMemo() 对比与用例分析。</p>\n<h3 id=\"React技术内幕-setState的秘密\"><a href=\"#React技术内幕-setState的秘密\" class=\"headerlink\" title=\"[React技术内幕]:setState的秘密\"></a><a href=\"https://segmentfault.com/a/1190000010785692\">[React技术内幕]:setState的秘密</a></h3><p>对于大多数的React开发者，setState可能是最常用的API之一。React作为View层，通过改变data从而引发UI的更新。React不像Vue这种MVVM库，直接修改data并不能视图的改变，更新状态(state)的过程必须使用setState。</p>\n<h3 id=\"刨根问底，揭开-Vue-中-Scope-CSS-实现的幕后（原理）\"><a href=\"#刨根问底，揭开-Vue-中-Scope-CSS-实现的幕后（原理）\" class=\"headerlink\" title=\"刨根问底，揭开 Vue 中 Scope CSS 实现的幕后（原理）\"></a><a href=\"https://mp.weixin.qq.com/s/MJScjoqGtKh9IuFpfMbbQg\">刨根问底，揭开 Vue 中 Scope CSS 实现的幕后（原理）</a></h3><p>我想大家应该都对 Vue 的 Scope CSS 耳熟能详了，但是说起 Vue 的 Scope CSS 实现的原理，很多人应该会说不就是给 HTML、CSS 添加属性吗 🙃️？</p>\n<p>确实是这样的，不过这只是最终 Scope CSS 呈现的结果。而这个过程又是如何实现的？我想能回答上一二的同学应该不多。</p>\n<p>那么，回到今天本文，我将会围绕以下 3 点，和大家一起从 Vue 的 Scope CSS 的最终呈现结果出发，深入浅出一番其实现的底层原理：</p>\n<ul>\n<li>什么是 Scope CSS</li>\n<li>vue-loader 处理组件（.vue 文件）</li>\n<li>Patch 阶段应用 ScopeId 生成 HTML 的属性</li>\n</ul>\n<h3 id=\"React组件到底什么时候render啊\"><a href=\"#React组件到底什么时候render啊\" class=\"headerlink\" title=\"React组件到底什么时候render啊\"></a><a href=\"https://juejin.cn/post/6886766652667461646\">React组件到底什么时候render啊</a></h3><p>React 到底什么时候才会 render？</p>\n<h3 id=\"在你写memo-之前\"><a href=\"#在你写memo-之前\" class=\"headerlink\" title=\"在你写memo()之前\"></a><a href=\"https://overreacted.io/zh-hans/before-you-memo/\">在你写memo()之前</a></h3><p>在这篇文章里，React 核心开发者 Dan 分享了关于 memo 的两种不同的技巧。它们十分基础，这也正是为什么人们很少会意识到它们可以提升渲染性能。这些技巧和你已经知道的内容是互补的，它们并不会替代 memo 或者 useMemo，但是先试一试它们还是不错的</p>\n<h3 id=\"轻松理解webpack热更新原理\"><a href=\"#轻松理解webpack热更新原理\" class=\"headerlink\" title=\"轻松理解webpack热更新原理\"></a><a href=\"https://juejin.cn/post/6844904008432222215\">轻松理解webpack热更新原理</a></h3><p>Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。HMR的好处，在日常开发工作中体会颇深：节省宝贵的开发时间、提升开发体验。</p>\n<h3 id=\"React技术揭秘\"><a href=\"#React技术揭秘\" class=\"headerlink\" title=\"React技术揭秘\"></a><a href=\"https://react.iamkasong.com/\">React技术揭秘</a></h3><p>本书的宗旨是打造一本严谨、易懂的React源码分析教程。为了达到这个目标，在行文上，本书会遵循：</p>\n<ul>\n<li>不预设观点 —— 所有观点来自React核心团队成员在公开场合的分享。</li>\n<li>丰富的参考资料 —— 包括在线Demo、文章、视频。</li>\n<li>保持更新 —— 在React版本更新后会及时补充。当前版本v17.0.0-alpha。</li>\n</ul>\n<h3 id=\"React-事件系统工作原理\"><a href=\"#React-事件系统工作原理\" class=\"headerlink\" title=\"React 事件系统工作原理\"></a><a href=\"https://juejin.cn/post/6909271104440205326\">React 事件系统工作原理</a></h3><p>React 为我们提供了一套虚拟的事件系统，这套虚拟事件系统是如何工作的，笔者对源码做了一次梳理，整理了下面的文档供大家参考。</p>\n<h3 id=\"vue3源码解析和最佳实践\"><a href=\"#vue3源码解析和最佳实践\" class=\"headerlink\" title=\"vue3源码解析和最佳实践\"></a><a href=\"https://vue3.w2deep.com/\">vue3源码解析和最佳实践</a></h3><p>这是一个收录 vue3 源码解析和关于 vue3 的最佳实践的网站，网站分为两部分，vue3 源码解析和vue3 最佳实践，你可以根据你的需要进行阅读。另外网站作者之前也做过一次 react 的源码解析，是基于 react 16.7 版本的，<a href=\"https://react.jokcy.me/\">网址在这里</a></p>\n<h3 id=\"React-Fiber-Architecture\"><a href=\"#React-Fiber-Architecture\" class=\"headerlink\" title=\"React Fiber Architecture\"></a><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a></h3><p>Fiber introduces several novel concepts that are difficult to grok solely by looking at code. This document began as a collection of notes I took as I followed along with Fiber’s implementation in the React project. As it grew, I realized it may be a helpful resource for others, too.</p>\n<h3 id=\"揭开-React-Hooks-的神秘面纱-数组解构融成魔法\"><a href=\"#揭开-React-Hooks-的神秘面纱-数组解构融成魔法\" class=\"headerlink\" title=\"揭开 React Hooks 的神秘面纱:数组解构融成魔法\"></a><a href=\"https://github.com/xitu/gold-miner/blob/master/TODO1/react-hooks-not-magic-just-arrays.md\">揭开 React Hooks 的神秘面纱:数组解构融成魔法</a></h3><p>我超喜欢 React 新出的这个 Hooks API。而在使用它时却有一些奇怪的规则。为了那些纠结于为什么要有这些规则的人，在这里我会以模型图的方式来向你们展示这个新的 API。</p>\n<h3 id=\"一文吃透-React-SSR-服务端渲染和同构原理\"><a href=\"#一文吃透-React-SSR-服务端渲染和同构原理\" class=\"headerlink\" title=\"一文吃透 React SSR 服务端渲染和同构原理\"></a><a href=\"https://segmentfault.com/a/1190000020417285\">一文吃透 React SSR 服务端渲染和同构原理</a></h3><p>全网最完整的 React SSR 同构技术原理解析与实践，从零开始手把手带你打造自己的同构应用开发骨架，帮助大家彻底深入理解服务端渲染及底层实现原理，学完本课程，你也可以打造自己的同构框架。</p>\n<h3 id=\"React-Fiber\"><a href=\"#React-Fiber\" class=\"headerlink\" title=\"React Fiber\"></a><a href=\"https://juejin.cn/post/6844903582622285831\">React Fiber</a></h3><p>react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差。<br>为了解决这个问题，react团队经过两年的工作，重写了react中核心算法——reconciliation。并在v16版本中发布了这个新的特性。为了区别之前和之后的reconciler，通常将之前的reconciler称为stack reconciler，重写后的称为fiber reconciler，简称为Fiber。</p>\n<h3 id=\"Why-React-Hooks\"><a href=\"#Why-React-Hooks\" class=\"headerlink\" title=\"Why React Hooks?\"></a><a href=\"https://dev.to/tylermcginnis/why-react-hooks-51lj\">Why React Hooks?</a></h3><p>通过代码非常详尽地解释了为什么会有 React Hooks，以及它的优缺点和注意事项，通俗易懂</p>\n<h3 id=\"【译】什么时候使用-useMemo-和-useCallback\"><a href=\"#【译】什么时候使用-useMemo-和-useCallback\" class=\"headerlink\" title=\"【译】什么时候使用 useMemo 和 useCallback\"></a><a href=\"https://jancat.github.io/post/2019/translation-usememo-and-usecallback/\">【译】什么时候使用 useMemo 和 useCallback</a></h3><p>性能优化总是会有成本，但并不总是带来好处。我们来谈谈 useMemo 和 useCallback 的成本和收益。</p>\n<h3 id=\"关于ref的一切\"><a href=\"#关于ref的一切\" class=\"headerlink\" title=\"关于ref的一切\"></a><a href=\"https://mp.weixin.qq.com/s/hYLlE_gfYrLkZebT7f6rwA\">关于ref的一切</a></h3><p>作为React开发者，你能回答如下几个问题么？</p>\n<ol>\n<li>为什么string类型的ref prop将会被废弃？</li>\n<li>function类型的ref prop会在什么时机被调用？</li>\n<li>React.createRef与useRef的返回值有什么不同？</li>\n</ol>\n<p>其实，这三个问题中的ref包含两个不同概念：</p>\n<ol>\n<li><p>不管是string、function类型或是React.createRef、useRef创建的ref，都是作为数据结构看待</p>\n</li>\n<li><p>问题2探讨的时机是将ref作为生命周期看待</p>\n</li>\n</ol>\n<p>该文会分别从数据结构、生命周期两个角度探讨ref。这，就是关于ref的一切。作者还写了关于 React 的其他文章共十篇：<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU0MDg4NDY2Mg==&amp;action=getalbum&amp;album_id=1497862391320068101&amp;scene=173#wechat_redirect\">#关于React的一切</a></p>\n<h3 id=\"为什么Vue3-0不再使用defineProperty实现数据监听？\"><a href=\"#为什么Vue3-0不再使用defineProperty实现数据监听？\" class=\"headerlink\" title=\"为什么Vue3.0不再使用defineProperty实现数据监听？\"></a><a href=\"https://www.infoq.cn/article/sPCMAcrdAZQfmLbGJeGr\">为什么Vue3.0不再使用defineProperty实现数据监听？</a></h3><p>Vue 3.0 中，响应式数据部分弃用了 Object.defineProperty，使用Proxy来代替它。本文将主要通过以下方面来分析为什么 Vue 选择弃用 Object.defineProperty。</p>\n<ol>\n<li>Object.defineProperty 真的无法监测数组下标的变化吗？</li>\n<li>分析 Vue2.x 中对数组 Observe 部分源码。</li>\n<li>对比Object.defineProperty和 Proxy。</li>\n</ol>\n<h3 id=\"从-IIFE-聊到-Babel-带你深入了解前端模块化发展体系\"><a href=\"#从-IIFE-聊到-Babel-带你深入了解前端模块化发展体系\" class=\"headerlink\" title=\"从 IIFE 聊到 Babel 带你深入了解前端模块化发展体系\"></a><a href=\"https://juejin.im/post/5cb9e563f265da03712999e8\">从 IIFE 聊到 Babel 带你深入了解前端模块化发展体系</a></h3><p>作者从十年前的 IIFE 开始介绍，一步步分析与介绍了前端模块化的演进与发展，文章很长，信息量很大。</p>\n<h3 id=\"这几个概念你可能还是没搞清require、import和export\"><a href=\"#这几个概念你可能还是没搞清require、import和export\" class=\"headerlink\" title=\"这几个概念你可能还是没搞清require、import和export\"></a><a href=\"https://juejin.im/post/5ccf98eae51d453a4a357e4a\">这几个概念你可能还是没搞清require、import和export</a></h3><p>作者从一开始的 Function 到后来的对象写法再到后来的闭包写法，介绍了模块写法的演进历程，同时还介绍了CommonJS规范、AMD规范、CMD规范和AMD与CMD的区别</p>\n<h3 id=\"useEffect-完整指南\"><a href=\"#useEffect-完整指南\" class=\"headerlink\" title=\"useEffect 完整指南\"></a><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">useEffect 完整指南</a></h3><p>该文篇幅较长，深入讲解了 React Hook 中的 useEffect，看完后可以帮你明白下面几个问题的答案：</p>\n<ol>\n<li>🤔 如何用useEffect模拟componentDidMount生命周期？</li>\n<li>🤔 如何正确地在useEffect里请求数据？[]又是什么？</li>\n<li>🤔 我应该把函数当做effect的依赖吗？</li>\n<li>🤔 为什么有时候会出现无限重复请求的问题？</li>\n<li>🤔 为什么有时候在effect里拿到的是旧的state或prop？</li>\n</ol>\n<h3 id=\"前端构建秘籍\"><a href=\"#前端构建秘籍\" class=\"headerlink\" title=\"前端构建秘籍\"></a><a href=\"https://juejin.im/post/5c9075305188252d5c743520\">前端构建秘籍</a></h3><p>你对 webpack 了解多少？如何针对业务集成最佳配置？如何优化开发体验？如何开足马力，实现极速的 webpack 的构建性能 🚀？又会有哪些坑 💣？该文带你解答这些问题</p>\n<h3 id=\"import、require、export、module-exports-混合使用详解\"><a href=\"#import、require、export、module-exports-混合使用详解\" class=\"headerlink\" title=\"import、require、export、module.exports 混合使用详解\"></a><a href=\"https://juejin.im/post/5a2e5f0851882575d42f5609\">import、require、export、module.exports 混合使用详解</a></h3><p>该文通过以下几个问题进行展开，详细介绍了模块化相关规范以及 webpack 和 babel 在这其中起到的作用：</p>\n<ol>\n<li>为何有的地方使用 require 去引用一个模块时需要加上 default？ require(‘xx’).default</li>\n<li>经常在各大UI组件引用的文档上会看到说明 import { button } from ‘xx-ui’ 这样会引入所有组件内容，需要添加额外的 babel 配置，比如 babel-plugin-component？</li>\n<li>为什么可以使用 es6 的 import 去引用 commonjs 规范定义的模块，或者反过来也可以又是为什么？</li>\n<li>我们在浏览一些 npm 下载下来的 UI 组件模块时（比如说 element-ui 的 lib 文件下），看到的都是 webpack 编译好的 js 文件，可以使用 import 或 require 再去引用。但是我们平时编译好的 js 是无法再被其他模块 import 的，这是为什么？</li>\n<li>babel 在模块化的场景中充当了什么角色？以及 webpack ？哪个启到了关键作用？</li>\n<li>听说 es6 还有 tree-shaking 功能，怎么才能使用这个功能？</li>\n</ol>\n<h3 id=\"基于-webpack-的持久化缓存方案\"><a href=\"#基于-webpack-的持久化缓存方案\" class=\"headerlink\" title=\"基于 webpack 的持久化缓存方案\"></a><a href=\"https://github.com/pigcan/blog/issues/9\">基于 webpack 的持久化缓存方案</a></h3><p>如何基于 webpack 做持久化缓存似乎一直处于没有最佳实践的状态。作为开发者最大的诉求是：在 entry 内部内容未发生变更的情况下构建之后也能稳定不变。而 pigcan 的这篇文章通过具体的场景层层深入，带你逐步揭晓 webpack 持久化缓存的实现方案</p>\n<h3 id=\"让虚拟DOM和DOM-diff不再成为你的绊脚石\"><a href=\"#让虚拟DOM和DOM-diff不再成为你的绊脚石\" class=\"headerlink\" title=\"让虚拟DOM和DOM-diff不再成为你的绊脚石\"></a><a href=\"https://juejin.im/post/5c8e5e4951882545c109ae9c\">让虚拟DOM和DOM-diff不再成为你的绊脚石</a></h3><p>作者通过实际代码一步步地对虚拟 DOM 实现和 Diff 算法进行了讲解和实现，讲解的很清楚，逻辑很清晰</p>\n<h3 id=\"为什么顺序调用对-React-Hooks-很重要？\"><a href=\"#为什么顺序调用对-React-Hooks-很重要？\" class=\"headerlink\" title=\"为什么顺序调用对 React Hooks 很重要？\"></a><a href=\"https://overreacted.io/zh-hans/why-do-hooks-rely-on-call-order/\">为什么顺序调用对 React Hooks 很重要？</a></h3><p>同事推荐，对 React Hooks 讲解的很清楚，而且非常贴心的把评论神马的都翻译成了中文</p>\n<h3 id=\"react-组件的生命周期\"><a href=\"#react-组件的生命周期\" class=\"headerlink\" title=\"react 组件的生命周期\"></a><a href=\"https://segmentfault.com/a/1190000003691119\">react 组件的生命周期</a></h3><p>作者详细介绍了和 react 生命周期的一些函数执行时机以及它们的作用，通过实例的方式进行了讲解，个人感觉讲解的非常清晰</p>\n<h3 id=\"Gulp-和-Webpack-对比\"><a href=\"#Gulp-和-Webpack-对比\" class=\"headerlink\" title=\"Gulp 和 Webpack 对比\"></a><a href=\"http://www.jianshu.com/p/b1022d224817\">Gulp 和 Webpack 对比</a></h3><p>作者通过实际的代码对比了 gulp 和 webpack 在功能、原理以及模块化方面的优缺点</p>\n<h3 id=\"webpack-常用插件及其作用\"><a href=\"#webpack-常用插件及其作用\" class=\"headerlink\" title=\"webpack 常用插件及其作用\"></a><a href=\"http://www.monster1935.site/blog/2017/08/24/webpack%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/\">webpack 常用插件及其作用</a></h3><p>介绍了 webpack 经常用到的一些插件和它们的作用，美中不足的是没有具体代码以及介绍的插件有点少</p>\n<h3 id=\"webpack-源码阅读——npm-脚本运行-webpack-与命令行输入-webpack-的区别\"><a href=\"#webpack-源码阅读——npm-脚本运行-webpack-与命令行输入-webpack-的区别\" class=\"headerlink\" title=\"webpack 源码阅读——npm 脚本运行 webpack 与命令行输入 webpack 的区别\"></a><a href=\"http://www.monster1935.site/blog/2017/09/07/webpack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-npm%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8Cwebpack%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5webpack%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/\">webpack 源码阅读——npm 脚本运行 webpack 与命令行输入 webpack 的区别</a></h3><p>虽然是一个小知识点，不过作者读源码的精神可嘉</p>\n<h3 id=\"webpack-收藏集-掘金\"><a href=\"#webpack-收藏集-掘金\" class=\"headerlink\" title=\"webpack - 收藏集 - 掘金\"></a><a href=\"https://segmentfault.com/a/1190000009435832\">webpack - 收藏集 - 掘金</a></h3><p>掘金上面的 webpack 相关文章，webpack 本身实在太复杂，还是需要一些文章差补缺漏的</p>\n<h3 id=\"Vue-js——60分钟快速入门\"><a href=\"#Vue-js——60分钟快速入门\" class=\"headerlink\" title=\"Vue.js——60分钟快速入门\"></a><a href=\"http://www.cnblogs.com/keepfool/p/5619070.html\">Vue.js——60分钟快速入门</a></h3><p>vue 入门教程，还有另外两篇文章，文章最后有链接，个人认为是目前为止看到的最舒服的 vue 入门教程，排版配色都很不错</p>\n<h3 id=\"深入到源码：解读-redux-的设计思路与用法\"><a href=\"#深入到源码：解读-redux-的设计思路与用法\" class=\"headerlink\" title=\"深入到源码：解读 redux 的设计思路与用法\"></a><a href=\"https://github.com/Lucifier129/Lucifier129.github.io/issues/9\">深入到源码：解读 redux 的设计思路与用法</a></h3><p>一直都没搞明白 redux，后来看了这篇文章，讲的很详细，而且讲解了一部分源码，推荐！（下面一段话取自该文章） 组织 <code>redux</code> 的流程莫过于：</p>\n<ul>\n<li>设计全局 state 的数据结构</li>\n<li>设计更改 state 数据的 actionTypes 常量以及其他跟视图展现相关的 actionTypes 常量</li>\n<li>根据 actionTypes 常量，书写 actionCreator 。</li>\n<li>根据各个 actionCreator 的返回值，涉及 reducer 做数据的最后处理</li>\n<li>在有了 reducer 函数之后，createStore(reducer, initState) 得到 store 对象</li>\n<li>用 bindActionCreators 函数将 actionCreators 和 store.dispatch 绑定起来，得到一组能修改全局状态的函数</li>\n<li>分发各个状态修改函数到各个 DOM 事件中。</li>\n</ul>\n<h3 id=\"Vue-生命周期深入\"><a href=\"#Vue-生命周期深入\" class=\"headerlink\" title=\"Vue 生命周期深入\"></a><a href=\"https://segmentfault.com/a/1190000014705819\">Vue 生命周期深入</a></h3><p>这篇博客会从下面四个常见的应用诠释了组件的生命周期，以及各个生命周期应该干什么事，博主写的很不错，直观易懂，很适合接触 vue 不深的童鞋。</p>\n<ol>\n<li>单组件的生命周期</li>\n<li>父子组件的生命周期</li>\n<li>兄弟组件的生命周期</li>\n<li>宏 mixin 的生命周期</li>\n</ol>\n<h3 id=\"2019-年-Vue-学习路线图\"><a href=\"#2019-年-Vue-学习路线图\" class=\"headerlink\" title=\"2019 年 Vue 学习路线图\"></a><a href=\"https://mp.weixin.qq.com/s/jGmJndL-oK3i5lYLiQROIg\">2019 年 Vue 学习路线图</a></h3><p>作者我将在这篇文章中展示了一个高级“知识地图”，它包含了与 Vue 开发相关的关键领域，你可以使用这张地图作为 2019 年学习 Vue 的图鉴。英文原文：<a href=\"https://vuejsdevelopers.com/2018/12/04/vue-js-2019-knowledge-map/\">https://vuejsdevelopers.com/2018/12/04/vue-js-2019-knowledge-map/</a></p>\n<h3 id=\"一口-很长的-气了解-babel\"><a href=\"#一口-很长的-气了解-babel\" class=\"headerlink\" title=\"一口(很长的)气了解 babel\"></a><a href=\"https://juejin.im/post/5c19c5e0e51d4502a232c1c6\">一口(很长的)气了解 babel</a></h3><p>作者详细介绍了 babel 究竟是做什么的，以及 babel 的一些配套工具的作用，同时还介绍了如何争取地进行配置和使用 babel。</p>\n<h3 id=\"Which-of-the-635000-npm-modules-do-I-choose\"><a href=\"#Which-of-the-635000-npm-modules-do-I-choose\" class=\"headerlink\" title=\"Which of the 635000 npm modules do I choose?\"></a><a href=\"https://www.coreycleary.me/which-of-the-635000-npm-modules-do-i-choose/\">Which of the 635000 npm modules do I choose?</a></h3><p>npm 现在已经有 60 多万个库，如何在如此繁杂的 module 中选择合适自己的感觉是件难事，而作者就基于此对一些比较大型使用比较多的库进行了横向比较，会对你在技术上的选择起到帮助作用。</p>\n<h3 id=\"2019-年-React-学习路线图\"><a href=\"#2019-年-React-学习路线图\" class=\"headerlink\" title=\"2019 年 React 学习路线图\"></a><a href=\"https://mp.weixin.qq.com/s/PWSeeqDwu8QOcamlo_FJrA\">2019 年 React 学习路线图</a></h3><p>和上面的 Vue 学习路线图类似，建议搭配食用，英文原文：<a href=\"https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02\">https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02</a></p>\n<h3 id=\"细说-webpack-之流程篇\"><a href=\"#细说-webpack-之流程篇\" class=\"headerlink\" title=\"细说 webpack 之流程篇\"></a><a href=\"http://taobaofed.org/blog/2016/09/09/webpack-flow/\">细说 webpack 之流程篇</a></h3><p>淘宝 FED 这篇博客，对 webpack 的整体流程梳理的非常清晰，以及 webpack 的基础架构讲解的很细致，对 compiler 和 complation 对象也做了很细致的剖析。</p>\n<h3 id=\"React-是怎样炼成的\"><a href=\"#React-是怎样炼成的\" class=\"headerlink\" title=\"React 是怎样炼成的\"></a><a href=\"https://segmentfault.com/a/1190000013365426\">React 是怎样炼成的</a></h3><p>文章主要讲述 React 的诞生过程和优化思路。内容整理自 2014 年的 <a href=\"https://speakerdeck.com/vjeux/oscon-react-architecture\">OSCON - React Architecture by vjeux</a>，虽然从今天来看可能会有点历史感，但仍然值得学习了解。以史为鉴，从中也可以管窥 Facebook 优秀的工程管理文化。</p>\n","categories":[{"name":"推荐","path":"api/categories/推荐.json"}],"tags":[{"name":"框架","path":"api/tags/框架.json"}]}