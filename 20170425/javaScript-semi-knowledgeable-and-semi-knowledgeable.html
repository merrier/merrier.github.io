<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Merrier说">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://merrier.wang">
    <!--SEO-->

<meta name="description" content="Merrier的个人博客">



<meta name="keywords" content="merrier 博客 前端 北邮人">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
<meta name="google-site-verification" content="UkMBUrF2qTuMWfmPXWFFmc_pnqCRAxHQY1ndE0Zu1p0">
    <!--Title-->


<title>读书笔记系列（7）——JavaScript半知半解 | Merrier说</title>


    <link rel="alternate" href="/atom.xml" title="Merrier说" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1264342320 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1264342320%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="Merrier">
            <img src="/images/hexo_others_8.jpeg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 叩首问路，码梦为生 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://merrier.wang">Merrier说</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/frontend/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/algorithm/"><i class="fa "></i>算法</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/series/"><i class="fa "></i>系列专栏</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>文章归档</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="读书笔记系列（7）——JavaScript半知半解">
            
	            读书笔记系列（7）——JavaScript半知半解
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/JS">
            JS
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/JS" title="JS">
                        JS
                    </a>
                
                    <a href="/tags/笔记" title="笔记">
                        笔记
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2017/04/25</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这本书是我无意中看到的一本电子版书籍，但是第一章就吸引到了我，然后就对作者展开了深入“挖掘”，通过作者的<a href="http://ghmagical.com/" target="_blank" rel="noopener">个人博客</a>发现作者是一个很厉害的技术开发人员，不管是前端还是后台都有所涉猎，所以推荐大家去他的个人博客逛逛，同时推荐他的两本书籍：《JavaScript半知半解》和《Web实战》，一定会有所收获</p>
<h1 id="1-完整的JavaScript"><a href="#1-完整的JavaScript" class="headerlink" title="1.完整的JavaScript"></a>1.完整的JavaScript</h1><p>完整的JavaScript实现由下列三个不同的部分组成：</p>
<ul>
<li>核心（<strong>ECMAScript</strong>）</li>
<li>文档对象模型（<strong>DOM</strong>）</li>
<li>浏览器对象模型（<strong>BOM</strong>）</li>
</ul>
<h1 id="2-元素"><a href="#2-元素" class="headerlink" title="2.元素"></a>2.<script>元素</h1><p>向HTML页面中插入JavaScript的主要方法，就是使用<script>元素。 <code>&lt;script&gt;</code>中定义了下列6个属性：</p>
<ul>
<li><strong><code>async</code></strong>：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效</li>
<li><strong><code>charset</code></strong>：可选，表示通过src属性指定的代码的字符集，比较少用。</li>
<li><strong><code>defer</code></strong>：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li>
<li><strong><code>language</code></strong>：已废弃</li>
<li><strong><code>src</code></strong>：可选，表示包含要执行代码的外部文件</li>
<li><strong><code>type</code></strong>：可选，表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。在HTML5中，默认是text/javascript，所以不需要设置。</li>
</ul>
<p>3.在使用<code>&lt;script&gt;</code>嵌入JavaScript代码时，切记不要在代码中的任何地方出现<code>&lt;/script&gt;</code>。执行下面的代码时，会产生一个错误：</p>
<p>“ &gt;<script><br>function loadScript(){<br>  alert(‘</script>‘);<br>}<br><p></p>
<h1 id="4-JavaScript代码的执行顺序"><a href="#4-JavaScript代码的执行顺序" class="headerlink" title="4.JavaScript代码的执行顺序"></a>4.JavaScript代码的执行顺序</h1><p>只要不存在defer和async属性，JavaScript代码就会从上至下依次解析。 带有src属性的<script>元素不应该在其<script>和</script>标签之间再包含额外的JavaScript代码，嵌入代码会被忽略。 <strong>只要不存在defer和async属性，浏览器都会按照<code>&lt;script&gt;</code>出现的先后顺序对它们依次进行解析。</strong> 一般将全部JavaScript引用放在<body>元素中页面的内容后面。</body></p>
<h1 id="5-延迟脚本"><a href="#5-延迟脚本" class="headerlink" title="5.延迟脚本"></a>5.延迟脚本</h1><p>当给<script>元素添加了<code>defer</code>属性时，src指向的外部文件会立即下载，但包含的脚本会延迟到浏览器遇到<code>&lt;/html&gt;</code>标签（整个页面解析完毕）后再执行（按添加顺序执行），会先于DOMContentLoaded事件执行。</p>
<script defer="defer" src="example.js"></script>
<script async src="example2.js"></script>

</p><p>会先执行example.js，然后执行example2.js 注意：defer只适合外部脚本文件。</p>
<h1 id="6-异步脚本"><a href="#6-异步脚本" class="headerlink" title="6.异步脚本"></a>6.异步脚本</h1><p><code>async</code>与<code>defer</code>属性类似，都用于改变处理脚本的行为，适用于外部脚本文件，并告诉浏览器立即下载，但标记为<code>async</code>的脚本并不保证按照指定它们的先后顺序执行。</p>
<script async src="example.js"></script>
<script async src="example2.js"></script>

<p><strong>两个执行顺序不定</strong>。 指定<code>async</code>属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。 注意：异步脚本不要在加载期间修改DOM。 <strong>异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行</strong>。</p>
<h1 id="7-元素"><a href="#7-元素" class="headerlink" title="7.元素"></a>7.<noscript>元素</noscript></h1><p>当浏览器不支持JavaScript或被禁用时，显示里面的内容。</p>
<p>元素” &gt;<noscript><br> 本页面需要浏览器支持（启用）JavaScript<br></noscript></p>
<h1 id="8-关键字和保留字"><a href="#8-关键字和保留字" class="headerlink" title="8.关键字和保留字"></a>8.关键字和保留字</h1><p>ECMA-262描述了一组具有特定用途的<strong>关键字</strong>，这些关键字可用于控制语句的开始或结束，或者用于执行特定操作等，不能用作标识符。</p>
<blockquote>
<p>break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try</p>
</blockquote>
<p>ECMA-262还描述了一组不能用作标识符的<strong>保留字</strong>：</p>
<blockquote>
<p>abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public</p>
</blockquote>
<p>如果使用关键字作标识符，会导致“Identifier Expected”错误。 有些时候，我们不得不用到保留字货关键字的，比如CSS样式中的float，这时就需要这样：</p>
<p>style.cssFloat</p>
<h1 id="9-隐式全局变量"><a href="#9-隐式全局变量" class="headerlink" title="9.隐式全局变量"></a>9.隐式全局变量</h1><p>在下面的代码中，由于从右至左的操作符优先级，所以表达式“b=0”是先执行的，而此时b未经过声明，所以它会成为全局变量。</p>
<p>function test() {<br>  var a = b = 0;<br>}<br>test();<br>console.log(b);  // 0<br>console.log(a);  // ReferenceError: a is not defined</p>
<p>关于全局变量：</p>
<ul>
<li>使用var创建的全局变量不能删除。</li>
<li>不是var创建的隐含全局变量可以使用delete删除（因为它并不是真正的变量，而是全局对象window的属性）</li>
</ul>
<p>function test() {<br>  var a = b = 0;<br>  delete a;<br>  delete b;<br>  console.log(a);  //  0<br>  console.log(b);  // ReferenceError: b is not defined<br>}<br>test();</p>
<h1 id="10-变量提升"><a href="#10-变量提升" class="headerlink" title="10.变量提升"></a>10.变量提升</h1><p><strong>变量提升</strong>是指所有变量的声明语句，都会被提升到代码的头部。 在函数内也一样，函数中的所有变量声明会在函数执行时被“提升”至函数体顶端：</p>
<p>console.log(a);  // undefined<br>var a = 1;<br>function test(){<br>  console.log(a);  // undefined<br>  var a = 2;<br>}<br>test();</p>
<p>结果是不是有点出乎你的意料。其实JavaScript的执行环境分为<strong>声明阶段</strong>和<strong>执行阶段</strong>，因此对于上面的代码，JavaScript会这样解释代码：</p>
<p>var a;<br>console.log(a);  // undefined<br>a = 1;<br>function test(){<br>  var a;<br>  console.log(a);  // undefined<br>  a = 2;<br>}<br>test();</p>
<h1 id="11-typeof操作符"><a href="#11-typeof操作符" class="headerlink" title="11.typeof操作符"></a>11.typeof操作符</h1><p><strong><code>typeof</code></strong>操作符用来检测给定变量的数据类型，可能的返回值：</p>
<ul>
<li>“undefined”–&gt;这个值未定义</li>
<li>“boolean”–&gt;这个值是布尔值</li>
<li>“string”–&gt;这个值是字符串</li>
<li>“number”–&gt;这个值是数值</li>
<li>“object”–&gt;这个值是对象或<strong>null</strong></li>
<li>“function”–&gt;这个值是函数</li>
</ul>
<h1 id="12-undefined和null类型"><a href="#12-undefined和null类型" class="headerlink" title="12.undefined和null类型"></a>12.undefined和null类型</h1><p><code>Undefined</code>类型只有一个值，即特殊的<code>undefined；`</code>Null<code>类型也是只有一个值的数据类型，这个特殊值就是</code>null；null和undefined没有属性，甚至连toString()这种标准方法都没有<code></code>undefined<code>其实是派生自</code>null`值：</p>
<p>console.log(null == undefined);  // true</p>
<h1 id="13-Boolean"><a href="#13-Boolean" class="headerlink" title="13.Boolean()"></a>13.Boolean()</h1><p>要将一个值转换为其对应的Boolean值，可以使用转型函数Boolean():</p>
<p>var name = ‘tg’;<br>console.log(Boolean(name);  // true</p>
<p>可以对任何类型的值调用Boolean函数，而且总会返回一个Boolean值（true或false） <strong>转换规则</strong>：</p>
<ul>
<li>对于true或false，返回原值（true或false）</li>
<li>对于String类型的值，任何非空字符串返回true，空字符串（””）返回false</li>
<li>对于Number类型的值，任何非零数字值（包括无穷大），返回true；0和NaN返回false</li>
<li>对于Object类型的值，任何对象返回true，null返回false</li>
<li>对于Undefined类型，undefined返回false（只有一个值）</li>
</ul>
<h1 id="14-浮点数值"><a href="#14-浮点数值" class="headerlink" title="14.浮点数值"></a>14.浮点数值</h1><p>保存浮点数值需要的内存空间是保存整数值的两倍。 默认情况下，ECMAScript会将那些小数点后面带有6个零以上的浮点数值转换为以e表示的数值。 浮点数的最高精度是17位小数（所以浮点数的比较比较麻烦）。</p>
<p>0.1 + 0.2 = 0.3000000000000004; // 不是等于0.3</p>
<h1 id="15-数值范围"><a href="#15-数值范围" class="headerlink" title="15.数值范围"></a>15.数值范围</h1><p>ECMAScript能够表示的最小数值保存在<code>Number.MIN_VALUE</code>（最小值）中，这个值是5e-324；能够表示的最大数值保存在<code>Number.MAX_VALUE</code>（最大值）中，这个值是1.7976931348623157e+308 注意：Infinity是不能参与计算的数值。 用<code>isFinite()</code>来判断这个值是否无穷，该函数接受一个参数。如果参数位于最小与最大数值之间，返回true。</p>
<p>console.log(isFinite(1));  //true<br>console.log(isFinite(Infinity));  // false</p>
<h1 id="16-NaN"><a href="#16-NaN" class="headerlink" title="16.NaN"></a>16.NaN</h1><p>NaN（Not a Number）表示非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 注意点：</p>
<ul>
<li>任何涉及NaN的操作都会返回NaN。</li>
<li>NaN与任何值都不相等，包括NaN本身。</li>
<li>任何操作数与NaN比较，都会返回false</li>
</ul>
<p>console.log(NaN == NaN);  //false</p>
<p>我们可以用<code>isNaN()</code>函数来判断是否非数值，该函数接受一个参数，可以是任何类型。<code>isNaN()</code>在接收到这个参数之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，比如：字符串”10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。</p>
<p>console.log(isNaN(NaN));  // true<br>console.log(isNaN(10));  // false<br>console.log(isNaN(‘blue’));  //  true</p>
<h1 id="17-Number"><a href="#17-Number" class="headerlink" title="17.Number()"></a>17.Number()</h1><p><strong>Number()函数的转换规则</strong>：</p>
<ul>
<li>如果是Boolean值，true和false将分别转换为1和0</li>
<li>如果是数字值，只是简单的传入和返回</li>
<li>如果是null值，返回0</li>
<li>如果是undefined，返回NaN</li>
<li>如果是字符串，遵循下列规则： （<ul>
<li>如果是字符串中只包含数字（包括前面带正负号），则将其转换为十进制数值（前导的零会被忽略）</li>
<li>如果字符串中包含有效的浮点格式，如1.1，则将其转换为对应的浮点数值</li>
<li>如果字符串中包含有效的十六进制，如0xf，则将其转换为相同大小的十进制数值</li>
<li>如果字符串是空的，返回0</li>
<li>如果字符串中包含上述格式以外的字符，返回NaN ）</li>
</ul>
</li>
<li>如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回字符串值</li>
</ul>
<p>console.log(Number(‘tg’));   // NaN<br>console.log(Number(‘’));   // 0<br>console.log(Number(‘0011’));  // 11<br>console.log(Number(true));   //1</p>
<p>一元加操作符的操作与Number函数规则相同</p>
<h1 id="18-parseInt-和parseFloat"><a href="#18-parseInt-和parseFloat" class="headerlink" title="18.parseInt()和parseFloat()"></a>18.parseInt()和parseFloat()</h1><p><code>parseInt()</code>会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回NaN。如果第一个字符是数字字符，就会继续解析，直到解析完所有后续字符或者遇到了一个非数字字符。 <code>parseInt()</code>也能识别八进制（在ECMAScript 5中无法识别，将开头的0当作0）和十六进制，最后会转换成十进制。</p>
<p>console.log(parseInt(‘123tg’));  // 123<br>console.log(parseInt(‘’));   // NaN<br>console.log(parseInt(‘070’));  // 70<br>console.log(parseInt(‘0xf’));  //15<br>console.log(parseInt(22.5));  // 22</p>
<p>我们还可以为<code>parseInt()</code>提供第二个参数，指定需要转换的进制（刷算法题的时候经常用到）：</p>
<p>console.log(parseInt(‘0xAF’,16));  // 175<br>console.log(parseInt(‘AF’,16));  // 175<br>console.log(parseInt(‘AF’));  // NaN<br>console.log(parseInt(‘070’,8));  // 56<br>console.log(parseInt(‘70’,8));  // 56</p>
<p><code>parseFloat()</code>和<code>parseInt()</code>类似，也是从第一个字符（位置0）开始解析每个字符，而且一直解析到字符串末尾，或者解析到遇到一个无效的浮点数字字符为止，换句话说，字符串中的第一个小数点是有效的，后面的小数点是无效的，它还会忽略前导的零，只会解析十进制值。</p>
<p>console.log(parseFloat(‘123tg’));  // 123<br>console.log(parseFloat(‘22.12.4’));   // 22.12<br>console.log(parseFloat(‘070’));  // 70<br>console.log(parseFloat(‘0xf’));  //0<br>console.log(parseFloat(22.5));  // 22.5</p>
<h1 id="19-Object类型"><a href="#19-Object类型" class="headerlink" title="19.Object类型"></a>19.Object类型</h1><p>在ECMAScript中，<code>Object</code>类型是所有对象的基础。 <code>Object</code>的每个实例都具有下列属性和方法：</p>
<ul>
<li><strong><code>Constructor</code></strong>：保存着用于创建当前对象的函数，比如上面的例子，构造函数就是Object()</li>
<li><strong><code>hasOwnProperty(propertyName)</code></strong>：用于检查给定的属性在当前对象实例中是否存在（而不是在实例的原型中），参数必须是字符串形式</li>
<li><strong><code>isPrototypeOf(object)</code></strong>：用于检查传入的对象是否是另一个对象的原型</li>
<li><strong><code>propertyIsEnumerable(propertyName)</code></strong>：用于检查给定的属性是否能够使用for-in语句来枚举，参数必须是字符串形式</li>
<li><strong><code>toLocaleString()</code></strong>：返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li><strong><code>toString()</code></strong>：返回对象的字符串表</li>
<li><strong><code>valueOf()</code></strong>：返回对象的字符串、数值或布尔值表示，通常和toString()返回的值相同</li>
</ul>
<h1 id="20-递增和递减"><a href="#20-递增和递减" class="headerlink" title="20.递增和递减"></a>20.递增和递减</h1><p>递减和递增操作符会遵循下列规则：</p>
<ul>
<li>当操作数是一个包含有效数字字符的字符串，系统会将其转换为数字值，再执行递减或递增。</li>
<li>当操作数是一个不包含有效数字字符的字符串，系统将变量的值设置为NaN</li>
<li>当操作数是布尔值，会将其转为数值（true转为1，false转为0）再操作。</li>
<li>当操作数是浮点数值，直接执行递减或递增</li>
<li>当操作数是对象，先调用对象的valueOf()方法取得一个可供操作的值，然后再遵循上面的三条规则。如果结果是NaN，则在调用toString()方法后再遵循上面的规则转换。</li>
</ul>
<p>var a = ‘2’;<br>var b = ‘a’;<br>var c = false;<br>var d = 1.1;<br>var o = {<br>  valueOf: function() {<br>    return -1;<br>  }<br>};<br>a++;  // 3<br>b++;  // NaN<br>c–;  // -1<br>d–;  // 0.10000000000000009 （浮点数操作结果，类似0.1+0.2 != 0.3）<br>o–;  -2</p>
<h1 id="21-按位非（NOT）"><a href="#21-按位非（NOT）" class="headerlink" title="21.按位非（NOT）"></a>21.按位非（NOT）</h1><p>位运算符并不直接操作64位的值，而是先将64位的值转换为32位，然后执行操作，最后将结果转换回64位。 按位非（否运算）就是<strong>一个数与自身的取反值相加，等于-1</strong>。</p>
<blockquote>
<p>~3 + 3 = -1 =&gt; -1 - 3 = -4 == ~3</p>
</blockquote>
<h1 id="22-位运算符"><a href="#22-位运算符" class="headerlink" title="22.位运算符"></a>22.位运算符</h1><p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。</p>
<h1 id="23-逻辑与（-amp-amp-）"><a href="#23-逻辑与（-amp-amp-）" class="headerlink" title="23.逻辑与（&amp;&amp;）"></a>23.逻辑与（&amp;&amp;）</h1><p>逻辑与（&amp;&amp;）有两个操作数，如果是布尔值，只有两个都是true时，才会返回true，否则返回false；逻辑与操作属于短路操作，也就是说如果第一个操作数能够决定结果（等于false时），就不会再对第二个操作数求值 如果不是布尔值，它遵循下面的规则：</p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值为true时才会返回第二个操作数</li>
<li>如果有一个操作数是null，则返回null</li>
<li>如果有一个操作数是NaN，则返回NaN</li>
<li>如果有一个操作数是undefined，则返回undefined</li>
</ul>
<p>逻辑与操作符也就是先将第一个操作数转换为Boolean类型判断是true或false，再根据结果决定是否执行第二个操作数</p>
<p>0 &amp;&amp; ‘tg’ ;  //  0<br>{} &amp;&amp; ‘tg’;  // “tg”</p>
<h1 id="24-乘法运算符"><a href="#24-乘法运算符" class="headerlink" title="24.乘法运算符"></a>24.乘法运算符</h1><p>乘法运算符(<code>*</code>)，用于计算两个数值的乘积。 处理特殊值时，乘法运算符会遵循下列规则：</p>
<ul>
<li>如果操作数都是数值，但乘积超过了ECMAScript数值范围，则返回Infinity或-Infinity</li>
<li>如果有一个操作数是NaN，结果是NaN</li>
<li>如果是Infinity乘以0，结果是NaN</li>
<li>如果是Infinity与非0数值相乘，结果是Infinity或-Infinity，取决于非0数值的符号</li>
<li>如果是Infinity与Infinity相乘，结果是Infinity</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后遵循上面的规则</li>
</ul>
<p>console.log(1 <em> NaN);  // NaN<br>console.log( Infinity </em> 2);  // Infinity<br>console.log(Infinity <em> 0);  // NaN<br>console.log(Infinity </em> Infinity);  // Infinity</p>
<h1 id="24-除法运算符"><a href="#24-除法运算符" class="headerlink" title="24.除法运算符"></a>24.除法运算符</h1><p>除法运算符（/），执行第二个操作数除第一个操作数计算。 处理特殊值，规则如下：</p>
<ul>
<li>如果操作数都是数值，但商超过了ECMAScript的表示范围，则返回Infinity或-Infinity</li>
<li>如果有一个操作数是NaN，结果是NaN</li>
<li>如果是Infinity被Infinity除，结果是NaN</li>
<li>如果是零被零除，结果是NaN</li>
<li>如果是非零的有限数被零除，结果是Infinity或-Infinity，取决于有符号的操作数</li>
<li>如果是Infinity被任何非零数值除，结果是Infinity或-Infinity</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后遵循上面的规则。</li>
</ul>
<p>console.log(NaN / 1); // NaN<br>console.log(0 / 0);  // NaN<br>console.log(1 / 0);  //  Infinity<br>console.log(2 / Infinity);  // 0<br>console.log(Infinity / Infinity);  // NaN<br>console.log(Infinity / 2);   // Infinity</p>
<h1 id="25-求模"><a href="#25-求模" class="headerlink" title="25.求模"></a>25.求模</h1><p>求模（余数）运算符（%） 处理特殊值，规则如下：</p>
<ul>
<li>如果被除数是无穷大值而除数是有限大的数值，结果是NaN</li>
<li>如果被除数是有限大的数值而除数是零，结果是NaN</li>
<li>如果是Infinity被Infinity除，结果是NaN</li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数</li>
<li>如果被除数是零，结果是零</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后遵循上面的规则。</li>
</ul>
<p>console.log(5 % 3);  // 2</p>
<h1 id="26-减法"><a href="#26-减法" class="headerlink" title="26.减法"></a>26.减法</h1><p>减法运算符（-） 对于特殊值，减法操作会遵循下列规则：</p>
<ul>
<li>如果有一个操作数是NaN，结果是NaN</li>
<li>如果Infinity减Infinity，结果是NaN</li>
<li>如果是-Infinity减-Infinity，结果是NaN</li>
<li>如果是Infinity减-Infinity，结果是Infinity</li>
<li>如果是-Infinity减Infinity，结果是-Infinity</li>
<li>如果是+0减+0，结果是+0</li>
<li>如果是-0加-0，结果是+0</li>
<li>如果是+0减-0，结果是-0</li>
<li>如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()将其转换为数值，然后遵循上面的规则进行计算。</li>
<li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值；如果该对象没有valueOf()方法，则调用其toString()方法将得到的字符串转换为数值，然后遵循上面的规则进行计算。</li>
</ul>
<p>5 - true;  // 4 （true转换成1）<br>5 - ‘2’    // 3<br>5 - null;  // 5（null转换成0）</p>
<h1 id="27-逗号运算符"><a href="#27-逗号运算符" class="headerlink" title="27.逗号运算符"></a>27.逗号运算符</h1><p>逗号运算符多用于声明多个变量。 逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项：</p>
<p>var num = (1,5,3);  // num的值为3</p>
<h1 id="28-标签语句"><a href="#28-标签语句" class="headerlink" title="28.标签语句"></a>28.标签语句</h1><p>语句是可以添加标签的，标签是由语句前的标识符和冒号组成：</p>
<blockquote>
<p><strong>label</strong> : statement</p>
</blockquote>
<p>label语句定义的标签一般由break或continue语句引用。加标签的语句一般要与for等循环语句配合使用。</p>
<p>var num = 0;<br>tip : for(var i = 0; i &lt; 10; i++){<br>  num += i;<br>  console.log(i);  //  轮流输出：0、1、2、3、4、5<br>  if(i ==5) {<br>    break tip;<br>  }<br>}<br>console.log(num);  // 15</p>
<p>当执行到i=5时，会跳出循环，也就是tip对应的层，然后执行其下方的代码。</p>
<h1 id="29-with语句"><a href="#29-with语句" class="headerlink" title="29.with语句"></a>29.with语句</h1><p><strong><code>with</code></strong>语句用于临时扩展作用域链，也就是将代码的作用域设置到一个特定的对象中。</p>
<p>with(object){<br>  statement<br>}</p>
<p>将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原生状态。</p>
<p>var o = {<br>  name: ‘tg’,<br>  age: 24<br>};<br>with(o){<br>  console.log(‘name：’ + name);  // name：tg<br>  console.log(‘age：’ + age);  // age：24<br>}</p>
<p>with里面的name相当于o.name。 <strong>注意</strong>：在严格模式中是禁止使用with语句的，因为with语句性能非常差，不推荐使用。</p>
<h1 id="30-debugger语句"><a href="#30-debugger语句" class="headerlink" title="30.debugger语句"></a>30.debugger语句</h1><p>debugger语句用来产生一个断点（breakpoint），JavaScript代码的执行会停止在断点的位置。一般用来调试代码。</p>
<h1 id="31-对象"><a href="#31-对象" class="headerlink" title="31.对象"></a>31.对象</h1><p><strong>键名</strong>：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。</p>
<p>var o = {<br>  ‘1a’ : ‘a’<br>}</p>
<p>上面的代码中，如果键名’1a’不用引号引起来，就会报错。 注意：为了避免这种歧义，JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。</p>
<h1 id="32-创建对象"><a href="#32-创建对象" class="headerlink" title="32.创建对象"></a>32.创建对象</h1><p>在JavaScript中，有三种方法创建对象</p>
<ul>
<li><strong>对象直接量</strong>： var o={};</li>
<li><strong>关键字new</strong>： var o=new Object();</li>
<li><strong>Object.create()函数</strong>： var o=Object.create(null)</li>
</ul>
<h2 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h2><p>如果对对象中的方法进行提取，则会失去与对象的连接。</p>
<p>var obj = {<br>  name: ‘a’,<br>  get: function() {<br>    console.log(this.name);<br>  }<br>};</p>
<p>console.log(obj.get());  //  “a”</p>
<p>var func = obj.get;<br>console.log(func());  // undefined</p>
<p>在上面的例子中，object对象中有一个方法get()，用来获取obj对象中的name，而当get()方法赋值给一个变量func，再调用func()函数时，此时的this是指向window的，而非obj的。 注意：如果在严格模式下，this会是undefined。</p>
<h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><ul>
<li>可写（writable attribute）：可设置该属性的值。</li>
<li>可枚举（enumerable attribute）：可通过for/in循环返回该属性。</li>
<li>可配置（configurable attribute）：可删除或修改属性。</li>
</ul>
<h2 id="查看所有属性"><a href="#查看所有属性" class="headerlink" title="查看所有属性"></a>查看所有属性</h2><p>查看一个对象本身的所有属性，可以使用Object.keys方法，返回一个数组。</p>
<p>var o = {<br>  name : ‘a’,<br>  age : 12<br>}</p>
<p>Object.keys(o)  //[‘name’,’age’]</p>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p>delete运算符可以删除对象的属性。</p>
<p>var o={<br>  name : ‘a’<br>}<br>delete o.name  //true<br>o.name  //undefined</p>
<p>注意：delete运算符只能删除自有属性，不能删除继承属性。 删除一个不存在的属性，delete不报错，而且返回true。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。</p>
<h1 id="33-序列化对象"><a href="#33-序列化对象" class="headerlink" title="33.序列化对象"></a>33.序列化对象</h1><p>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 在JavaScript中，提供了内置函数<strong>JSON.stringify()</strong>和<strong>JSON.parse()</strong>用来序列化和还原JavaScript对象。 NaN、Infinity和-Infinity序列化的结果是null</p>
<p>var o = {<br>  name : ‘a’,<br>  age : 12,<br>  intro : [false,null,’’]<br>}<br>s= JSON.stringify(o)  // s {“name”:”a”,”age”:12,”intro”:[false,null,””]}<br>p=JSON.parse(s)  // p是o的深拷贝</p>
<p>注意：JSON.stringify()只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。</p>
<h1 id="34-原型"><a href="#34-原型" class="headerlink" title="34.原型"></a>34.原型</h1><p>每一个JavaScript对象（null除外）都和另一个对象相关联，也可以说，继承另一个对象。另一个对象就是我们熟知的“原型”（prototype），每一个对象都从原型继承属性。只有null除外，它没有自己的原型对象。 所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过JavaScript代码Object.prototype获得对原型对象的引用。 通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。比如：通过new Object()创建的对象继承自Object.prototype；通过new Array()创建的对象的原型就是Array.prototype。 没有原型的对象为数不多，Object.prototype就是其中之一，它不继承任何属性。 所有的内置构造函数都具有一个继承自Object.prototype的原型。</p>
<h1 id="35-空位"><a href="#35-空位" class="headerlink" title="35.空位"></a>35.空位</h1><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在<strong>空位</strong>（hole）。 如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</p>
<p>var arr = [,,];<br>arr.length  //2</p>
<h1 id="36-类数组对象"><a href="#36-类数组对象" class="headerlink" title="36.类数组对象"></a>36.类数组对象</h1><p>在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。 <code>类数组对象</code>有一个特征，就是具有length属性。换句话说，只要有length属性，就可以认为这个对象类似于数组。但是，对象的length属性不是动态值，不会随着成员的变化而变化。 典型的类似数组的对象是函数的<strong>arguments对象</strong>，以及<strong>大多数DOM元素集</strong>，还有<strong>字符串</strong>。</p>
<h1 id="37-函数表达式"><a href="#37-函数表达式" class="headerlink" title="37.函数表达式"></a>37.函数表达式</h1><p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>
<p>var f = function(x){<br>  console.log(x);<br>}</p>
<h1 id="38-函数被提前"><a href="#38-函数被提前" class="headerlink" title="38.函数被提前"></a>38.函数被提前</h1><p>就像变量的“被提前”一样，函数声明语句也会“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。在函数提升中，函数体也会跟着提升（不像变量一样，只会提升变量声明），这也是我们可以引用后面声明的函数的原因。 此外，<strong>以表达式定义的函数并没有“被提前”，而是以变量的形式“被提前”</strong>。</p>
<p>f();<br>var f = function (){};<br>// TypeError: f is not a function</p>
<p>变量其实是分为声明，赋值两部分的，上面的代码等同于下面的形式</p>
<p>var f;<br>f();<br>f = function() {};</p>
<h1 id="39-实参对象"><a href="#39-实参对象" class="headerlink" title="39.实参对象"></a>39.实参对象</h1><p><code>arguments</code>类数组中每一个元素的值会与对应的命名参数的值保持同步，这种影响是单向的，也可以这样说，<strong>如果是修改<code>arguments</code>中的值，会影响到命名参数的值，但是修改命名参数的值，并不会改变<code>arguments</code>中对应的值</strong>。</p>
<p>function f(x){<br>  console.log(x);    // 1<br>  arguments[0]=null;<br>  console.log(x);    // null<br>}</p>
<p>f(1);</p>
<p><code>arguments</code>并不是真正的数组，它只是类数组对象（有length属性且可使用索引来访问子项）。但我们可以借助Array类的原型对象的slice方法，将其转为真正的数组：</p>
<p>Array.prototype.slice.call(arguments, 0);<br>//更简洁的写法<br>[].slice.call(arguments, 0);</p>
<h1 id="40-函数的属性、方法"><a href="#40-函数的属性、方法" class="headerlink" title="40.函数的属性、方法"></a>40.函数的属性、方法</h1><h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>name属性返回紧跟在function关键字之后的那个函数名。</p>
<p>function f(){}<br>f.name   //f</p>
<h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a><strong>length属性</strong></h2><p>函数的length属性是只读属性，代表函数形参的数量，也就是在函数定义时给出的形参个数。</p>
<p>function f(x,y){}<br>f.length  //2</p>
<h1 id="41-立即调用的函数表达式（IIFE）"><a href="#41-立即调用的函数表达式（IIFE）" class="headerlink" title="41.立即调用的函数表达式（IIFE）"></a>41.立即调用的函数表达式（IIFE）</h1><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：</p>
<ul>
<li>一是不必为函数命名，避免了污染全局变量；</li>
<li>二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li>
</ul>
<h1 id="42-Object对象的静态方法"><a href="#42-Object对象的静态方法" class="headerlink" title="42.Object对象的静态方法"></a>42.Object对象的静态方法</h1><p><code>Object.keys()</code>方法和<code>Object.getOwnPropertyNames()</code>方法一般用来遍历对象的属性，它们的参数都是一个对象，返回一个数组，该数组的项都是对象自身的（不是继续原型的）的所有属性名。两者的区别在于，<code>Object.keys()</code>只返回可枚举的属性，<code>Object.getOwnPropertyNames()</code>方法还返回不可枚举的属性名。</p>
<p>var arr = [‘a’, ‘b’];<br>console.log(Object.keys(arr));  // [“0”, “1”]<br>console.log(Object.getOwnPropertyNames(arr)); // [“0”, “1”, “length”]</p>
<h1 id="43-splice"><a href="#43-splice" class="headerlink" title="43.splice()"></a>43.splice()</h1><p><code>splice()</code>用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素，该方法会改变原数组。 第一个参数是删除的起始位置，如果是负数，就表示从倒数位置开始删除 第二个参数是被删除的元素个数。 如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如只是单纯地插入元素，splice方法的第二个参数可以设为0。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>
<p>var arr = [‘a’,’b’,’c’,’d’];<br>console.log(arr.splice(1,1));  // [“b”]<br>console.log(arr);  //  [“a”, “c”, “d”]</p>
<p>var arr = [‘a’,’b’,’c’,’d’];<br>console.log(arr.splice(1,1,’f’));   //  [“b”]<br>console.log(arr);  //  [“a”, “f”, “c”, “d”]</p>
<p>var arr = [‘a’,’b’,’c’,’d’];<br>console.log(arr.splice(1,0,’h’));  //  []<br>console.log(arr);  //  [“a”, “h”, “b”, “c”, “d”]</p>
<h1 id="44-some-、every"><a href="#44-some-、every" class="headerlink" title="44.some()、every()"></a>44.some()、every()</h1><p><code>some()</code>用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。</p>
<p>var arr = [1,2,3];<br>var bool = arr.some(function(v){<br>  return (v == 3);<br>});<br>console.log(bool);  // true</p>
<p><code>every()</code>用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。</p>
<p>var arr = [1,2,3];<br>var bool = arr.every(function(v){<br>  return (v == 3);<br>});<br>console.log(bool);  // false</p>
<p>var bool2 = arr.every(function(v){<br>  return (v &gt; 0);<br>});<br>console.log(bool2);  // true</p>
<p>some和every方法还可以接受第二个参数，用来绑定函数中的this关键字。</p>
<h1 id="45-基本包装类型"><a href="#45-基本包装类型" class="headerlink" title="45.基本包装类型"></a>45.基本包装类型</h1><p>ECMAScript提供了三个基本包装类型：<code>Boolean</code>、<code>Number</code>、<code>String</code>。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能过调用一些方法来操作这些数据。执行步骤如下：</p>
<ul>
<li>创建S提让那个类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例</li>
</ul>
<p>引用类型与基本包装类型的区别在于对象的生存期：使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁，这也是我们不能再运行时为基本类型值添加属性和方法的原因。</p>
<p>var s = ‘tg’;<br>s.age =10;<br>console.log(s.age);  // undefined</p>
<p>上面代码执行输出的是undefined，这是音乐第二行创建的String对象在执行第三行代码时已经被销毁了，第三行又创建自己的String对象，而该对象没有age属性。</p>
<h1 id="46-Boolean类型"><a href="#46-Boolean类型" class="headerlink" title="46.Boolean类型"></a>46.Boolean类型</h1><p>即使你使用false创建一个Boolean实例对象，当进行逻辑运算时，它会被转为true，因为它是一个对象，而所有对象在逻辑运算中都会返回true。</p>
<p>var bool = new Boolean(false);<br>if(bool){<br>  console.log(true);<br>}</p>
<p>// true</p>
<h1 id="47-document-referrer"><a href="#47-document-referrer" class="headerlink" title="47.document.referrer"></a>47.document.referrer</h1><p>document.referrer属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。 注：HTTPS默认会关闭referrer，需要通过meta来设置，设置方法如下：</p>
<meta name="referrer" content="always">

<h1 id="48-数据集（dataset）属性"><a href="#48-数据集（dataset）属性" class="headerlink" title="48.数据集（dataset）属性"></a>48.数据集（dataset）属性</h1><p>在HTML5文档中，任意以“data-”为前缀的小写的属性名字都是合法的。 HTML5还在Element对象上定义了dataset属性。该属性指代一个对象，它的各个属性对应于去掉前缀的data-属性。因此dataset.x应该保存data-x属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test属性就变成dataset.jqueryTest属性。</p>
<div id="top" data-tip="title"></div>

<p>var t=document.getElementById(‘top’);<br>t.dataset.tip  //title<br>t.dataset.tip = ‘title2’</p>
<p>注意：dataset属性是元素的data-属性的实时、双向接口。设置或删除dataset的一个属性就等同于设置或移除对应元素的data-属性。</p>
<h1 id="49-addEventListener"><a href="#49-addEventListener" class="headerlink" title="49.addEventListener()"></a>49.addEventListener()</h1><p>调用addEventListener()并不会影响onclick属性的值。</p>
<button id="mybutton">点击</button>

<p>var v = document.getElementById(‘mybutton’);<br>v.onclick = function() {alert(‘1’);}<br>v.addEventListener(‘click’,function(){alert(‘2’);},false);</p>
<p>上面的代码中，单击按钮会产生两个alert()对话框。 能通过多次调用addEventListener()方法为同一个对象注册同一事件类型的多个处理程序函数。</p>
<h1 id="50-调用顺序"><a href="#50-调用顺序" class="headerlink" title="50.调用顺序"></a>50.调用顺序</h1><p>文档元素或其他对象可以指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照下面的规则调用所有的事件处理程序：</p>
<ul>
<li>通过设置对象属性或HTML属性注册的处理程序一直优先调用。</li>
<li>使用addEventListener()注册的处理程序按照它们的注册顺序调用。</li>
<li>使用attachEvent()注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。</li>
</ul>
<h1 id="51-进度事件"><a href="#51-进度事件" class="headerlink" title="51.进度事件"></a>51.进度事件</h1><p>进度事件用来描述一个事件进展的过程。比如XMLHttpRequest对象发出的HTTP请求的过程、<code>&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;</code>加载外部资源的过程。下载和上传都会发生进度事件。 进度事件有以下几种：</p>
<ul>
<li>abort事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。</li>
<li>error事件：由于错误导致资源无法加载时触发。</li>
<li>load事件：进度成功结束时触发。</li>
<li>loadstart事件：进度开始时触发。</li>
<li>loadend事件：进度停止时触发，发生顺序排在error事件\abort事件\load事件后面。</li>
<li>progress事件：当操作处于进度之中，由传输的数据块不断触发。</li>
<li>timeout事件：进度超过限时触发。</li>
</ul>
<h1 id="52-JSON语法"><a href="#52-JSON语法" class="headerlink" title="52.JSON语法"></a>52.JSON语法</h1><p>JSON对值的类型和格式有严格的规定：</p>
<ul>
<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li>
<li>简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。</li>
<li>字符串必须使用双引号表示，不能使用单引号。</li>
<li>对象的键名必须放在双引号里面。</li>
<li>数组或对象最后一个成员的后面，不能加逗号。</li>
</ul>
<h1 id="53-上传文件"><a href="#53-上传文件" class="headerlink" title="53.上传文件"></a>53.上传文件</h1><p>如果要允许选择多个文件，可设置file控件的multiple属性。</p>
<input type="file" multiple>

<h1 id="54-同源策略"><a href="#54-同源策略" class="headerlink" title="54.同源策略"></a>54.同源策略</h1><p>同源策略是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。当Web页面使用多个<code>&lt;iframe&gt;</code>元素或打开其他浏览器窗口的时候，这一策略通常就会发挥作用。 所谓“同源”指的是”三个相同“。</p>
<ul>
<li><strong>协议</strong>相同</li>
<li><strong>域名</strong>相同</li>
<li><strong>端口</strong>相同</li>
</ul>
<p>从不同Web服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用http:协议载入的文档和使用https:协议载入的文档具有不同的来源，即使它们来自同一个服务器。 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h1 id="55-获取表单元素"><a href="#55-获取表单元素" class="headerlink" title="55.获取表单元素"></a>55.获取表单元素</h1><p>获取表单元素一般有两种方式：</p>
<ul>
<li>通过id来获取，比如获取一个id名为form1的表单元素：</li>
</ul>
<p>document.getElementById(‘form1’);</p>
<ul>
<li>通过docuemnt.forms获取name名为form1的表单元素：</li>
</ul>
<p>document.forms[“form1”]</p>
<p><code>document.forms</code>可以获取到当前页面中所有的表单元素，我们又可以通过方括号表示法获取某个属性，传入数值索引或<code>name</code>值。</p>
<h1 id="56-重置表单"><a href="#56-重置表单" class="headerlink" title="56.重置表单"></a>56.重置表单</h1><p>重置表单也有两种方式：</p>
<ul>
<li>重置按钮</li>
</ul>
<input type="reset">

<button type="reset"></button>

<p>当点击重置按钮时，会触发reset事件：</p>
<p>form1.onreset = function(){<br>}</p>
<ul>
<li>通过reset()方法</li>
</ul>
<p>form1.reset();</p>
<p>与调用submit()不同，调用reset()方法时也会触发reset事件。</p>
<h1 id="57-离线检测"><a href="#57-离线检测" class="headerlink" title="57.离线检测"></a>57.离线检测</h1><p>HTML5定义了一个<code>navigator.onLine</code>属性，用来检测设备是在线还是离线，为true时表示设备能上网，否则表示设备离线。 检测代码：</p>
<p>if (navigator.onLine){<br>  // 正常工作<br>} else {<br>  // 设备已离线<br>}</p>
<p>除了<code>navigator.onLine</code>属性，HTML5还为检测网络是否可用提供了两个事件：<code>online</code>和<code>offline</code>。</p>
<ul>
<li><code>online</code>：当网络从离线变为在线时触发</li>
<li><code>offline</code>：当网络从在线变为离线时触发</li>
</ul>
<h1 id="58-应用缓存"><a href="#58-应用缓存" class="headerlink" title="58.应用缓存"></a>58.应用缓存</h1><p>HTML5的应用缓存（application cache），简称：appcache，是专门为开发离线Web应用而设计的。 Appcache就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。 <code>manifest</code> 文件可分为三个部分：</p>
<ul>
<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>
<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>
<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>
</ul>
<p>CACHE MANIFEST</p>
<p>CACHE:<br># 需要缓存的列表<br>test.css<br>test.jpg<br>test.js</p>
<p>NETWORK:<br># 不需要缓存的<br>test2.jpg</p>
<p>FALLBACK:<br># 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件*.html /offline.html<br>2.jpg/3.jpg</p>
<p>注意：manifest文件的<code>MIME</code>类型必须是”text/cache-manifest”。</p>
<blockquote>
<p>描述文件的扩展名以前推荐用manifest，现在推荐用appcache</p>
</blockquote>
<h1 id="59-localStorage和sessionStorage"><a href="#59-localStorage和sessionStorage" class="headerlink" title="59.localStorage和sessionStorage"></a>59.<strong>localStorage和sessionStorage</strong></h1><p><code>localStorage</code>和<code>sessionStorage</code>这两个属性都代表同一个Storage对象（一个持久化关联数组，数组使用字符串来索引，存储的值都是字符串形式的）。</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a><strong>localStorage</strong></h2><p>通过<code>localStorage</code>存储的数据是永久性的，除非Web应用刻意删除存储的数据或用户通过设置浏览器设置来删除，否则数据将一直保留在用户的电脑里，永不过期。 <code>localStorage</code>的作用域是限定在文档源（document origin）级别。 同源的文档间共享同样的<code>localStorage</code>数据。</p>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a><strong>sessionStorage</strong></h2><p><code>sessionStorage</code>的作用域同样是限定在文档源中，不过它被限定在窗口中。也就是说，如果同源的文档在不同的浏览器标签页中，那它们互相之间拥有的是各自的<code>sessionStorage</code>数据，无法共享。 注意：基于窗口作用域的<code>sessionStorage</code>指的窗口只是顶级窗口。如果一个浏览器标签页包含多个<code>&lt;iframe&gt;</code>元素，它们包含的文档是同源的，两者之间的sessionStorage是可共享的。</p>
<h1 id="60-finally子句"><a href="#60-finally子句" class="headerlink" title="60.finally子句"></a>60.finally子句</h1><p>当使用<code>finally</code>子句时，其代码无论如何都会执行，也就是说，不管是正常执行还是出错了，<code>finally</code>子句都会执行。甚至<code>return</code>语句，也不会阻止<code>finally</code>子句的执行。看下面的例子：</p>
<p>function test(){<br>  try{<br>    console.log(‘a’);<br>    return 2;<br>  }catch(error){<br>    console.log(‘b’);<br>  }finally{<br>    console.log(‘c’);<br>  }<br>}<br>console.log(test());<br>//结果<br>a<br>c<br>2</p>
<p>从运行结果，我们可以看到，<code>return</code>语句并没有阻止<code>finally</code>子句的执行，而且是在<code>finally</code>子句执行后才会返回<code>return</code>语句的值。</p>
</h1>
    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="/images/hexo_others_5.png"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="/images/hexo_others_6.png"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="//merrier.wang" target="_blank">Merrier说</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/20170501/understanding-and-application-of-JS-width-and-height.html" class="pre-post btn btn-default" title="JS宽高的理解和应用">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">JS宽高的理解和应用</span>
        </a>
    
    
        <a href="/20170425/passing-value-and-address-in-js.html" class="next-post btn btn-default" title="JS中的传值与传址">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">JS中的传值与传址</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
  <script id="dsq-count-scr" src="https://merrier.disqus.com/count.js" async></script>


<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

<script type="text/javascript">
  if (document.getElementById('disqus_thread')) {
    var disqus_config = function () {
      this.page.url = 'http://merrier.wang/20170425/javaScript-semi-knowledgeable-and-semi-knowledgeable.html';
      this.page.identifier = '20170425/javaScript-semi-knowledgeable-and-semi-knowledgeable.html';
      this.page.title = '读书笔记系列（7）——JavaScript半知半解';
    };
    (function(){
      var d = document,
          s = d.createElement('script');
      s.async = true;
      s.src = 'https://merrier.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
</script>




    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#写在前面"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-完整的JavaScript"><span class="toc-text">1.完整的JavaScript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-元素"><span class="toc-text">2.元素&lt;/h1&gt;&lt;p&gt;向HTML页面中插入JavaScript的主要方法，就是使用&lt;script&gt;元素。 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;中定义了下列6个属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;async&lt;/code&gt;&lt;/strong&gt;：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/strong&gt;：可选，表示通过src属性指定的代码的字符集，比较少用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/strong&gt;：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;language&lt;/code&gt;&lt;/strong&gt;：已废弃&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;src&lt;/code&gt;&lt;/strong&gt;：可选，表示包含要执行代码的外部文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;type&lt;/code&gt;&lt;/strong&gt;：可选，表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。在HTML5中，默认是text/javascript，所以不需要设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.在使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;嵌入JavaScript代码时，切记不要在代码中的任何地方出现&lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;。执行下面的代码时，会产生一个错误：&lt;/p&gt;
&lt;p&gt;“ &amp;gt;&lt;script&gt;&lt;br&gt;function loadScript(){&lt;br&gt;  alert(‘‘);}
4.JavaScript代码的执行顺序只要不存在defer和async属性，JavaScript代码就会从上至下依次解析。 带有src属性的元素不应该在其&lt;script&gt;和标签之间再包含额外的JavaScript代码，嵌入代码会被忽略。 只要不存在defer和async属性，浏览器都会按照&lt;script&gt;出现的先后顺序对它们依次进行解析。 一般将全部JavaScript引用放在元素中页面的内容后面。
5.延迟脚本当给元素添加了&lt;code&gt;defer&lt;/code&gt;属性时，src指向的外部文件会立即下载，但包含的脚本会延迟到浏览器遇到&lt;code&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;标签（整个页面解析完毕）后再执行（按添加顺序执行），会先于DOMContentLoaded事件执行。&lt;/p&gt;
&lt;script defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;


会先执行example.js，然后执行example2.js 注意：defer只适合外部脚本文件。
6.异步脚本async与defer属性类似，都用于改变处理脚本的行为，适用于外部脚本文件，并告诉浏览器立即下载，但标记为async的脚本并不保证按照指定它们的先后顺序执行。



两个执行顺序不定。 指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。 注意：异步脚本不要在加载期间修改DOM。 异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。
7.元素当浏览器不支持JavaScript或被禁用时，显示里面的内容。
元素” &gt; 本页面需要浏览器支持（启用）JavaScript
8.关键字和保留字ECMA-262描述了一组具有特定用途的关键字，这些关键字可用于控制语句的开始或结束，或者用于执行特定操作等，不能用作标识符。

break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try

ECMA-262还描述了一组不能用作标识符的保留字：

abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public

如果使用关键字作标识符，会导致“Identifier Expected”错误。 有些时候，我们不得不用到保留字货关键字的，比如CSS样式中的float，这时就需要这样：
style.cssFloat
9.隐式全局变量在下面的代码中，由于从右至左的操作符优先级，所以表达式“b=0”是先执行的，而此时b未经过声明，所以它会成为全局变量。
function test() {  var a = b = 0;}test();console.log(b);  // 0console.log(a);  // ReferenceError: a is not defined
关于全局变量：

使用var创建的全局变量不能删除。
不是var创建的隐含全局变量可以使用delete删除（因为它并不是真正的变量，而是全局对象window的属性）

function test() {  var a = b = 0;  delete a;  delete b;  console.log(a);  //  0  console.log(b);  // ReferenceError: b is not defined}test();
10.变量提升变量提升是指所有变量的声明语句，都会被提升到代码的头部。 在函数内也一样，函数中的所有变量声明会在函数执行时被“提升”至函数体顶端：
console.log(a);  // undefinedvar a = 1;function test(){  console.log(a);  // undefined  var a = 2;}test();
结果是不是有点出乎你的意料。其实JavaScript的执行环境分为声明阶段和执行阶段，因此对于上面的代码，JavaScript会这样解释代码：
var a;console.log(a);  // undefineda = 1;function test(){  var a;  console.log(a);  // undefined  a = 2;}test();
11.typeof操作符typeof操作符用来检测给定变量的数据类型，可能的返回值：

“undefined”–&gt;这个值未定义
“boolean”–&gt;这个值是布尔值
“string”–&gt;这个值是字符串
“number”–&gt;这个值是数值
“object”–&gt;这个值是对象或null
“function”–&gt;这个值是函数

12.undefined和null类型Undefined类型只有一个值，即特殊的undefined；`Null类型也是只有一个值的数据类型，这个特殊值就是null；null和undefined没有属性，甚至连toString()这种标准方法都没有undefined其实是派生自null`值：
console.log(null == undefined);  // true
13.Boolean()要将一个值转换为其对应的Boolean值，可以使用转型函数Boolean():
var name = ‘tg’;console.log(Boolean(name);  // true
可以对任何类型的值调用Boolean函数，而且总会返回一个Boolean值（true或false） 转换规则：

对于true或false，返回原值（true或false）
对于String类型的值，任何非空字符串返回true，空字符串（””）返回false
对于Number类型的值，任何非零数字值（包括无穷大），返回true；0和NaN返回false
对于Object类型的值，任何对象返回true，null返回false
对于Undefined类型，undefined返回false（只有一个值）

14.浮点数值保存浮点数值需要的内存空间是保存整数值的两倍。 默认情况下，ECMAScript会将那些小数点后面带有6个零以上的浮点数值转换为以e表示的数值。 浮点数的最高精度是17位小数（所以浮点数的比较比较麻烦）。
0.1 + 0.2 = 0.3000000000000004; // 不是等于0.3
15.数值范围ECMAScript能够表示的最小数值保存在Number.MIN_VALUE（最小值）中，这个值是5e-324；能够表示的最大数值保存在Number.MAX_VALUE（最大值）中，这个值是1.7976931348623157e+308 注意：Infinity是不能参与计算的数值。 用isFinite()来判断这个值是否无穷，该函数接受一个参数。如果参数位于最小与最大数值之间，返回true。
console.log(isFinite(1));  //trueconsole.log(isFinite(Infinity));  // false
16.NaNNaN（Not a Number）表示非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 注意点：

任何涉及NaN的操作都会返回NaN。
NaN与任何值都不相等，包括NaN本身。
任何操作数与NaN比较，都会返回false

console.log(NaN == NaN);  //false
我们可以用isNaN()函数来判断是否非数值，该函数接受一个参数，可以是任何类型。isNaN()在接收到这个参数之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，比如：字符串”10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。
console.log(isNaN(NaN));  // trueconsole.log(isNaN(10));  // falseconsole.log(isNaN(‘blue’));  //  true
17.Number()Number()函数的转换规则：

如果是Boolean值，true和false将分别转换为1和0
如果是数字值，只是简单的传入和返回
如果是null值，返回0
如果是undefined，返回NaN
如果是字符串，遵循下列规则： （
如果是字符串中只包含数字（包括前面带正负号），则将其转换为十进制数值（前导的零会被忽略）
如果字符串中包含有效的浮点格式，如1.1，则将其转换为对应的浮点数值
如果字符串中包含有效的十六进制，如0xf，则将其转换为相同大小的十进制数值
如果字符串是空的，返回0
如果字符串中包含上述格式以外的字符，返回NaN ）


如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回字符串值

console.log(Number(‘tg’));   // NaNconsole.log(Number(‘’));   // 0console.log(Number(‘0011’));  // 11console.log(Number(true));   //1
一元加操作符的操作与Number函数规则相同
18.parseInt()和parseFloat()parseInt()会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回NaN。如果第一个字符是数字字符，就会继续解析，直到解析完所有后续字符或者遇到了一个非数字字符。 parseInt()也能识别八进制（在ECMAScript 5中无法识别，将开头的0当作0）和十六进制，最后会转换成十进制。
console.log(parseInt(‘123tg’));  // 123console.log(parseInt(‘’));   // NaNconsole.log(parseInt(‘070’));  // 70console.log(parseInt(‘0xf’));  //15console.log(parseInt(22.5));  // 22
我们还可以为parseInt()提供第二个参数，指定需要转换的进制（刷算法题的时候经常用到）：
console.log(parseInt(‘0xAF’,16));  // 175console.log(parseInt(‘AF’,16));  // 175console.log(parseInt(‘AF’));  // NaNconsole.log(parseInt(‘070’,8));  // 56console.log(parseInt(‘70’,8));  // 56
parseFloat()和parseInt()类似，也是从第一个字符（位置0）开始解析每个字符，而且一直解析到字符串末尾，或者解析到遇到一个无效的浮点数字字符为止，换句话说，字符串中的第一个小数点是有效的，后面的小数点是无效的，它还会忽略前导的零，只会解析十进制值。
console.log(parseFloat(‘123tg’));  // 123console.log(parseFloat(‘22.12.4’));   // 22.12console.log(parseFloat(‘070’));  // 70console.log(parseFloat(‘0xf’));  //0console.log(parseFloat(22.5));  // 22.5
19.Object类型在ECMAScript中，Object类型是所有对象的基础。 Object的每个实例都具有下列属性和方法：

Constructor：保存着用于创建当前对象的函数，比如上面的例子，构造函数就是Object()
hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在（而不是在实例的原型中），参数必须是字符串形式
isPrototypeOf(object)：用于检查传入的对象是否是另一个对象的原型
propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举，参数必须是字符串形式
toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应
toString()：返回对象的字符串表
valueOf()：返回对象的字符串、数值或布尔值表示，通常和toString()返回的值相同

20.递增和递减递减和递增操作符会遵循下列规则：

当操作数是一个包含有效数字字符的字符串，系统会将其转换为数字值，再执行递减或递增。
当操作数是一个不包含有效数字字符的字符串，系统将变量的值设置为NaN
当操作数是布尔值，会将其转为数值（true转为1，false转为0）再操作。
当操作数是浮点数值，直接执行递减或递增
当操作数是对象，先调用对象的valueOf()方法取得一个可供操作的值，然后再遵循上面的三条规则。如果结果是NaN，则在调用toString()方法后再遵循上面的规则转换。

var a = ‘2’;var b = ‘a’;var c = false;var d = 1.1;var o = {  valueOf: function() {    return -1;  }};a++;  // 3b++;  // NaNc–;  // -1d–;  // 0.10000000000000009 （浮点数操作结果，类似0.1+0.2 != 0.3）o–;  -2
21.按位非（NOT）位运算符并不直接操作64位的值，而是先将64位的值转换为32位，然后执行操作，最后将结果转换回64位。 按位非（否运算）就是一个数与自身的取反值相加，等于-1。

~3 + 3 = -1 =&gt; -1 - 3 = -4 == ~3

22.位运算符位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。
23.逻辑与（&amp;&amp;）逻辑与（&amp;&amp;）有两个操作数，如果是布尔值，只有两个都是true时，才会返回true，否则返回false；逻辑与操作属于短路操作，也就是说如果第一个操作数能够决定结果（等于false时），就不会再对第二个操作数求值 如果不是布尔值，它遵循下面的规则：

如果第一个操作数是对象，则返回第二个操作数
如果第二个操作数是对象，则只有在第一个操作数的求值为true时才会返回第二个操作数
如果有一个操作数是null，则返回null
如果有一个操作数是NaN，则返回NaN
如果有一个操作数是undefined，则返回undefined

逻辑与操作符也就是先将第一个操作数转换为Boolean类型判断是true或false，再根据结果决定是否执行第二个操作数
0 &amp;&amp; ‘tg’ ;  //  0{} &amp;&amp; ‘tg’;  // “tg”
24.乘法运算符乘法运算符(*)，用于计算两个数值的乘积。 处理特殊值时，乘法运算符会遵循下列规则：

如果操作数都是数值，但乘积超过了ECMAScript数值范围，则返回Infinity或-Infinity
如果有一个操作数是NaN，结果是NaN
如果是Infinity乘以0，结果是NaN
如果是Infinity与非0数值相乘，结果是Infinity或-Infinity，取决于非0数值的符号
如果是Infinity与Infinity相乘，结果是Infinity
如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后遵循上面的规则

console.log(1  NaN);  // NaNconsole.log( Infinity  2);  // Infinityconsole.log(Infinity  0);  // NaNconsole.log(Infinity  Infinity);  // Infinity
24.除法运算符除法运算符（/），执行第二个操作数除第一个操作数计算。 处理特殊值，规则如下：

如果操作数都是数值，但商超过了ECMAScript的表示范围，则返回Infinity或-Infinity
如果有一个操作数是NaN，结果是NaN
如果是Infinity被Infinity除，结果是NaN
如果是零被零除，结果是NaN
如果是非零的有限数被零除，结果是Infinity或-Infinity，取决于有符号的操作数
如果是Infinity被任何非零数值除，结果是Infinity或-Infinity
如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后遵循上面的规则。

console.log(NaN / 1); // NaNconsole.log(0 / 0);  // NaNconsole.log(1 / 0);  //  Infinityconsole.log(2 / Infinity);  // 0console.log(Infinity / Infinity);  // NaNconsole.log(Infinity / 2);   // Infinity
25.求模求模（余数）运算符（%） 处理特殊值，规则如下：

如果被除数是无穷大值而除数是有限大的数值，结果是NaN
如果被除数是有限大的数值而除数是零，结果是NaN
如果是Infinity被Infinity除，结果是NaN
如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数
如果被除数是零，结果是零
如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后遵循上面的规则。

console.log(5 % 3);  // 2
26.减法减法运算符（-） 对于特殊值，减法操作会遵循下列规则：

如果有一个操作数是NaN，结果是NaN
如果Infinity减Infinity，结果是NaN
如果是-Infinity减-Infinity，结果是NaN
如果是Infinity减-Infinity，结果是Infinity
如果是-Infinity减Infinity，结果是-Infinity
如果是+0减+0，结果是+0
如果是-0加-0，结果是+0
如果是+0减-0，结果是-0
如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()将其转换为数值，然后遵循上面的规则进行计算。
如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值；如果该对象没有valueOf()方法，则调用其toString()方法将得到的字符串转换为数值，然后遵循上面的规则进行计算。

5 - true;  // 4 （true转换成1）5 - ‘2’    // 35 - null;  // 5（null转换成0）
27.逗号运算符逗号运算符多用于声明多个变量。 逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项：
var num = (1,5,3);  // num的值为3
28.标签语句语句是可以添加标签的，标签是由语句前的标识符和冒号组成：

label : statement

label语句定义的标签一般由break或continue语句引用。加标签的语句一般要与for等循环语句配合使用。
var num = 0;tip : for(var i = 0; i &lt; 10; i++){  num += i;  console.log(i);  //  轮流输出：0、1、2、3、4、5  if(i ==5) {    break tip;  }}console.log(num);  // 15
当执行到i=5时，会跳出循环，也就是tip对应的层，然后执行其下方的代码。
29.with语句with语句用于临时扩展作用域链，也就是将代码的作用域设置到一个特定的对象中。
with(object){  statement}
将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原生状态。
var o = {  name: ‘tg’,  age: 24};with(o){  console.log(‘name：’ + name);  // name：tg  console.log(‘age：’ + age);  // age：24}
with里面的name相当于o.name。 注意：在严格模式中是禁止使用with语句的，因为with语句性能非常差，不推荐使用。
30.debugger语句debugger语句用来产生一个断点（breakpoint），JavaScript代码的执行会停止在断点的位置。一般用来调试代码。
31.对象键名：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。
var o = {  ‘1a’ : ‘a’}
上面的代码中，如果键名’1a’不用引号引起来，就会报错。 注意：为了避免这种歧义，JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。
32.创建对象在JavaScript中，有三种方法创建对象

对象直接量： var o={};
关键字new： var o=new Object();
Object.create()函数： var o=Object.create(null)

提取方法如果对对象中的方法进行提取，则会失去与对象的连接。
var obj = {  name: ‘a’,  get: function() {    console.log(this.name);  }};
console.log(obj.get());  //  “a”
var func = obj.get;console.log(func());  // undefined
在上面的例子中，object对象中有一个方法get()，用来获取obj对象中的name，而当get()方法赋值给一个变量func，再调用func()函数时，此时的this是指向window的，而非obj的。 注意：如果在严格模式下，this会是undefined。
属性特性
可写（writable attribute）：可设置该属性的值。
可枚举（enumerable attribute）：可通过for/in循环返回该属性。
可配置（configurable attribute）：可删除或修改属性。

查看所有属性查看一个对象本身的所有属性，可以使用Object.keys方法，返回一个数组。
var o = {  name : ‘a’,  age : 12}
Object.keys(o)  //[‘name’,’age’]
删除属性delete运算符可以删除对象的属性。
var o={  name : ‘a’}delete o.name  //trueo.name  //undefined
注意：delete运算符只能删除自有属性，不能删除继承属性。 删除一个不存在的属性，delete不报错，而且返回true。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。
33.序列化对象对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 在JavaScript中，提供了内置函数JSON.stringify()和JSON.parse()用来序列化和还原JavaScript对象。 NaN、Infinity和-Infinity序列化的结果是null
var o = {  name : ‘a’,  age : 12,  intro : [false,null,’’]}s= JSON.stringify(o)  // s {“name”:”a”,”age”:12,”intro”:[false,null,””]}p=JSON.parse(s)  // p是o的深拷贝
注意：JSON.stringify()只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。
34.原型每一个JavaScript对象（null除外）都和另一个对象相关联，也可以说，继承另一个对象。另一个对象就是我们熟知的“原型”（prototype），每一个对象都从原型继承属性。只有null除外，它没有自己的原型对象。 所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过JavaScript代码Object.prototype获得对原型对象的引用。 通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。比如：通过new Object()创建的对象继承自Object.prototype；通过new Array()创建的对象的原型就是Array.prototype。 没有原型的对象为数不多，Object.prototype就是其中之一，它不继承任何属性。 所有的内置构造函数都具有一个继承自Object.prototype的原型。
35.空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。
var arr = [,,];arr.length  //2
36.类数组对象在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。 类数组对象有一个特征，就是具有length属性。换句话说，只要有length属性，就可以认为这个对象类似于数组。但是，对象的length属性不是动态值，不会随着成员的变化而变化。 典型的类似数组的对象是函数的arguments对象，以及大多数DOM元素集，还有字符串。
37.函数表达式采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。
var f = function(x){  console.log(x);}
38.函数被提前就像变量的“被提前”一样，函数声明语句也会“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。在函数提升中，函数体也会跟着提升（不像变量一样，只会提升变量声明），这也是我们可以引用后面声明的函数的原因。 此外，以表达式定义的函数并没有“被提前”，而是以变量的形式“被提前”。
f();var f = function (){};// TypeError: f is not a function
变量其实是分为声明，赋值两部分的，上面的代码等同于下面的形式
var f;f();f = function() {};
39.实参对象arguments类数组中每一个元素的值会与对应的命名参数的值保持同步，这种影响是单向的，也可以这样说，如果是修改arguments中的值，会影响到命名参数的值，但是修改命名参数的值，并不会改变arguments中对应的值。
function f(x){  console.log(x);    // 1  arguments[0]=null;  console.log(x);    // null}
f(1);
arguments并不是真正的数组，它只是类数组对象（有length属性且可使用索引来访问子项）。但我们可以借助Array类的原型对象的slice方法，将其转为真正的数组：
Array.prototype.slice.call(arguments, 0);//更简洁的写法[].slice.call(arguments, 0);
40.函数的属性、方法name属性name属性返回紧跟在function关键字之后的那个函数名。
function f(){}f.name   //f
length属性函数的length属性是只读属性，代表函数形参的数量，也就是在函数定义时给出的形参个数。
function f(x,y){}f.length  //2
41.立即调用的函数表达式（IIFE）通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：

一是不必为函数命名，避免了污染全局变量；
二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

42.Object对象的静态方法Object.keys()方法和Object.getOwnPropertyNames()方法一般用来遍历对象的属性，它们的参数都是一个对象，返回一个数组，该数组的项都是对象自身的（不是继续原型的）的所有属性名。两者的区别在于，Object.keys()只返回可枚举的属性，Object.getOwnPropertyNames()方法还返回不可枚举的属性名。
var arr = [‘a’, ‘b’];console.log(Object.keys(arr));  // [“0”, “1”]console.log(Object.getOwnPropertyNames(arr)); // [“0”, “1”, “length”]
43.splice()splice()用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素，该方法会改变原数组。 第一个参数是删除的起始位置，如果是负数，就表示从倒数位置开始删除 第二个参数是被删除的元素个数。 如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如只是单纯地插入元素，splice方法的第二个参数可以设为0。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。
var arr = [‘a’,’b’,’c’,’d’];console.log(arr.splice(1,1));  // [“b”]console.log(arr);  //  [“a”, “c”, “d”]
var arr = [‘a’,’b’,’c’,’d’];console.log(arr.splice(1,1,’f’));   //  [“b”]console.log(arr);  //  [“a”, “f”, “c”, “d”]
var arr = [‘a’,’b’,’c’,’d’];console.log(arr.splice(1,0,’h’));  //  []console.log(arr);  //  [“a”, “h”, “b”, “c”, “d”]
44.some()、every()some()用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。
var arr = [1,2,3];var bool = arr.some(function(v){  return (v == 3);});console.log(bool);  // true
every()用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。
var arr = [1,2,3];var bool = arr.every(function(v){  return (v == 3);});console.log(bool);  // false
var bool2 = arr.every(function(v){  return (v &gt; 0);});console.log(bool2);  // true
some和every方法还可以接受第二个参数，用来绑定函数中的this关键字。
45.基本包装类型ECMAScript提供了三个基本包装类型：Boolean、Number、String。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能过调用一些方法来操作这些数据。执行步骤如下：

创建S提让那个类型的一个实例
在实例上调用指定的方法
销毁这个实例

引用类型与基本包装类型的区别在于对象的生存期：使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁，这也是我们不能再运行时为基本类型值添加属性和方法的原因。
var s = ‘tg’;s.age =10;console.log(s.age);  // undefined
上面代码执行输出的是undefined，这是音乐第二行创建的String对象在执行第三行代码时已经被销毁了，第三行又创建自己的String对象，而该对象没有age属性。
46.Boolean类型即使你使用false创建一个Boolean实例对象，当进行逻辑运算时，它会被转为true，因为它是一个对象，而所有对象在逻辑运算中都会返回true。
var bool = new Boolean(false);if(bool){  console.log(true);}
// true
47.document.referrerdocument.referrer属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。 注：HTTPS默认会关闭referrer，需要通过meta来设置，设置方法如下：


48.数据集（dataset）属性在HTML5文档中，任意以“data-”为前缀的小写的属性名字都是合法的。 HTML5还在Element对象上定义了dataset属性。该属性指代一个对象，它的各个属性对应于去掉前缀的data-属性。因此dataset.x应该保存data-x属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test属性就变成dataset.jqueryTest属性。


var t=document.getElementById(‘top’);t.dataset.tip  //titlet.dataset.tip = ‘title2’
注意：dataset属性是元素的data-属性的实时、双向接口。设置或删除dataset的一个属性就等同于设置或移除对应元素的data-属性。
49.addEventListener()调用addEventListener()并不会影响onclick属性的值。
点击

var v = document.getElementById(‘mybutton’);v.onclick = function() {alert(‘1’);}v.addEventListener(‘click’,function(){alert(‘2’);},false);
上面的代码中，单击按钮会产生两个alert()对话框。 能通过多次调用addEventListener()方法为同一个对象注册同一事件类型的多个处理程序函数。
50.调用顺序文档元素或其他对象可以指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照下面的规则调用所有的事件处理程序：

通过设置对象属性或HTML属性注册的处理程序一直优先调用。
使用addEventListener()注册的处理程序按照它们的注册顺序调用。
使用attachEvent()注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。

51.进度事件进度事件用来描述一个事件进展的过程。比如XMLHttpRequest对象发出的HTTP请求的过程、&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;加载外部资源的过程。下载和上传都会发生进度事件。 进度事件有以下几种：

abort事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。
error事件：由于错误导致资源无法加载时触发。
load事件：进度成功结束时触发。
loadstart事件：进度开始时触发。
loadend事件：进度停止时触发，发生顺序排在error事件\abort事件\load事件后面。
progress事件：当操作处于进度之中，由传输的数据块不断触发。
timeout事件：进度超过限时触发。

52.JSON语法JSON对值的类型和格式有严格的规定：

复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。
简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。
字符串必须使用双引号表示，不能使用单引号。
对象的键名必须放在双引号里面。
数组或对象最后一个成员的后面，不能加逗号。

53.上传文件如果要允许选择多个文件，可设置file控件的multiple属性。


54.同源策略同源策略是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。当Web页面使用多个&lt;iframe&gt;元素或打开其他浏览器窗口的时候，这一策略通常就会发挥作用。 所谓“同源”指的是”三个相同“。

协议相同
域名相同
端口相同

从不同Web服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用http:协议载入的文档和使用https:协议载入的文档具有不同的来源，即使它们来自同一个服务器。 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。
55.获取表单元素获取表单元素一般有两种方式：

通过id来获取，比如获取一个id名为form1的表单元素：

document.getElementById(‘form1’);

通过docuemnt.forms获取name名为form1的表单元素：

document.forms[“form1”]
document.forms可以获取到当前页面中所有的表单元素，我们又可以通过方括号表示法获取某个属性，传入数值索引或name值。
56.重置表单重置表单也有两种方式：

重置按钮





当点击重置按钮时，会触发reset事件：
form1.onreset = function(){}

通过reset()方法

form1.reset();
与调用submit()不同，调用reset()方法时也会触发reset事件。
57.离线检测HTML5定义了一个navigator.onLine属性，用来检测设备是在线还是离线，为true时表示设备能上网，否则表示设备离线。 检测代码：
if (navigator.onLine){  // 正常工作} else {  // 设备已离线}
除了navigator.onLine属性，HTML5还为检测网络是否可用提供了两个事件：online和offline。

online：当网络从离线变为在线时触发
offline：当网络从在线变为离线时触发

58.应用缓存HTML5的应用缓存（application cache），简称：appcache，是专门为开发离线Web应用而设计的。 Appcache就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。 manifest 文件可分为三个部分：

CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）

CACHE MANIFEST
CACHE:# 需要缓存的列表test.csstest.jpgtest.js
NETWORK:# 不需要缓存的test2.jpg
FALLBACK:# 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件*.html /offline.html2.jpg/3.jpg
注意：manifest文件的MIME类型必须是”text/cache-manifest”。

描述文件的扩展名以前推荐用manifest，现在推荐用appcache

59.localStorage和sessionStoragelocalStorage和sessionStorage这两个属性都代表同一个Storage对象（一个持久化关联数组，数组使用字符串来索引，存储的值都是字符串形式的）。
localStorage通过localStorage存储的数据是永久性的，除非Web应用刻意删除存储的数据或用户通过设置浏览器设置来删除，否则数据将一直保留在用户的电脑里，永不过期。 localStorage的作用域是限定在文档源（document origin）级别。 同源的文档间共享同样的localStorage数据。
sessionStoragesessionStorage的作用域同样是限定在文档源中，不过它被限定在窗口中。也就是说，如果同源的文档在不同的浏览器标签页中，那它们互相之间拥有的是各自的sessionStorage数据，无法共享。 注意：基于窗口作用域的sessionStorage指的窗口只是顶级窗口。如果一个浏览器标签页包含多个&lt;iframe&gt;元素，它们包含的文档是同源的，两者之间的sessionStorage是可共享的。
60.finally子句当使用finally子句时，其代码无论如何都会执行，也就是说，不管是正常执行还是出错了，finally子句都会执行。甚至return语句，也不会阻止finally子句的执行。看下面的例子：
function test(){  try{    console.log(‘a’);    return 2;  }catch(error){    console.log(‘b’);  }finally{    console.log(‘c’);  }}console.log(test());//结果ac2
从运行结果，我们可以看到，return语句并没有阻止finally子句的执行，而且是在finally子句执行后才会返回return语句的值。
</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-JavaScript代码的执行顺序"><span class="toc-text">4.JavaScript代码的执行顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-延迟脚本"><span class="toc-text">5.延迟脚本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-异步脚本"><span class="toc-text">6.异步脚本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-元素"><span class="toc-text">7.元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-关键字和保留字"><span class="toc-text">8.关键字和保留字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-隐式全局变量"><span class="toc-text">9.隐式全局变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-变量提升"><span class="toc-text">10.变量提升</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-typeof操作符"><span class="toc-text">11.typeof操作符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-undefined和null类型"><span class="toc-text">12.undefined和null类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Boolean"><span class="toc-text">13.Boolean()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-浮点数值"><span class="toc-text">14.浮点数值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-数值范围"><span class="toc-text">15.数值范围</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-NaN"><span class="toc-text">16.NaN</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-Number"><span class="toc-text">17.Number()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-parseInt-和parseFloat"><span class="toc-text">18.parseInt()和parseFloat()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-Object类型"><span class="toc-text">19.Object类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-递增和递减"><span class="toc-text">20.递增和递减</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-按位非（NOT）"><span class="toc-text">21.按位非（NOT）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-位运算符"><span class="toc-text">22.位运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-逻辑与（-amp-amp-）"><span class="toc-text">23.逻辑与（&amp;&amp;）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-乘法运算符"><span class="toc-text">24.乘法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-除法运算符"><span class="toc-text">24.除法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-求模"><span class="toc-text">25.求模</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-减法"><span class="toc-text">26.减法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-逗号运算符"><span class="toc-text">27.逗号运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-标签语句"><span class="toc-text">28.标签语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-with语句"><span class="toc-text">29.with语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-debugger语句"><span class="toc-text">30.debugger语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-对象"><span class="toc-text">31.对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-创建对象"><span class="toc-text">32.创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#提取方法"><span class="toc-text">提取方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性特性"><span class="toc-text">属性特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查看所有属性"><span class="toc-text">查看所有属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除属性"><span class="toc-text">删除属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-序列化对象"><span class="toc-text">33.序列化对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-原型"><span class="toc-text">34.原型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-空位"><span class="toc-text">35.空位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-类数组对象"><span class="toc-text">36.类数组对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37-函数表达式"><span class="toc-text">37.函数表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-函数被提前"><span class="toc-text">38.函数被提前</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-实参对象"><span class="toc-text">39.实参对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-函数的属性、方法"><span class="toc-text">40.函数的属性、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#name属性"><span class="toc-text">name属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#length属性"><span class="toc-text">length属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-立即调用的函数表达式（IIFE）"><span class="toc-text">41.立即调用的函数表达式（IIFE）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-Object对象的静态方法"><span class="toc-text">42.Object对象的静态方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-splice"><span class="toc-text">43.splice()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-some-、every"><span class="toc-text">44.some()、every()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-基本包装类型"><span class="toc-text">45.基本包装类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-Boolean类型"><span class="toc-text">46.Boolean类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-document-referrer"><span class="toc-text">47.document.referrer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-数据集（dataset）属性"><span class="toc-text">48.数据集（dataset）属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49-addEventListener"><span class="toc-text">49.addEventListener()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50-调用顺序"><span class="toc-text">50.调用顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51-进度事件"><span class="toc-text">51.进度事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#52-JSON语法"><span class="toc-text">52.JSON语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-上传文件"><span class="toc-text">53.上传文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54-同源策略"><span class="toc-text">54.同源策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-获取表单元素"><span class="toc-text">55.获取表单元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56-重置表单"><span class="toc-text">56.重置表单</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-离线检测"><span class="toc-text">57.离线检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-应用缓存"><span class="toc-text">58.应用缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59-localStorage和sessionStorage"><span class="toc-text">59.localStorage和sessionStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#localStorage"><span class="toc-text">localStorage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sessionStorage"><span class="toc-text">sessionStorage</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#60-finally子句"><span class="toc-text">60.finally子句</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2018
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




    <script src="/assets/tagcanvas.min.js?rev=2.9"></script>
    <script>
        var tagOption = {
            textColour: '#444', // 字体颜色
            outlineMethod: 'block', // 选中模式
            outlineColour: '#FFDAB9', // 选中模式的颜色
            interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
            textHeight: 13,
            outlineRadius: 3,
            freezeActive: true || '', // 选中的标签是否继续滚动
            frontSelect: true || '', // 不选标签云后部的标签
            initial: [0.1, -0.1],
            depth: 0.5,
            decel: 0.95,
            maxSpeed: 0.03,
            reverse: true || '', // 是否反向触发
            fadeIn: 500, // 进入动画时间
            wheelZoom: true || '' // 是否启用鼠标滚轮
        }
        TagCanvas.Start('tag-cloud-3d','',tagOption);
    </script>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>