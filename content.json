{"meta":{"title":"Merrier说","subtitle":"叩首问路，码梦为生","description":"Merrier的个人博客","author":"Merrier","url":"http://merrier.wang"},"pages":[],"posts":[{"title":"再见，2018","slug":"再见，2018","date":"2019-01-01T08:46:28.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20190101/goodbye-2018.html","link":"","permalink":"http://merrier.wang/20190101/goodbye-2018.html","excerpt":"","text":"不知不觉，又一年过去了，而当时写再见，2017时的情形还历历在目；不得不感叹，人真是越老越快啊！ 2018这一年对于我来说是成长的一年，首先在工作上，逐渐适应了公司的工作节奏，对业务也开始逐渐熟悉，和小伙伴们打成了一团；在生活中，第一次租房虽然说有一些小插曲，但是最终还是安定了下来……下面就用一句话们总结一下我的2018吧： 第一次租房，不算被坑，小有经验 第一次做饭，西红柿炒蛋，闭着眼吃完 买了心心念念的机械键盘，喜欢上打字的感觉很爽 和女票过了1000天纪念，希望第10000天的时候还能不忘初心 注册了个公司，老爸起的名字 建了一个小学同学微信群，很难想象这么多年了还能联系上 见证了antd团队因为圣诞彩蛋事件而“收获”最低年终奖 见证了ofo和锤子的没落，互联网的寒冬真的来了 今年最常说的一句话：成年人的生活里没有容易二字 2019很多朋友都在朋友圈晒自己立的Flag，有的充满激情（工资翻番）、有的踌躇满志（去三十多个国家）、有的令人心酸（不脱发）、有的不敢苟同（穿一次女装），而我的新年愿望是自己和认识的人都能平安健康，收获属于自己的幸福，不以物喜，不以己悲。 最后祝大家 2018一笔“狗”销，2019“猪”事顺利！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://merrier.wang/categories/杂谈/"}],"tags":[{"name":"生活","slug":"life","permalink":"http://merrier.wang/tags/life/"}]},{"title":"铲屎官，这里有一份属于你的空投","slug":"铲屎官，这里有一份属于你的空投","date":"2018-09-22T04:30:47.000Z","updated":"2019-01-17T13:21:55.962Z","comments":true,"path":"20180922/cat-strategy.html","link":"","permalink":"http://merrier.wang/20180922/cat-strategy.html","excerpt":"","text":"这篇文章对养猫的一些注意事项进行了介绍，同时推荐了一些淘宝物件，那些想养猫或者已经养猫的爱心人士不要错过了~ 关于领养可以去豆瓣加入“北京宠物领养小组” 猫粮猫粮的选择尤其重要，因为影响着猫的健康以及毛色，同时不同的猫粮含有不同的营养，而幼猫和成猫需要的营养有所不同，所以在猫粮的选择上一定要做足功课。关于猫粮，公众号【斜对面的老阳】做过比较详细的评测，具体可以查看这篇推送：2018海外猫粮榜：天下美食尽为朕所有！，我总结一下就是以下几点： 国产的猫粮相比进口猫粮会差一些 渴望是很贵的品牌，但是在评测结果中也是最好的，不过幼猫吃可能营养过剩；另外爱肯拿也不错，不过购买渠道比较窄 如果不是很喜欢昂贵的品牌（没钱），可以考虑百利这个品牌，性价比很高 Go性价比也很高，要买就买九种肉，紫色包装的那一款 一定要选择天然猫粮，其他推荐的品牌：凌采EVO、伊诺凡、素力高、Lorde 一些比较详细的猫粮介绍： 皇家，国产猫粮，不算便宜，适合1-4月龄的猫咪，不过对质量的质疑不少，略油，泪痕较重，还有点黑下巴。 NOW幼猫粮，小猫吃完毛发会变得很顺滑，不过价格过高，性价比一般。 希尔斯幼猫粮，适合12个月以下幼猫，富含牛磺酸，小猫会很喜欢吃，吃了一阵子后也是毛发很油滑，推荐！ 一些贴吧会有猫粮的团购，还是很实惠的，下面就是爱猫生活吧中的某网友总结的2018年上半年吧内猫粮团购均价表： 而公众号【斜对面的老阳】在送检了32个品牌共51款猫粮之后，精心准备了一份“智能换粮攻略”：【猫粮攻略】这些进口粮月开销超低！你竟然还不知道？ ，关于猫粮购买店铺，下面是一些同事以及周围养猫的朋友推荐的店铺，淘宝搜索店铺名即可： 【疯狂桔子家】 【紫色宠物】 【土猫宠物家】 【大兴宠物】 其实除了猫粮以外，自制的一些食物也是很不错的：鸡胸肉或牛肉煮熟，而生牛肉需要冷冻两天后融化后喂食，并且在两个小时内吃完。 零食和人一样，猫每天光吃正餐肯定是不够的，因为营养不均衡，所以零食也是必不可少的，而猫的零食有很多种，我还没有看到过一个比较靠谱的评测，就推荐一下我家猫很爱吃的几种吧，仅供参考： 路斯饼干 珍致罐头 羊奶布丁 羊奶粉，有both、谷登、卫仕、麦德氏、贝克等牌子 罐头除了珍致这个牌子以外，还有一些其他推荐的品牌：卡尼、wellness、雪诗雅。饼干和罐头我家猫都很爱吃，不过每只猫的口味都不一样，建议先少买一些试吃一下，如果猫喜欢吃的话再多买一些。不过猫零食虽然好吃，但是最好让猫少吃，每周奖励1-2次就行。 一些推荐的店铺： 【宅猫酱】，他家有很多吃的，用的，都挺靠谱的，猫粮也可以在他家买 【五汪一喵的家】，他家有很多玩具，还有一些小零食。 保健品保健品不同于药品，偶尔吃一下起到避免生病作用。 now品牌鱼油/卵磷脂是美毛的，也可以尝试微量鸡蛋黄 益生菌可以调节肠道，不时补充一下 化毛膏要偶尔吃，因为里面含有诱食剂；营养膏每周三次；红狗、骏宝这两个牌子不错（骏宝确实是目前最好的化毛膏和营养膏品牌，但是奸商太黑，导致价格下不来，所以很多人买红狗了，油质是差了点但是便宜，可以结合猫草） 维生素B用来补充维生素和治疗猫癣，可以每天半片，推荐品牌：卫仕 高免因子胶囊，用来增加抵抗力 发育宝，促进发育和提高免疫力，对肠胃也有保护作用 乳铁蛋白，增强免疫力，有鼻支爱打喷嚏的吃了会有好转 推荐店铺：【淘宝小折】 药品家里可以常备一些 如果猫咪腹泻拉肚子，可以去药房买妈咪爱或者思密达（没错，就是这个名字），妈咪爱是调节肠道菌群的作用，思密达是把干的作用 如果感冒打喷嚏，可以适当的买阿莫西林克拉维酸钾（有宠物专用的），这就是速诺的主要成份。正确剂量是15mg/kg，不要养成滥用的习惯，因为抗生素对肠道菌的摧残是很严重的。猫氨可以预防感冒，当有迹象的时候可以吃一点。 日常清理耳道建议耳肤灵 莫匹罗星软膏可以有效地对付黑下巴、马尾病，就是太浓稠，剃掉毛涂药才比较有效果 家中常备眼药水（左氧氟沙星眼药水与氯霉素眼药水），不过猫咪有眼屎是正常现象，不要担心。 猫癣的话，除了上面介绍的维生素B，艾贝尔和癣力宁是专门治疗猫癣的药品。爱猫生活吧有一篇帖子介绍了猫癣的具体治疗措施：《出个有用的贴，主要针对治疗猫藓，主子有猫藓的可以进来看看》 推荐店铺：【想要变成猫】，他家客服是兽医，一些小毛病还可以问问他。 猫砂猫砂好不好，主要看能不能遮臭。。而Lorde猫砂是不错的选择，不过有些猫咪可能对该品牌的猫砂不感冒，所以当你发现它不在猫砂盆里面进行某些活动的话，就赶紧换猫砂吧~一些其他品牌的猫砂推荐： TOMCAR绿茶豆腐猫砂，易铲屎 Drymax洁克，几乎没有尘土 小佩，巧克力味的超好闻 小猫在 3-4 周就要开始学习使用猫砂盆排泄：把沾有它屎的纸巾扔在猫砂盒里让它闻，并且用手拨弄它的小爪子，让它学会埋沙子的动作，慢慢就学会自己上厕所了。 玩具猫对玩具的喜爱超乎你的想象 逗猫棒，这是猫基本上永远不会腻的玩具，不过最好多准备几个 激光笔，你懂得 各种会响的球类，猫咪很喜欢圆的和会响的东西 转盘三层，每一层里面都有球，这个我也给我家猫买了，它很喜欢，就是晚上的时候要记得把它收起来，否则后果很严重！ 玩具最好 半个月/一个月 就买一个新的，因为猫咪喜新厌旧。猫咪比较警惕，所以玩具买回来后它可能不会玩，但是等它熟悉了以后就会去玩了。 用品 猫爬架占地方比较大，而且其实很多猫对它都不感兴趣，性价比不是很高 猫抓板用来给猫磨爪子，有靠墙立式的，有车子式的，有碗式的，还有月牙式的。不过猫抓板不管长什么样，其实好坏差别不大，有一个就行 猫吊床，猫是一种充满好奇心的生物，所以会经常望着窗外发呆，而猫吊床可以粘在玻璃上，这样让猫可以很舒服的望着窗外，也可以在上面睡觉。 猫碗，最好有个小饭桌，这样可以保护猫的颈椎 水碗，有条件的可以买专用饮水机，淘宝上的小佩饮水机很不错，价格也不是很贵；猫用水一定要纯净水，矿物质水容易结石。 猫砂盆，最好用全封闭的，因为遮臭效果好。 最好养成定期刷牙的习惯，建议维克牙膏 消毒的话推荐杜邦卫克 肢体语言猫的尾巴的秘密： 猫的尾巴是向下耷拉着，还不断的顫抖，这代表着猫咪处于一种惊慌害怕的状态。 猫的尾巴直直地竖起，甚至可以看到它的小菊花，代表它很开心見到你，是心情非常好的标志！ 猫的尾巴放在地上，尾尖時不时抖动，代表它現在有些沮丧，这个时候尽量不要去打扰到它。 猫的尾巴微微回勾，有点像小问好，就表示，赶紧让我们成为朋友吧，我很喜欢你~ 猫的尾巴自然放松和身体几乎齐平，一般这种情況在猫走路的进行中，这表示它对于眼前的事物非常感兴趣。 猫的尾巴竖起并大幅度颤抖表示它現在即将发怒，离炸毛只有一步之遥。 猫的尾巴缓慢悠长地甩在体侧，代表它现在感受到了爱意，不论对象是人还是异性猫。 猫的尾巴夹在两腿之间，表示猫咪現在比较紧张和担忧。 猫的尾巴大幅度抖动，猫的背拱起，这是属于猫最暴怒的状态，惹恼它到这一步就要赶紧躲远些… 一些文章 知乎：《一篇文章，弄明白猫与狂犬病》 CandyStory猫舍：《请在接猫前一周做好接猫准备》 其他 给猫洗澡的话三两个月一次，开始的时候最好去靠谱的宠物医院去，洗完一定要吹干，因为猫咪身体湿的话很容易得猫癣；不建议去宠物店，容易传染其他疾病，寄养也是如此。 驱虫，体内每三个月一次（拜耳、巴迪U-800、巴迪D-800），体外每月一次（大宠爱、福来恩、爱沃克），最好是轮换着品牌，因为每个品牌的药品驱不同种类的虫。 猫的胆子很小，所以不要打它，容易记仇，而且长期下去的话以后容易对陌生人乱抓。 猫咪禁区喷雾，可以防止猫乱尿，猫发情期之前可以买一瓶 柳屋生发液，让秀发浓密的同时还有柑橘味、风油精、薄荷味，可以预防猫靠近和抓头发","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://merrier.wang/categories/杂谈/"}],"tags":[{"name":"指南","slug":"指南","permalink":"http://merrier.wang/tags/指南/"},{"name":"心得","slug":"心得","permalink":"http://merrier.wang/tags/心得/"},{"name":"生活","slug":"life","permalink":"http://merrier.wang/tags/life/"},{"name":"猫","slug":"猫","permalink":"http://merrier.wang/tags/猫/"}]},{"title":"简单聊一下服务端渲染","slug":"简单聊一下服务端渲染","date":"2018-09-18T08:07:53.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20180918/server-side-render.html","link":"","permalink":"http://merrier.wang/20180918/server-side-render.html","excerpt":"","text":"写在前面Server Slide Rendering 服务端渲染,又简写为 SSR，他一般被用在我们的 SPA（Single-Page Application） 中，即单页应用。 为什么要用SSR？首先我们需要知道 SSR 对于 SPA 的好处，优势是什么。 更好的 SEO（Search Engine Optimization），SEO 是搜索引擎优化，简而言之就是针对百度这些搜索引擎，可以让他们搜索到我们的应用。这里可能会有误区，就是我也可以在 index.html 上写 SEO ，为什么会不起作用。因为 React、Vue 的原理是客户端渲染，通过浏览器去加载 js、css，有一个时间上的延迟，而搜索引擎不会管你的延迟，他就觉得你如果没加载出来就是没有的，所以是搜不到的。 解决一开始的白屏渲染，上面讲了 React 的渲染原理，而SSR服务端渲染是通过服务端请求数据，因为服务端内网的请求快，性能好所以会更快的加载所有的文件，最后把下载渲染后的页面返回给客户端。 服务端渲染VS客户端渲染客户端渲染路线： 请求一个 html 服务端返回一个 html 浏览器下载 html 里面的 js/css 文件 等待 js 文件下载完成 等待 js 加载并初始化完成 js 代码终于可以运行，由js代码向后端请求数据( ajax/fetch ) 等待后端数据返回 react-dom ( 客户端 )从无到完整地，把数据渲染为响应页面 服务端渲染路线： 请求一个 html 服务端请求数据( 内网请求快 ) 服务器初始渲染（服务端性能好，较快） 服务端返回已经有正确内容的页面 客户端请求 js/css 文件 等待 js 文件下载完成 等待 js 加载并初始化完成 react-dom ( 客户端 )把剩下一部分渲染完成( 内容小，渲染快 ) 从上面两者的渲染路线可以看到，其主要区别就在于，客户端从无到有的渲染，服务端是先在服务端渲染一部分，在再客户端渲染一小部分。 参考文章React服务端渲染+pm2自动化部署","categories":[{"name":"前端","slug":"frontend","permalink":"http://merrier.wang/categories/frontend/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"},{"name":"渲染","slug":"渲染","permalink":"http://merrier.wang/tags/渲染/"}]},{"title":"部落冲突COC游戏攻略","slug":"部落冲突COC游戏攻略","date":"2018-05-30T09:30:57.000Z","updated":"2019-01-17T13:21:55.962Z","comments":true,"path":"20180530/coc-walkthrough.html","link":"","permalink":"http://merrier.wang/20180530/coc-walkthrough.html","excerpt":"","text":"写在前面《部落冲突》是一个战争策略类游戏，简称为 “COC” ，最重要的是这是一款极其良心的游戏，如果说让我投票一款不用花钱又好玩的游戏，那我肯定投给它（王者荣耀没有铭文也不太好玩），可能很多人已经玩过这款游戏了，如果屏幕前的你没有玩过，建议去《部落冲突》官网领略一下这款游戏的魅力。而我入这款游戏的坑比较晚，经舍友介绍才开始玩的，中间因为专注于学术而弃坑了一段时间，不过玩的时间还算比较久的，下面就整理一下玩这款游戏过程中所领悟的心得，先来一发目前基地截图： 大本营自从更新新版本之后，就多了一个新的基地——建筑大师基地，所以现在这款游戏是有两个基地的，而两个基地之间除了宝石是互通的以外，其他毫无关联，所以我将分别介绍这两个基地的玩法与攻略，首先就先说一下大本营： 关于升本大本营的等级很重要，它决定了你的防御以及资源建筑的等级上限，而我的建议是前5本之前随便升，你可以选择速本，也可以选择防御或资源建筑升满的时候再升本，因为这个阶段还属于挨打阶段，很难说靠打别人走向发家致富的道路；而在5本以后（包括5本），一定要升满防御和资源建筑以后再升本，换句话说就是在升本之前要保证除了墙以外的其他所有建筑都升到最高级，这样有两个好处： 在部落战的时候可以占据很大的优势； 可以很好的骗到别人，因为很多人都不太会看防御建筑的等级，所以盲目的进行攻打，而如果你的防御建筑是最高级的话，这样就可以保住自己的基地或资源。 关于布局还是那个观点，5本之前随便摆，但是5本之后就有很大的讲究了，一个好的布局是第一重要的，因为这个游戏拼的就是策略，如果你的布局足够好，就算你的资源比较多，别人也会望而却步的。每个本位都有相应的布局，具体的可以参照4399部落冲突神阵大全，基本上主要思路就是保主基地和你的资源，比如从开头我的主基地截图就可以看到一些端倪。 关于部落部落可以理解为一个公会或一个势力，首先加入部落的前提条件就是要先建好部落堡垒，这个就不用多说了；然后，部落最好是找一个比较活跃等级比较高的，这样福利会比较好，反正部落是越早加入越好，可以请求增援，也可以给别人捐兵加经验升级。这里推荐一下我所在的部落（IOS），直接搜索一下 “BigWorldBigBang”，或者在手机上点击此链接直接就可以加入了。 关于部落战加入部落的目的之一就是打部落战了，部落战除了可以给部落加经验之外，对于个人而言最大的好处就是可以达成成就与获得资源了，所以部落战如果有时间打的话一定要报名参加，其实也用不了多长时间，而部落战的话每个本位都有不同的打法，网上有很多攻略，自己搜一下就可以了，这里就不再赘述了。 关于资源资源是这个游戏最关键的点，所有建筑的升级都需要资源，而资源从何而来呢？这里需要明确一点的就是：资源是靠打的，仅靠自己的建筑生产的那点资源是肯定不够的，这也成为了一些人弃坑的原因，但是不可否认的是，这种策略类游戏不就是让你去攻打别人的吗？而每个本位中的每个布局都有不同的打法，涉及到摆放的位置以及技能和法术释放的时机的，这是这个游戏的魅力所在，充满着无限的可能性，而具体怎么打就不可言喻了，需要从实战中获得经验（举个例子，我现在9本，基本上用大皮卡+法师+治疗法术是可以打任何布局的）。不过，在攻打前一定要看一下对方的防御建筑以及可以掠夺的资源，再衡量一下自己所用兵力所需要的资源，不能打完发现还亏了。 关于杯数杯数是一个核定你现在实力的标准，而你去攻打别人的时候，匹配到的敌人一定会是和你杯数差不多的人，当然打你的人也是一样，所以这个游戏要想玩的好，杯数保持是有讲究的：总体而言就是根据你当前大本营的本位来保持，5本控制在700左右，6本800，7本900-1000，8本1100-1500，9本1500-1800，控制在这个范围是最佳的。 建筑大师基地建筑大师基地是后来出的新玩法，具体什么时间忘了，不过自从出了建筑大师基地以后，之前的大本营/村庄在游戏里就被称之为家乡了，其实两者主要的玩法是差不多的，只不过一个是白天，一个是黑夜，所以建筑大师基地有时也被称为夜世界。首先介绍一下这个基地和大本营不同的地方，因为是新出的模式，所以可能朋友可能不知道，还是有必要说一下的： 训练部队不需要消耗圣水，需要的只是时间 你只会匹配到在线的玩家，你进攻他的同时，他也会进攻你的基地，这里和大本营正好互反，大本营是不会匹配到在线的玩家的 技艺高超的首领会平衡基地的进攻能力和防守能力。因此，在升级部队提升进攻实力的同时，别忘了建筑大师基地的阵型和防御建筑也需要不断的优化和升级 关于进攻在这个基地中，进攻的策略比大本营更为重要，因为最终的胜负是按照两方进攻所得星数来判断的，下面讲一些注意事项和小技巧： 搜到对手后、有一分钟的时间思考人生、不要操之过急、仔细观察阵型再配兵打战。 看见缺口一定有陷阱、所以不要一股脑全把兵放下去了，时间是很充足的，可以先下几个兵试探一下 不到最后一秒千万不要放弃，你以为自己打的星数比较少，没准对面更少或者直接掉线了！ 关于防守防守是与进攻并重的，所以这里说几点比较重要的： 内置大本营，这是基本要素，因为最终判定输赢的时候是按照星数来判定的，也就是说如果你打了49%摧毁率0颗星，对面打了10&amp;摧毁率1颗星，也是算对面赢的，所以一定不要让对面轻轻松松就打掉大本营 撼地巨石守入口，如果地方用近战部队进攻，那么撼地巨石一定会教他们做人的。 防空建筑内置， 防空是个很重要的建筑，一定要放在里面 特斯拉电磁塔和多管迫击炮要紧邻巨石，这两个是这个游戏攻击最高和攻速最快的建筑，守着撼地巨石是避免敌方用远程隐秘弓箭手进攻，毕竟撼地巨石的攻击距离不忍直视 陷阱放在没有巨石的另外一边， 没人是傻子，看见陷阱还往里面闯？那么我们防御薄弱的另一侧就需要陷阱来协助防守了 关于建筑建筑的升级也有一些讲究： 搜对手做任务的时候不要让防御和陷阱处在升级状态，这期间可以升级资源建筑之类的，防御类的建筑放在不打任务时升级最好 时光机器不一定非要等到打任务时用，一般是有了加速就点，单纯为了压缩所有时间 关于本位建筑大师基地目前满本是8本，所以基本上到5本就已经可以算后期了。对于本位，首先根据指引到达2本，2本不要停留太久，造完升本需要的建筑就直接速升到三本。到三本之后一定要先升兵营，升到可以造小亡灵，在三本这个本位，小亡灵打法基本上无敌：先放一个兵营的胖子挡住箭塔，之后小亡灵直接踏平。 注意：小亡灵不要升到很高的级别，主要升级胖子弓箭手和野蛮人 到了三本后期有两个基本的流派，以6级的弓箭手和6级野蛮人为核心。先从野蛮人说起，6级的野蛮人一个兵营可以造10个，30个野蛮人很无敌，挑那些撼地巨石外置的阵型，先放1-2个让他砸一下，然后趁着他还在缓冲的时候，直接下去一半秒掉锤子，最后分散再下一波清边，负责踩炸弹和蹭百分比 再来说说弓箭手，5级及以下的弓箭手最好是下在一起，以高攻击争取爆本，而六级弓箭手就可以无脑绕圈放，基本都是50%以上，赢得几率很大 升到四本后基本还是这两个流派，就不赘述了，三本其实还是可以速本的，但是杯一定要上去，保持在1600左右发育，生完四本速度出钟楼，然后把钟楼升满，这样发育会快很多 就这样一直发育，等满防满科技再生五本，把小龙升满，小龙分开绕圈放加上战争机器简直无敌 通用这里讲一下大本营和建筑大师基地的一些通用的攻略： 关于宝石很多新手不知道宝石有什么用，以为和金水一样可以随便用，那我告诉你可大错特错了，宝石是这个游戏里最重要也是最宝贵的资源，其相当于现实世界中的人民币（你说有用不？），这里我的建议是所有的宝石都用来购买建筑工人，先把主基地中的5个建筑工人买齐，这样可以加快建筑的升级速度，而买齐之后就可以用来加速了，毕竟如果你不是人民币玩家的话，就需要拿时间来玩了，时间就是金钱啊！","categories":[{"name":"游戏","slug":"游戏","permalink":"http://merrier.wang/categories/游戏/"}],"tags":[{"name":"COC","slug":"COC","permalink":"http://merrier.wang/tags/COC/"}]},{"title":"Apache配置二级域名及SSL证书","slug":"Apache配置二级域名及SSL证书","date":"2018-04-24T10:13:56.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20180424/apache-configuration-of-ssl-certificate.html","link":"","permalink":"http://merrier.wang/20180424/apache-configuration-of-ssl-certificate.html","excerpt":"","text":"写在前面前一段日子，我费了九牛二虎之力将 “Merrier说” 博客升级成了HTTPS，虽然回过头来看，其实申请SSL证书以及配置都是现成的轮子，别人已经为我们写好了脚本，不过对于第一次接触服务器相关的童鞋来说，确实会遇到很多麻烦，如果你也有这个需求，可以参考我的另一篇文章——网站配置HTTPS踩坑记，不过这几天我又配置了一个二级域名（api.merrier.wang），用作爬虫输出的 REST API 所用。 Apache配置首先，我们既然要配置二级域名，那肯定要更改服务器的配置了，这里我以Apache为例，介绍一下如何配置二级域名： 服务器的配置文件以 .conf 为后缀，首先找到 apache 配置文件（httpd.conf）所在位置： 1find / -name httpd.conf 假如 httpd.conf 所在路径为 /etc/httpd/conf/httpd.conf ，在 httpd.conf 中加入这样一句代码： 1Include /etc/httpd/conf/extra/*.conf 其含义是将 /etc/httpd/conf/extra/ 路径下的所有以 .conf 为后缀的文件都作为 apache 的配置文件进行引入，这样我们就可以将除了 httpd.conf 之外的其他配置文件都放到 extra 文件夹下，便于管理。接着配置一下 NameVirtualHost，将配置文件中的下面一行代码取消注释： 1NameVirtualHost *:80 然后，我们在 extra 文件夹下新建一个配置文件，如果主域名为 merrier.wang，而想配置的二级域名为 api.merrier.wang 的话，配置文件可以取名为 httpd-api.conf，这样命名比较规范。在新建的配置文件中填入以下代码： 123456789101112131415161718192021&lt;VirtualHost *:80&gt; ServerAdmin root@merrier.wang DocumentRoot &quot;/var/www/html/merrier-api&quot; &lt;Directory &quot;/var/www/html/merrier-api&quot;&gt; AllowOverride all Order allow,deny Allow from all &lt;/Directory&gt; ServerName api.merrier.wang ProxyRequests off &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; &lt;Location /&gt; ProxyPass http://localhost:3000/ ProxyPassReverse http://localhost:3000/ &lt;/Location&gt; ErrorLog logs/merrier.wang-error_log CustomLog logs/merrier-wang-access_log common&lt;/VirtualHost&gt; 其中有几个字段名需要按照真实情况进行修改： DocumentRoot和Directory：你的文件存放路径 ServerAdmin：一般为 root@主域名 ServerName：二级域名 ProxyPass和ProxyPassReverse：node 服务占用的端口号，如果没有 node 服务，可以不填写 ErrorLog和CustomLog：log 存放地址 这样修改完之后重启服务器让配置生效： 1service httpd restart 然后访问一下你的二级域名（http），如果一切顺利的话应该就可以看到页面了（如果有 node 服务的话，需要先启动 node 服务） PM2及node相关配置如果你需要启动 node 服务，那你肯定需要进行进程管理，尤其是如果你的网站需要占用多个端口有多个 node 服务的话，那在 node 进程管理工具中，业界使用最多的就是 pm2 了，下面就介绍一下如何合理的进行 pm2 配置以及 node 相关安装和配置（如果你没有 node 服务，那这一部分就可以跳过了）： 安装nodejs和npmcentos 默认是没有 nodejs 和 npm 的，所以需要进行安装：首先要通过 yum 来安装 nodejs 和 npm，而这需要先给 yum 添加 epel 源，添加方法在 centos 添加epel和remi源 中，安装完成后，执行： 1yum -y install nodejs npm --enablerepo=epel 安装nvm在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。nvm 应运而生，nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm。在 centos 系统，我们可以通过 curl 的方式安装 nvm ： 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash 如果你看到以下报错，说明你的 git 版本太低了（可以通过 git --version 查看当前 git 的版本）： 12=\\&gt; error: pathspec &apos;v0.29.0&apos; did not match any file(s) known to git.Your version of git is out of date. Please update it! 可以按照centos 6.7 安装 最新版 git的教程进行最新版git的安装，讲解步骤很详细。安装完 nvm 之后，我们对 node 的版本管理就非常简单了，例如，如果我们要安装 8.1.3 版本，可以用如下命令： 1nvm install 8.1.3 列出远程服务器上所有的可用版本： 1nvm ls-remote 列出本地已安装的版本： 1nvm ls 切换到某个版本： 1nvm use 8.1.3 nvm 的更多用法参见：使用 nvm 管理不同版本的 node 与 npm 安装pm2使用 npm 全局安装，一行命令不能再简单： 1npm install -g pm2 配置pm2如果你的服务入口文件为 app.js，在当前项目目录下启动pm2： 1pm2 start app.js --watch 这里用了 –watch 参数，意味着当你的 express 应用代码发生变化时，pm2 会帮你自动重启服务，多贴心。不过如果不经常改动，最好省去这个参数。关于 pm2 的其他命令可以查看PM2实用入门指南。 shell脚本启动多个服务我们可以通过shell脚本控制多个服务的同时开启，比如新建一个bootstrap.sh文件： 1234567#!/bin/bashCURRENT\\_DIR=&quot;$(cd -P &quot;$(dirname &quot;$&#123;BASH\\_SOURCE\\[0\\]&#125;&quot;)&quot; &amp;&amp; pwd)&quot;cd $CURRENT_DIR. ~/.nvm/nvm.shnvm use v8.1sleep 1pm2 start app.json 而 app.json 中可以填入多个 node 服务的相关信息，名称、端口、log 信息等等，这种玩法苏南大叔讲的很详细了，可以移步：pm2 start命令进阶详解 配置SSL证书接下来就是配置 SSL 证书的环节了，这里我们依然可以选择 Let’s entrypt 的证书，同时利用 certbot 工具可以节省很多麻烦，如果你配置过顶级域名的 SSL 证书（如果没有配置过，可以参考我的另一篇文章：网站配置HTTPS踩坑记进行配置），可以进入之前已经生成好的 certbot-auto 目录，然后执行以下命令： 1sudo certbot-auto --apache --duplicate 当你遇到以下信息时，建议单独选择你没有进行配置过 HTTPS 的域名，这样就不会覆盖掉原来申请过的证书： 12345678910111213Which names would you like to activate HTTPS for?\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-1: merrier.wang2: api.merrier.wang\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-Select the appropriate numbers separated by commas and/or spaces, or leave inputblank to select all options shown (Enter &apos;c&apos; to cancel): 配置完成之后，重启服务就可以了： 1service httpd restart Have Fun！ 参考文章 centos用 yum 方式安装 nodejs 和 npm centos 添加 epel 和 remi 源 centos 使用 nvm 安装 nodejs （nvm安装时出错，git 版本太老） centos 6.7 安装 最新版 git PM2实用入门指南 使用 nvm 管理不同版本的 node 与 npm","categories":[{"name":"服务器","slug":"服务器","permalink":"http://merrier.wang/categories/服务器/"}],"tags":[{"name":"apache","slug":"apache","permalink":"http://merrier.wang/tags/apache/"},{"name":"ssl","slug":"ssl","permalink":"http://merrier.wang/tags/ssl/"}]},{"title":"网站配置HTTPS踩坑记","slug":"网站配置HTTPS踩坑记","date":"2018-04-16T06:36:36.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20180416/website-configuration-https.html","link":"","permalink":"http://merrier.wang/20180416/website-configuration-https.html","excerpt":"","text":"近两年来 HTTPS 取代 HTTP 已经成为大势所趋。早在 2014 年 Google Chromium 安全团队提议将所有的 HTTP 协议网站标注为不安全。现在，Chrome 浏览器已经开始执行这一标准了。从 Chrome 56 开始，任何网页，如果有输入密码或者信用卡资料的，却没有使用 HTTPS，将被 Chrome 浏览器标识为不安全；逐步的，任何没有使用 HTTPS 协议的网页 Chrome 浏览器都会被标识为”不安全”，或者 “Not Secure”。所以处女座的我打算将 merrier.wang 升级成 HTTPS，以下对升级过程中遇到的问题和坑进行一下总结，如果你也有类似需求，希望这篇文章能够帮到你一二~ SSL证书选择1、对于国内用户来说，可以使用与百度云、腾讯云、阿里云合作的赛门铁克签署的证书，一年免费，申请和使用都很方便。 （不过我一开始用腾讯云的免费证书，发现chrome浏览器还是标记不安全，所以我就放弃用国内的证书- -） 2、自从 Let’s Encrypt 免费签发证书后，SSL 证书的价格就开始平民化了，有不少免费和收费的 SSL 可以选择。Let’s Encrypt 的证书虽然只有90的天，不过自动续期也很方便，对于小站来说，是很不错的选择。而我使用的就是 Lets Encrypt 颁发的证书，下面就主要记录一下申请证书，配置证书到 apache，以及自动续期的实现步骤，供有兴趣的童鞋参考。 申请证书Certbot 是一个简单易用的 SSL 证书部署工具，由 EFF 开发，前身即 Let’s Encrypt 官方（Python）客户端。简单来说，certbot 就是一个简化 Let’s Encrypt 部署，和管理 Let’s Encrypt 证书的工具。所以我们可以通过 Certbot 非常方便的生成证书并借助脚本实现自动续费。 首先来到 Certbot官网，在下面的蓝色箭头处选择操作系统和服务器型号： 以我的阿里云 ECS 举例，操作系统是 CentOS 6，服务器是 Apache，选择完之后页面下方会出现指引；按照其指引，我们首先需要安装 certbot-auto，在你想要安装的目录（这个目录最好是一个简单好找的目录，比如 /etc/httpd/conf，因为后面还要用到）下执行以下命令： 12wget https://dl.eff.org/certbot-autochmod a+x certbot-auto 然后我们通过certbot获取证书： 1sudo ./path/to/certbot-auto --apache 期间会让你填一些自己的信息，比如个人邮箱等等，按照自己的实际情况填写即可，然后过程中可能会遇到下面这条信息： 123456Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-1: No redirect - Make no further changes to the webserver configuration.2: Redirect - Make all requests redirect to secure HTTPS access. Choose this fornew sites, or if you&apos;re confident your site works on HTTPS. You can undo thischange by editing your web server&apos;s configuration. 这里我强烈建议选择第二个 Redirect 选项，因为这样 Certbot 会对 apache 配置文件进行修改，当用户访问 HTTP 链接时，强制重定向到 HTTPS 链接，就不需要我们自己进行修改了。 如果一切顺利的话，当我们看到下面的提示信息时，就证明我们的证书已经申请成功并配置成功了： 123456\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-Congratulations! You have successfully enabled https://merrier.wangYou should test your configuration at:https://www.ssllabs.com/ssltest/analyze.html?d=merrier.wang\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\- 自动续费此时我们可以访问一下 HTTPS 的链接，看看证书是否生效，如果不生效，可以尝试一下重启 apache： 1service httpd restart Let’s Encrypt 的证书，默认的有效期是 90 天，不过官方推荐每 60 天续期。到期之后，我们需要用命令来为证书续期，不过我们是懒人，这种体力活还是交给机器来完成比较合适。所以，我们可以用 Linux 的 cron job 来完成这类的任务。 安装如果服务器上没有安装 crontabs，需要手动安装，centos 系统建议通过 yum 安装： 1yum install crontabs 启动服务12service crond startchkconfig crond start 添加新的任务1crontab \\[-u user\\] -e 其中：-u user：用来设定某个用户的 crontab 服务，例如，“-u ixdba”表示设定 ixdba 用户的 crontab 服务，此参数一般由 root 用户来运行。即执行 crontab -u root -e 来添加任务，此时会打开一个新的文件，填入以下脚本信息： 10 0,12 * * * python -c &apos;import random; import time; time.sleep(random.random() * 3600)&apos; &amp;&amp; ./path/to/certbot-auto renew --post-hook &quot;service httpd restart&quot; 如果出现 crontab: installing new crontab 就说明我们的脚本已经生效了，自动续费就配置好了。关于更多 crontab 的内容可以点击这里查看，你可以利用他做更多有意思的事情。如果你不确定自己的定时任务是否设置成功，可以通过执行 crontab -l 进行查看，如果出现上面的那段 python 代码，说明定时任务已经设置成功；有时候可能 crond 服务莫名的挂掉，我们可以通过上面的命令手动启动，同时也可以通过下面的命令手动更新证书： 1/etc/httpd/conf/certbot-auto renew Wordpress配置https如果你的网站是通过 wordpress 搭建的，除了进行上面的流程之外，还需要进行额外的配置： 修改wordpress后台配置中的地址改为https版本 注意：一定要保证https和http两种方式都能正常访问网站，才能改这个配置，否则可能导致网站无法访问。通过上面的设置，绝大部分导航中的链接就由 wordpress 系统会自动改为 HTTPS 版本。 替换正文的内部链接和其他静态资源对于这部分链接需要手工修改，修改的方法有两种： （1）直接在数据库中更新，更新的sql如下：1update wp\\_posts set post\\_content = replace(post_content, ‘http://your-website-name/’,‘https://your-website-name/’) 对于数据库不熟悉的童鞋不推荐这种方法，对数据库错误的更新对网站可能是毁灭性的打击，建议更新前最好备份数据库。 （2）利用wordpress提供的api来重写链接在使用的主题（themes）的目录下的 functions.php 加入如下代码： 1234567891011if ( function\\_exists('add\\_theme\\_support') )add\\_theme_support('post-thumbnails');add\\_filter('script\\_loader\\_src', 'agnostic\\_script\\_loader\\_src', 20,2);function agnostic\\_script\\_loader_src($src, $handle) &#123; return preg_replace('/^(http|https):/', '', $src);&#125;add\\_filter('style\\_loader\\_src', 'agnostic\\_style\\_loader\\_src', 20,2);function agnostic\\_style\\_loader_src($src, $handle) &#123; return preg_replace('/^(http|https):/', '', $src);&#125; 这个方法优点是可逆，不会对网站的数据库有什么影响，推荐使用这种方法。 调整完内部链接后，检查整个网站的页面，包括首页，栏目页，内容页，sitemap，页面head部分内容，比如：css，js，canonical 等，是否都转换成了 HTTPS 版本。 可能会遇到的问题Apache配置文件找不到可能某些童鞋的 apache 配置文件不在 /etc/httpd/conf 目录下，可以通过 find 命令进行查找： 1find / -name httpd.conf 其中“/”是指在根目录下进行查找，如果你知道在哪个目录下，可以自行修改，节省查找的时间 Invalid command ‘SSLEngine’, perhaps misspelled or defined by a module not included in the server configuration不管是在证书申请过程中还是在自己修改配置过程中遇到次报错，一般情况下是因为在 modules 文件夹下并没有 ssl 模块，那就需要自己安装了，我在stackoverflow上搜到了解决方案，代码如下： 1yum install mod_ssl 当我们安装完毕之后，就可以看到 modules 文件夹下多了一个 mod_ssl.so 文件了，此时我们再重启 apache 就应该不报错了。 [warn] module ssl_module is already loaded, skipping Address already in use: make_sock: could not bind to address 0.0.0.0:443 no listening sockets available, shutting down出现该警告说明 ssl module 被多处使用，可以用如下命令检查： 1grep ssl_module -rI /etc/httpd/* 此时会出现： 其中 httpd.bk.conf 是我自己建的备份，所以有两种解决方法： httpd.conf 中去掉 LoadModule ssl\\_module modules/mod\\_ssl.so、去掉 Listen 443 直接删除 /etc/httpd/conf.d/ssl.conf，推荐直接删除 ssl.conf 参考文章WordPress整站轻松开启HTTPS apache服务器添加https（针对ios10 https） 通过Certbot配置Let’s Encrypt的SSL（Apache）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/categories/HTTP/"}],"tags":[{"name":"指南","slug":"指南","permalink":"http://merrier.wang/tags/指南/"},{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/tags/HTTP/"},{"name":"wordpress","slug":"wordpress","permalink":"http://merrier.wang/tags/wordpress/"}]},{"title":"Promise入门","slug":"Promise入门","date":"2018-02-26T14:14:10.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20180226/introduction-to-promise.html","link":"","permalink":"http://merrier.wang/20180226/introduction-to-promise.html","excerpt":"","text":"幕课网上的视频——Promise入门笔记，Promise 作为 ES6 中最重要的特性之一，对其进行了解和学习是非常有必要的，课程的源码已经上传至我的github。 Promise是什么MDN The Promise object is used for asynchronous computations. A Promise represents a value which may be available now, or in the future, or never. MDN中文 Promise对象用于异步计算。 一个Promise表示一个现在、将来或永不可能可用的值。 按照用途来解释 主要用于异步计算 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。 可以在对象之间传递和操作Promise，帮助我们处理队列。 回调存在的问题 嵌套层次很深，难以维护 无法正常使用 return 和 throw 无法正常检索堆栈信息 多个回调之间难以建立联系 Promise 详解 Promise 是一个代理对象，它和原先要进行的操作并无关系 它通过引入一个回调，避免更多的回调 Promise 有 3 个状态 pending[待定]——初始状态 fulfilled[实现\\——操作成功 rejected[被否决]——操作失败 当 Promise 的状态发生改变，就会触发 .then() 里的响应函数处理后续步骤；Promise 状态一经改变，不会再变；只有在连续多个回调顺序执行的时候，Promise才会显示出其威力 .then() .then() 接受两个函数作为参数，分别代表 fulfilled 和 rejected .then() 返回一个新的 Promise 实例，所以它可以链式调用 当前面的 Promise 状态改变时，.then() 根据其最终状态，选择特定的状态响应函数执行 状态响应函数可以返回新的 Promise，或其它值 如果返回新的 Promise，那么下一级 .then() 会在新的 Promise 状态改变之后执行 如果返回其它任何值，则会立刻执行下一级 .then() 错误处理Promise 会自动捕获内部异常，并交给 rejected 响应函数处理 最好是在语句的最后通过 catch 捕获错误，因为 catch 可以捕获 resolve 回调中发生的错误，而 reject 回调无法捕获；catch 也会返回一个 Promise 实例，并且它返回的 Promise 实例如果没有错误的话也是 fulfilled 状态，所以 catch() 后面的 .then() 也都会触发，但是 catch() 后面的 .catch() 不会触发（如果在第一个catch()中没有抛出错误） 强烈建议在所有队列最后都加上.catch()，以避免漏掉错误处理造成意想不到的问题： 123456doSomething() .doAnotherThing() .doMoreThing() .catch( err =&gt; &#123; console.log(err); &#125;); 实现队列有时候我们不希望所有动作一起发生，而是按照一定顺序，逐个进行： 12345let promise = doSomething();promise = promise.then(doSomethingElse);promise = promise.then(doSomethingElse2);promise = promise.then(doSomethingElse3);... 使用.forEach()1234567891011121314function queue(things) &#123; let promise = Promise.resolve(); things.forEach( thing =&gt; &#123; promise = promise.then( () =&gt; &#123; return new Promise( resolve =&gt; &#123; doThing(thing, () =&gt; &#123; resolve(); &#125;) &#125;) &#125;) &#125;); return promise;&#125;queue(\\['lots', 'of', 'things', ....\\]); 使用.reduce()123456789101112function queue(things) &#123; return things.reduce( (promise, thing) =&gt; &#123; promise = promise.then( () =&gt; &#123; return new Promise( resolve =&gt; &#123; doThing(thing, () =&gt; &#123; resolve(); &#125;) &#125;) &#125;) &#125;, Promise.resolve());&#125;queue(\\['lots', 'of', 'things', ....\\]); Promise常用函数Promise.resolve()返回一个 fulfilled 的 Promise 实例，或原始 Promise 实例 参数为空，返回一个状态为 fulfilled 的 Promise 实例 参数是一个跟 Promise 无关的值，同上，不过 fulfilled 响应函数会得到这个参数 参数为 Promise 实例，则返回该实例，不做任何修改 参数为 thenable（有 then 方法），立刻执行它的 .then() Promise.reject()返回一个 rejected 的 Promise 实例 Promise.reject()不认thenable 其他和 Promise.resolve() 类似 Promise.all()Promise.all(\\[p1, p2, p3, ...\\]) 用于将多个 Promise 实例包装成一个新的 Promise 实例 当所有子 Promise 都完成，该 Promise 完成，返回值是全部值的数组；有任何一个失败，该 Promise 失败，返回值是第一个失败的子Promise的结果，最常见的是和 .map() 连用 ###Promise.race() 类似 Promise.all() ，区别在于它有任意一个完成就算完成。 常见用法： 把异步操作和定时器放在一起 如果定时器先触发，就认为超时，告知用户 async/awaitES2017 新增运算符，新的语言元素 赋予 JavaScript 以顺序手法编写异步脚本的能力！ 既保留异步运算的无阻赛特性，还继续使用同步写法。 还能正常使用 return/try/catch","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"},{"name":"ES6","slug":"ES6","permalink":"http://merrier.wang/tags/ES6/"},{"name":"慕课网","slug":"慕课网","permalink":"http://merrier.wang/tags/慕课网/"}]},{"title":"慕课网视频评分&推荐","slug":"慕课网视频评分&推荐","date":"2018-02-19T02:11:11.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20180219/video-scoring-and-recommendation-on-muke.html","link":"","permalink":"http://merrier.wang/20180219/video-scoring-and-recommendation-on-muke.html","excerpt":"","text":"总有童鞋问我慕课网上面有哪些视频比较好，我就索性写一篇文章总结一下我看过的慕课网上面的优秀的视频，绝大部分都是前端相关的，希望能够提升你的效率，节省时间。下面我会对这些视频从以下几个方面进行评分（单纯个人评分，不喜勿喷- -）： 难度系数：视频所讲内容的难度 实战系数：视频所讲内容的实际应用系数 版本系数：视频所讲内容中涉及到的框架/插件的版本是否是最新的 综合评分：综合评价 推荐大家用 1.75 倍速播放，这样可以节省很多时间，同时也能听清- - 前端工具前端内容的自动化构建 难度系数：★☆☆☆☆ 实战系数：★★★★☆ 版本系数：★★☆☆☆ 综合评分：★★★☆☆ 该课程分为三个部分，第一部分讲解什么是构建，为什么需要自动化构建，后面两部分分别讲解如何使用 Gulp 进行 JavaScript 和 CSS 的构建。所讲内容比较简单，而且自动化构建在实际项目中经常会用到，不过 webpack 版本比较低，需要结合评论进行学习。。 webpack深入与实战 难度系数：★★★★☆ 实战系数：★★★★☆ 版本系数：★★☆☆☆ 综合评分：★★★★☆ 该课程介绍了如何在项目中使用 webpack 打包文件，处理各种资源，以及配置开发环境，上线环境等，通过实际的例子来讲解 webpack 的使用方法，带你探索 webpack 强大的功能。可以说是很全面了，作者讲解的也比较详细，想初步了解 webpack 如何使用的童鞋可以选择看一下该视频。 前端实时可视化开发工具体验 难度系数：★★☆☆☆ 实战系数：★★★★☆ 版本系数：★★★☆☆ 综合评分：★★★☆☆ 前端开发中，我们常常需要频繁的修改 html，css，js，然后刷新页面，看效果，再调整，再刷新。该课程使用 liveStyle，liveReload，browserSync 工具实现修改代码后，立即体现效果的功能，使用可见即可得的开发模式，极大的提高前端开发效率。实时可视化在开发环境应用的比较多，会很大程度地提高工作效率，感兴趣的童鞋可以再自行搜索 hotreload，这样结合本视频观看食用效果更佳 前端性能优化-基础知识认知 难度系数：★★★☆☆ 实战系数：★★★★☆ 版本系数：★★★★☆ 综合评分：★★★★☆ 该课程从前端优化目的，简单方法、分类开始，到如何优化，优化过程中的常见错误，业内公认的但是不适应所有方案。我们还可从这个课程中学习到当我们访问一个站点的时候，我们究竟做了什么以及怎么样才叫优化成功。性能优化是一个老生常谈的问题，如果你对该问题有一定的基础认知，想再深入了解相关知识的话，该课程你不容错过 WebAppHello，移动WEB 难度系数：★★★☆☆ 实战系数：★★★★★ 版本系数：★★★★☆ 综合评分：★★★★☆ 该课程介绍移动 web 的开发基础，高效的排版布局，常见的移动 web 问题，终端触摸交互，各种 bug 坑如何解决等多方面。虽然视频比较短，但是干货多多，对于移动端的适配布局这类问题进行了很详细的讲解。 JavaScriptPromise入门 难度系数：★★★★☆ 实战系数：★★★★★ 版本系数：★★★★☆ 综合评分：★★★★★ Promise 是 ES6 中最重要的特性之一，该课程为我们讲解了为什么会有 Promise，以及 Promise 的常见用法和注意事项，通过实际代码进行讲解清晰易懂，适合前端中级水平开发者，我对该课程进行了总结，笔记在这里可以查看得到。 ajax跨域完全讲解 难度系数：★★★☆☆ 实战系数：★★★★★ 版本系数：★★★★☆ 综合评分：★★★★★ 跨域是前端领域中经常遇到的问题，尤其是各种 CDN 服务兴起之后，而究竟什么情况下跨域，如何解决跨域问题更是笔试或面试时经常被问到的问题，该视频教程详细讲解了 jsonp 的工作机制，http 协议如何支持跨域，以及 http 服务器 nginx 和 apache 的 2 种不同解决思路，让大家知其然并知其所以然，是非常不错的跨域入门讲解课程 CSSCSS深入理解系列 难度系数：★★★☆☆ 实战系数：★★★★★ 版本系数：★★★★☆ 综合评分：★★★★★ 该系列视频为张鑫旭老师对 CSS 相关属性的讲解，包括 margin、padding、position、z-index 等等基础属性，适合具备一定 CSS 基础知识的童鞋，张鑫旭老师的讲课风格很独特，也不知道是否符合你的口味，不过我是很喜欢啦~而且张鑫旭老师对于这些属性的讲解很深入，在实际项目中应用的很多，毕竟前端工程师一年写的 CSS 代码可以绕地球三圈啊（我对该系列视频的讲解进行了总结，在系列专栏中的CSS深入理解系列中可以看到） 如何用CSS进行网页布局 难度系数：★☆☆☆☆ 实战系数：★★★★☆ 版本系数：★★★☆☆ 综合评分：★★★☆☆ 该课程教你怎么制作一列布局、二列布局、三列布局当然还有最通用的混合布局，而且你还可以选择让它固定还是自适应。用 CSS 重新规划你的网页，让你的网页从此更美观、更友好。难度系数很低，而布局在实际项目中是很基本也是很重要的知识点 分页页码制作 难度系数：★☆☆☆☆ 实战系数：★★☆☆☆ 版本系数：★★★★☆ 综合评分：★★★☆☆ 通过本课程的学习，我们可以学习到利用 HTML、CSS 样式技术制作出分页页码的效果。包括最简单的直角分页页码效果，修复行内元素之间的间隔 bug 问题分析，代码整理，为分页页码插入小图标。虽然一般不需要我们自己制作分页页码，但是如果你想自己写框架或者对这类知识比较好奇的话，该视频能够充分解答你的疑惑，最为关键的是提供源码啊~ JavaScriptHybrid设计 难度系数：★★☆☆☆ 实战系数：★★★★☆ 版本系数：★★★★☆ 综合评分：★★★★☆ 该课程首先会告诉大家什么是 Hybrid，Hybrid 有什么特点，也会告诉大家业内有哪些常见的 Hybrid 应用以及 Hybrid 合理的应用场景。 然后，课程会简单介绍一个 Hybrid 架构的方方面面，包括 Hybrid 的发展，比如超级 Hybrid 方案 React Native 以及 Weex 学习该课程，大家会知道 Hybrid 中 H5 与 Native 如何交互，并且对 Hybrid 体验增强和 Hybrid 离线包有一些认识，是大家做混合 APP 的必备良药。 zepto设计和源码分析 难度系数：★★★☆☆ 实战系数：★★★☆☆ 版本系数：★★★☆☆ 综合评分：★★★☆☆ 当熟练使用 zepto 的 API 之后，也应该解读一下 zepto 的源码，了解一下 zepto 的设计原理。该教程深入浅出的介绍了 zepto 最核心的设计原理，看完之后即能轻松解读 zepto 所有源码。就像 TJ 大神一样，有时候看别人写的代码会有不同寻常的收获 Web安全-XSS 难度系数：★★☆☆☆ 实战系数：★★★★☆ 版本系数：★★★☆☆ 综合评分：★★★☆☆ 该课程从 Web 安全 XSS 的定义开始讲起，到深入剖析 XSS 攻击的原理和流程，了解常见 XSS 攻击的危害。同时通过项目实战针对性的分析如何应对 XSS 攻击做到安全的 XSS 防御措施。XSS 是最常见的一种 web 攻击，了解一些相关知识百利无一害= =","categories":[{"name":"慕课网","slug":"慕课网","permalink":"http://merrier.wang/categories/慕课网/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://merrier.wang/tags/前端/"},{"name":"推荐","slug":"推荐","permalink":"http://merrier.wang/tags/推荐/"},{"name":"慕课网","slug":"慕课网","permalink":"http://merrier.wang/tags/慕课网/"},{"name":"教程","slug":"教程","permalink":"http://merrier.wang/tags/教程/"}]},{"title":"那些惊艳的移动端H5案例","slug":"那些惊艳的移动端H5案例","date":"2018-02-11T08:25:53.000Z","updated":"2019-01-17T13:21:55.962Z","comments":true,"path":"20180211/those-amazing-mobile-h5-cases.html","link":"","permalink":"http://merrier.wang/20180211/those-amazing-mobile-h5-cases.html","excerpt":"","text":"不管是公司用于宣传还是对某个产品进行营销，移动端 H5 的应用范围越来越广，其取得的效果也有目共睹，而这篇文章就带大家领略一下那些十分惊艳的移动端H5案例，希望大家抱着猎奇的心态观看，毕竟可远观而不可亵玩呐-。-（以下活动有可能是限时的，所以当你再次访问时有可能已经关站了，排名不分先后） 案例adidas-胜势全开\badidas 为自己的新战靴做的宣传，不过看开头动画的时候有点吓到我了- -，这为了宣传新鞋也真是下了一番功夫啊。。 凡科720°全景×活动促销凡科互动是凡科旗下的一个子品牌，主要做的就是这种活动促销 H5，其中大多数为游戏的形式，而这个 720° 全景营销案例很经典，之前我也曾经尝试过实现一个类似的，结果可想而知。。因为 720° 需要用到一些数学知识，同时为了让其滑动的更顺滑，引入了很多插件，所以是一个比较难实现的案例。 Merrier和王者荣耀的故事不知道你们能不能打开这个链接，应该是只能在微信中打开的- -，这是王者荣耀在两周年的时候出的一个总结性质的 H5，色彩搭配很舒服，同时各种数据的统计证明这个文案是用了很大心思的。 有志者，吃就橙大众点评和摩拜单车联合搞的一次“炫光吃货车”活动，虽然其实就是一个不能暂停也没有很人性化的静音按钮的视频，但是不得不说，文案还是有一丢丢创意的，而且配音也很有意思。。 车轮招聘节车轮——让有车生活更美好制作的招聘宣传 H5，虽然动画比较简单，而且元素也比较单一，但是整体效果还是不错的，而且有一个很牛逼的微信分享标题：《我们在召唤你，艾泽拉斯最强的勇士们！》 开打法魔用能只章文篇这（这个标题用了我 30 秒的时间）不得不承认这是我见过的最炫酷的 H5 宣传案例了，当那熟悉的旋律响起，我们仿佛就置身于霍格沃茨魔法学院，通过一些手势产生互动，最后还能学到魔法，不得不说真的很赞，不过缺点就是：这个是宣传什么的来着？ 艾泽拉斯全景之旅80 年代的魔兽世界，大灾变之前的艾泽拉斯，wower 老玩家的回忆。不知不觉，魔兽世界已经陪伴我们超过十年了，虽然我自己玩魔兽的时间很短很短，不过对魔兽世界的文化本身还是比较感兴趣的，而这个 720° 全景可以说做的很用心，也很真实，同时还能够看到一些玩家在暴风城等地方留下的感慨，岁月流转，曾经一起下副本的朋友们你们过得还好吗？ 朕收到一条来自你妈的微信这个标题着实吓到我了，不过点开才发现，这和我妈有什么关系？！其实就是故宫食品的宣传 H5，在这里赞一下文案设计，风趣而不失稳重（看饿了）： 圣旨到奉天承运，皇帝诏曰朕最近心情不佳打农药微信总弹窗段位一直掉掉掉掉烦死朕了朕实在控记不住记几啊点开一看朕收到了你妈的微信让你中秋回家吃月饼 SO朕就给你批个长假回家过节反正带不回对象那就带朕的心意哈哈哈哈，没想到吧朕给自家御膳房走波广告（…各种弹幕）朕的御厨，平时很闲除了月饼，还做了一堆（…各种吃的）现在有些妖艳的月饼咬一口防腐半年一定是哪个刁民想谋害朕好继承朕的江山稳住我们能赢！朕的御膳房，刀枪不入，百毒不侵国味汝肴典藏月饼这就是朕的心意故 宫 的 月 饼眼花了吧 哈哈哈哈哈朕就是这样迷人的汉子（好不要脸） 领英丨名企梦工厂-今日头条领英在校招季携手 18 家顶级名企，用 VR 全景带你全方位无死角地触碰心仪公司，可以说结合 VR 进行企业的介绍效果很赞，再加上旁白的介绍更加饱满充实，不过就是流量消耗巨大。。如果对 VR 感兴趣的话，欢迎去 VeeR-全球VR内容分享社区观看更多 VR 视频（首先，你得有一副好的 VR 眼镜） 2017两会人民日报在两会期间做的微信宣传 H5，很有创意，借用微信群聊和朋友圈的方式对国家取得的成果进行了展示，同时进行了一些宣传和号召。 王思聪邀请你加入群聊现在的标题党越来越多了。。其实和上面那个两会的 H5 类似，只不过粗糙一些，而且内容也比较少，就是滴滴的一个活动的宣传，很明显的不太用心啊。 河北衡水中学720°全景图衡中虽然占地面积比较小，但是每年产出的清北人数可以说在全国都是名列前茅的，而这个 720° 全景图相比之前魔兽和凡科的就差太多了，好希望有人能做一个比较细致的 720° 全景图啊- - 比尔盖茨邀请你加入群聊需要在微信中打开，和上面的“王思聪邀请你加入群聊”类似，都是模仿微信进行宣传，同时加入了一些用户互动，最后重定向到了公众号中的一篇文章，其实这种形式是一种很好的宣传，值得借鉴 以你之名，守护汉字网易有道做的“守护汉字”主题活动，根据你的姓名为你分配一个需要守护的古汉字，让我不禁想起了《国家宝藏》，不过不得不说，动画特效和 BGM 都很赞，在“提笔忘字”的今天，守护汉字显得尤为重要 快看！李彦宏父女跑进你的手机啦！虽然只是一个视频，技术上难度很低，不过这个视频做的很赞，百度通过这种形式宣传自己的“手机百度”，虽然对百度并无好感，不过如此用心的视频还是要赞一个 2017，谁是头条？头条对于 2017 年度新闻的总结，水墨画与太极的结合很是中国风，文案处处体现着“中国功夫”的元素。 唐朝名媛高阶生活指南你不看到末尾不会想到，这是中国移动的广告。。。 二零一七年娱乐圈画传去年的一个网易娱乐年度新闻盘点的 H5 页面非常的新颖，采用画中画的形式依次串联十多个手绘娱乐图片，加上洗脑的“好运来”音乐，让人有很大的分享的欲望。这里有一篇解密的文章：《Canvas 实现画中画动画效果–网易娱乐年度盘点H5动画解密》 她挣扎48小时后死去，无人知晓副标题：《你也是这个故事的主角》，首先不要被这个标题所吓到，其实这是网易出品的一个号召大家关注环境保护的一个 H5，不得不说，网易在这个方面做的真的很出色。 制造【我】的草莓音乐节可以在线生成草莓音乐节主题海报，你可以定制自己的外形，并添加一些简单的文案。 重回1978，带你潇洒走一回！腾讯新闻出品的，结合重力感应带你回顾改革开放四十年来我们的变化，筒子楼、迪斯科、马里奥，这些具有十分明显的时代痕迹的符号代表了那一辈人的童年，就像标题一样，带你潇洒走一回！ 一些专门做H5媒体内容的平台：木疙瘩H5 交互融媒体内容制作与管理平台。首先吐槽一下这个名字，可能是因为只买到了这个稍微能凑出汉字的域名吧，毕竟现在的域名是真贵啊- -，其特色有： 免费无广告 零代码交互 自动适配屏幕 可导出源文件 然而，人民日报的一篇题为《燃爆！人民日报首部闪卡H5动画“史上最牛团队这样创业！”》的 H5 文案却被删除了： 凡科互动H5 游戏营销领导者。H5游戏因为其跨平台、传播快等特性，近年来受到了广泛关注，而凡科互动就是专注于 H5 游戏的一个平台，我自己也试玩了一下它的几款游戏，包括大转盘、摇一摇、砸金蛋等等，画面音效都很不错，不过应该不是免费的，所以还是要预估一下成本和收益再做决定吧。 720yun从名字可以看出，这是一家做 720 度全景和 VR 视频的平台，首先这个网站的风格我很喜欢，非常紧致有力，不过名气不是很大，也不知道效果如何和收费情况。 MAKA MAKA 是一款简单、强大的 H5 数字化营销创作工具 其在线编辑器可帮助企业创作出专业级 H5 酷炫动态效果 这是其官网的介绍，MAKA 在业界算是很有名气的了，经常会看到一些企业用 MAKA 做 H5 宣传，所以其本身的效果是已经经过广泛验证的了，最关键的是免费制作（当然，有一些也需要收费），如果有感兴趣的童鞋可以下载一下 MAKA 的 APP 尝试一下，操作简单但是功能强大。 易企秀 企业移动营销综合服务平台 极简制作流程 奢华呈现形式 精准投放保证传播效果 数据随时跟踪反馈 从营销到再营销 从传播到二次传播 易企秀提供一键解决方案 易企秀和 MAKA 类似，也是我最开始接触到的 H5 营销平台，虽然其介绍感觉比 MAKA 要强大许多，不过从我自身的体验来讲，易企秀比较适合中小型企业以及那些不太追求外表，同时在线时间比较短的营销活动，比如年会邀请函、新品介绍等等。总之吧，和 MAKA 相比各有千秋。 它山之石还有一些志同道合的童鞋也对与H5的玩法案例进行了总结： H5玩法知多少来自简书，作者不仅介绍了许许多多经典的 H5 案例，作者还将 H5 玩法归纳为基于传感器、基于触摸屏操作、基于画面呈现、基于内容这四类，内容很充实。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://merrier.wang/categories/移动端/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://merrier.wang/tags/移动端/"}]},{"title":"再见，2017","slug":"再见，2017","date":"2017-12-31T15:15:52.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20171231/goodbye-2017.html","link":"","permalink":"http://merrier.wang/20171231/goodbye-2017.html","excerpt":"","text":"今天是2017年12月31号，也就是2017年的最后一天，一般有个人博客的人都会搞个总结神马的，那我也不能落后啊？！ 20172017 对于我来说，可以说是非常重要的一年，在这一年中我经历了很多，也度过了很多个难忘的夜晚，废话少说： 人首先，2017 年最重要的当然是找到了第一份工作，在字节跳动遇到了很多有趣的同事，其实现在想想，我的秋招就这样以一场面试开始，以同样一场面试结束了。。 在这里不得不讲一下字节跳动的种种，这里的人都很 nice，上级并没有官架子，同事们也很有趣，当然这里的饭菜在互联网界也是非常出名的，每一餐都是 50+ 的水准，不得不说，一个好食堂真的能提高生产力~除此之外，每天中午吃完饭之后还能休息 1-2 个小时，这对于我这种不睡午觉一天就没精神的简直是超级福利。。说了这么多，如果有想来字节跳动工作的童鞋，欢迎联系我~ 2017 年对于所有的90后来说也是独特的一年，因为过了今天就意味着所有的90后都已满18岁，不再是当初那个叛逆的年纪了，所以在最近也看到了各种秀 18 岁的朋友圈，时光催人老，不服不行： 这张照片是当初在衡中远足时拍的，应该在 2009 年，当时差不多 17 岁。2017 年还是一个主播行业大热的年份，不得不说，我是看着冯提莫、二珂、大表姐、大奶强等主播逐渐成长起来的，可以说直播不仅让我吃外卖的时候不感觉无聊，同时让我学到了很多姿势，成为了我日常生活中不可缺少的一部分。 事首先，这一年我的个人博客终于上线了。在经过一系列的折腾和 YueBug 的热情帮助下，Merrier说在今年 4 月份的时候上线了，虽然我的水平有限，不能像其他前端大牛一样对各种新鲜技术进行讲解，或对一些框架的源码进行解读，但是我始终相信，基础知识才是最重要的，所以如果你也入了前端的坑，那么 Merrier说 一定能让你学到一些东西~ 2017 年不得不提一下共享单车这个行业，从最初的 ofo，到后来的各种单车，再到现在的 ofo 和摩拜平分天下的形势，可以说我们都成为了共享单车行业的见证人，同时也让我们看到了为什么创业需谨慎，提到共享单车，就联想到了我至今还没有追回的 99 大洋押金： 当然，如果让我在 ofo 和摩拜中选一个，我站摩拜（新摩拜简直好骑到爆）！ 不知道什么时候，本命年的梗深受人心，不过对于我来说，2017 年可以说是收获的一年，不仅在前端方面找到了自己喜爱的学习方式，同时在工作上也有了自己满意的结果，当然希望看到这里的有缘人不管 2017 年过得如何，在 2018 年都能如自己所愿。 2018展望一下2018的话，希望能够： 在工作上取得突破，不管是前端技术还是为人处事都能再进一步 说了好几年的健身应该能付诸行动了吧？ 多看几部纪录片 把漫威DC的电影都看一遍 Leetcode 再刷 200 道题 Merrier说 能够再多一些干货文章 完成一个 chrome 插件 向 npm 库提交一个自己做的插件 小程序可以玩一玩 一直想做的图片上传和展示网站能落地 顺利毕业！ 摇到号！ 最后你以为完了？并没有！以一张网图作为结束吧： 愿你走出半生，归来仍是少年。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://merrier.wang/categories/杂谈/"}],"tags":[{"name":"生活","slug":"life","permalink":"http://merrier.wang/tags/life/"},{"name":"总结","slug":"总结","permalink":"http://merrier.wang/tags/总结/"}]},{"title":"Blue老师ES6视频笔记","slug":"Blue老师ES6视频笔记","date":"2017-12-12T14:10:42.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20171212/teacher-blue-es6-video-notes.html","link":"","permalink":"http://merrier.wang/20171212/teacher-blue-es6-video-notes.html","excerpt":"","text":"请容许我吐槽一下，我发现中国很多前端的大神的英文真的差啊。。 ES6 兼容性可以在线查看兼容性： ES5：kangax.github.io/compat-table/es5/ ES6：kangax.github.io/compat-table/es6/ 在线编译babel === browser.js，只不过叫法不同 可以通过如下方式实现在线编译 ES6，只不过会多出额外的编译时间，用户体验稍差： 123456&lt;script src=\"browser.js\"&gt;&lt;/script&gt;&lt;script type=\"text/babel\"&gt; let a = 12; let b = 5; alert(a+b);&lt;/script&gt; 变量ES5 中 var 的缺点： 可以重复声明 无法限制修改，即没有常量的概念 没有块级作用域 1234if(true)&#123; var a = 12;&#125;alert a; // 12 块级作用域有什么用？可以限定变量在块中起作用，而不像ES5一样在函数块中起作用，最常见的是 for 循环中的索引值 箭头函数 如果只有一个参数，()可以省略 如果只有一个 return，{}可以省略 函数的参数ES6新增： 参数扩展（…args必须为最后一个形参）123456function show(a, b, ...args)&#123; alert(a); alert(b); alert(args);&#125;show(12, 15, 8, 9, 20); 展开一个数组12let arr = \\[1, 2, 3\\];\\[...arr\\] = \\[1, 2, 3\\]; 默认参数123function show(a, b=5, c=12)&#123; console.log(a, b, c);&#125; 解构赋值1234567891011121314let \\[a, b, c\\] = \\[1, 2, 3\\]console.log(a, b, c);let \\[&#123;a, b&#125;, \\[n1, n2, n3\\], num, str\\] = \\[&#123;a: 12, b: 5&#125;, \\[12, 5, 8\\], 8, 'cxzcv'\\];console.log(a, b, n1, n2, n3, num, str);let \\[a, b\\] = &#123;a: 12, b: 45&#125;;console.log(a, b); // undefined is not a function, 前提1let &#123;a, b&#125; = &#123;12, 5&#125;;console.log(a, b); // unexpected token, 前提2let \\[a, b\\];\\[a, b\\] = \\[12, 5\\]; // XXXX error, 前提3 前提： 左右两边解构必须一样 右边必须是个东西 声明和赋值不能分开（必须在一句话中完成） 数组新增四个方法： map：映射 reduce：汇总 filter：过滤器 forEach：循环（迭代） map12345let arr = \\[12, 5, 8\\];let result = arr.map(function(item)&#123; return item*2;&#125;)alert(result); // 24, 10, 16 reduce经常用来算总数、平均数等指标 12345let arr = \\[12, 69, 180, 8763\\];let result = arr.reduce(function (tmp, item, index)&#123; return tmp + item;&#125;)alert(result); 求平均数： 123456789let arr = \\[12, 69, 180, 8763\\];let result = arr.reduce((tmp, item, index) =&gt; &#123; if(index != arr.length - 1)&#123; return tmp+item; &#125;else &#123; return (tmp+item)/arr.length; &#125;&#125;)alert(result); filterfilter 中 return true 就留下来，return false 就不保留 forEach类似于传统的 for 循环，参数为 item, index 字符串新增： 多了两个新方法，startsWith，endsWith 字符串模板 字符串模板普通字符串无法折行，字符串模板可以折行 123let a = 12;let str = \\`a$&#123;a&#125;bc\\`;alert(str); // a12bc 面向对象ES5 中的面向对象：类和构造函数不分，混为一谈；ES6 中的面向对象： class 关键字，构造器和类分开了 class 里面直接加方法 extends-继承 JSONjson 的标准写法： 只能用双引号 所有的名字（key）都必须用引号包起来 在 ES 中，当名字和值相同时，可以只写其中一个；方法可以省掉: function Promise异步会让代码更复杂，而同步的代码简单，而 Promise 用同步的方式来书写异步代码 12345678910111213let p = new Promise(function (resolve, reject)&#123; $.ajax(&#123; url: 'arr.txt', dataType: 'json', success(arr)&#123; resolve(arr); &#125;, error(err)&#123; reject(err); &#125; &#125;)&#125;)p.then(function ()&#123;alert('成功')&#125;, function ()&#123;alert('失败')&#125;); Promise.all([promise1, promise2, …]) =&gt; 都 resolve 的时候才算成功，只要有一个 reject 就算失败Promise.\brace([promise1, promise2, …]) =&gt; 只要有一个 resolve 的时候就算成功，全部 reject 才算失败 在高版本 jQuery 中，$.ajax 的返回值就是一个 Promise 对象 generator和普通函数相比，中间能暂停，需要和 yield 配合使用 generator 并不会直接执行，而是会创建一个 generator 对象，其中该对象的 next 方法用于继续执行，碰到 yield 就会停 12345678function *show()&#123; alert('a'); yield; alert('b');&#125;let genObj = show();genObj.next(); // agenObj.next(); // b yieldyield 既可以传参，又可以返回 12345678910function *show(num1, num2)&#123; alert(`$&#123;num1&#125;, $&#123;num2&#125;`); alert('a'); let a = yield; alert('b'); alert(a);&#125;let gen = show(99, 88);gen.next(12); // 第一个next没法给yield传参gen.next(5); // 会传给上面的yield，所以a=5 Promise 的局限性其实 generator 之所以出现也是因为纯 Promise 也有其自身的缺陷，并不能完全避免“回调陷阱”，而网上对于 Promise 的局限性解释很多，建议大家直接去看相关博客就可以了，而在我理解就是Promise 在解决数据依赖问题时避免不了“回调陷阱”，比如我需要根据数据 A 去请求数据 B，然后再根据数据 B 请求数据 C，然后再……，如果你自己用 Promis e实现一下的话就会发现这时候它的局限性所在；这也再一次证明了那句话：懒惰是最大生产力 ES7 预览ES6 还没掌握，ES7 都定稿了。。ES8 都有草案了。。，不过现在浏览器对 ES7 的支持很惨 数组 includes -&gt; 检查数组是否包含某元素 数组 keys/values/entries -&gt; 一般配合 for…of 使用，for…of 即对 value 的循环，entries 是对键值对的循环 求幂新操作符 -&gt; 3**8 === Math.pow(3, 8) 字符串的 padStart/padEnd 方法 -&gt; 补充空格或其他字符串 增加了函数容忍度 function show(a, b, c, ) -&gt; 不报错 async 和 await，这基本上是 ES7 最好用的。。用于替代 generator 和 yield ……","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"},{"name":"ES6","slug":"ES6","permalink":"http://merrier.wang/tags/ES6/"}]},{"title":"Hybrid设计与浅析","slug":"Hybrid设计与浅析","date":"2017-12-01T14:19:00.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20171201/hybrid-design-and-analysis.html","link":"","permalink":"http://merrier.wang/20171201/hybrid-design-and-analysis.html","excerpt":"","text":"慕课网视频——Hybrid设计的学习笔记，同时加入了一些自己的理解，希望通过本篇文章能够让你理解什么是 Hybrid，以及 Hybrid 有什么特点，同时还会简单介绍一下 Hybrid 开发时的注意事项。 什么是 HybridHybrid 和普通前端代码没差别，只不过宿主不一样，Hybrid 就是在 app 中运行的前端代码。 业内的 Hybrid App 携程 百度糯米 京东 天猫 微信 QQ 手机百度 支付宝 一般地，APP 开发方式有以下几种方式： Web App（浏览器网页） Native App（原生app） Hybrid App（ H5 混合app） 超级Hybrid（React Native、Weex） 微信/支付宝小程序（或内嵌页面） Hybrid 相比 Native 和纯 Html5 的优缺点 Native 与 H5 的职责 H5 做业务 Native 提供基础能力 Native 做好必须 Native 做的业务 H5 与 Native 通信JavascriptCore和 JS Bridge 类似 通过 URL Schema 通信App 主动与 H5 通信 将一组 API 绑定在 webview 的 window 对象上，App 通过 iOS/Android 原生方法调用 window 对象中的 js 方法 H5 主动与 App 通信 App 实现对 WebView URL 的观察者模式，H5 通过改变 URL 的哈希值，App 会通过解析哈希值的变化执行对应的操作","categories":[{"name":"慕课网","slug":"慕课网","permalink":"http://merrier.wang/categories/慕课网/"}],"tags":[{"name":"Hybrid","slug":"Hybrid","permalink":"http://merrier.wang/tags/Hybrid/"},{"name":"慕课网","slug":"慕课网","permalink":"http://merrier.wang/tags/慕课网/"}]},{"title":"浅谈搜索引擎（SEO）","slug":"浅谈搜索引擎（SEO）","date":"2017-11-30T14:47:40.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20171130/talking-about-seo.html","link":"","permalink":"http://merrier.wang/20171130/talking-about-seo.html","excerpt":"","text":"这是一篇视频笔记，最近看了幕课网上的视频——浅谈搜索引擎_SEO，同时结合了之前有位公司的同事分享的关于 SEO 的一些内容，可以说是基本上包含了 SEO 的全部内容了~ SEO 与 SEM 的区别SEO：Search Engine Optimization，搜索引擎优化，SEM：Search Engine Marketing，搜索引擎营销，因为价钱越高排名越靠前，所以也可以称为搜索引擎竞价 SEO 免费，SEM 付费 SEM 短，效益快、SEO 长期投入，增长慢 新广告法颁布之后 SEM 广告位减少、竞争压力大 IP、PV、UV IP：独立IP访问的用户 PV：页面浏览量或点击量 UV：独立访客数 搜索引擎占有率工具：statcounter SEO 的三个大方向 优化网站的内容 提升用户体验，吸引更多流量 优化网站结构，帮助搜索引擎抓取 虽然搜索引擎的算法，网站的技术不断更新，但是 SEO 的三个大的方向从未变过 SEO 优化最重要的三要素 标题（title，一般格式为内容-关键词-品牌词） 关键词（keywords，一般不超过 100 个字符） 描述（description，50-170 个字） title:一般会作为搜索结果的标题中，description:可能会被引用为搜索结果，也可能不会，keyowrds:由于很多网站无法准确提取关键词，一些网站恶意堆砌关键词，关键词的重要性已经在降低。 链接内链 提升网站内部页面抓取率 优化本站、提高流量 经典的内链网站为百度百科 外链外链是指网站与网站之间的链接向导，外链是提升权重的方式，互联网是链接与链接实现的一条网络，灌水式外链会让人头疼 友情链接交换注意事项和内容相近的网站交换 链接交换形式多样 单向链接：别人指向我或者我指向别人，而对方不指过来 双向链接：网站与网站之间互相交换链接 SEO建议 经常更新 质量 原创 关键词密度（2%~8%） 图文并茂 和SEO相关的HTML标签a 标签中的 nofollow1&lt;a rel=\"nofollow\"&gt;链接&lt;/a&gt; 作用：使链接指向的页面不影响本页权重，但不能保证搜索引擎不抓取，使用时机： 搜索引擎不需要抓取的页面，如登录、注册、付费等； 对页面没有正向权重的页面，如了解更多； 页面中的重复链接。 meta 中 robots 设置1&lt;meta name=\"robots\" content=\"index,follow\"&gt; noindex：不要索引此页面 nofollow：不要关注此页面的链接 noatchive：不要保存网页快照 nosnippet：不要此页面的描述 目前不是所有的搜索引擎都支持 robots，即使支持，也不是所有的字段都会遵守。 避免过度 SEO不要尝试欺骗搜索引擎 采用图片遮盖、透明度等方式隐藏文字 关键词、标题、描述和内容不符 避免抄袭 避免机器采集 有技巧的借鉴 购买外链，恶意交换友情链接 保证适量的外链和友情链接 不购买被百度惩罚了的网站的外链 移动端强引导下载冰心算法是专门用来打击移动端的强引导下载。不下载 app 就无法阅读网页全部内容被百度认为是最严重影响用户体验的行为 其他 《SEO实战密码》——堪称 SEO 必读书籍 seoWhy——关于 seo 的一个论坛 cnzz、百度统计、谷歌统计——流量统计网站 本博客用的就是 cnzz，因为流量比较小，所以看不出来和百度统计、谷歌统计比有哪些好处，而且这三家统计网站好像统计的标准都不相同，所以最好的方案就是放三套统计代码。。","categories":[{"name":"慕课网","slug":"慕课网","permalink":"http://merrier.wang/categories/慕课网/"}],"tags":[{"name":"慕课网","slug":"慕课网","permalink":"http://merrier.wang/tags/慕课网/"},{"name":"SEO","slug":"SEO","permalink":"http://merrier.wang/tags/SEO/"}]},{"title":"是时候为网易云音乐的评论打call了","slug":"是时候为网易云音乐的评论打call了","date":"2017-11-07T08:37:46.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20171107/comments-on-netease-cloud-music.html","link":"","permalink":"http://merrier.wang/20171107/comments-on-netease-cloud-music.html","excerpt":"","text":"如果你问我，用的最频繁的软件是什么？我的回答不会是微信 or QQ ，而是网易云音乐！是的，虽然从研究生开始才入了网易云音乐的坑，但是入了坑才发现之前的音乐播放器都是什么鬼东西啊我的天！而更吸引我的是网易云音乐的评论，一个纯粹的音乐软件竟然把评论系统做的如此有声有色实属不易；所以，是时候为网易云音乐的评论打 call 了！ 一生所爱（卢冠廷版）第一首给我最爱的《一生所爱》，最爱的电影《大话西游》和最喜欢的导演星爷 不戴金箍，如何救你；戴了金箍，如何爱你。 白晶晶爱的是孙悟空，爱白晶晶的是至尊宝，紫霞爱的是至尊宝，爱紫霞的是孙悟空，你以为是同一个人，其实已经相隔 500 年。 95 版此恨绵绵无绝期，15版曾经沧海难为水，时移、事易，不同心境而已。无悔，都是自己的回忆。有回忆，还是好的。有怨，还是未能免俗。世俗了，我能理解，不接受。 《大话西游》的结尾有句话，“你看那个人，好奇怪哟，象一条狗”。像条狗的人，是放弃了人间的男女情欢，无欲无念兢兢业业走在西天取经路上的至尊宝。他如你我这般，收起了脾气火气不再任性淘气，只顾奔波职场。人生百年，谁不曾大闹天宫，谁不曾头上紧箍，谁不曾爱上层楼，谁不曾孤单上路。 一生所爱（莫文蔚版）莫文蔚在天籁之战第八期上的翻唱版本，就像评论说的“兜兜转转，最终没有得到孙悟空的白晶晶又唱起了一生所爱，我想没有人会比她更适合翻唱这首歌了。” 想要救紫霞就必须打败牛魔王，想要打败牛魔王就必须要变成孙悟空，想要变成孙悟空就必须忘掉七情六欲从此不能再有半点沾染。人生就是这样：想自由地和心爱之人在一起必须要事业有成，想要事业有成就必须要抛弃天真戴上面具，当你变得有能力给心爱之人一切时，却发现找不回最初的自己亦失去了爱的能力。 白晶晶和紫霞都找到了如意郎君，只有至尊宝沉迷在“大话西游”的世界出不来。 “昨晚你念晶晶的名字98次，哦，晶晶是我的娘子，还有个叫紫霞的你念了784次，啊，这紫霞一定欠你很多钱。”之前以为这句台词只是为了搞笑 知乎上有个提问：为何我年龄越大，看周星驰的电影就越心酸？点赞数最高的答案结尾写道：究其原因，我们都变成了我们当初讨厌的模样。 “从此相逢，便是路人”——一致《一生所爱》 孟婆汤是否分六口，一口出世甜、二口叛逆辣、三口珍惜酸、四口情责苦、五口身心麻，最后一口却为白水，淡了口中味，忘了前尘事，泯了爱恩仇，舒了川字眉 每个男人都想当至尊宝有梦想的日子，简单快乐，却不得不戴上紧箍咒，变成齐天大圣，但你会失去很多，生活就是紧箍咒，社会就是牛魔王，父母就是唐僧，紫霞就是梦想，可是你却活的像条狗 I Wanna Fuck You额。。我英语不好。。 想草就直说，别披着爱情的虚伪 看到歌名我沉默了，我想了很久，还是同意了，来吧，阿肯，如果你不介意我是个男的话 有时候你想约个炮，却不小心谈了场恋爱；有时候你想好好谈个恋爱，却发现只是约了个炮。世界那么大，床却那么小，床上的两个人曾经那么好，却不能一起携手到老。我喜欢牵了手就能成婚的故事，却活在了一个上了床也没有结果的时代。 隔烟水（Cover 晃儿）歌手：暖阳/特曼，之前一直看不起古风类的歌曲，后来发现有些古风歌曲不管是词还是曲都还是蛮不错的。。 爹爹给我的基因也就只有美貌了 我只剩一百块了 我还是愿意花三十块钱打个车去找你 六十块钱买两张电影票再花八块钱给你买两杯奶茶 剩下两块钱自己坐公交车到银行 提三百万明天我们一起花 总有一天，你会碰到这样一个女孩，她温柔体贴，漂亮大方，不嫌你穷，不嫌你丑，不要你的钱，也不要你的车，也不要你。 Strength Of A Thousand Men自从听了几首纯音乐之后，日推就再也没有词了。。 尼玛 送快递 听这些音乐 感觉自己在护送核弹 别让 isis 看到这个歌单。。。 我要把中国的雾霾全吸干净 不要拦着我 借我三千虎骑，复我浩荡中华！ 饮马恒河畔，剑指天山西； 碎叶城揽月，库叶岛赏雪； 黑海之滨垂钓，贝加尔湖张弓； 中南半岛访古，东京废墟遥祭华夏列祖。 汉旗指处，望尘逃遁——敢犯中华天威者、虽远必诛; 爸妈，对不起，原谅我的不辞而别。我只是在床上听了这首音乐，感觉地球有灾难了，我必须站出来了！ 扶朕起来！朕还能再刷几十道高数！！ 步戏歌手：五音Jw 我此生遇到过三个戏子，第一个哥哥演绎的程蝶衣，一生戏痴，第二个二月红，以情入戏，第三个解语花，红妆倾城，从此入了戏，世间有朵解语花，凭谁解花语 这三个中有两个在三叔笔下 他们都有血有肉 对于我来说已经不只是一个书中的角色那么简单了 我本是听书人 奈何入戏太深——典狱司 讲真的，哪一天这歌很火了，他们就开始疯狂的刷评论，而我们这些老一辈的评论就有很重要的历史意义了，是我们帮他们打下江山，那时候我们早开始新的旅程了，而他们还刚开始。不知过了多久，他们便会发现，哪里都有我们的足迹 这么多年，他硬是将这身粉色穿出了杀气。 当这个歌没火的时候评论多半在说第几第几 坐等火 不火没道理之类的 火了之后人们才开始说歌词和故事 而没有故事的万年单身狗只能凭借一腔喜欢刷评论 简单而执着 瞎子无眼，却道破天机。 哑巴无言，却生死不弃。 戏子无情，却缘定倾心。 天真无邪，却阴谋算尽。 一身是血的他笑着嘲笑吴邪太天真，告诉他倒斗界里有规矩，不管同伴是谁都要先保自己，却忘了是谁一身伤仍披着沉重的盔甲，忍受着头发钻进伤口的痛苦，一步一步把吴邪带出山洞；忘了是谁还未了解计划的全部，就为了吴邪铤而走险，与强大的对手搏斗。他叫解雨臣，有着世界上最冰冷的温柔。 九九八十一 piano ver.评论的各位大佬真的是 666 “何谓孤寂？”“清风、艳日，无笑意。”“可否具体？”“左拥、右抱，无情欲。”“可否再具体？”“不得你。” “何谓思服？”“巧笑、含睇、山阿盼。”“可否具体？”“琴瑟、钟鼓、寤寐求。”“可否再具体？”“不见你。” “何谓无医？” “灵丹、妙药、救不急。”“可否具体”“华佗、仲景、摇头不语。”“可否再具体？”“思你成疾” “何谓绝色？”“长空，落日，江山雪。”“可否具体？”“青冥，残霞，天水一线。”“可否再具体？”“不如你” “何谓颓靡？” “功名、利禄、皆无趣。”“可否具体”“山珍、糟粕、食之如一。”“可否再具体？”“让我忘了你” “何谓遗世？”“流放，独立，无踪迹。”“可否具体？”“无情，冷梦，旧不记。”“可否再具体？”“他已弃。” “何谓怠惰?”“无痛，无痒，心惆怅”“可否具体”“淡欲，浅望，双眼迷离”“可否再具体”“心在轮回道” “何谓痴情？”“相思泪、千杯酒，是否再遇。”“可否具体？”“足荆棘、手玫瑰，只博一笑。”“可否再具体？”“爱上你。” “何为漂泊？”“飞蓬，飘萍，无根底。”“可否具体？”“只鹤，孤雁，寒塘独下迟。”“可否再具体？”“南游，东出，客愁，旅思，离乡千万里。”“可否更具体？”“春行，秋度，杳杳无归期。”“仍是不解。”“浪迹云游，何处寻你。” “何谓分裂？”“喜孤、厌闹、渴关注。”“可否具体？”“古风、电音、蒸汽波。”“可否再具体？”“欲卸网易却不舍。” 天空之城歌手：李志，其实蒋敦豪版本也不错。。 有次校园广播，一哥们说点一首天空之城送给他的港岛妹妹，于是响起了经典的久石让 这个高冷的人，关闭了微博评论，舞台上他很少话就一直唱啊唱，一曲又一曲，曲曲都肆意。起初不以为意，听久了才发现他是一个经得起单曲循环的歌者。 从今天起朝九晚五，早起早睡，作息规律，有法定休假，有保险，福利，有体面的工作，有规划有书有音乐，终于成为了普通人，和这座城市的所有人一样，不再奢望仗剑走天涯不再以梦为马，终于可以坦然的承认所有的不羁都将成为过去，都将随着公交车周而复始的轮回被淹没，一切，为了更好的生活。 人平均活到六十八岁，一共24820天，19万个小时，3500万分钟，差不多21亿秒左右，这10秒，你在读这段话，这十秒，你只属于我，我爱你陌生人 爱民谣的人是孤独的…05年许巍，06年朴树，07年李健，08年李志，09年绕十三，10年宋冬野，11年贰佰，12年左小祖咒，13年赵雷，14年王喂马，15年周云鹏……身边朋友都说我听的歌变态…是吗？也许这就是用心听歌与用耳听歌的区别吧… 梵高的爱人是一个妓女 他把所有的钱都用在画画和妓女身上 有一天妓女说想要梵高的耳朵 于是梵高真的把耳朵割下来 有了著名的梵高的自画像 但是当梵高把耳朵给了妓女的时候妓女吓的落荒而逃了 你看 为什么我把你想要的给了你 你还是走了 如果我爱你歌手：周冬雨/张一山，电视剧《春风十里，不如你》片头曲；“春风十里，不如你”，很喜欢这句话。 公交车上来两个初中生，他们聊天声音很轻，之间的距离也保持在刚好不会碰到彼此。男孩一直害羞低着头不看旁边的女生，女孩一直笑笑的听男生说话，他们一直偷偷瞟着对方。我突然心里柔软得想要笑着落泪，那样青涩又美好的时光，就像小时候偷喝了蜜糖，踩在云端，甜在心里，却再也回不来。✔很棒 如果我们不能结婚，你来当伴郎吧，因为我们也算是同走红地毯。后来我又想，如果我们不能结婚，你来砸我场、抢我走吧，我一定脱下高跟鞋，跟你私奔到天涯。后来仔细想想，算了，如果我们不能结婚，你别来了，我怕你什么都不做、却举杯祝我幸福。 “我喜欢你”四个字，在我肠子里饶了几个弯儿，在我胸口跌倒好几回，爬到我的喉咙里又开始胆怯，滑到我的嘴边又改头换面，最后乔装打扮成“你好吗”又或者是“你在干嘛” 逝年歌手：夏小虎，“时间似流水，催促我们长大，年轻的心有了白发，当初的人呐，你们如今在哪” 当所有人喜欢《董小姐》的时候，你听董小姐，当所以人热捧《南山南》的时候，你循环南山南，我说这些美丽你遇见的太晚了，你说我不懂流行，我笑你不懂民谣。仅此而已。 我有故事，你有酒嘛 逆流时光歌手：安图声乐队，第一次听这首歌的时候感觉没什么，第二次感觉还可以，就这样听了将近一百次。。 后来听说你混的风声水起 可我还是喜欢那个与世无争的你 如果我18岁， 我会喜欢这首歌。 好吧，其实我28岁也喜欢， 但是，我已经38岁了。 那又怎样，我48岁依旧爱这首歌。 一般般吧，我也就单曲循环了2个小时就换歌了。 愿你有高跟鞋也有跑鞋，喝茶也喝酒。愿你有勇敢的朋友，有牛逼的对手。愿你对过往的一切情深意重，但从不回头。愿你特别美丽，特别平静，特别凶狠，也特别温柔。 慢慢捱歌手：土不叔叔乐队/李柏凝，曲很简单，词也很简单，但是放在一起就不简单了 带着当初跟朋友借的200块买了一张火车票孤身一人出门闯荡，当时立志士不成名誓不还，闯过北京，去过上海，到过深圳，从当初的200块到30万，再到200万，500万，800万，再到现在的1300万，我没有任何炫富的意思，我只是想告诉大家，手机像素越高拍的照片越清晰。 网易诗人多如狗，可惜都没女朋友 生来平庸，茅屋未破衣暖饭饱。打量比较，陷于名利未圆其梦。前方泥沼，后有余埃。微笑苦笑，未知几年几日，死于荒谬。 一个歌手的情书歌手：周三/蔡健雅，从《红色高跟鞋》认识蔡健雅，然后就反复地听她的歌了 你不是赵雷的南方姑娘，不是马頔的傲寒，不是宋冬野的董小姐，不是李志的港岛妹妹，不是海龟的玛卡瑞纳，不是王威的她，不是贰佰的玫瑰，不是尧十三的北方女王，不是许巍的故乡，不是低苦艾的小花花，不是陈粒的祝星。不是周三情书里的那个心上人。你只是风尘中我恋恋不舍的姑娘。 她说民谣太穷了，一听就是一根烟，一听就是一瓶酒。而我只有一根烟了，还要撑一夜，只剩一点爱了，还要过一生。 别有天歌手：排骨教主，平常听古风类歌曲的话比较喜欢听排骨教主的，嗓音很特别 你说，十里桃花，两人一马； 后来，谢了繁华，生死无话。 你说，修起篱笆，闲话桑麻； 后来，岁至月腊，空负韶华。 你说，对坐饮茶，共看晚霞； 后来，惨淡月牙，心思暗哑。 你说，不恋戎马，归田卸甲； 后来，倾覆天下，一夜白发。 自古红尘多少人只欲寻仙问道超然去，却不知，总有仙人偶然窥见了人间华灯初上的光景，便甘愿从此坠入红尘中寻世间烟火、听市井俚歌，只为遇到一个萍水相逢的你。一场绮梦天涯，此生无悔。 采桑子 欧阳修 画船载酒西湖好， 急管繁弦， 玉盏催传， 稳泛平波任醉眠。 行云却在行舟下， 空水澄鲜， 俯仰留连， 疑是湖中别有天。 你，好不好？歌手：周兴哲，电视剧《遗憾拼图》片尾图，相信很多人听到这首歌都会有很多感受 有些异性不能拿来做恋人，却也舍不得给别人。 想让你吃醋，又怕你祝我幸福。 我戒烟了，没玩游戏了，每天不断的充实自己，我真的过的很好，你来看下我好不好 牙疼 你的喜糖就不吃了 不胜酒力 你的喜酒就不喝了 健忘 特别健忘 你叫什么就不记了 ​​ 朋友之间，千万别谈爱情，要么一生，要么陌生。 ブルーバード每当听到这首歌的时候就想起了火影，就像某条评论“虽然不会日语，但这首歌我差不多可以唱完。” 看火影那么多年，才知道。晓组织的十叛忍：佩恩，迪达拉，小南，鼬，绝，带土，鬼鲛，角都，飞段，蝎。代表了人类的十个梦想：和平，艺术，友情，亲情，统治，爱情，力量，金钱，宗教，童年。 此生无悔入火影，来世愿生木叶村 电影院里一个小孩问妈妈：“怎么这么多大人？大人也爱看动漫么？” 妈妈说“是看动漫的小孩都长大了” 看了那么多年火影，才知道木叶三忍，自来也，纲手，大蛇丸分别代表黄，赌，毒。 每次听到这歌，心中的火之意志在熊熊燃烧，尼玛我们村长太腐败了，劳资要推翻他，建立和平の村。 整个火影故事里，有人相信血统，有人相信精神，有人相信身体，有人相信眼睛，有人相信先天传承，有人相信后天努力。只有大蛇丸，他相信科学。 写在后面很荣幸你能看到最后（或者你直接就翻到最后了。。），现在网易云音乐对于我而言已经不再是一款单纯的音乐软件了，而是一种信仰！所以，我的网易云音乐账户叫 wangcongbug，欢迎大家关注我~（我收藏了很多好听到爆的歌曲，希望你也能喜欢~）： 歌单里又有很多歌变灰了，在版权面前，情怀仿佛变得不堪一击，但是，我不会选择离开，你会吗？","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"生活","slug":"life","permalink":"http://merrier.wang/tags/life/"},{"name":"网易云音乐","slug":"网易云音乐","permalink":"http://merrier.wang/tags/网易云音乐/"}]},{"title":"机器学习概念入门","slug":"机器学习概念入门","date":"2017-11-02T14:23:08.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20171102/introduction-to-machine-learning-concept.html","link":"","permalink":"http://merrier.wang/20171102/introduction-to-machine-learning-concept.html","excerpt":"","text":"最近在做毕设，需要用到一些机器学习的内容（不要问我为什么，做前端根本没办法毕业！），这篇文章是我看 bilibili 上莫烦系列教程-Tensorflow教程时候做的笔记，都是一些机器学习入门概念，如果你和我一样都是入门选手，我相信这些概念能够帮助到你~ 什么是机器学习机器学习是一帮计算机科学家想让计算机像人一样思考，所研发出来的计算机理论 机器学习分类监督学习有数据和标签 非监督学习只有数据，没有标签 半监督学习结合了监督学习和非监督学习 强化学习从经验中总结提升 遗传算法和强化学习类似，有着适者生存，不适者淘汰准则 什么是神经网络神经网络是一种数学模型，是存在于计算机的神经系统，由大量的神经元相连接并进行计算，在外界信息的基础上，改变内部的结构，常用来对输入和输出间复杂的关系进行建模。 神经网络由大量的节点和之间的联系构成，负责传递信息和加工信息，神经元也可以通过训练而被强化。 怎么检验神经网络为了检验、评价神经网络，并努力改善这些问题，我们常会把收集到的数据分为训练数据和测试数据，一般用于训练的数据可以是全部数据的百分之 70，剩下的百分之 30 可以用来测试学习结果。接着，对于神经网络的评价，基本上基于这百分之 30 的测试结果。 评价机器学习可以从误差这个值开始，随着训练时间的变长，优秀的神经网络能够预测到更精准的答案，预测的误差也会越小； 除了误差曲线，我们也可以看它的精确度曲线，最好的精度是趋向于百分之百的精度； 对于回归问题，我们可以采用 R2 score 作为评分标准； 还有 F1 score 用来测量不均衡数据的精度。 什么叫过拟合如下图，训练时的误差比测试误差小，神经网络虽然学习到了知识，但是对于训练数据太过依赖，所以测试数据产生的误差会产生波谷，后面会变大。 在机器学习中，解决过拟合的方法也有很多，比如 L1，L2正规化和 Dropout方法 什么是交叉验证交叉验证不仅可以用于神经网络的调参，还可以用于其他机器学习方法的调参，同样是选择你想观看的误差值或者精确度，不过横坐标不再是学习时间，而是你要测试的某一参数，比如说神经网络的层数。。 为什么要特征标准化我们在机器学习训练之前, 先对数据预先处理一下, 取值跨度大的特征数据, 我们浓缩一下, 跨度小的括展一下, 使得他们的跨度尽量统一，这样可以提升学习效率 通常用于 特征标准化的途径有两种, 一种叫做 min max normalization, 他会将所有特征数据按比例缩放到 0-1 的这个取值区间. 有时也可以是 -1 到 1 的区间. 还有一种叫做 standard deviation normalization, 他会将所有特征数据缩放成平均值为 0, 方差为 1. 使用这些标准化手段. 我们不仅可以快速推进机器学习的学习速度, 还可以避免机器学习学得特扭曲. 区分好用的特征在选择特征的时候,我们得要时刻回想起这三点.： 避免无意义的信息 避免重复性的信息 避免复杂的信息 这就是我们这次机器学习简介中所聊到的如何区分好用的特征 为什么需要激励函数因为现实中的问题往往不是线性的，所以需要一个激励函数来扭曲原来的线性结果 你甚至可以创造自己的激励函数来处理自己的问题, 不过要确保的是这些激励函数必须是可以微分的, 因为在 backpropagation 误差反向传递的时候, 只有这些可微分的激励函数才能把误差传递回去. 在少量层结构中, 我们可以尝试很多种不同的激励函数. 在卷积神经网络 Convolutional neural networks 的卷积层中, 推荐的激励函数是 relu. 在循环神经网络中 recurrent neural networks, 推荐的是 tanh 或者是 relu 如何加速神经网络训练越复杂的神经网络，越多的数据，我们需要在训练神经网络的过程上花费的时间也就越多；原因很简单，就是因为计算量太大了。可是往往有时候为了解决复杂的问题, 复杂的结构和大数据又是不能避免的, 所以我们需要寻找一些方法, 让神经网络聪明起来, 快起来. 包括以下几种模式: Stochastic Gradient Descent (SGD) Momentum AdaGrad RMSProp Adam 关于这几种方法的具体原理，可以点击这里观看莫烦的讲解 如何处理不均衡数据不均衡的数据预测起来很简单. 永远都猜多的那一方面准没错. 没错, 机器也懂这个小伎俩. 所以机器学到最后, 学乖了, 每次都预测多数派. 解决的方法有几种, 我们来谈谈. 方法一：想办法获取更多数据方法二：更换评判方式通常, 我们会用到准确率 accuracy, 或者误差 cost 来判断机器学习的成果. 可是这些评判方法在不均衡数据面前, 高的准确率和低的误差变得没那么重要. 所以我们得换一种方式评判. 通过 confusion matrix 来计算 precision 和 recall, 然后通过 precision 和 recall 再计算f1 score.这种方式能成功地区分不均衡数据, 给出更好的评判分数. 方法三：重组数据这是最简单粗暴的方法之一，重新组合不均衡数据，使之均衡。有两种方式： 复制或者合成少数部分的样本, 使之和多数部分差不多数量 砍掉一些多数部分, 使两者数量差不多 方法四：使用其他机器学习方法如果使用的机器学习方法像神经网络等, 在面对不均衡数据时, 通常是束手无策. 不过有些机器学习方法, 像决策树, decision trees 就不会受到不均很数据的影响. 方法五：修改算法最后一种方法是让自己变得有创造力, 尝试修改算法. 如果你用的是 Sigmoid 的激励函数, activation function, 他会有一个预测门槛, 一般如果输出结果落在门槛的这一段,预测结果为梨, 如果落在这一段, 预测结果为苹果, 不过因为现在的梨是多数派, 我们得调整一下门槛的位置，使得门槛偏向苹果这边, 只有很自信的时候, 模型才会预测这是苹果. 让机器学习,学习到更好的效果. 什么是批标准化和普通的数据标准化类似, 是将分散的数据统一的一种做法, 也是优化神经网络的一种方法. Batch normalization 的 batch 是批数据, 把数据分成小批小批进行 stochastic gradient descent. 而且在每批数据进行前向传递 forward propagation 的时候, 对每一层都进行 normalization 的处理 Batch normalization 也可以被看做一个层面. 在一层层的添加神经网络的时候, 我们先有数据 X, 再添加全连接层, 全连接层的计算结果会经过 激励函数 成为下一层的输入, 接着重复之前的操作. Batch Normalization (BN) 就被添加在每一个全连接和激励函数之间。 扩展阅读 一文学会用 Tensorflow 搭建神经网络","categories":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"},{"name":"机器学习","slug":"机器学习","permalink":"http://merrier.wang/tags/机器学习/"}]},{"title":"我为什么要写个人博客","slug":"我为什么要写个人博客","date":"2017-10-17T07:51:33.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20171017/why-do-i-write-blog.html","link":"","permalink":"http://merrier.wang/20171017/why-do-i-write-blog.html","excerpt":"","text":"之前看到了一篇文章：做为技术人员为什么要写博客，作者写的很真诚，也说出了很多技术人员的心声，然后，我后来又看到了一篇文章：为什么有些技术人员不写博客？，这篇文章篇幅较短，虽然看题目好像是一篇介绍“不写博客”的，但是看完之后才发现，其实作者还是推荐大家写博客。。作为众多拥有个人博客的技术人员之一，我也斗胆谈一下我为什么要写个人博客？ 初衷其实我从小学开始就喜欢收藏和总结，记得小学的时候流行那种或圆形或方形的卡片，我就收藏了很多；然后初中之后就收藏烟盒（这个习惯到目前还有）；后来到大学之后，和计算机打交道比较多，就将一些好用的软件和工具记录下来；研究生期间开始做前端，看到写的好的技术类文章就保存到有道云笔记里，虽然有些可能一直放在里面后来再也没看过。。 所以，其实总结和个人习惯是密切关联的，这也是我写博客的初衷。 导火线虽然写博客的想法很早之前就有，但是就像上面那两篇文章里说的，那时候觉得自己水平有限，就算写出来恐怕也是哗众取宠，无人问津罢了，同时也不知道是去某个平台写还是自己搭建一个网站，这件事情就暂时搁置了；后来到研二的时候，需要找实习了，而前端知识繁杂，找实习之前脑子里还一头雾水，就打算趁着这个机会把当初那个小愿望实现了吧。。 淫僧就是如此的奇妙，找实习就成为了我写博客的导火线。 wordpress？关于为什么用 wordpress 搭建而不是去某些平台或者用其他工具，我在之前的一篇文章：Merrier说？已经简单介绍过了，所以在这篇文章里我就再讲一遍凑字数了： 其实，目前有很多现成的博客平台，我在写博客之前也了解了一些，而最终没有选择大平台的原因是： 被动：虽然有很多博客平台，但是也有一些平台都已经死气沉沉半死不活了，所以不能确保现在你选择的某个平台能否一直活下去，如果突然某一天，你选择的某个平台停止维护了而又没办法导出数据的话，那简直就是“叫天天不应，叫地地不灵”了 不安全：虽然我们现在已经身处一个“没有隐私”的世界，但是这种意识还是要有的，而如果选择平台的话，你发的文章都会存储在别人的数据库中，同时你的一些行为也会被记录下来，不得不说，这确实是不安全的 缺乏灵活性：其实我是喜欢定制化的东西的，而平台的话会受到许许多多的制约，比如你想添加某个插件或者改变网站的背景颜色，估计是做不到的 所以基于以上原因，我最终选择自己搭建博客，而选择 wordpress 的原因很简单，毕竟 wordpress 在业界已经拥有统治地位了，值得信赖。 建议前面可能对你的作用不是很大，那么下面我就说一下在个人博客这件事情上我的建议，如果能够对你所有帮助是再好不过的了： 通过平台搭建或者个人搭建各有利弊，一定要考虑清楚；上面我已经介绍了平台搭建的弊端，而个人搭建的话相对来说会更麻烦，需要你对服务器、域名等知识也有所了解，会有一定的学习成本，同时日常的维护也会比现成平台繁琐 写博客贵在坚持；如果你写过技术类博客的话，你肯定会有所感触：写一篇文章往往需要几个小时甚至几天的时间，你需要阅读大量相关资料，同时还有可能需要写domo、敲代码，这无疑会占用你大量的业余时间，在写博客之前要有心理准备 心态放平稳；对于每一个博客作者而言，如果自己写的东西受到更多人关注那肯定是一件好事，而其实大部分人写的文章是很少有人看到的，这种现象的造成会有很多原因，有个人的原因（文章质量、SEO等），也有外界的原因（墙、技术迭代很快）；但是“事在人为”，一定要放平心态，即使现在访问量/阅读量很少，相信坚持下去你肯定会收货很多读者 总结说了这么多，总结成一句话就是： 有些事情你现在不去做，可能以后都不会有机会了！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://merrier.wang/categories/杂谈/"}],"tags":[{"name":"生活","slug":"life","permalink":"http://merrier.wang/tags/life/"}]},{"title":"杂谈系列","slug":"杂谈系列","date":"2017-10-17T06:02:51.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20171017/chat-series.html","link":"","permalink":"http://merrier.wang/20171017/chat-series.html","excerpt":"","text":"这个系列的文章大多数都是我的所想所感，大部分和技术关联不大，或感概或吐槽或叙述，反正就是想到什么就会写点什么，毕竟博客的意义就在于此嘛。。当然，因为平时喜欢看一些东西，发现了一些不错的文章/视频，参见他山之石，可以攻玉，好文章推荐和推荐一些视频。以下文章按照发布时间倒叙排列： 不想当诗人的程序员不是好工程师 身在IT界，不能不知道这些名词 总有那么一句话…… 写给刚接触前端的你 Merrier说？","categories":[{"name":"系列专栏","slug":"series","permalink":"http://merrier.wang/categories/series/"}],"tags":[]},{"title":"读书笔记系列（9）——你不知道的JavaScript（上卷）","slug":"读书笔记系列（9）——你不知道的JavaScript（上卷）","date":"2017-10-10T11:42:12.000Z","updated":"2019-01-17T13:21:55.962Z","comments":true,"path":"20171010/you-dont-know-js-volume1.html","link":"","permalink":"http://merrier.wang/20171010/you-dont-know-js-volume1.html","excerpt":"","text":"这本书在 github 上很火，而中文译本迟迟没有发行，最近出了中卷，我很早之前就听说了该大作，然而一直没有时间拜读，现在实习告一段落了，终于可以静下心来品味经典了。 作用域是什么在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析将字符串分解成有意义的代码块，这些代码块被称为词法单元（token），例如：var a = 2;，会被分解为下面这些词法单元：var、a、=、2、； 解析/语法分析将语法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，被称为“抽象语法树”（AST）。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier (它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。 代码生成将 AST 转换为可执行代码。简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。 然而，比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。 对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内。 理解作用域首先介绍将要参与到对程序 var a = 2; 进行处理的过程中的演员们。 引擎从头到尾负责整个 JavaScript 程序的编译及执行过程。 编译器引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。 作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 变量的赋值操作变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。（我们在面试时会经常遇到变量为undefined的问题，其实就是这个道理） 编译器有话说当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。 讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。 引擎和作用域的对话123function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 ); 让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。 引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。引擎:哥们太够意思了!好吧，我来执行一下 foo。引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。作用域:放心吧，这个变量没有变动过，拿走，不谢。 引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。 …… 小结JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤: 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，但是如果对结果的操作是非法或不合理的，会抛出 TypeError 异常，或者直接抛出 ReferenceError 异常(严格模式下)。 词法作用域变量查找全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。 window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”(也可以说欺骗)词法作用域呢? JavaScript 中有两种机制来实现这个目的。 eval with 欺骗词法作用域会导致性能下降。 eval在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。 在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。 1234567function foo(str) &#123; \"use strict\"; eval( str ); console.log( a ); // ReferenceError: a is not defined &#125; foo( \"var a = 2\" ); JavaScript 中还有其他一些功能效果和 eval(..) 很 相 似。setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们! new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。 withwith 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。with 的副作用通过一个简单的例子就可以看到： 123456789101112131415161718function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a ); // 2foo( o2 );console.log( o2.a ); // undefinedconsole.log( a ); // 2——不好，a 被泄漏到全局作用域上了! with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 结合上面的例子，o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a=2 执行时，自动创建了一个全局变量(因为是非严格模式)。 性能如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。 函数作用域和块作用域函数中的作用域函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。 全局命名空间某些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中： 123456789var MyReallyCoolLibrary = &#123; awesome: \"stuff\", doSomething: function() &#123; // ... &#125;, doAnotherThing: function() &#123; // ... &#125; &#125;; 匿名和具名123setTimeout( function() &#123; console.log(\"I waited 1 second!\");&#125;, 1000 ); 这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 然而，匿名函数也有几个缺点： 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 综合考虑而言，始终给函数表达式命名是一个最佳实践（下面的例子叫做行内函数表达式）： 123setTimeout( function timeoutHandler() &#123; // &lt;-- 快看，我有名字了! console.log( \"I waited 1 second!\" );&#125;, 1000 ); 立即执行函数表达式立即执行函数表达式（IIFE）有两种形式： (function foo(){ .. })() (function foo(){ .. }()) 这两种形式在功能上是一致的，选择哪个全凭个人喜好。 IIFE的用途把它们当做函数调用并传递参数进去：1234567var a = 2;(function IIFE( global ) &#123; var a = 3; console.log( a ); // 3 console.log( global.a ); // 2&#125;)( window );console.log( a ); // 2 解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined: 1234567undefined = true; // 给其他代码挖了一个大坑!绝对不要这样做! (function IIFE( undefined ) &#123; var a; if (a === undefined) &#123; console.log( \"Undefined is safe here!\" ); &#125;&#125;)(); 倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去12345678var a = 2;(function IIFE( def ) &#123; def( window );&#125;)(function def( global ) &#123; var a = 3; console.log( a ); // 3 console.log( global.a ); // 2&#125;); 函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。 块作用域块作用域的例子： withwith就是块作用域的一个例子（形式），用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效 try/catchtry/catch 是 ES3 的规范，而很少有人注意到，catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效 尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境(除了老 版本的 IE 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。 letES6 引入的 let 关键字可以将变量绑定到所在的任意作用域中(通常是{ .. }内部)。换句话说，let 为其声明的变量隐式地了所在的块作用域。 但是，let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”： 1234&#123; console.log( bar ); // ReferenceError! let bar = 2;&#125; constES6 还引入了 const，同样可以用来创建块作用域变量，但是其值是固定的 提升先有鸡还是先有蛋首先，抛出两个例子，也是很经典的JS的“坑”： 123456a = 2;var a; console.log(a); // 2console.log(a); // undefined var a = 2; 关于这一奇怪现象，可以用一句话概括：包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理 当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个——声明:var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。 换句话说，先有蛋（声明）后又鸡（赋值）；所以上面的两个例子会以如下形式进行处理： 例子一：（第一部分是编译，第二部分是执行） 123var a;a = 2; console.log(a); 例子二： 123var a;console.log(a);a = 2; 再举一个例子： 1234foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123; // ...&#125;; 这段程序中的变量标识符 foo() 被提升并分配给所在作用域(在这里是全局作用域)，因此foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式，那么就会赋值)。foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。 从上面的例子，我们还可以得出：函数声明会被提升，但是函数表达式不会被提升 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。考虑下面的例子： 12345678910foo(); // 3function foo() &#123; console.log(1);&#125;var foo = function() &#123; console.log(2);&#125;;function foo() &#123; console.log(3);&#125; 上面的例子会被引擎理解为如下形式： 1234function foo() &#123; console.log(3);&#125;foo(); // 3 从这两段代码我们可以得出两个结论： var foo 尽管出现在 function foo()…的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。 尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。 作用域闭包老生常谈，闭包是什么划重点：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 这一部分之前已经讲了很多次了，感觉这本书也没有很多新意，所以想了解闭包的童鞋可以参见我的另一篇文章：前端面试系列（10）——JS中的闭包 不太显性的闭包其实，你已经写过的代码中一定到处都是闭包的身影。 setTimeout123456function wait(message) &#123; setTimeout(function timer() &#123; console.log(message); &#125;, 1000 );&#125;wait(\"Hello, closure!\"); 将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域 的闭包，因此还保有对变量 message 的引用。wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..) 作用域的闭包。 jQuery 或其他 JS 框架1234567function setupBot(name, selector) &#123; $( selector ).click( function activator() &#123; console.log( \"Activating: \" + name ); &#125;);&#125;setupBot( \"Closure Bot 1\", \"#bot_1\" );setupBot( \"Closure Bot 2\", \"#bot_2\" ); 本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包! IIFE1234var a=2;(function IIFE() &#123; console.log( a );&#125;)(); 虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么?因为函数(示例代码中的 IIFE)并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行(而外部作用域，也就是全局作用域也持有 a)。a 是通过普通的词法作用域查找而非闭包被发现的。 尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。 块作用域和闭包一道很经典的面试题： 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 这段代码在运行时会以每秒一次的频率输出五次 6，具体原因就不再赘述了。。而如果我们想让他连续输出1 2 3 4 5应该怎么办呢？有两种方法: 利用闭包1234567for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)(i);&#125; 闭包+块作用域12345for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 模块模块有两个主要特征： 为创建内部作用域而调用了一个包装函数; 包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览器或引擎有一个默认的“模块加载器”(可以被重载，但这远超出了我们的讨论范围)可以在导入模块时异步地加载模块文件。 模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。 动态作用域与词法作用域下面一段代码很有意思： 123456789function foo() &#123; console.log( a ); // 2(不是3!)&#125;function bar() &#123; var a = 3; foo(); &#125;vara=2;bar(); 如果 JS 是动态作用域，上面将会输出 3，因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。 需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 关于this误解有两种常见的对于this的解释，但是它们都是错误的： 指向自身人们很容易把 this 理解成指向函数自身，然而如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符(变量)来引用它。 思考一下下面这两个函数： 123456function foo() &#123; foo.count = 4; // foo 指向它自身&#125;setTimeout( function()&#123; // 匿名(没有名字的)函数无法指向自身&#125;,10); 第一个函数被称为具名函数，在它内部可以使用 foo 来引用自身。 但是在第二个例子中，传入 setTimeout(..) 的回调函数没有名称标识符(这种函数被称为匿名函数)，因此无法从函数内部引用自身。 它的作用域第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。 每当你想要把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。 this到底是什么this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。 this全面解析调用位置在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置(而不是声明的位置)；然而做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。 下面通过一个例子来看看到底什么是调用栈和调用位置： 1234567891011121314151617181920function baz() &#123; // 当前调用栈是:baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar 的调用位置 &#125;function bar() &#123; // 当前调用栈是 baz -&gt; bar // 因此，当前调用位置在 baz 中 console.log( \"bar\" ); foo(); // &lt;-- foo 的调用位置&#125;function foo() &#123; // 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中 console.log( \"foo\" );&#125;baz(); // &lt;-- baz 的调用位置 绑定规则我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。 默认绑定12345function foo() &#123; console.log( this.a );&#125;vara = 2;foo(); // 2 this.a 被解析成了全局变量 a。为什么?因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此this会绑定到 undefined 这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只有foo()运行在非strict mode下时，默认绑定才能绑定到全局对象；严格模式下与foo() 的调用位置无关： 123456789function foo() &#123; console.log( this.a );&#125;var a = 2;(function()&#123; \"use strict\"; foo(); // 2&#125;)(); 隐式绑定另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。 12345678function foo() &#123; console.log( this.a );&#125;var obj=&#123; a: 2, foo: foo&#125;;obj.foo(); // 2 调用位置会使用 obj 上下文来引用函数，因此你可以说函数foo被调用时 obj 对象“拥有”或者“包含”它。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说: 123456789101112function foo() &#123; console.log( this.a );&#125;var obj2 = &#123; a: 42, foo: foo&#125;;var obj1 = &#123; a: 2, obj2: obj2&#125;;obj1.obj2.foo(); // 42 显示绑定可以使用函数的 call(..) 和 apply(..) 方法。这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。 1234567function foo() &#123; console.log( this.a );&#125;var obj = &#123; a:2&#125;;foo.call( obj ); // 2 通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现在其他的参数上，但是现在我们不用考虑这些。 硬绑定 12345678910111213function foo() &#123; console.log( this.a );&#125;var obj = &#123; a:2&#125;;var bar = function() &#123; foo.call( obj );&#125;;bar(); // 2setTimeout( bar, 100 ); // 2// 硬绑定的 bar 不可能再修改它的 thisbar.call( window ); // 2 无论我们如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype. bind，它的用法如下： 12345678910function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125;var obj = &#123; a:2&#125;;var bar = foo.bind( obj );var b = bar(3);//23console.log( b ); // 5 bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。 new绑定JS 中 new 的机制和面向类的语言完全不同：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作： 创建(或者说构造)一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 一个简单的例子来解释 new 绑定： 12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。 优先级（原书中通过很多例子得到了上面四种绑定方式的优先级，这里就不再赘述了。。） 我们可以按照下面的顺序来进行判断： 函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。 var bar = new foo() 函数是否通过 call、apply(显式绑定)或者硬绑定调用?如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo() 然而，凡事总有例外。 绑定例外在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用的可能是默认绑定规则。 被忽略的this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则: 12345function foo() &#123; console.log( this.a );&#125;vara=2;foo.call( null ); // 2 一般，如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择。 然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。 划重点：Object.create(null)和{}很像，但是并不会创建Object.prototype 这个委托，所以它比 {}“更空” 间接引用你有可能(有意或者无意地)创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。而间接引用最容易在赋值时发生： 12345678function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a:3, foo: foo&#125;;var p = &#123; a:4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。 软绑定硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。 下面是一种被称为软绑定的方法，有时间的话可以研究一下： 12345678910111213141516if (!Function.prototype.softBind) &#123; Function.prototype.softBind = function(obj) &#123; var fn = this; // 捕获所有 curried 参数 var curried = \\[\\].slice.call( arguments, 1 ); var bound = function() &#123; return fn.apply( (!this || this === (window || global)) ? obj : this curried.concat.apply( curried, arguments ) ); &#125;; bound.prototype = Object.create( fn.prototype ); return bound; &#125;;&#125; this语法ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。 123456789101112131415function foo() &#123; // 返回一个箭头函数 return (a) =&gt; &#123; //this 继承自 foo() console.log( this.a ); &#125;;&#125;var obj1 = &#123; a:2&#125;;var obj2 = &#123; a:3&#125;;var bar = foo.call( obj1 );bar.call( obj2 ); // 2, 不是3! foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不 行!) 对象语法对象可以通过两种形式定义:声明(文字)形式和构造形式。 文字形式（对象字面量）1234var myObj = &#123; key: value // ... &#125;; 构造形式12var myObj = new Object();myObj.key = value; 构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键值对，但是在构造形式中你必须逐个添加属性。 类型在 JavaScrip t中一共有六种主要类型（语言类型）： string number boolean null undefined object 简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。 null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 “object”。实际上，null 本身是基本类型。 原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。 内置对象JavaScript 中还有一些对象子类型，通常被称为内置对象。 String Number Boolean Object Function Array Date RegExp Error 自动转换123var strPrimitive = \"I am a string\";console.log( strPrimitive.length ); // 13console.log( strPrimitive.charAt( 3 ) ); // \"m\" 使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。同样的事也会发生在数值字面量上 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式（只能通过 new Date() 创建一个 Date 对象）。 内容12345var myObject = &#123; a:2&#125;;myObject.a; // 2myObject\\[\"a\"\\]; // 2 .a 语法通常被称为“属性访问”，[“a”] 语法通常被称为“键访问”。这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法： 123456789var myObject = &#123; &#125;;myObject\\[true\\] = \"foo\";myObject\\[3\\] = \"bar\";myObject\\[myObject\\] = \"baz\";myObject\\[\"true\"\\]; // \"foo\"myObject\\[\"3\"\\]; // \"bar\"myObject\\[\"\\[object Object\\]\"\\]; // \"baz\" 数组数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性： 1234var myArray = \\[ \"foo\", 42, \"bar\" \\];myArray.baz = \"baz\";myArray.length; // 3myArray.baz; // \"baz\" 可以看到虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，数组的 length 值并未发生变化。但是，如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标(因此会修改数组的内容而不是添加一个属性)： 12345var myArray = \\[ \"foo\", 42, \"bar\" \\];myArray\\[\"4\"\\] = \"baz\";myArray.length; // 5myArray\\[4\\]; // \"baz\"myArray\\[3\\]; // undefined Object.defineProperty在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。 12345678910var myObject = &#123;&#125;;Object.defineProperty( myObject, \"a\", &#123; value: 2, writable: true, configurable: true, enumerable: true&#125;);myObject.a; // 2 不变性有时候你会希望属性或者对象是不可改变(无论有意还是无意)的，在 ES5 中可以通过很多种方法来实现： 对象常量结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性(不可修改、重定义或者删除): 123456var myObject = &#123;&#125;;Object.defineProperty( myObject, \"FAVORITE_NUMBER\", &#123; value: 42, writable: false, configurable: false&#125;); 禁止扩展如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..)： 123456var myObject = &#123; a:2&#125;;Object.preventExtensions( myObject );myObject.b = 3;myObject.b; // undefined 密封Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable: false。 所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。 冻结Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable: false，这样就无法修改它们的值。 这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。 数组上不要用for..in循环在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。 遍历ES5中增加了一些数组的辅助迭代器： forEach(..)：遍历数组中的所有值并忽略回调函数的返回值 every(..)：会一直运行直到回调函数返回 false some(..)：会一直运行直到回调函数返回 true 混合对象“类”类的机制构造函数类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息(状态)。 类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。 JS中的类在传统的面向类的语言中 super 有一个功能，就是从子类的构造函数中通过 super 可以直接调用父类的构造函数。通常来说这没什么问题，因为对于真正的类来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——实际上“类”是属于构造函数的(类似 Foo.prototype… 这样的类型引用)。由于JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用 注: 其实这一部分还蛮重要的，而原文也通过比较大量的篇幅对JS中的“类”进行了介绍，只不过我感觉没有什么与众不同之处就略过了，对这一部分还不太熟悉的童鞋可以自己研究一下。。 原型[[Prototype]]JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。 而[[Prototype]]的作用是：对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链： 123456var anotherObject = &#123; a:2&#125;;// 创建一个关联到 anotherObject 的对象var myObject = Object.create( anotherObject );myObject.a; // 2 使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到(并且是 enumerable)的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链(无论属性是否可枚举) Object.prototype所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。由于所有的“普通”(内置，不是特定主机的扩展)对象都“源于”(或者说把 [[Prototype]] 链的顶端设置为)这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。 属性屏蔽如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为myObject.foo 总是会选择原型链中最底层的 foo 属性。 12345678910111213141516var anotherObject = &#123; a:2&#125;;var myObject = Object.create( anotherObject );anotherObject.a; // 2myObject.a; // 2anotherObject.hasOwnProperty( \"a\" ); // truemyObject.hasOwnProperty( \"a\" ); // falsemyObject.a++; // 隐式屏蔽!anotherObject.a; // 2myObject.a; // 3myObject.hasOwnProperty( \"a\" ); // true 尽管 myObject.a++ 看起来应该(通过委托)查找并增加 anotherObject.a 属性，但是别忘了++操作相当于myObject.a = myObject.a + 1。因此++操作首先会通过[[Prototype]]查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐! “类”“类”函数所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象： 1234function Foo() &#123; // ...&#125;Foo.prototype; // &#123; &#125; 这个对象通常被称为 Foo 的原型，然而，如果是我的话就 会叫它“之前被称为 Foo 的原型的那个对象”。好吧我是开玩笑的，你觉得“被贴上‘Foo 点 prototype’标签的对象”这个名字怎么样？最直接的解释就是，这个对象是在调用new Foo()时创建的，最后会被(有点武断地)关联到这个“Foo 点 prototype”对象上。 继承与原型继承意味着复制操作，JavaScript(默认)并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。委托(参见第 6 章)这个术语可以更加准确地描述 JavaScript 中对象的关联机制。 构造函数还是调用在JS中，new 会劫持所有普通函数并用构造对象的形式来调用它。换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 constructor 并不表示被构造function Foo() { / .. / }Foo.prototype = { / .. / }; // 创建一个新原型对象var a1 = new Foo();a1.constructor === Foo; // false! a1.constructor === Object; // true! a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性(不过默认的 Foo.prototype 对象有这个属性!)，所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。 a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。 （原型）继承Object.setPrototypeOf(…)ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联： 1234// ES6 之前需要抛弃默认的 Bar.prototypeBar.ptototype = Object.create( Foo.prototype );// ES6 开始可以直接修改现有的 Bar.prototype Object.setPrototypeOf( Bar.prototype, Foo.prototype ); 对象关联[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。 这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。 行为委托委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。下面是一个例子： 1234567891011121314151617181920Task = &#123; setID: function(ID) &#123; this.id = ID; &#125;, outputID: function() &#123; console.log( this.id ); &#125;&#125;;// 让XYZ委托TaskXYZ = Object.create( Task );XYZ.prepareTask = function(ID,Label) &#123; this.setID( ID ); this.label = Label;&#125;;XYZ.outputTaskDetails = function() &#123; this.outputID(); console.log( this.label );&#125;;// ABC = Object.create( Task );// ABC ... = ... 在上面这段代码中，Task 和 XYZ 并不是类（或者函数），它们是对象。XYZ 通过 Object. create(..) 创建，它的 [[Prototype]] 委托了 Task 对象 互相委托（禁止）你无法在两个或两个以上互相(双向)委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。如果你引用了一个两边都不存在的属性或者方法，那就会在 [[Prototype]] 链上产生一个无限递归的循环。 所以互相委托是被禁止的。 调试JavaScript 规范并不会控制浏览器中开发者工具对于特定值或者结构的表示方式，所以浏览器和工具的解析结果并不一定相同。下面是一个例子： 123function Foo() &#123;&#125;var a1 = new Foo(); a1; // Foo &#123;&#125; 这段代码在chrome中会输出：Foo {}；而在Firefox中会得到Object {} Chrome 实际上想说的是“{} 是一个空对象，由名为 Foo 的函数构造”。Firefox 想说的是“{} 是一个空对象，由 Object 构造”。之所以有这种细微的差别，是因为 Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性，但是其他浏览器并不会跟踪这些额外的信息。 然而，这个行为被认定是 Chrome 的一个 bug，当你读到此书时，它可能已经被修复了。所以你看到的可能是 1a1; // Object &#123;&#125;。 类与对象相比“类”的构造方式，对象关联可以更好地支持关注分离（separation of concerns）原则，创建和初始化并不需要合并为一个步骤。 对象关联除了能让代码看起来更简洁(并且更具扩展性)外还可以通过行为委托模式简化代码结构。 更好的语法在 ES6 中，你可以使用对象的字面形式(这样就可以使用简洁方法定义)来改写之前繁琐的属性赋值语法(比如 AuthController 的定义)，然后用 Object.setPrototypeOf(..) 来修改它的 [[Prototype]]: 1234567891011121314// 使用更好的对象字面形式语法和简洁方法 var AuthController = &#123; errors: \\[\\], checkAuth() &#123; // ... &#125;, server(url, data) &#123; // ... &#125; // ... &#125;;// 现在把 AuthController 关联到 LoginControllerObject.setPrototypeOf( AuthController, LoginController ); 内省自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。 在 js 中，instanceof 语法会产生语义困惑而且非常不直观。如果你想检查对象 a1 和某个对象的关系，那必须使用另一个引用该对象的函数才行——你不能直接判断两个对象是否关联。 123456function Foo() &#123; /* .. */ &#125;function Bar() &#123; /* .. */ &#125;Bar.prototype = Object.create( Foo.prototype ); // 让Foo和Bar互相关联Bar.prototype instanceof Foo; // trueBar instanceof Foo; // false 然而，又回到上面的那个问题，如果通过对象关联的方式构造对象，内省的方法将更加简洁并且清晰： 12345678910var Foo = &#123; /* .. */ &#125;;var Bar = Object.create( Foo ); // 让Foo和Bar互相关联var b1 = Object.create( Bar ); // 让b1关联到Foo和BarFoo.isPrototypeOf( Bar ); // true Object.getPrototypeOf( Bar ) === Foo; // trueFoo.isPrototypeOf( b1 ); // true Bar.isPrototypeOf( b1 ); // true Object.getPrototypeOf( b1 ) === Bar; // true 附录ES6中的Class除了语法更好看之外，ES6 还解决了什么问题？ （基本上）不再引用杂乱的 .prototype 了； 不再需要通过 Object.create(..) 来替换 .prototype 对象，也不需要设置 .__proto__ 或者 Object.setPrototypeOf(..)； 可以通过 super(..) 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法； class 字面语法不能声明属性(只能声明方法)。看起来这是一种限制，但是它会排除掉许多不好的情况，可以帮助你避免犯错； 可以通过 extends 很自然地扩展对象(子)类型，甚至是内置的对象(子)类型，比如 Array 或 RegExp。 然而，class 语法并没有解决所有的问题，你可能会认为 ES6 的 class 语法是向 JavaScript 中引入了一种新的“类”机制，其实不是这样。class 基本上只是现有 [[Prototype]](委托!)机制的一种语法糖。 也就是说，class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你 (有意或无意)修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托。 除此之外，class 还有以下问题： class 语法无法定义类成员属性（只能定义方法）； class 语法仍然面临意外屏蔽的问题； super 并不是动态绑定this的，它会在声明时“静态”绑定。（可以通过 toMethod(…) 手动修改 super 绑定） 综上，class 最大的问题在于，像传统的类一样)它的语法有时会让你认为，定义了一个 class 后，它就变成了一个(未来会被实例化的)东西的静态定义。你会彻底忽略 C 是一个对象，是一个具体的可以直接交互的东西。 ES6 的 class 想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让 JavaScript 更加难以理解。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/categories/笔记/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"推荐一些视频","slug":"推荐一些视频","date":"2017-10-07T14:10:49.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20171007/recommend-some-videos.html","link":"","permalink":"http://merrier.wang/20171007/recommend-some-videos.html","excerpt":"","text":"平时很喜欢看一些东西，当然不局限于前端，而相比文字而言，更喜欢看视频，尤其是有了“弹幕”这个神奇的东东之后，在这里就推荐一些我看过的有趣的视频，有些是技术类的，也有些是搞笑片段或纪录片，闲暇之余仅供娱乐。 技术类Javascript作者接受采访视频从知乎上看到的，之前就听说过JS是一位大神用 10 天时间赶出来的。。虽然目前看来JS存在很多问题和很多坑，但是10天写出一门风靡全球的语言也是一件很伟大的事情了。。 浏览器的背后（续）浏览器其实有很多可以探讨的东西，同时也是笔试面试时的常客，这个视频来自优酷，虽然有个“续”字，但是我并没有找到前面的视频啊我勒个擦？！ 动画设计的12原则在看文章-给用户界面添加缓和效果(Easing Curves)时发现的一个视频，其实设计动画的初衷是为了对用户更“亲切”，所以动画设计的原则就是要满足现实世界中的物理学规则，而该视频就是对该原则的总结，视频来自Youtube，所以需要fq，文字版的在这里，除此之外你能在 Codepen 找到它们全部的开源 HTML 和 CSS 代码。 Maxoden的演讲视频Maxoden 是Voxel.js（一个在浏览器里运行的 Minecraft 框架）的作者，而他也借此做了一个 Minecraft 风格的展示他自己项目的页面，是一个很有探索精神的前端工程师。 What the heck is the event loop anywayPhilip Roberts 的演讲视频:，主题为《什么是 JavaScript 中的事件循环》，收到了广泛好评，对 event loop 仍然存在疑问的童鞋可以花半小时看一下，当然，如果你更喜欢文字版的，可以移步掘金上的这篇演讲译文 像素的一生Life of a Pixel - Steve KobesYoutube 上关于像素的演讲，从微博上看到的，也有很多同事反馈讲的不错，关键是还有中英文双语字幕，这对于我这种英文水平不是很高的人说来说不能再贴心。 Getting Started with ReduxRedux 作者出的入门教学视频，不过非常贴心的配了字幕。 剧集类《国家宝藏》系列央视：你爸爸还是你爸爸。节目集结了以故宫博物院为首的九大博物馆，每个博物馆选出三件文物组内 battle，每件文物都有一位明星守护人来讲述这件文物前世今生的故事。总之吧，你要是不跪着看完请来打我…… 地下交通站这是一部拿鬼子和汉奸做包袱的国产情景喜剧，豆瓣评分 9.0，包袱无处不在，堪称国产神作，不过笑点低的就算了吧，别再笑岔过去- - 演讲类玉伯在2017SEE Conf大会上的演讲视频&amp;version=12020710&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=l0UsBpASywvC83tRkNCFcXohxiiAWaeAwNErJ39lVT%2Br2MnNzTewpNPZbKzn5PtD)玉伯在首届蚂蚁体验科技 SEE Conf 大会上分享的总结，不管是前端还是设计师都值得一看。 故宫“看门人”带您探访紫禁城故宫博物院院长讲述故宫博物院概况，未开放区的故事，和故宫中的趣事。别的不说，院长的 ppt 做的很棒，同时讲解风趣幽默，还调侃了一下国家领导人，怪不得后面好多人站着听完。。 How GitHub Uses GitHub to Build GitHub题目看似一个绕口令，其实就是一个绕口令，这个视频为我们讲述了 github 团队是如何利用 github 搭建 github 这个站点的，不过该网站需要翻墙，也不知道当你观看的时候视频是否存在，一切随缘吧~ Git and GitHub Secretsgithub 是当今最流行的版本控制工具了（没有之一），而 git 和 github 的功能非常强大，我们平常用到的都是一些最基本的功能，所以有一些隐藏功能是大多数人都不知道的，而这个视频就是 git 创始人之一Zach Hloman 的一篇演讲，可以让你了解到 git 和 github 的秘密机关。 缅怀经典！乔布斯2007年iPhone发布会全程 中文字幕乔布斯已经离开我们有一段时间了，但是他的传奇仍在继续，Apple 作为全球第二大互联网科技公司，其对世界的影响是有目共睹的，在 2018 年的今天，就让我们一起穿越回 2007 年，那一年是属于乔布斯的，是属于 iPhone的！ 周其仁号称14亿人都应该看的关于以色列的演讲视频北大国家发展研究院教授在联想之星 WILL 大会上发表的演讲，虽然主题是经济，但是值得所有人看一下。 广告类年度走心广告：总有人偷偷爱着你这是 999感冒灵推出的感恩节短片，广告片选取真人事件改编，以一段网络问答为线，串联 5 个反转故事。看完后你会觉得：这个世界没有想象中的那么好，但似乎……也没那么糟，总有人偷偷爱着你。 近年最喜欢的 Apple 广告片来自简书-刘英滕的推荐，Apple 的广告往往不会单纯的宣传其产品，更注重的是传达一种理念，表达一种对设计和交互的思考，同时关注人情和应用场景。 两秒钟，你究竟错过了什么？——美国抵制分心驾驶公益广告手机给我们传递了最新消息，有时无意中也为我们“推送”了安全隐患。开车时，即便是两秒钟的分神，也会使车辆碰撞的概率翻倍。专心驾驶，才是最不容错过的事！ 纪录片类Google搜索：“How”Google 刚刚发布了 2017 年搜索关键词报告，这一年，我们在 Google 搜索栏，键入最多的一个单词是：“How”。为此 Google 做了一支名为“How”的视频。这家全球最大的搜索引擎公司，每天悄无声息的出现在我们生活里。 那个两寸长的搜索框，记录着 2017 年里人们的好奇、困惑、恐惧、沮丧、无助，但更多的是希望和善良。 最动人的年度视频：3分钟回望20172017 即将结束，新浪带我们回首了这一年发生的种种，有国家的荣耀时刻，也有英雄的陨落 知乎发布 2017 大事记：关于世界，关于中国，关于你知乎也发布了 2017 总结视频。。 Life in A Day这部 Youtube 筹划的纪录片，记录着全世界 2010 年 7 月 24 日这天，世界各角落的可能性。影片由全世界的 Youtube 使用者拍摄，上传至 Youtube，并由导演 Kevin MacDonald 和 Ridley Scott 剪辑成九十分钟影片，影片没有各种花哨的技术手法，为的是让你看到世界上最真实的人生百态。 北邮60年 | 校庆官方宣传片《世界因你而改变》这部六十周年校庆官方宣传片思路新颖，通过纪录15级毕业生张浩用镜头重新审视母校，让大家了解到北邮的过去和今天。同时还包含很多校友采访及珍贵的老资料，让人们感受到北邮所肩负的“传邮万里、国脉所系”的历史使命和“大众创业、万众创新”的时代责任。 工作细胞豆瓣评分 9.2 分的岛国神作，无论是否喜欢看动漫，都很难不被《工作细胞》精准秒杀。网易云音乐《工作细胞》主题曲的评论区里，有人这样说： 请记住，如果哪天不高兴或者是有很不好的想法，请记住这个身体里有37兆细胞还在为你辛勤工作着，他们一直在努力，请你也不要放弃 这里有一篇介绍，可以提前看一下：《岛国9.2高分神作！揭露身体的秘密，看完再也不忍心作践自己….》 其他【敖厂长】史上最垃圾游戏判明!被誉为“镇站之宝”的 Bilibili 视频，虽然完整的看下来之后只有佩服二字可言（因为从头到尾也没看懂说的是个啥），但是佩服就足够了，上一张伪封面图感受一下： 2017 最火歌曲，YouTube 第一个浏览量达到 30 亿的MVRT，这首《despacito》是一首西语歌，发行于 2017 年 1 月 13 日，发行之后就收获了很多奖项：YouTube 网站上播放量最多、YouTube 上第一个浏览量达到30亿次的视频、YouTube 上最快达到 20 亿次浏览量的视频；当然，由于贾斯汀比伯的加入，让《despacito》更火了。其中这个剪辑视频的最后，当人们听到贾斯汀比伯的西语时的表情是一个亮点。。 3 分钟带你认识一夜爆火的“引力波”，目前最清楚明了的科普短片题目说明了一切。。 这样的旅行记录太酷了吧，像科幻大片旅行记录做的非常酷","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"推荐","slug":"推荐","permalink":"http://merrier.wang/tags/推荐/"}]},{"title":"Merrier说还可以这样玩儿？！","slug":"Merrier说还可以这样玩儿？！","date":"2017-09-23T06:32:34.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170923/how-to-play-in-this-blog.html","link":"","permalink":"http://merrier.wang/20170923/how-to-play-in-this-blog.html","excerpt":"","text":"不知不觉，Merrier说 已经上线近半年了；前不久添加了 CNZZ 的统计代码，虽然 UV、PV 不是很多，但是发现老访客的比例还是比较高的，下面我介绍一个技巧——“把喜欢的网站添加到主屏幕，方便以后访问”，这样以后再想访问我的博客就会变得很简单了（当然，也可以用在其他喜欢的网站） 第一步，打开浏览器，访问Merrier说主页（http://merrier.wang）我的手机是iOS的，目前发现只有safari才行 第二步，点击浏览器下方的“发送”按钮如下图红框处： 第三步，找到“添加到主屏幕”按钮如下图红框处，在靠下方位置（不要在意那个“宇宙第一美男”。。）： 最后一步，点击“添加”按钮即可由于wordpress本身就做了这方面的工作，所以当我们在上一步点击“添加到主屏幕”时，就会看到下面已经配置好的内容： 从上面的截图中可以看出，“添加到主屏幕”的结果是：一个图标将会添加到您的主屏幕，以便您快速访问此网站。 最终结果添加到主屏幕之后，我们就可以看到主屏幕上多了一个“很怪”的图标。。 以后直接点击 Merrier说 图标就可以访问我的博客啦~~！！ 关于安卓iOS 可以按照上面的步骤添加图标至主屏幕，安卓的话因为身边没有安卓手机，所以暂时不太了解有没有类似功能。。（据说安卓的 UC 浏览器中有类似的按钮？）","categories":[{"name":"移动端","slug":"移动端","permalink":"http://merrier.wang/categories/移动端/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://merrier.wang/tags/技巧/"},{"name":"Merrier说","slug":"Merrier说","permalink":"http://merrier.wang/tags/Merrier说/"}]},{"title":"不想当诗人的程序员不是好工程师","slug":"不想当诗人的程序员不是好工程师","date":"2017-09-06T14:40:12.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170906/a-programmer-who-doesnt-want-to-be-a-poet-is-not-a-good-engineer.html","link":"","permalink":"http://merrier.wang/20170906/a-programmer-who-doesnt-want-to-be-a-poet-is-not-a-good-engineer.html","excerpt":"","text":"RT，作为一名程序员，如果会几首诗，那你就不是一名普通的程序员，而是一名 会几首诗的程序员 一封情书（中文更惊艳） I love three things in this world.Sun, Moon and You.Sun for morning,Moon for night,and You forever. 中文版： 浮世三千，吾爱有三。日、月与卿。日为朝，月为暮，卿为朝朝暮暮。 另一个版本： 浮世三千，挚爱有三。喷薄朝阳，皓婉皎月；不及汝尔，沧海桑田。 如果有来生 如果有来生，要做一棵树，站成永恒，没有悲欢的姿势。一半在土里安详，一半在风里飞扬，一半洒落阴凉，一半沐浴阳光，非常沉默非常骄傲， 从不依靠从不寻找。 毛不易《消愁》 一杯敬朝阳，一杯敬月光；一杯敬故乡，一杯敬远方；一杯敬明天，一杯敬过往；一杯敬自由，一杯敬死亡。 木心《从前慢》 从前车马很慢，书信很远，一生只够爱一个人。 黑别人可不是好孩子 从一而终薛之谦百年贤妻翟欣欣下周回国贾跃亭真爱无敌邓文迪遵纪守法郎咸平西门官人王宝强 来自网易云音乐《起风了（Cover 高橋優）》评论 我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。曾经我自诩半个诗人，见山是深情伟岸，见海是热情澎湃，见花见草信他们皆有故事，云海江潮，虫鸣鸟啼都暗藏情愫。唯独见了你，山川沉默，海面静谧，云海不再翻涌，江潮不再澎湃，花鸟鱼虫被光与尘凝固，世界万籁俱寂，只剩下你。 梁启超《少年中国说》 故今日之责任，不在他人，而全在我少年。少年智则国智，少年富则国富；少年强则国强，少年独立则国独立；少年自由则国自由；少年进步则国进步；少年胜于欧洲，则国胜于欧洲；少年雄于地球，则国雄于地球。红日初升，其道大光。河出伏流，一泻汪洋。潜龙腾渊，鳞爪飞扬。乳虎啸谷，百兽震惶。鹰隼试翼，风尘翕张。奇花初胎，矞矞皇皇。干将发硎，有作其芒。天戴其苍，地履其黄。纵有千古，横有八荒。前途似海，来日方长。美哉我少年中国，与天不老！壮哉我中国少年，与国无疆！ 《侠客行》 十步杀一人，千里不留行。事了拂衣去，深藏身与名。 《横渠四句》 为天地立心，为生民立命，为往圣继绝学，为万世开太平 《寻李白》 酒入豪肠，七分酿成了月光余下的三分啸成剑气绣口一吐，就半个盛唐 龙应台《目送》 很多时候不是我们去看父母的背影而是承受他们追逐的目光，承受他们不舍的，不放心的，满眼的目送。最后才渐渐明白，这个世界上，再也没有任何人，可以像父母一样，爱我如生命。 互联网 产品有三宝，弹窗，浮层加引导；设计有三宝，透明，阴影加圆角；运营有三宝，短信，推送加红包；程序员有一宝，这个做不了。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://merrier.wang/categories/杂谈/"}],"tags":[{"name":"生活","slug":"life","permalink":"http://merrier.wang/tags/life/"}]},{"title":"Mac下的效率工具autojump","slug":"Mac下的效率工具autojump","date":"2017-08-30T13:09:31.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170830/mac-efficiency-tool-autojump.html","link":"","permalink":"http://merrier.wang/20170830/mac-efficiency-tool-autojump.html","excerpt":"","text":"首先，这篇文章的封面图是我随便找的，好像是一个游戏的名字。。但是就连 autojump的github 上面都没有一张图片，所以我也很无奈啊~ 介绍autojump 是干什么的呢？从它的名字能看出来，它的功能类似“自动跳转”，比如我们之前曾经访问过一个目录：/Users/frontend/repos/mineProject，现在我们通过简单的一条指令：autojump mine 就可以跳转到这个目录（注意：我们在任意位置都可以跳），autojump 它自己是这么描述的： autojump is a faster way to navigate your filesystem. It works by maintaining a database of the directories you use the most from the command line. autojump 就是通过记录你在 history 中的行为把你访问过的文件夹路径都 cache 下来，然后当你输入指令时再读取 cache 文件(/Users/frontend/Library/autojump/autojump.txt)，它还有一个快捷方式：j mine，总而言之，这个小工具可以让你游荡于文件夹之间不费吹灰之力！ 安装首先，安装 homebrewhomebrew 是 mac 上的一个软件包管理器，可以通过如下方式进行安装（粘贴至终端即可）： 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 更多关于 homebrew 的介绍可以查看它的官网 然后，安装 zsh给大家讲个笑话： Zsh 全称为 Z Shell，因为 Z 是最后一个字母，因此大家称之为——终极 Shell。 我们可以通过 brew 安装 zsh： 1brew install zsh 安装 autojump1brew install autojump 配置 .zshrc在 ~/.zshrc 中编辑以下内容：plugins=(autojump)，当然，如果你有其他 zsh 插件比如 git，直接在后面添加即可：plugins=(git autojump)。然后继续在 .zshrc 文件中添加如下内容： 1\\[\\[ -s $(brew --prefix)/etc/profile.d/autojump.sh \\]\\] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh 还剩最后一步，使刚才的更改生效： 1source ~/.zshrc Enjoy coding:) 其他可能错误.zshrc:3: command not found: ^M The temporary solution to that is changing your core.autocrlf git config setting to use input, given that you are on OSX. See #4402 (comment). 1234cd $ZSH git config core.autocrlf input git rm --cached -r . git reset --hard PATH set to RVM ruby but GEM_HOME and/or GEM_PATH not set PATH set to RVM ruby but GEM_HOME and/or GEM_PATH not set Add RVM set at ~/.zshrc: 1export PATH=\"$PATH:$HOME/.rvm/bin\" # Add RVM to PATH for scripting 参考文章 Mac下的效率工具autojump mac终端快速启动Sublime/WebStrom/VS Code/Atom等编辑器 MacOS X 安装 oh-my-zsh autojump","categories":[{"name":"工具","slug":"工具","permalink":"http://merrier.wang/categories/工具/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://merrier.wang/tags/mac/"},{"name":"autojump","slug":"autojump","permalink":"http://merrier.wang/tags/autojump/"}]},{"title":"网罗天下好教程","slug":"网罗天下好教程","date":"2017-08-27T07:56:15.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170827/good-courses.html","link":"","permalink":"http://merrier.wang/20170827/good-courses.html","excerpt":"","text":"总结了一下我看过的好的教程，多数为系列文章，鉴于如今信息鱼龙混杂，这篇文章可以省去很多找好教程的时间。 入门级HTML手把手教你使用Hexo + Github Pages搭建个人独立博客很完整很详细的 Hexo 搭建个人博客教程 从0到1搭建和部署个人博客此教程会教你从 0 到 1 搭建一个完整的博客，包括前端展示页、后台管理系统、后端接口及接口文档、服务端部署整个完整流程。技术栈是 vue+express+mongodb Hexo 主题开发指南该文章包含的内容如下： 主题的基本结构 常见问题 常用页面的实现 基本工具 CSSCSS布局说——可能是最全的其实很多时候，我们都会在布局上花费很多时间，尤其是遇到一个比较“严格”的设计师的时候，而 css 虽然语法简单（css 有语法？），但是真正用起来会有很多学问，而布局这种问题是老生常谈的问题了，这篇来自 SegmentFault的文章对 css 中的布局的相关知识进行了总结，满满的干货。 CSS 中重要的层叠概念作者参考了很多关于层叠概念的文章，对这一经常迷糊的概念进行了全面总结，讲解的非常清晰全面，是我看过的讲层叠概念最好的文章，十分值得一看！ JavaScriptJavaScript 标准参考教程（alpha）阮一峰的 JS 教程，内容很多，而且讲解的很详细，很透彻，是一篇不错的 JS 入门教程。 如何定义一个高逼格的原生JS插件作者通过很多实例介绍了如何定义自己的 JS 插件，包含了很多方面和技巧 框架七天学会node.js这是一篇比较详细的 node.js 入门教程，但是我确实没有七天就学会。。 node.js之fs模块fs 模块是 node.js 中一个很重要的模块，其提供了文件相关操作，包括打开、读取、写入和追加等等操作 Express 4 入门中文手册最近在做 node 相关的项目，express 之前接触过，但是基本上一点印象都没有留下。。然后 express 的英文文档从布局和样式上就给人一种不想看的感觉，同时我的英语水平也很差，所以就在网上找了很久的中文文档，最终追根溯源找到了上面这篇，无法评价好坏，因为有就不错了嘛~ Redux中文文档在线 gitbook，有很多实例，是一个很不过的 redux 入门文档（我就是通过看这个文档入门的~） Redux从设计到源码这也是一篇 Redux 入门教程，虽然比不上上面的教程，但是这篇文章里面的某些图片画的还是相当不错的，可以当做补充资料 react-starter-kit 入门（翻译）starter-kit 的教程实在太少了，只找到了这一篇中文的，就先凑合看吧，具体写的好不好可以先睹为快，因为篇幅比较短，而且 starter-kit 本来就是一个脚手架，还是需要了解其他技术栈才能真正看懂 React Router官方教程官方给出的 react-router 入门文档，通过14个实例一步步进行讲解，由浅入深，由易到难，只需要一个多小时就可以跟着文档写完 14 个实例，同时在写的过程中还可以学习到 express 和 webpack 的相关知识。 Redux作者出的教学视频Redux 作者自己在 egghead.io 上面上传了教学视频，墙裂推荐，不过全程英文讲解，可能会有点费劲- -： 基础篇：Getting Started with Redux 进阶篇：Building React Applications with Idiomatic Redux 从零开始学 ReactJS（ReactJS 101）从零开始学 ReactJS（ReactJS 101）是一本希望让初学者一看就懂的 ReactJS 中文入门教学书，由浅入深学习 ReactJS 生态系 (Flux, Redux, React Router, ImmutableJS, React Native, Relay/GraphQL etc.)。 工具入门Webpack，看这篇就够了进度条说明了一切，作者通过对比 gulp 和 webpack，详细的介绍了 webpack 的优缺点，同时还介绍了一些其他工具的用法，虽然篇幅较长，但是大部分都是代码，可以跟着作者自己敲一遍，相信敲完之后的你可以自信的说 webpack 我终(hai)于(shi)会(bu)了(hui) webpack 2 打包实战这是一篇对于 webpack 2 的讲解，作者通过追根溯源向我们阐述了为什么需要 webpack，作为历史的产物， webpack 具备哪些优势，文章篇幅较长，不过弥补了 webpack 官方文档写的很差的缺陷，是一篇比较不错的 webpack 入门文档 令人困惑的webpack之entry鉴于 webpack 的文档实在太差，而 webpack 本身又比较复杂，各种 loader，各种 plugin，各种配置，所以刚接触 webpack 的童鞋会感到很头疼，而 entry 作为 webpack 中最基础的配置，可以作为入门 webpack 的关键点，这篇文章非常详细的介绍了 entry 配置项的作用以及参数含义 用grunt搭建自动化的web前端开发环境-完整教程jQuery 在使用 grunt，bootstrap 在使用 grunt，百度 UEditor 在使用 grunt，你没有理由不学、不用！ Sublime Text 2 - 性感无比的代码编辑器！程序员必备神器！这是一篇比较全的 sublime 介绍文章，作者介绍了很多 sublime 的特性和优点，同时还推荐了一些插件和使用技巧。 浅入浅出webpackwebpack 作为一个非常流行的构建工具，其文档和使用一直为人所诟病，而当我真正的自己对 webpack 进行了了解和实战之后，发现其实 webpack 并不是那么难理解，而很多童鞋其实是因为 webpack 的功能太强大而对其产生了畏惧，这篇文章对这部分童鞋来说是一篇很好的教程，从基本使用的角度对 webpack 进行了介绍和讲解，除此之外还介绍一些高阶应用，如 TreeShaking、构建 PWA 应用等 iOS开发工具——网络封包分析工具CharlesCharles 是在 Mac 下常用的截取网络封包的工具。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。作者在该教程中介绍了安装 Charles、安装SSL证书、将Charles设置成系统代理、过滤网络请求、截取 iPhone 上的网络封包、截取 SSL 信息、模拟慢速网络、修改网络请求内容等内容。 webpack 教程资源收集作者收集总结了关于 webpack 的各种教程，大概共有 50 篇文章。 运营小白带你5分钟入门谷歌分析(GA)主要通过截图的方式简单介绍了如何使用 GA 进行数据分析，以及 GA 都有哪些功能。 全网最贴心的webpack4系列中文教程和配套代码作者花费了 3 个多月整理了这份教程，一共分成 16 节，每节都有讲解，并且准备了配套代码。 理论同构(Isomorphic) web 是什么鬼？同构这个概念最近比较火，相比 SPA，同构会有其独特的优势，作者用非常简短的语言介绍了同构产生的背景和如何将自己的网站改造为同构 web。 再不懂区块链，你就OUT了！区块链从 15 年到 17 年，但是你却任对区块链一知半解，百度经验联合火币网打造讲解区块链的系列小动画《区块链100问》 ，将抽象的区块链概念转化为100集轻松易懂的 1 分钟小动画，每集学懂一个知识点~ 快乐的Linux命名行The Linux Command Line 的中文版，一个文科生说他看完这个都会 Linux 了 HTTPS 的故事作者缘于在 Twitter 上看到的 HTTPS explained with carrier pigeons，原作者用很简单的故事就把 HTTP / HTTPS 的传输过程讲解的很清楚。 借原文的意思，该作者重新写了这个故事，加上了一些配图和补充，很形象的解释了为什么要有https以及如何实现。 JS 函数式编程指南这是mostly-adequate-guide的中文版，可以说是最好的\b函数式编程书籍，作者还非常有心的提供了 EPUB 和 MOBI 格式的下载。 Bash 脚本 set 命令教程阮一峰老师写的教程，也是一些大牛推荐的 set 命令教程，文章短小精悍，基本上把 set 命令相关的所有知识都涵盖了。 其他npm scripts 使用指南阮一峰讲解的 npm script 入门知识，关于 npm script 首推这篇文章 Linux大棚版Thrift入门教程thrift 作为一种 RPC 框架，其诞生以来就受到了广泛关注，虽然 RPC 框架有很多种，但是 thrift 还是有其独特优势的，这篇入门教程篇幅较长，作者介绍了 thrift 的基础概念，同时通过实例介绍了如何应用 thrift，比其他教程要详细很多。 Shell脚本编程30分钟入门前端工程师和 shell 打交道会比较少，但是知道一些往往会节省自己很多时间，比如定时备份、定时提交修改神马的，这篇文章虽然看上去有点“标题党”的意思，但是作者介绍的还算详细，同时作者还有一些其他类型的“30 分钟教程”，也可以看一看（作者是多么喜欢30分钟这个时间段啊。。） Docker 入门Docker 是一个非常有趣的项目。它最大的作用就是隔绝了操作系统环境，类似于虚拟机，但是相对于虚拟机，他又拥有绝对的高效率、和通用性。相信看完这篇文章之后，你会对docker有一个直观的认识= = 图说设计模式通过画图的方式理解设计模式，以一种轻松的姿势理解高深的学问。 Go 指南该指南介绍了 Go 的大部分重要特性，同时有一些练习进行巩固。 centos 6.7安装最新版 git阿里云上的 ECS 很多人都会选择 CentOS 系统，而作为前端，可能需要安装 nvm，但是 CentOS 6.7 默认安装的 git 版本是比较低的 1.7.1 版本，所以需要重新安装最新版 git，这篇教程讲的很详细，我按照他的步骤很顺利的就安装成功了。 Jenkins+nginx 搭建前端构建环境废话很少，直接上代码的方式我很喜欢，Jenkins 解决了很令人头疼的构建问题，所以如果想成为一名称职的前端工程师，这是一篇值得参考和手巧的教程，赶快跟着作者的手速敲起来吧！ 技术胖 155 集前端视频教程技术胖在 2017 年录制的 155 集视频教程，可以免费观看，其中包括 Vue2.x、Vue-cli、Vue-router、vuex、Vue实战、weex、ES6、React基础、React全家桶、Koa2.x、Fabric.js 和 CocosCreater 实战教程等。 进阶级深入理解JSON作者将 JSON 和 JS 中的 JSON 都梳理了一遍，也对里面的细节和注意点进行了一次遍历，从中我们能够知道 JSON 是一种语法上衍生于JS语言的一种轻量级的数据交换格式，也会明白 JSON 相对于一般的JS数据结构（尤其是对象）的差别；除此之外，作者更进一步地仔细讨论了 JS 中关于 JSON 处理的 3 个函数和细节。 通用 CSS 笔记、建议与指导作者总结了 CSS 的相关规范，但是建议下面腾讯 AlloyTeam 总结的那篇。。 前端规范总结-AlloyTeam腾讯 AlloyTeam 通过分析 github 代码库总结出来的工程师代码书写习惯，内容很全很详细，值得一看！ CSS进阶系列通过作者的 github，可以看出来这是一位腾讯的大牛，作者通过 CSS 实现了很多复杂的效果，其中有些例子是《CSS揭秘》这本书里面的，这本书也是我之前强烈推荐大家看的一本 CSS 进阶书籍。 简书-前端基础进阶系列作者叫“波同学”，我之前是从来没有听说过作者大名的，但是读过作者这一系列的文章之后对作者的前端能力很是钦佩，同时作者的讲解能力也很强，将一些别人讲的晦涩难懂的原理讲的很透彻，十分推荐大家认真阅读一下作者这一系列的文章，我相信你看完之后你的前端水平会有很大的提升 更新于2017-01-26：波同学将自己在简书上的文章都迁移到了自己的Gitbook上 深入理解 JavaScript 系列汤姆大叔写的文章，文章内容实在是多。。而且感觉难度有点大，推荐大家先看一下上面简书的前端基础进阶系列，再来看汤姆大叔这一系列的文章，可能理解起来会更容易一些。 webshell 原理webshell，顾名思义：web 指的是在 web 服务器上，而 shell 是用脚本语言编写的脚本程序，webshell 就是就是 web 的一个管理工具，可以对 web 服务器进行操作的权限，也叫 webadmin。接触过集群的童鞋对这个概念肯定不会感到陌生，虽然一般人不会接触到 webshell，但是多了解一些总是没错的~ 全自动科学上网方案分享有些童鞋并不了解如何通过 VPS 实现科学上网，这篇文章介绍了如何利用 VPS 进行代理配置，以及实现自动切换，讲解的很详细。","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://merrier.wang/tags/前端/"},{"name":"教程","slug":"教程","permalink":"http://merrier.wang/tags/教程/"}]},{"title":"iOS中采用AMP规范时的scroll和position:fixed带来的bug","slug":"iOS中采用AMP规范时的scroll和position:fixed带来的bug","date":"2017-08-26T12:23:20.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170826/the-bugs-caused-by-scroll-and-position.html","link":"","permalink":"http://merrier.wang/20170826/the-bugs-caused-by-scroll-and-position.html","excerpt":"","text":"本文翻译自一位前辈的两篇文章，原文链接： AMP, iOS, Scrolling and Position Fixed AMP, iOS, Scrolling and Position Fixed Redo — the wrapper approach 首先，你需要先了解一下 AMP，点击这里 前言我们对于 AMP 的目标是确保 document 文档在不同环境中都是可嵌入的，无论是单独查看还是在 webview 中或者在 iframe 中——总体而言，它在不同环境中的功能和行为表现都应该尽可能相同。我们将从一个简单的栗子开始，在这个栗子中，一个 AMP 文档通过 iframe 被嵌入了一个 web app。这听起来很正常，但是很实在的说，iframes 在最近已经很少有人用了。闲话少说，html 结构是这样的： 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;I’m a Web App and I show AMP documents&lt;/title&gt; &lt;style&gt; iframe &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe … width=\"100%\" height=\"100%\" scrolling=\"yes\" src=\"https://cdn.ampproject.org/c/pub1.com/doc1\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 上面这段代码通常来说在移动设备上表现良好。然后我们有了一个新的想法，我们尝试将 iframe 调整到整个 document 的高度，同时使用 static 定位，从而将滚动委托给上一层的 window。然而，出于一些原因，我们放弃了这种方法： 当视口高度等于文档高度时，在嵌入的AMP文档中设置“position: fixed”是不会起作用的 计算文档高度容易出错，而且有延迟 当然，我们最终没有很好的解决方案。主要是，设置了“scrolling=yes”的 iframe 会丢失一些移动设备的特性，比如滚动时隐藏地址栏。然而，我们仍然觉得这已经是一个很好的折衷方案了。除此之外，一些浏览器已经开始尝试将这些特性扩展到非 body 滚动的情况中。我们就这样美滋滋，直到我们遇到了 iOS。。 问题1：iOS 不支持 iframe 的 “scrollable=yes”Bug：https://bugs.webkit.org/show_bug.cgi?id=149264 简单的说：ios中不能有可以滚动的iframe。然而，我们找到了解决这个 bug 的方法。参考这里ViewportBindingNaturalIosEmbed_。简短而言，我们让 document 中真正的&lt;body&gt;元素滚动。这样的话，即使 iframe 自身不滚动，它里面的内容也会滚动。 我们按照上面方案修改后的 AMP 文档如下： 123456789101112131415&lt;html AMP style=\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"&gt;&lt;head&gt;&lt;/head&gt;&lt;body style=\" overflow-y: auto; -webkit-overflow-scrolling: touch; position: absolute; top: 0; left: 0; right: 0; bottom: 0; \"&gt;&lt;/body&gt;&lt;/html&gt; 我们以为自己很牛逼，然而。。 问题2：现在 scrollTop，scrollLeft，scrollHeight，scrollWidth 不管用了Bug：https://bugs.webkit.org/show_bug.cgi?id=106133 这是 webkit 中长期存在的一个 bug。scrollTop 和其他类似属性被分配给了 “document.body”，但是却委托给了“document.documentElement”。最终，当 “scrollingElement” 是文档里的大部分元素的时候，这个问题会被解决。同时，令人惊喜的是，这个 bug 不会对我们在问题1中提出的解决方案造成冲突。然而，“scrollTop” 将会一直是 0，从而导致其他连带属性也会受到影响，比如 “window.pageYOffset” 解决方案是添加一个滚动的元素到文档顶部。它的 “getBoundingClientRect().top” 就可以用来重新计算文档的滚动位置。 具体如下所示： 123456789101112131415161718192021222324&lt;html AMP style=\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"&gt;&lt;head&gt;&lt;/head&gt;&lt;body style=\" overflow-y: auto; -webkit-overflow-scrolling: touch; position: absolute; top: 0; left: 0; right: 0; bottom: 0; \"&gt; &lt;div id=\"scroll-pos\" style=\" position: absolute; top: 0; left: 0; width: 0; height: 0; visibility: hidden; \"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们的 JS 代码： 123456function getScrollTop() &#123; // 要对scrollPos.top取负值的原因是滚动位置在计算时， // 我们的scrollPos元素会向上滚动，在视口范围外, // 此时它的top值是负的 return -scrollPos.getBoundingClientRect().top;&#125; 从上面的代码可以看出，这个解决方案显得很蠢，但是它确实奏效了。类似的方法可用于“scrollLeft”，“scrollHeight” 以及剩余属性。 然而，我们又有了新的发现。。 问题3：“postion: fixed” 的元素在 “overflow: auto” 容器中会有很多 bugBug：https://bugs.webkit.org/show_bug.cgi?id=154399 如果一个 “position: fixed” 元素在一个 “overflow: auto” 的容器中，它的表现会让你很失望：滚动的时候，“position: fixed” 元素会跳远和闪现。它看起来像是稍微滚动一点然而又跳回到正确的位置。这个效果很差，可以通过这个视频演示看到这个 bug。 要哭了。我们通过各种 hack 解决了各种 bug，最后还是有一个 bug，我们如何解决这个？这里有一个很疯狂的 idea 貌似好使。我们可以添加一个虚拟元素到 “document.documentElement”（不是 “body”，所以它其实是 “body” 的兄弟元素）。我们把它叫做“固定层”。他将占据整个视口。我们将使用CSS来找到所有的可能是 “fixed” 的元素（希望不会有太多。。），如果在某些时候它们是确定 “fixed” 的，我们就通过正确的 “z-index” 属性将它们移动到“固定层” 你可能看晕了，直接上代码： 1234567891011121314151617181920212223242526272829303132333435&lt;html AMP style=\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"&gt;&lt;head&gt; &lt;style&gt; #fixed-element &#123; position: fixed; right: 20px; top: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style=\" overflow-y: auto; -webkit-overflow-scrolling: touch; position: absolute; top: 0; left: 0; right: 0; bottom: 0; \"&gt; &lt;div id=\"fixed-element\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;div id=\"fixed-layer\" style=\" position: absolute; top: 0; left: 0; width: 0; height: 0; pointer-events: none; \"&gt;&lt;/div&gt;&lt;/html&gt; 当我们找到一个确实 “fixed” 的元素的时候，我们将它移动到“固定层”，像这样： 12345678910111213&lt;div id=\"fixed-layer\" style=\" position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; \"&gt; &lt;div id=\"fixed-element\" style=\"pointer-events: initial; z-index: 11;\"&gt; &lt;/div&gt;&lt;/div&gt; 因此，我们可以根据某元素是否 “fixed” 来将它在 “\bbody” 中的原始位置和“固定层”之间移动。 这个方法就无懈可击了吗？很明显没有： \b这代码看都看不懂！ 计算 “z-index” 会相当痛苦 我们将失去一些 CSS 祖先选择器 但是它确实是有效的，可以看一下这条PR。还有别的 idea 吗？ 准确来说是有的，下面是作者第二篇文章的译文： 回顾一下简单回顾一下，AMP 文档经常在一个滚动的 iframe 中进行展示。它的 html 结构看起来像这样： 12345678910111213141516171819&lt;html&gt; &lt;head&gt; &lt;title&gt;I'm a Web App and I show AMP documents&lt;/title&gt; &lt;style&gt; iframe &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe … width=\"100%\" height=\"100%\" scrolling=\"yes\" src=\"https://cdn.ampproject.org/c/pub1.com/doc1\"&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 在大部分浏览器中，上面这段代码表现很正常。但是在 ios 中会有很多异常表现，我们尝试了很多方法，包括通过内容调整 iframe 大小和滚动主文档。但是他们都有一些性能问题，具体可以参见上面的问题描述。 根本而言，ios 的 safari 浏览器不支持滚动的 iframe。换句话说，“scrolling=yes” 这个属性被直接忽略了。看这个例子。这个 bug 由来已久，可以在这里发现。 我们在之前提到的一篇文章中发现了一个很原始的方案。简而言之，我们让真正的 “body” 元素滚动。于是，即使 iframe 它自身不滚动，iframe 中的内容也会滚动，AMP 文档如下： 12345678910111213141516&lt;html AMP style=\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"&gt; &lt;head&gt;&lt;/head&gt; &lt;body style=\" overflow-y: auto; -webkit-overflow-scrolling: touch; position: absolute; top: 0; left: 0; right: 0; bottom: 0; \"&gt; &lt;!\\-\\- document content --&gt; &lt;/body&gt;&lt;/html&gt; 现在我们 iframe 可以滚动了！这个 AMP 中的解决方案我们用了一年。然而，随着时间的流逝，我们发现了一系列的问题，这些问题在上一篇文章中已经详细介绍过了，这里再简单罗列一下： 给“ body” 添加 “position: absolute” 属性是作者不想看到的，会影响原始布局。另外一个副作用是我们不没办法在 “body” 元素上设置 margin body 的 scrollTop，scrollLeft，scrollHeight 和 scrollWidth 将不起作用。这个 bug 通过上面介绍的注入虚拟 dom 元素可以解决。 “position: fixed” 在 “-webkit-overflow-scrolling: touch” 容器中会有各种 bug 抵消 header 和 footer 需要给 body 设置边框，这个代价很昂贵，因为它缩小了滚动区域，同时可能会打破现有布局。而隐藏头部又会造成 UI 视觉的隔断和滚动的间断 那我们如何解决这个问题呢，我们的主角就要登场了。。 新的解决方案——wrapper 元素这个方案已开源，可以点击这里查看源代码 DOM 结构通俗来讲，wrapper 元素和滚动的 “body” 元素是类似的。iframe 在 ios 的 safari 浏览器中依然无法滚动，所以我们需要让 iframe 中的内容滚动。因为让&lt;body&gt;滚动会有一系列问题，所以我们可以创建一个滚动的 wrapper，然后将它放在&lt;html&gt;和&lt;body&gt;中间。换句话说，我们将&lt;body&gt;元素包装在一个可滚动的容器中。 现在的 dom 结构类似这样： 12345678910111213141516171819&lt;html AMP style=\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"&gt; &lt;head&gt;&lt;/head&gt; &lt;i-amp-html-wrapper style=\" display: block; overflow-y: auto; -webkit-overflow-scrolling: touch; position: absolute; top: 0; left: 0; right: 0; bottom: 0; \"&gt; &lt;body style=\"position: relative;\"&gt; &lt;!\\-\\- document content --&gt; &lt;/body&gt; &lt;/i-amp-html-wrapper&gt;&lt;/html&gt; 毫无疑问，这看起来很怪，但是它确实解决了原来的问题——它让 iframe 在 ios 的 safari 浏览器中可以滚动。此外，它也解决了上面描述的许多问题： 对于&lt;body&gt;元素没有任何强制要求：它仍然拥有原来的“position”属性，同时也可以拥有默认的“overflow: visible”属性。AMP 允许 dom 中的大多数 css 样式，这样可以减少对代码原作者样式的干扰 可滚动的 wrapper 元素可以用来获取 scrollTop，scrollLeft，scrollHeight 和 scrollWidth 属性，于是之前介绍过的虚拟元素将不再需要 不再需要给&lt;body&gt;设置边界来抵消 header 和 footer 了——只需要给 wrapper 元素添加 padding 就足够了 然而，“position: fixed” 的问题仍然存在，我们稍后再谈。 两个&lt;html&gt;元素我们采用了 wrapper 方案，然后很快就碰到了一个小问题。很多人喜欢 html&gt;body 选择器，而我们在 &lt;html&gt; 和 &lt;body&gt; 中间插入了 i-amp-html-wrapper 元素。为了解决这个问题，我们将 i-amp-html-wrapper 作为另外一个 &lt;html&gt; 元素，最终的 dom 结构长这样： 12345678910111213141516171819&lt;html AMP style=\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"&gt; &lt;head&gt;&lt;/head&gt; &lt;html id=\"i-amp-html-wrapper\" style=\" display: block; overflow-y: auto; -webkit-overflow-scrolling: touch; position: absolute; top: 0; left: 0; right: 0; bottom: 0; \"&gt; &lt;body style=\"position: relative;\"&gt; &lt;!\\-\\- document content --&gt; &lt;/body&gt; &lt;/html&gt;&lt;/html&gt; 加倍奇怪，加倍好玩。总而言之现在 html&gt;body 选择器将正常起作用 实践AMP runtime 会在启动时尽可能早的创建 wrapper 元素。而现有的 &lt;body&gt; 元素会作为子元素放到新建 wrapper 里面 12345678910111213141516171819// Create wrapper.const wrapper = document.createElement('html');wrapper.id = 'i-amp-html-wrapper';// Setup classes and styles.wrapper.className = document.documentElement.className;document.documentElement.className = '';document.documentElement.style = '...';wrapper.style = '...';// Attach wrapper straight inside the document root.document.documentElement.appendChild(wrapper);// Reparent the body.const body = document.body;wrapper.appendChild(body);Object.defineProperty(document, 'body', &#123; get: () =&gt; body,&#125;); 这段代码很简单，不过有一个细节——将 body 移到 wrapper 里面会将 document.body 重置为 null，因此我们需要将 document.body 重写回初始的 &lt;body&gt; 元素，可以通过 Object.defineProperty 来实现 position: fixed问题尽管 wrapper 方案能够解决大部分问题，但是 position: fixed 的问题仍然存在 这个问题在上面那篇文章已经详细介绍过了，有关 ios 的 safari 浏览器 bug 可以点击这里查看 简而言之，一个 position: fixed 元素在一个 -webkit-overflow-scrolling: touch 容器中滚动时会出现跳跃和闪现的问题。它看起来像是稍微滚动一点然而又跳回到正确的位置。可以通过这个视频演示看到这个 bug。 在我们之前的解决方案中，我们将有 position: fixed 属性的元素放到了 &lt;body&gt; 外面，同时放到了一个虚拟“固定层”元素内部，这个“固定层”元素放在了 -webkit-overflow-scrolling: touch 容器外面 最终的 dom 结构： 123456789101112131415161718192021222324252627282930&lt;html AMP style=\"overflow-y: auto; -webkit-overflow-scrolling: touch;\"&gt; &lt;head&gt;&lt;/head&gt; &lt;html id=\"i-amp-html-wrapper\" style=\" display: block; overflow-y: auto; -webkit-overflow-scrolling: touch; position: absolute; top: 0; left: 0; right: 0; bottom: 0; \"&gt; &lt;body style=\"position: relative;\"&gt; &lt;!\\-\\- document content --&gt; &lt;/body&gt; &lt;/html&gt; &lt;body id=\"i-amp-fixed-layer\" style=\" position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; \"&gt; &lt;!\\-\\- fixed elements reparented here --&gt; &lt;/body&gt;&lt;/html&gt; 于是，我们最终获得了两个&lt;html&gt;元素和两个&lt;body&gt;元素。看起来很疯狂，但是它确实解决了两个问题： iframe 不滚动和 position:fixed 元素闪现问题 很明显，我们将取得更好的效果如果存在已久的 ios safari 问题被修复。。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://merrier.wang/categories/移动端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://merrier.wang/tags/前端/"},{"name":"AMP","slug":"AMP","permalink":"http://merrier.wang/tags/AMP/"},{"name":"fixed","slug":"fixed","permalink":"http://merrier.wang/tags/fixed/"},{"name":"ios","slug":"ios","permalink":"http://merrier.wang/tags/ios/"}]},{"title":"移动端滚动事件大起底","slug":"移动端滚动事件大起底","date":"2017-08-20T13:43:33.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170820/mobile-scroll-event.html","link":"","permalink":"http://merrier.wang/20170820/mobile-scroll-event.html","excerpt":"","text":"最近在做移动端的项目，其中有个需求就是滚动监听标签页，实现用户滚动到不同位置时点亮相应 tab 按钮；这其实是个很简单的需求，但是根据之前的项目经验，移动端的滚动事件会有各种坑，所以就花时间做了一些功课，对移动端滚动事件中的坑进行了总结，同时提供了一些解决方案。 移动端滚动事件介绍我们这里要讲的是 onscroll 事件，具体参见MDN文档 滚动事件应用我做了几个简单的 demo，可以直接点击下面的链接查看（在手机上效果更佳~），关于移动端滚动事件的简单 demo 我上传到了我的 github，可以点击这里查看源码： 下拉刷新 吸顶效果 图片懒加载 无限加载 侧边浮动导航栏 滚动事件分类和兼容性按照实际滚动的 dom 类型分为全局滚动和局部滚动 全局滚动滚动条在 body 节点或者更顶层，一般是这样调用： 123456789window.onscroll = function() &#123; var bHeight = document.body.clientHeight, // body对象高度，如果有滚动高度也包括 wHeight = window.innerHeight, // 浏览器窗口的视口 sTop = document.body.scrollTop; // body距离滚动顶部的距离 var isScrollBottom = bHeight - (wHeight + sTop) === 0 ? true : false; if (isScrollBottom) &#123; // 执行相关代码 &#125;&#125; 也可以通过 addEventListener 的方式 局部滚动滚动条在 body 下某一个 dom 节点，在移动端如果使用局部滚动，意思就是我们的滚动在一个固定宽高的 div 内触发，将该 div 设置成 overflow:scroll/auto; 来形成 div 内部的滚动，这时我们监听 div 的 onscroll 发现触发的时机；调用方式和全局滚动类似： 1（document.getElementById('div1').onscroll = function()&#123;&#125;） 兼容性整体来看，全局滚动的兼容性要不如局部滚动，安卓比 IOS 兼容性更好： body 滚动 局部滚动 iOS 不能实时触发 不能实时触发 android 实时触发 实时触发 iOS WKWebview 内核 实时触发 实时触发 为什么 IOS 下的滚动事件会有各种 bug 呢，通过查阅资料，得出如下结论： iOS 的 webview 内核设定了其在进行 momentum scrolling (弹性滚动， 设置 -webkit-overflow-scrolling:touch 可以达到弹性滚动效果，安卓无效)时，会停止所有的 事件响应 及 DOM操作引起的页面渲染，故 onscroll 不能实时响应，具体可以点击这里查看某位大牛写的实例 这里说明一下关于 iOS 的 wkwebview 内核是 iOS 从 iOS8 开始提供的新型 webview 内核，和之前的 uiwebview 相比，性能要好，具体大家可以自行查看关于 wkwebview 的相关概念 解决方案既然 onscroll 事件在 iOS 和安卓上的表现并不统一，同时根据浏览器内核的不同会有潜在的 bug 出现，就出现了针对于移动端滚动事件的各种兼容方案，总结如下： 使用 ontouchmove 去替代 onscroll，虽然能更频繁的触发事件，但是这边的项目需求是实时响应滚动事件的同时，还要对页面元素进行重定位的 DOM 操作，由上述原因可知，在滚动过程中，页面会停止一切关于 DOM 方面的操作，所以若使用 ontouchmove 去实现的话，在按住屏幕进行滑动的时候，屏幕会出现元素抖动的情况(事件触发与 DOM 操作间具有几十毫秒的时间差)，兼容失败 使用 iscroll 的 probe 版本，该版本能实时探查到滚动的距离，但该钩子函数是实时去关注 requestAnimationFrame 下的状态，所以对浏览器的版本性能消耗很大，安卓机根本动不了，兼容失败 使用 swiper 插件，在启动 freeMode 模式时模拟原生的弹性滚动( swiper 模拟原生滚动的方案能兼容较多的安卓机型不出现bug，推荐), 因为 swiper 没有实时监听滚动位置的功能,故我监听滚动开始及结束后的事件，通过 setInterval 及一些计算去实现滚动条的监听，但因为 react 元素的变化量比较大，导致 swiper 在移动端时对父容器的计算速率达到了一个瓶颈，依旧出现很卡顿的现象，兼容失败 通过以上的兼容性尝试，可以发现其实并没有一个完美的解决方案，所以如果真的需要达到某些移动端滚动效果的话，可以采取 fallback 方案： Android 用 scroll 方案，因为兼容性很可观； IOS 如果不需要兼容 8 以下版本的话，就也直接用 scroll 方案，因为 wkwebview 已经对滚动事件进行了优化，而如果需要兼容8以下版本的话，可以考虑 isroll 或 JRroll 这两种插件，同时需要真机测试查看效果是否达到要求（尤其是 QQ 浏览器和搜狗浏览器）。 由于查询到的资料比较老旧，对于滚动事件的兼容性描述可能已经过时了，我就在最近（2017-8-24）用各种浏览器测试了一下iOS中的滚动事件的兼容性，总结如下： 是否可以弹性滚动 是否需要设置 overflow:scrolling 才能弹性滚动 设置 overflow:scrolling 之后，滚动期间是否监听事件 未设置 overflow:scrolling，滚动期间是否监听事件 safari(v10.0) 否 - 是 是 chrome(v60.0) 是 否 是 是 firefox(v8.2) 否 - 是 是 weixin(v6.5.14) 是 否 是 是 QQ(v7.7.2) 是 否 是 是 搜狗(v5.8.1) 是 否 否 否 从上面的表格可以看到，最新版的 iOS 浏览器其实并不需要 overflow:scrolling 就可以实现弹性滚动，同时除了搜狗浏览器之外，其他浏览器在滚动期间都会监听事件，由此可见截止到目前（2017-8-24），iOS 和浏览器对滚动事件的兼容性已经做了很多优化和改进了，之后有时间的话再在 android 手机上做一下测试…… 滚动事件性能优化除了兼容性问题以外，由于滚动事件和 resize 事件同属于会频繁触发的事件。如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。 防抖和节流scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。 针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），下面介绍两种常用的解决方法，防抖和节流（underscore和lodash里面有封装好的这两种方法，感兴趣的话可以研究一下源码）。 防抖防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。 节流防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的 ajax 请求加载也是同理。 这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。 节流函数，只允许一个函数在 X 毫秒内执行一次。 与防抖相比，节流函数最主要的不同在于它保证在 X 毫秒内至少执行一次我们希望触发的事件 handler。 使用 rAF（requestAnimationFrame）触发滚动事件上面介绍的抖动与节流实现的方式都是借助了定时器 setTimeout ，但是如果页面只需要兼容高版本浏览器或应用在移动端，又或者页面需要追求高精度的效果，那么可以使用浏览器的原生方法 rAF（requestAnimationFrame）。 window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数。这个方法接受一个函数为参，该函数会在重绘前调用。 rAF 常用于 web 动画的制作，用于准确控制页面的帧刷新渲染，让动画效果更加流畅，当然它的作用不仅仅局限于动画制作，我们可以利用它的特性将它视为一个定时器。（当然它不是定时器） 通常来说，rAF 被调用的频率是每秒 60 次，也就是 1000 / 60 ，触发频率大概是 16.7ms 。（当执行复杂操作时，当它发现无法维持 60fps 的频率时，它会把频率降低到 30fps 来保持帧数的稳定。） 总结一下 防抖动：防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。 节流函数：只允许一个函数在 X 毫秒内执行一次，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。 rAF：16.7ms 触发一次 handler，降低了可控性，但是提升了性能和精确度。 从本质上而言，我们应该尽量去精简 scroll 事件的 handler ，将一些变量的初始化、不依赖于滚动位置变化的计算等都应当在 scroll 事件外提前就绪。建议：避免在 scroll 事件中修改样式属性 / 将样式操作从 scroll 事件中剥离 参考文章 吸顶效果解决方案 onscroll Event Issues on Mobile Browsers 前端: 移动端onscroll事件在部分浏览器内不能实时触发 移动web之滚动篇* 高性能滚动 scroll 及页面渲染优化","categories":[{"name":"移动端","slug":"移动端","permalink":"http://merrier.wang/categories/移动端/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://merrier.wang/tags/移动端/"}]},{"title":"SSH connect to github fail解决方案","slug":"SSH connect to github fail解决方案","date":"2017-08-20T13:22:16.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170820/ssh-connect-to-gitHub-fail-solution.html","link":"","permalink":"http://merrier.wang/20170820/ssh-connect-to-gitHub-fail-solution.html","excerpt":"","text":"来自于stackoverflow上的一个问题，有位仁兄在命令行中输入了如下命令： 1ssh -T git@github.com 然而报错了： 1ssh: Could not resolve hostname github.com: nodename nor servname provided, or not known 其实，之前就有人碰到过 ssh fail 的问题，报错的原因是 DNS 服务器设置的问题，将 DNS 地址设置为 OpenDNS 或者 Google DNS 就可以了： OpenDNS 208.67.222.222 208.67.220.220 GoogleDNS 8.8.8.8 8.8.4.4 下面就介绍一下在 Mac 中如何设置 DNS（来自文章How to Switch Mac OS X to Use OpenDNS or Google DNS）： 首先，系统偏好设置-网络 点击高级选项 DNS-添加按钮 设置为上面我们提到的 OpenDNS 或 GoogleDNS 地址中的一个就可以啦~","categories":[{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/categories/stackoverflow/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://merrier.wang/tags/Github/"},{"name":"dns","slug":"dns","permalink":"http://merrier.wang/tags/dns/"},{"name":"ssh","slug":"ssh","permalink":"http://merrier.wang/tags/ssh/"}]},{"title":"影响Cache的几个HTTP头信息","slug":"影响Cache的几个HTTP头信息","date":"2017-08-20T13:12:54.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170820/several-HTTP-headers-affecting-cache.html","link":"","permalink":"http://merrier.wang/20170820/several-HTTP-headers-affecting-cache.html","excerpt":"","text":"HTTP 协议是前端工程师接触最多的一种协议，而它的内容又多的要命，所以很多前端童鞋在遇到 HTTP 的时候都会产生“畏惧”的心理，其实对于这种内容非常多又难以理解的知识点，我的建议是用到的时候再详查，而我接下来要介绍的这几个头信息则是非常重要的知识点，是每一个称职的前端工程师都需要掌握的~ HTTP 的 cache 机制HTTP 的 cache 机制总共有4个组成部分：Cache-Control、Last-Modified（If-Modified-Since）、Etag（If-None-Match）、Expires 服务器响应头：Last-Modified、Etag 浏览器请求头：If-Modified-Since、If-None-Match 流程：服务器发出 Etag，Last-Modified 头后，下次浏览器再进行同样的请求，则会发出 If-None-Match，If-Modified-Since头，而后服务器根据这些信息来判断是否需要发送数据，如果没有更新，服务器就简单的发送一个 304 状态告诉浏览器用缓存就OK了，不用下载数据了，从而节约了带宽。 Last-Modified / If-Modified-SinceLast-Modified 是响应头，If-Modified-Since 是请求头。Last-Modified 把 Web 组件的最后修改时间告诉客户端，客户端在下次请求此Web组件的时候，会把上次服务端响应的最后修改时间作为 If-Modified-Since 的值发送给服务器，服务器可以通过这个值来判断是否需要重新发送，如果不需要，就简单的发送一个 304 状态码，客户端将从缓存里直接读取所需的Web组件。如果有更新，返回 HTTP 200 和更新的页面内容，并且携带新的 ETag 和 LastModified。 使用这个机制，能够避免重复发送文件给浏览器，不过仍然会产生一个 HTTP 请求。 ETag / If-None-MatchETag 是响应头，If-None-Match 是请求头。Last-Modified / If-Modified-Since 的主要缺点就是它只能精确到秒的级别，一旦在一秒的时间里出现了多次修改，那么 Last-Modified / If-Modified-Since 是无法体现的。相比较，ETag / If-None-Match 没有使用时间作为判断标准，而是使用一个特征串。Etag 把 Web 组件的特征串告诉客户端，客户端在下次请求此 Web 组件的时候，会把上次服务端响应的特征串作为 If-None-Match 的值发送给服务端，服务端可以通过这个值来判断是否需要从重新发送，如果不需要，就简单的发送一个 304 状态码，客户端将从缓存里直接读取所需的 Web 组件。 因此，HTTP/1.1 利用 Entity Tag 头提供了更加严格的验证。 当服务器发出响应的时候，可以通过两种方式来告诉客户端缓存请求：第一种是Expires，比如：Expires: Sun, 16 Oct 2016 05:43:02 GMT，在此日期之前，客户端都会认为缓存是有效的。 不过 Expires 有缺点，比如说，服务端和客户端的时间设置可能不同，这就会使缓存的失效可能并不能精确的按服务器的预期进行。第二种是Cache-Control，比如：Cache-Control: max-age=3600，这里声明的是一个相对的秒数，表示从现在起，3600 秒内缓存都是有效的，这样就避免了服务端和客户端时间不一致的问题。 但是 Cache-Control 是 HTTP1.1 才有的，不适用与 HTTP1.0，而 Expires 既适用于 HTTP1.0，也适用于 HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，会优先使用 Cache-Control。 基础知识什么是 Last-Modified?在浏览器第一次请求某一个 URL 时，服务器端的返回状态会是 200，内容是你请求的资源，同时有一个 Last-Modified 的属性标记 (Http Reponse Header），此文件在服务期端最后被修改的时间，格式类似这样：Last-Modified: Fri, 12 May 2006 18:53:33 GMT，客户端第二次请求此 URL 时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头（Http Request Header），询问该时间之后文件是否有被修改过：If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT，如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed.） 状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。 如果 If-Modified-Since 的时间比服务器当前时间（当前的请求时间 request_time）还晚，Apache 会认为是个非法请求 Last-Modified 和 Expires 的区别让我们回过头来比较一下 Expires 和 Last-Modified 这两个东西，似乎 Last-Modified 比不上 Expires，因为虽然它能够节省一点带宽，但是还是逃不掉发一个 HTTP 请求出去，而 Expires 却使得浏览器干脆连 HTTP 请求都不用发，岂不痛快！那还要 Last- Modified 这个东西干什么？理想状况的确是这样，不过当用户在 IE 或者 Firefox 里面按 F5 或者点击 Refresh 按钮的时候（不是在 URL 栏里重新输入一遍 URL 然后回车），就算对于有 Expires 的 URI，一样也会发一个 HTTP 请求出去，所以，Last-Modified 还是要用的，而且要和 Expires 一起用。 什么是 Etag？HTTP 协议规格说明定义 ETag 为“被请求变量的实体值” 。另一种说法是，ETag 是一个可以与 Web 资源关联的记号（token）。典型的 Web 资源可以是一个 Web 页，但也可能是 JSON 或 XML 文档。服务器单独负责判断记号是什么及其含义，并在 HTTP 响应头中将其传送到客户端，以下是服务器端返回的格式： ETag: &quot;50b1c1d4f775c61:df3&quot; 客户端的查询更新格式是这样的： If-None-Match: &quot;50b1c1d4f775c61:df3&quot; 如果 ETag 没改变，则返回状态 304，这也和 Last-Modified 一样。本人测试 Etag 主要在断点下载时比较有用。 Last-Modified和Etags如何帮助提高性能?聪明的开发者会把 Last-Modified 和 ETags 请求的 HTTP 报头一起使用，这样可利用客户端（例如浏览器）的缓存。因为服务器首先产生 Last-Modified / Etag 标记，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。过程如下: 客户端请求一个页面（A）。 服务器返回页面 A，并再给 A 加上一个 Last-Modified / ETag。 客户端展现该页面，并将页面连同 Last-Modified / ETag 一起缓存。 客户再次请求页面 A，并将上次请求时服务器返回的 Last-Modified / ETag 一起传递给服务器。 服务器检查该 Last-Modified 或 ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应 304 和一个空的响应体。 注意： Last-Modified 和 Etag 头都是由 Web Server 发出的 Http Reponse Header，Web Server 应该同时支持这两种头。 Web Server 发送完 Last-Modified / Etag 头给客户端后，客户端会缓存这些头； 客户端再次发起相同页面的请求时，将分别发送与 Last-Modified / Etag 对应的 Http Request Header:If-Modified-Since 和 If-None-Match。我们可以看到这两个 Header 的值和 Web Server 发出的 Last-Modified，Etag 值完全一样； 通过上述值到服务器端检查，判断文件是否继续缓存； Etag的弊端不过 ETag / If-None-Match 这点功能实在是个鸡肋，首先，Server 端的资源不大可能 Roll Back，更重要的是，有可能造成 Client Performance 下降。对于只有一个 Server 的网站，没什么问题，但是现在稍微上点规模的网站都需要 Scale Out，也就是说需要前端一个 Load Balancer，后面接多台 Server 来处理请求，俗称 Cluster，既然是 Cluster，那么每个请求到底返回什么结果应该和分配到哪个 Server 无关，不过这个 ETag 可能就坏事了。假如用户的第一次请求分配给 Server A，返回 ETag: &quot;abcdefg1234:0001&quot;，但是第二次请求分配给了Server B，Server B 上这个资源和 Server A 上的一模一样，但是计算出这个资源的 ETag 是”abcdefg1234:0002”，这下麻烦了，虽然内容一样，但是 ETag 不匹配，还是浪费了带宽把资源发送了一遍，冤枉啊！而事实上，不同 Server 上的 ETag 很有可能不同，对于 Apache，ETag 的计算考虑了 inode；对于 IIS，ETag 考虑了 metabase 的修改版本，要保证不同 server 上的这些信息一致，有点小难。不过不是有 Last-Modified / If- Not-Modified 吗？Server 端看到 If-Modified-Since，对照一下时间对得上，不管 If-None-Match，可以直接返回 304(Not Modified) 呀，很不幸， RFC2616对这种情况做了规定，如果既有 If-None-Match 又有 If-Modified-Since，除非两者不冲突，不然不会返回 304。 Apache 中的 Etag 设置Apache 默认开启 Etag，可以使用 FileEtag 来设置 扩展阅读 浅谈Web缓存 浅谈浏览器HTTP的缓存机制 浏览器缓存机制剖析","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/tags/HTTP/"},{"name":"cache","slug":"cache","permalink":"http://merrier.wang/tags/cache/"}]},{"title":"身在IT界，不能不知道这些名词","slug":"身在IT界，不能不知道这些名词","date":"2017-08-20T12:44:49.000Z","updated":"2019-01-17T13:21:55.962Z","comments":true,"path":"20170820/it-nouns.html","link":"","permalink":"http://merrier.wang/20170820/it-nouns.html","excerpt":"","text":"RT，作为码农 / 程序猿 / 攻城狮，有些名词不知道可就说不过去了 geek这是美国“俚语”，音译为“极客”。很多人都想成为“极客”，也有很多人自诩“极客”；然而究竟什么样的人算是“极客”呢？根据我的理解，我认为那种对自己要求极致并且不食人间烟火的技术达人，比如“楼教主”这种编程奇才。。 polyfillPolyfill 或者 Polyfiller，是英国 Web 开发者 Remy Sharp 在咖啡店蹲坑的时候拍脑袋造出来的。当时他想用一个词来形容”用 JavaScript（或者 Flash 之类的什么鬼）来实现一些浏览器不支持的原生 API”。苦思冥想一直想不到合适的单词，于是他一怒之下造了一个单词 Polyfill。除了他自己用这个词以外，他还给其他开发者用。随着他在各种 Web 会议演讲和他写的书《Introducing HTML5》中频繁提到这个词，大家用了都觉得很好，就一起来用。 Polyfill 的准确意思为：用于实现浏览器并不支持的原生 API 的代码。一个 Polyfill 是抹平新老浏览器标准原生 API 之间的差距的一种封装，而不是实现自己的 API。这里有一堆 Polyfills，有兴趣可以把玩一下：HTML5 Cross Browser Polyfills hackhack 一般用来形容某些“黑科技”，是指为了满足程序的某些需求而搞的一些代码，比如 css 中的一些 hack： 123&lt;!--[if IE]&gt;这段文字只在IE浏览器显示&lt;![endif]--&gt; bug懂的人自然懂，有一个段子分享一下： 我们是谁？程序员 我们是做什么的？消除 bug 然后做什么？写 bug ssr对于前端这个行业来说，ssr 不是你家的大天狗，也不是他家的妖刀姬，更不是别人家的姑获鸟，而是服务端渲染（Server Side Render）的意思，自从 NodeJS 问世以后，前端就出现了服务端渲染的方式，相比前端渲染，ssr 究竟有哪些优点呢？其本身又存在哪些不足呢？推荐一篇文章：精读前后端渲染之争。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://merrier.wang/categories/杂谈/"}],"tags":[{"name":"生活","slug":"life","permalink":"http://merrier.wang/tags/life/"},{"name":"IT","slug":"IT","permalink":"http://merrier.wang/tags/IT/"}]},{"title":"Git commit 中的Change-Id是什么","slug":"Git commit 中的Change-Id是什么","date":"2017-08-20T12:38:52.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170820/what-is-change-id-in-git-commit.html","link":"","permalink":"http://merrier.wang/20170820/what-is-change-id-in-git-commit.html","excerpt":"","text":"之前在创业公司实习的时候代码管理很不规范，技术部负责人把每个人的 ssh key 添加到公司 github 中之后就可以执行 git 相关操作了，根本没有权限的概念；后来进入公司之后，才知道还有 Gerrit 这种东西，而第一次 push 代码的时候就遇到了 ERROR: missing Change-Id in commit message 的错误，后来才得知是因为没有 Change-Id 的缘故，下面就介绍一下 Change-Id 是什么东东： 什么是 Change-IdChange-Id 其实就是一段形如 I7cbfa01f5136b8815e5e2c6dc5dcda28ce49d13a 的字符串，它的作用是： 保证已经提交审核的修订通过审核入库后，被别的分支 cherry-pick 后再推送至服务器时不会产生新的重复的评审任务。 Gerrit 设计了一套方法，即要求每个提交包含唯一的 Change-Id，这个 Change-Id 因为出现在日志中，当执行 cherry-pick 时也会保持，Gerrit 一旦发现新的提交包含了已经处理过的 Change-Id，就不再为该修订创建新的评审任务和 task-id，而直接将提交入库。总之，Change-Id 就是 Gerrit 为了确保 cherry-pick 已提交审核的分支时不会在产生新的提交记录。 解决 ERROR：missing Change-Id in commit message在一开始我们提到过，在执行 git push origin Head:refs/for/xxxx 时有时会报出上面标题这样的错误，也就是在 commit Message 仅仅包含如 feature：xxxx 等 title 这样的信息而缺少 Change-Id。那么怎样解决呢？ 临时解决git commit 有一个神奇的参数，叫做 --amend，如果我们遇到了上面的错误，可以执行下面的命令： 1git commit --amend 然后我们可以看到最近一次 commit 的相关信息，在 title 下面空出一行（注意，一定要空出一行，否则 git 会把其作为 title 的一部分处理）后，将 Change-Id: XXXX 复制到 Message 中。然后就可以 push 了。你可能会问了，我哪知道 Change-Id 是什么呢？可以先查看一下之前的 commit 信息： 1git log 然后你可能会看到这样一条信息： 现在你懂了吧，其实可以看到之前人提交 commit 信息的 Change-Id，我们只需要复制一下（注意 Change-Id: 后面有个空格）然后改一下其中某个字母就可以了（因为 Change-Id 不允许重复，如果重复了，可以再改一个字母，一般只需要改一个字母就可以了），这时我们就有了一个人工生成的 Change-Id 了。 注意，这种办法只是一种临时解决方案，下次如果你再想 commit 就需要再复制一个 Change-Id，然后 –amend 修改 commit 信息，是不是感觉每次这样修改很麻烦？没事，我们有一个永久解决方案： 自动生成 Change-Id其实我们可以利用 commit-msg 这个 hook 文件自动生成 Change-Id，具体做法如下： 将文章下面的 commit-msg hook 脚本复制到 git 项目中 .git/hooks 下，并命名为 commit-msg（一般情况下 .git/hooks 下会包含一个叫 commit-msg.sample 的文件，可以把它删除） 添加完之后，执行 1chmod u+x .git/hooks/commit-msg 激活 hook，以后提交的时候就会自动携带 Change-Id 了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#!/bin/sh\\# From Gerrit Code Review 2.6#\\# Part of Gerrit Code Review (http://code.google.com/p/gerrit/)#\\# Copyright (C) 2009 The Android Open Source Project#\\# Licensed under the Apache License, Version 2.0 (the \"License\");\\# you may not use this file except in compliance with the License.\\# You may obtain a copy of the License at#\\# http://www.apache.org/licenses/LICENSE-2.0#\\# Unless required by applicable law or agreed to in writing, software\\# distributed under the License is distributed on an \"AS IS\" BASIS,\\# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\# See the License for the specific language governing permissions and\\# limitations under the License.#unset GREP_OPTIONSCHANGE\\_ID\\_AFTER=\"Bug|Issue\"MSG=\"$1\"\\# Check for, and add if missing, a unique Change-Id#add_ChangeId() &#123;clean_message=`sed -e '/^diff --git a\\\\/.*/&#123;s///q&#125;/^Signed-off-by:/d/^#/d' \"$MSG\" | git stripspace`if test -z \"$clean_message\"thenreturnfi\\# Does Change-Id: already exist? if so, exit (no change).if grep -i '^Change-Id:' \"$MSG\" &gt;/dev/nullthenreturnfiid=`\\_gen\\_ChangeId`T=\"$MSG.tmp.$$\"AWK=awkif \\[ -x /usr/xpg4/bin/awk \\]; then\\# Solaris AWK is just too brokenAWK=/usr/xpg4/bin/awkfi\\# How this works:\\# - parse the commit message as (textLine+ blankLine*)*\\# - assume textLine+ to be a footer until proven otherwise\\# - exception: the first block is not footer (as it is the title)\\# - read textLine+ into a variable\\# - then count blankLines\\# - once the next textLine appears, print textLine+ blankLine* as these\\# aren't footer\\# - in END, the last textLine+ block is available for footer parsing$AWK 'BEGIN &#123;\\# while we start with the assumption that textLine+\\# is a footer, the first block is not.isFooter = 0footerComment = 0blankLines = 0&#125;\\# Skip lines starting with \"#\" without any spaces before it./^#/ &#123; next &#125;\\# Skip the line starting with the diff command and everything after it,\\# up to the end of the file, assuming it is only patch data.\\# If more than one line before the diff was empty, strip all but one./^diff --git a/ &#123;blankLines = 0while (getline) &#123; &#125;next&#125;\\# Count blank lines outside footer comments/^$/ &amp;&amp; (footerComment == 0) &#123;blankLines++next&#125;\\# Catch footer comment/^\\\\\\[\\[a-zA-Z0-9-\\]+:/ &amp;&amp; (isFooter == 1) &#123;footerComment = 1&#125;/\\]$/ &amp;&amp; (footerComment == 1) &#123;footerComment = 2&#125;\\# We have a non-blank line after blank lines. Handle this.(blankLines &gt; 0) &#123;print linesfor (i = 0; i &lt; blankLines; i++) &#123;print \"\"&#125;lines = \"\"blankLines = 0isFooter = 1footerComment = 0&#125;\\# Detect that the current block is not the footer(footerComment == 0) &amp;&amp; (!/^\\\\\\[?\\[a-zA-Z0-9-\\]+:/ || /^\\[a-zA-Z0-9-\\]+:\\\\/\\\\//) &#123;isFooter = 0&#125;&#123;\\# We need this information about the current last comment lineif (footerComment == 2) &#123;footerComment = 0&#125;if (lines != \"\") &#123;lines = lines \"\\\\n\";&#125;lines = lines $0&#125;\\# Footer handling:\\# If the last block is considered a footer, splice in the Change-Id at the\\# right place.\\# Look for the right place to inject Change-Id by considering\\# CHANGE\\_ID\\_AFTER. Keys listed in it (case insensitive) come first,\\# then Change-Id, then everything else (eg. Signed-off-by:).#\\# Otherwise just print the last block, a new line and the Change-Id as a\\# block of its own.END &#123;unprinted = 1if (isFooter == 0) &#123;print lines \"\\\\n\"lines = \"\"&#125;changeIdAfter = \"^(\" tolower(\"'\"$CHANGE\\_ID\\_AFTER\"'\") \"):\"numlines = split(lines, footer, \"\\\\n\")for (line = 1; line &lt;= numlines; line++) &#123;if (unprinted &amp;&amp; match(tolower(footer\\[line\\]), changeIdAfter) != 1) &#123;unprinted = 0print \"Change-Id: I'\"$id\"'\"&#125;print footer\\[line\\]&#125;if (unprinted) &#123;print \"Change-Id: I'\"$id\"'\"&#125;&#125;' \"$MSG\" &gt; \"$T\" &amp;&amp; mv \"$T\" \"$MSG\" || rm -f \"$T\"&#125;\\_gen\\_ChangeIdInput() &#123;echo \"tree \\`git write-tree\\`\"if parent=\\`git rev-parse \"HEAD^0\" 2&gt;/dev/null\\`thenecho \"parent $parent\"fiecho \"author \\`git var GIT\\_AUTHOR\\_IDENT\\`\"echo \"committer \\`git var GIT\\_COMMITTER\\_IDENT\\`\"echoprintf '%s' \"$clean_message\"&#125;\\_gen\\_ChangeId() &#123;\\_gen\\_ChangeIdInput |git hash-object -t commit --stdin&#125;add_ChangeId","categories":[{"name":"Git","slug":"Git","permalink":"http://merrier.wang/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://merrier.wang/tags/git/"},{"name":"change-id","slug":"change-id","permalink":"http://merrier.wang/tags/change-id/"}]},{"title":"在线接口地址总结","slug":"在线接口地址总结","date":"2017-08-20T12:37:00.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170820/summary-of-online-interface-addresses.html","link":"","permalink":"http://merrier.wang/20170820/summary-of-online-interface-addresses.html","excerpt":"","text":"我在这篇文章中总结了一些在线接口地址，这些接口可以很方便的进行在线调用，完成某些业务需求，不过由于公开 API 基本上没有盈利空间，所以有可能过一段时间就不再维护了，大家在使用之前一定要验证一下是否仍然有效 天气其实提供天气接口的网站很多，有人已经替我们总结好了，可以点击这里查看，有些接口是需要知道自己的城市代码的，大家可以去中国天气网首页进行查询，不过我更推荐和风天气，和风天气需要注册成为认证开发者才能获得免费 7 天天气预报的资格，注册还是很简单的，差不多一天就能通过。目前和风天气提供的开发者免费天气服务： 国内 3181+ 海外 4000 热门 7天天气预报 实况天气 逐三小时预报 生活指数（基础 8 项） 空气质量实况（国控站点） 每天访问量：14959 次 稳定性：99% 技术支持：邮件 虽然免费 API 有访问限制，每天不得超过14959次，但是做天气数据缓存之后就应该够用了 IP地址搜狐搜狐提供了一个获取本设备 IP 地址的接口：http://pv.sohu.com/cityjson?ie=utf-8，其返回结果类似于： 1var returnCitySN = &#123;\"cip\": \"114.255.41.188\", \"cid\": \"110000\", \"cname\": \"北京市\"&#125;; 不知道为什么明明是 json 格式，偏偏要写的不符合规范，所以在获取到 response 之后，还需要自己解析一下。 新浪新浪提供了一个查询指定 IP 地址所在地理位置的接口：http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&amp;ip=114.255.41.188，其返回结果类似于： 1var remote\\_ip\\_info = &#123;\"ret\":1,\"start\":-1,\"end\":-1,\"country\":\"\\\\u4e2d\\\\u56fd\",\"province\":\"\\\\u5317\\\\u4eac\",\"city\":\"\\\\u5317\\\\u4eac\",\"district\":\"\",\"isp\":\"\",\"type\":\"\",\"desc\":\"\"&#125;; 一些字段是 URL 编码过后的字符，所以需要使用 decodeURIComponent 来解码成中文 chaipiphttp://chaipip.com/，这是某大牛自己开发的一个根据 IP 地址查询实际地理位置的网站，不过网站加了很多防护，而且每人每天有查询次数的限制（最多 20 次），所以就用来自己使用吧- - 人脸识别说到人脸识别，第一想到的肯定是 Face++ 了，不过除了人脸识别，Face++ 目前还可以提供人体识别、文字识别和图像识别等等服务 地图目前我所了解的提供开放地图 API 的网站有三家：百度地图、高德地图和腾讯地图： 百度地图开放平台 高德地图API 腾讯地图API 音乐目前有网易云音乐（很全面，感谢作者一直在更新）和酷狗音乐，github 上有很多利用网易云音乐 API 做的项目，包括小程序、网页版、wap 版以及 electron 版，大家感兴趣的去同性交友网站上可以搜一下 字体我们知道通过 css 中的 @font-face 可以引入一些特殊字体，而现在 Google Font Api 也能实现，具体使用过程见大漠的文章——《Google Font的运用》 一句话一言网创立于 2016 年，隶属于萌创 Team，目前网站主要提供一句话服务。一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。或是感动，或是开心，亦或是单纯的回忆。这是一个我很喜欢的 API 服务，希望它永远不会停止吧！ 北邮人论坛非官方 API北邮人论坛非官方 API。基于 NodeJS，通过 superagent 抓取数据并用 cheerio 处理后返回 JSON 格式数据。目前有这些功能： 获取十大信息 获取版块主题列表 获取主题回帖列表及精彩回复 回复帖子 不过好像 github 上提供的线上域名无法访问了，所以如果你需要使用的话，需要自己部署一下 名人生日美国神婆星座网，提供名人生日查询、名人出生日期查询等,看看每一天都有哪些名人出生，哪些名人是和你一天出生的；不过目前只能通过爬取网页的形式来间接获取，没有开放 API 接口 表情图片斗图啦，表情图片社区斗图啦提供的开放 api，调用很简单，可以很方便的结合 IM 软件开发一个表情机器人。 图片压缩tinypng是知名的免费压缩图片的网站，而同时其也提供了压缩图片的 API 服务，API key 申请地址：https://tinypng.com/developers，调用这个网站提供的 API 需要申请一个 API key，输入邮箱，它会把包含 API key 的网址发到你邮箱，打开其中的链接就可以看到属于你的 API key 了；调用这个网站的 API 进行图片压缩的话，每个月前 500 张是免费的，之后要收费；不过既可以压缩 png 图片，又可以压缩 jpg 图片。 Githubgithub 的接口 api 都是开放的，我们可以借助公开 API 构建一个属于自己的项目管理工具。官方文档有 v3 和v4 2个版本，v3 是 Restful，v4 是 GraphQL，v3 版地址： https://api.github.com 在无 token 情况下使用 github 的 api，每分钟限制是 60 次请求，如果想完整的使用 github 的api，\b可以构建一个 web application，具体流程可以参考：【React 实战教程】从0到1 构建 github star管理工具 CDN资源cdnjs具体开放 API 列表可以看这里：https://cdnjs.com/api，你可以获取全部资源列表，也可以通过关键词进行搜索，还可以指定插件，功能比较强大 翻译google-translate-api，一个免费且无限制的谷歌翻译 API 库，npm 引入一下即可使用 一些提供接口的网站HaoService数据平台提供了很多数据接口服务，包括短信、语音验证码、银行卡归属地、手机归属地和天气等等，收费也比较良心，适合中小型公司使用。 RSSHubRSSHub 是一个轻量、易于扩展的 RSS 生成器, 可以给任何奇奇怪怪的内容生成 RSS 订阅源；同时该网页中包含了已有 RSS 内容的网址，涵盖多个领域，对于那些研究爬虫与内容订阅方向的童鞋来说是个福利。 京东万象向开发者提供国内外最全的金融数据、电商数据、运营商数据、京东数据、生活服务数据、应用开发数据、质检数据等接口,为开发者提供合法有效的优质 API 接口。京东万象,权威的数据交易平台。有收费的也有免费的，比如空气质量相关API 就是免费提供的。","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"接口","slug":"接口","permalink":"http://merrier.wang/tags/接口/"},{"name":"API","slug":"API","permalink":"http://merrier.wang/tags/API/"}]},{"title":"他山之石，可以攻玉，好文章推荐","slug":"他山之石，可以攻玉，好文章推荐","date":"2017-08-07T03:40:22.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170807/good-article-recommendation.html","link":"","permalink":"http://merrier.wang/20170807/good-article-recommendation.html","excerpt":"","text":"经常看别人的博客或者文章，有时候闲暇时间也会刷一刷微信公众号神马的（但其实微信公众号上的文章也是转载其他人的博客），所以难免会碰到一些“不想关闭”的文章，放到收藏夹里又怕哪天消失了，所以就放到这里吧，也可以节省大家寻找好文章的时间。（这些文章有些难度会比较大，不太推荐将大量的时间花费在“纠结原理”上） 人工智能相关深入浅出看懂AlphaGo元前段时间关于阿法狗的一篇文章（《今日Nature: 人工智能从0到1, 无师自通完爆阿法狗100-0 | 深度解析》）火爆了微信朋友圈，而关于阿法元是如何自我学习的，这篇文章讲述的很明白。 浅谈人工智能：现状、任务、构架与统一 | 正本清源“人工智能”这个名词在沉寂了近 30 年之后，最近两年“咸鱼翻身”，成为了科技公司公关的战场、网络媒体吸睛的风口，随后受到政府的重视和投资界的追捧。于是，新闻发布会、高峰论坛接踵而来，政府战略规划出台，各种新闻应接不暇，宣告一个“智能为王”时代的到来。 到底什么是人工智能？现在的研究处于什么阶段？今后如何发展？这是大家普遍关注的问题。这篇文章用大篇幅解释了这些问题，目录如下： 第一节 现状：正视现实 第二节 未来：一只乌鸦给我们的启示 第三节 历史：从“春秋五霸”到“战国六雄” 第四节 统一：“小数据、大任务”范式与认知构架 第五节 学科一：计算视觉 — 从“深”到“暗” 第六节 学科二：认知推理 — 走进内心世界 第七节 学科三：语言通讯 — 沟通的认知基础 第八节 学科四：博弈伦理 — 获取、共享人类的价值观 第九节 学科五：机器人学 — 构建大任务平台 第十节 学科六：机器学习 — 学习的终极极限与“停机问题” 第十一节 总结：智能科学 — 牛顿与达尔文的统一 前端相关玉伯《从前端技术到体验科技（附演讲视频）》我想，玉伯大神应该不用过多介绍了吧，从之前的 seajs 到现在的 ant design，而玉伯大神也从一名前端工程师“进化”为一名架构师，这篇文章是玉伯大神在 SEE Conf 大会上的演讲记录，同时文章末尾还有演讲视频链接，不喜欢看文字的朋友可以直接看演讲视频。 哔哩哔哩（B站）的前端之路作者总结了 B站 的前端进阶之路，前端的轮子很多，作者介绍了 B站 是如何选型的以及遇到了哪些坑。 深入剖析 WebKit这篇文章和他的题目一样，真的很“深入”，因为你可以看到滚轮滑动的速度。。不过图文并茂的表现形式并不会让你产生“看不下去”的感觉，来张目录感受一下是不是干货： 前端文章- 收藏集 - 掘金掘金上面关于前端的文章集合，闲暇时间看一下，可能会有意想不到的收获 前端工程——基础篇fis 作者张玉龙对于前端工程的理解，从组件化到资源管理都阐述了自己的观点，这是一篇 2015 年的文章，但是文中的某些观念到现在看来仍然是字字珠玑，相信看完之后的你可以对前端有更深层次的理解。 大公司里怎样开发和部署前端代码？又是张玉龙的文章，通过一个实际的场景一步步的告诉你大公司的前端代码是如何开发和部署上线的。 Web 前端知识体系精简从前端三剑客：HTML、CSS、Javascript 的角度分析了前端的知识体系，涉及到的领域比较广泛，很适合前端新人开拓视野和寻找学习方向，同时总结的也很全面，是一篇不错的入门教材。 移动时代的前端加密这篇文章篇幅很长，对于前端来说，很多人感觉“加密”是莫须有的一种东西，其实这是一种误解，“加密”并不意味着绝对安全，这篇文章将从这个角度向你阐述前端加密的正确姿势。 前端疲劳有这么多不同的前端技术栈，不同的前端框架，不同的前端工具和库像水一样包裹着我，我不去学就不会，学了又学不完。在前端的海洋里越陷越深的我究竟该如何自救呢？这篇文章可能有你要的答案 精读前后端渲染之争前后端渲染一直以来都是一个带有争议的话题，而该文章的作者对国外一篇关于前后端渲染的文章进行了精读，介绍了前后端渲染各自的优缺点，以及我们在实际项目中如何取舍。 技术雷达之「微前端」- 将微服务理念扩展到前端开发看标题就知道，这是一篇基本上看不懂的文章，不过图文并茂的形式让这篇文章生动了很多，内容很充实，覆盖面很广 理解 Web 路由关于路由，其实是一个很抽象的概念，而这篇文章对经常提到的前端路由和后端路由的实现和区别进行了很详细很清晰的讲解，同时对动态路由和严格路由也进行了介绍。 一站到底—前端基础之网络这篇文章算是近几年来我读过的信息量最大、知识点最全的文章了，作者从访问一个网址说起，为读者建立了一个健全的网络知识体系，该文章解答了以下问题： 必会： http 报文都有哪些内容？ HTTP 协议头含有哪些重要的部分，HTTP 状态码？ HTTP 状态码状态码都有哪些？ 什么是强缓存？什么是弱缓存？ 浏览器的现缓存机制是什么？如何设置 HTTP 缓存？ 你知道有哪些 HTTP 方法？POST 和 PUT 有什么区别？ 如何对数据进行压缩（ZLIB），Gzip? 压缩的范围是什么，请求头会压缩吗？ 跨域，为什么 JS 会对跨域做出限制？如何允许跨域? 基础： 影响网速的原因有哪些？网络丢包的主要原因是什么？ 网络体系结构的五层参考模型都是什么？它们之间的关系是什么？ 我们常听到报文、段（分组）、数据报、帧、和数据包，它们有什么关系？ Ajax 能发送 http 请求，它和 http 有什么样的关系？ HTTP1.0 到 HTTP1.1 解决了什么问题？ http2 有什么特性？ http1.1 为什么会有队首阻塞？ SSL 与 TLS 关系？HTTPS 协议如何实现？ 补课与拓展：（慢慢更新） 常用的传输层协议有哪些？TCP 和 UDP 分别有什么特点？ 解释一下 TCP 的三次握手和四次挥手？ 为什么说 TCP 可能是网络通信的瓶颈？如何解决 TCP 队首阻塞？ 谷歌新出 QUIC 为什么要基于 UDP？ QUIC 有哪些新特性，解决了什么问题？ WEB 服务器探究作者介绍了 web 服务器的基本概念，和常见的服务端演替路线。图文并茂的方式很容易理解，干货满满。 网站性能优化实战——从12.67s到1.06s的故事作者将自己的在线简历进行了性能优化，首屏时间从 12.67s 降低到了 1.06s，这个过程中作者踩了很多坑，翻阅了很多书籍，最终总结出了这篇文章。文章涉及到的知识点比较全面，对性能优化进行了系统的介绍。 现代 Web 开发基础与工程实践前端大牛@王下邀月熊的著作，对 Web 开发基础与工程实践的相关博客、示例代码与开源项目、整理成的系列书籍等内容进行了总结，信息量异常庞大，包含以下篇章： 导论篇: Web 开发简史与运行机制，数据流驱动的界面，模块化与组件化，工具化与工程化，前后端分离与 GraphQL，大前端与 WebAssembly。 基础篇: 对于 HTML、CSS、DOM 等 Web 开发中涉及的基础知识与理念的总结介绍。 工程实践篇: 构建工具，测试，安全，WebAssembly。 架构优化篇: 组件化，状态管理，性能优化，PWA。 React 篇：近年来前端领域百花齐放，各种技术方案争妍斗艳，各领风骚。本书立足于其中的佼佼者 React，深入浅出的介绍 React、Webpack 、 ES6、Redux 、 MobX 等常见前端开发工具与开发库的用法，帮助初学者能够迅速成为一名合格前端工程师。而本书也不仅局限于工具使用的层面，探寻各种技术方案背后蕴含的设计思想与架构模式，从前端工程化的角度讨论前端开发者在进阶过程中需要掌握的工程实践、模块化与组件化、质量保障、性能优化等知识要点。最终帮助开发者在前端开发中能够因地制宜的指定合理方案，以尽可能快的速度实现可信赖的产品。 Vue 篇：本部分目前正逐步启动，笔者的初衷是希望能够保证本书章节与 React 与前端工程化实践尽可能一致，从而更方便地去介绍不同技术栈下相通的设计理念；目前本书的目录只是拷贝自 React 与前端工程化实践，未来笔者会逐步完善。 雅虎前端优化35条规则翻译本文是大名鼎鼎的雅虎前端优化规则（Yslow）的翻译。作者对其中的一些例子进行了精简。 前端知识体系目录从基础到进阶，从 HTML、CSS、JS 到 HTTP，简单的总结了前端领域需要了解的知识点，同时推荐了一些书籍，对于那些想要入坑前端的童鞋来说是一份不错的指引文档。 微前端的那些事儿 微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。 这篇文章是 phodal 对于微前端的解读，包括其实现方式以及方案对比，而微服务与前端的结合会有多大的优势，值得期待。 2018 前端常见题汇总汇总了前端一些问题，作者不定时更新，建议收藏 HTML 相关 CSS 相关 JAVASCRIPT 相关 DOM 相关 HTTP 相关 VUE 相关 算法相关 网络安全相关 webpack 相关 其他 InfoQ 趋势报告之 JavaScript 和 Web 开发文章简单介绍了 Javascript 生态系统的现状和发展历程，文中提到了很多名词和框架，是一篇很不错的“扫盲”文章。 2019 - Web开发技术指南和趋势这是一个 2019 年你成为前端，后端或全栈开发者的进阶指南: 你不需要学习所有的技术成为一个 web 开发者 这个指南只是通过简单分类列出了技术选项 我将从我的经验和参考中给出建议 首选我们会介绍通用的知识, 最后介绍 2019 年的 Web 的一些趋势 要想知道更多细节, 请看 Youtube 视频: Web Development in 2019 前端模块化详解(完整版)这篇文章内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范，并且介绍下开发中最流行的 CommonJS, AMD, ES6、CMD 规范。作者试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望屏幕前的你阅读后，对模块化编程有个全新的认识和理解！ 2018 前端性能优化清单英文原文：https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/，文章较长，需要比较长的时间才能读完，涉及到的地方非常全面，五星推荐。 JS相关统一回复《怎么学JavaScript？》作者通过自己的经历告诉大家：如何学习前端。这是一篇很不错的前端入门文章，作者推荐了一些前端方面的书籍，同时还注明了这些书籍适合什么时候阅读以及适合怎样阅读，建议仍然不知道如何学前端的你好好看一下这篇文章 javascript 的 12 个怪癖（quirks）实际上 javascript 是一个相当简洁的语言，但是也难免会有一些怪癖（quirks）。这是作者翻译的国外一个开发者的系列文章，同时在我发布之前（2017-8-7），作者还没有翻译团队，如果有英语比较好的前端小伙伴，欢迎加入翻译的队伍中，像我这种英语“战五渣”表示只能“拿来”了。。 80% 应聘者都不及格的 JS 面试题从最简单的 setTimeout() 执行队列，到自执行函数产生闭包，再到 ES6 中的 promise 以及 ES7 中的 async 和 await，作者通过一道不断延伸出来的js面试题讲解了在面试中经常遇到的问题，同时对以上的这些知识点进行了概括总结 [翻译] We have a problem with promisespromise 一直是被认为判断一名“前端工程师”是否仍然处在“初级”的利器，而这篇文章通过 promise 相关的四段代码对 promise 进行了深入剖析，这是一篇译文，英文原文可以点击这里查看 学用 JavaScript 设计模式设计模式的概念很早之前就有了，而 JS 虽然之前一直被认为是“做网页”的语言，但是JS中也有设计模式的思想，相信看完这个系列的文章之后，你会对 JS 有更加深入的理解，该系列文章对于没有“面向对象”语言基础的童鞋来说可能会有些难度，建议在看的过程中及时查阅其他资料。 ajax跨域，这应该是最全的解决方案了看题目就很屌，恩。。 jQuery的document ready与 onload事件——你真的思考过吗？虽然题目看似和 jQuery 关系很大，但其实作者探究了很多 JS 相关问题，包括加载顺序以及 load 事件的产生原因，内容短小精悍，值得一看。下面这些问题是作者在文中所阐述探索的： window.onload 到底是什么加载完触发？ body 为什么会有 onload 事件？ 为什么是 window.onload，而不是 document.onload？ document ready到底是什么 ready，DOM 渲染完成？ jQuery 怎么实现 $(document).ready？ jQuery 的 ready，还能 ready 什么？ jQuery 的 document ready 就一定比 window.onload 快吗？ 为什么外部 script 文件放页面内容后面好，是一定的吗？ 10 分钟了解 JS 堆、栈以及事件循环的概念作者通过 JS的内存机制以及事件机制和大量的（例子）来讲解栈、堆究竟是个什么玩意。概念比较多，不用死读，把所有的实例代码手敲一遍就很清楚了，作者讲的很透彻，该文章来自于薄荷前端周刊，该周刊发布的文章都蛮不错的，建议阅读~ 7 分钟理解 JS 的节流、防抖及使用场景防抖和节流是两个很重要也经常会用到的知识点，这篇文章的重点并不是介绍它们的实现原理，而是着眼于它们的应用效果和应用场景，文中对于防抖和节流产生效果的总结很通俗易懂： 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。函数节流就是 fps 游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。 精读 The Cost of JavaScriptAddy 在 The Cost of JavaScript In 2018一文中分享了在保证用户友好交互体验的前提下如何高效分发 JavaScript 的开发经验，而我现在推荐的这篇文章是一篇导读文章，原文作者首先将全文的内容压缩成几条观点总结出来，之后从用户体验为 Web 带来的变化开始说起，到 JavaScript 的成本有哪些、它们为何如此高昂、如何降低开销以及持续集成，全文形成一个非常完整的优化流程： 写在开头的话 膨胀的 JavaScript 与 Web 现状 JavaScript 的成本所在 页面交互性解释与建议 处理 JavaScript 成本为何如此昂贵 千差万别的移动用户与应对策略 分发更少 JavaScript 的常见技巧 持续集成四部曲 深入理解javascript原型和闭包系列本系列有 16 篇文章，外加两篇后补的，一共 18 篇文章。将原型和闭包相关知识都进行了讲解，知识点很全，图文并茂。 JavaScript 模块化七日谈作者以 slide 的形式讲解了 JS 模块化的发展历程，目录： 第一日 上古时期 Module? 从设计模式说起 第二日 石器时代 Script Loader 只有封装性可不够，我们还需要加载 第三日 蒸汽朋克 Module Loader 模块化架构的工业革命 第四日 号角吹响 CommonJS 征服世界的第一步是跳出浏览器 第五日 双塔奇兵 AMD/CMD 浏览器环境模块化方案 第六日 精灵宝钻 Browserify/Webpack 大势所趋，去掉这层包裹！ 第七日 王者归来 ES6 Module 最后的战役 写了 10 年 Javascript 未必全了解的连续赋值运算a.x = a = {n:2} 是一个连续赋值表达式。 这个连续赋值表达式在引擎内部究竟发生了什么？是如何解释的？作者从这一问题出发，对 JS 中的变量定义规则进行了研究。 每个 JavaScript 工程师都应懂的33个概念这篇文章是参照 @leonardomso 创立，英文版项目地址在这里。 由于原版资源都要翻墙，所以作者创立了一个中文版，附上关于 JS 中的 33 个概念在国内的一些文章和视频。所以这可以看做是一个文章 / 视频集合，闲来无事的时候可以看一下巩固一下基础概念。 前端网老姚浅谈：怎么学 JavaScript？前端老姚对如何学习JS这一问题的解答，主要回答了以下几个问题： 看书有啥好处 看什么书 怎么看书 看书的层次 利用源码进行学习 时间、兴趣等问题 Effective JavaScript关于原生 JS 的 68 个实例，理论上,实践过下面的 68 个项目之后,你的JS能力应该有一个质的飞跃 how javascript works本文是翻译介绍 JavaScript 的工作原理的，该系列原文还在更新中，原文见这里。 HTML相关常用的 HTML 头部标签曾几何时，我们已经不再手写 HTML 标签。Emmet、Markdown 等工具让我们「健步如飞」，但是我们真的了解这些标签了吗？这篇文章着重介绍了一些我们容易忽视和用错的头部标签，特别是 iOS 等针对移动设备的一些标签。这是一篇非常基础的标签索引，其中 iOS 设备部分对设计师也有参考作用。 H5 项目常见问题汇总及解决方案这是一篇还算比较新的文章（2017-3-26），作者总结了一些前端开发过程中的常见问题，虽然有些问题可能不算是“常见”，但是看过一遍之后留下点印象也是可行的，到时候如果真遇到了不会解决的问题就知道去哪里找答案了~ HTML5 进阶系列：文件上传下载HTML5 中提供的文件API在前端中有着丰富的应用，上传、下载、读取内容等在日常的交互中很常见。而且在各个浏览器的兼容也比较好，包括移动端。作者在该文中介绍了一些上传下载的 API，包括 FileList 对象和 file 对象、Blob 对象和 FileReader 对象等。 图片上传知识点梳理在日常项目开发中，图片上传是一个十分常见的场景。在这篇文章中，作者通过简单的代码，解析了图片上传的各个知识点，包括样式自定义、图片校验、图片上传预览、图片上传与上传进度展示和拖拽上传。 CSS相关写 CSS 的姿势作者-大漠，内容很丰富，放在第一位是有原因的。。 CSS 实现长宽比的几种方案作者是传说中的大漠孤秋，介绍了单纯用CSS实现定比例长宽图形的几种方案 实用的 CSS — 贝塞尔曲线(cubic-bezier)贝塞尔曲线在 CSS 动画中应用较广，了解一下对于 CSS 动画效果会有更深的理解 探究 CSS 解析原理作者对浏览器的渲染过程和 CSS 的解析原理进行了详细解释，代码很多，干货满满 改变用户体验的滚动新特性作者是大漠，他在文中介绍了时至今日，CSS 中为浏览器滚动提供的相关新特性究竟能给用户带来哪些新的体验。图片和代码较多，慎用流量 说说CSS学习中的瓶颈张鑫旭 2012 年的文章，虽然年代比较久远了，但是至今看来还是颇受启发，如果你有“CSS好难”、“为什么CSS那么多属性”、“怎么让它垂直居中啊”等疑问，推荐你看这篇文章。 「前端那些事儿」③ CSS 布局方案作者几乎罗列了日常工作中遇到的所有类型的布局，并附上了详细的代码，其中包括：居中布局、多列布局、并排等分，单排对齐靠左布局和圣杯布局&amp;双飞翼布局等。源码传送门：https://github.com/willspace/css-layout/tree/master/demo-1 深入了解 CSS3 新特性这篇文章介绍了 Web 开发中关于 CSS3 的一些内容，由浅入深的逐步引出 CSS3 的各种相关属性。基于各个 CSS3 属性的原理，通过实际的源代码介绍各个 CSS3 新特性的特点，使用方式以及使用中需要注意的地方 You need to know css作者把自己的收获和工作中常用的一些 CSS 小样式总结成了这份文档，包含了 43 个 CSS 的小样式。 框架相关react 组件的生命周期作者详细介绍了和 react 生命周期的一些函数执行时机以及它们的作用，通过实例的方式进行了讲解，个人感觉讲解的非常清晰 Gulp 和 Webpack 对比作者通过实际的代码对比了 gulp 和 webpack 在功能、原理以及模块化方面的优缺点 webpack 常用插件及其作用介绍了 webpack 经常用到的一些插件和它们的作用，美中不足的是没有具体代码以及介绍的插件有点少 webpack 源码阅读——npm 脚本运行 webpack 与命令行输入 webpack 的区别虽然是一个小知识点，不过作者读源码的精神可嘉 webpack - 收藏集 - 掘金掘金上面的 webpack 相关文章，webpack 本身实在太复杂，还是需要一些文章差补缺漏的 Vue.js——60分钟快速入门vue 入门教程，还有另外两篇文章，文章最后有链接，个人认为是目前为止看到的最舒服的 vue 入门教程，排版配色都很不错 深入到源码：解读 redux 的设计思路与用法一直都没搞明白 redux，后来看了这篇文章，讲的很详细，而且讲解了一部分源码，推荐！（下面一段话取自该文章） 组织 redux 的流程莫过于： 设计全局 state 的数据结构 设计更改 state 数据的 actionTypes 常量以及其他跟视图展现相关的 actionTypes 常量 根据 actionTypes 常量，书写 actionCreator 。 根据各个 actionCreator 的返回值，涉及 reducer 做数据的最后处理 在有了 reducer 函数之后，createStore(reducer, initState) 得到 store 对象 用 bindActionCreators 函数将 actionCreators 和 store.dispatch 绑定起来，得到一组能修改全局状态的函数 分发各个状态修改函数到各个 DOM 事件中。 Vue 生命周期深入这篇博客会从下面四个常见的应用诠释了组件的生命周期，以及各个生命周期应该干什么事，博主写的很不错，直观易懂，很适合接触 vue 不深的童鞋。 单组件的生命周期 父子组件的生命周期 兄弟组件的生命周期 宏 mixin 的生命周期 2019 年 Vue 学习路线图作者我将在这篇文章中展示了一个高级“知识地图”，它包含了与 Vue 开发相关的关键领域，你可以使用这张地图作为 2019 年学习 Vue 的图鉴。英文原文：https://vuejsdevelopers.com/2018/12/04/vue-js-2019-knowledge-map/ 一口(很长的)气了解 babel作者详细介绍了 babel 究竟是做什么的，以及 babel 的一些配套工具的作用，同时还介绍了如何争取地进行配置和使用 babel。 Which of the 635000 npm modules do I choose?npm 现在已经有 60 多万个库，如何在如此繁杂的 module 中选择合适自己的感觉是件难事，而作者就基于此对一些比较大型使用比较多的库进行了横向比较，会对你在技术上的选择起到帮助作用。 2019 年 React 学习路线图和上面的 Vue 学习路线图类似，建议搭配食用，英文原文：https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02 浏览器相关浏览器进程？线程？傻傻分不清楚！什么是多进程架构浏览器？为什么浏览器内核是多线程？Javascript 是单线程又是什么鬼？进程和线程是否分得清楚呢？文章干货和知识点比较多，需要查阅相关知识才能完全消化。 WebView 性能、体验分析与优化来自美团的技术文档，对 webview 的方方面面都进行了详细的介绍，同时指出了其存在的问题，相信看完之后对于 webview 会有更深层次的理解~ 浅析 HTTP 缓存的机制-浏览器缓存在浏览器众多缓存中的 HTTP 缓存可能很多人对这个的概念并没有很清晰，每个人都知道进入一次网页之后再刷新一次页面，加载速度会比首次加载快非常多，每个人都知道这是浏览器缓存的 magic，但是对此背后的原因可能不甚了解；作者结合状态码介绍了强缓存和弱缓存的区别和触发条件，篇幅短小精悍，值得一读。 深入理解 JSCore目前业界流行的动态化方案，如 Facebook 的 React Native，阿里巴巴的 Weex 都采用了前端系的 DSL 方案，而它们在 iOS 系统上能够顺利的运行，都离不开一个背后的功臣：JavaScriptCore（以下简称 JSCore），它建立起了 Objective-C（以下简称OC）和 JavaScript（以下简称 JS）两门语言之间沟通的桥梁。作者从浏览器谈起，对 Webkit 内核的工作原理和组成进行了详细介绍，同时介绍了 JSCore 的组成部分：词法分析、语法分析和解释执行，后面还介绍了 iOS 中的 JSCore 的应用和一些机制，篇幅较长，但是干货满满，如果你对浏览器渲染引擎感兴趣，这篇文章值得一看~ H5 唤起 APP 指南(附开源唤端库)唤端的定义：引导已下载用户打开 APP，引导未下载用户下载 APP。对于用户留存来讲，唤起 App 是一种很重要的手段，这篇文章可以说把所有和唤端相关的知识点都介绍了，最后还给自己的工具打了一发广告。。 当···时发生了什么？这个仓库试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？不过作者不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。包括一些硬件知识也包含其中，我相信如果面试官问到你这道题，然后你的回答是这篇文章里面描述的话，面试官肯定会大吃一惊！ HTTP, HTTP2.0, SPDY, HTTPS 你应该知道的一些事作为一个经常和 web 打交道的程序员，了解这些协议是必须的，而这篇文章就向大家介绍了一下这些协议的区别和基本概念，文中不局限于前端知识，还包括一些运维，协议方面的知识。 浏览器的工作原理：新式网络浏览器幕后揭秘这是一篇全面介绍 WebKit 和 Gecko 内部操作的入门文章，是以色列开发人员塔利·加希尔大量研究的成果。在过去的几年中，她查阅了所有公开发布的关于浏览器内部机制的数，并花了很多时间来研读网络浏览器的源代码。 网络浏览器很可能是使用最广的软件。在这篇入门文章中，作者将会介绍它们的幕后工作原理。我们会了解到，从在地址栏输入 google.com 直到在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。文章讲解的很详细，篇幅较长，需要比较大的耐心才能看下去。 HTTP 请求头中的 X-Forwarded-For这篇文章对 HTTP 请求头中的 X-Forwarded-For（XFF）进行了详细的讲解，当我们需要取到用户的真实 IP 时，对这个请求头的理解和使用就显得尤为重要了，而从这个应用场景出发，作者还对请求头中的 x-real-ip 字段以及 Remote Address 进行了介绍。作者还有关于 HTTP 的其他文章，可以点击这里查看更多。 图解浏览器的基本工作原理可能每一个前端工程师都想要理解浏览器的工作原理。我们希望知道从在浏览器地址栏中输入 url 到页面展现的短短几秒内浏览器究竟做了什么；我们希望了解平时常常听说的各种代码优化方案是究竟为什么能起到优化的作用；我们希望更细化的了解浏览器的渲染流程。那么这篇文章就解答了上面的所有问题，文章较长，图文并茂。 Content Security Policy - An Introduction一篇介绍 CSP 的文章，介绍了我们为什么需要 CSP，以及涉及到 CSP 的一些协议头等等相关信息。 认识 HTTP—-Cookie 和 Session 篇虽然内容大多来自《图解HTTP》一书，但是条理清楚分明，文笔很好，作者解释的很清晰。 图解基于 HTTPS 的 DNS这是关于 dns 查询的过程讲解，配上插图和文字，可以对 dns 的查询过程有一个大概了解。 理解 WebKit 和 Chromium系统的描述了 Chrome 浏览器的信息，可以更加全面的了解 Chrome 浏览器，最给力的是有很多工具的使用介绍。 计算机基础编码简介：utf8, utf16 以及其它作者对 utf8 和 utf16 以及其它相关知识进行了介绍，前端同学可能很少会关注到字符编码规则，但是有时候我们经常会遇到乱码等问题和 Bug，而在阅读完这篇文章之后，相信你对字符编码这类知识会有一个很深的理解。 可以说的秘密-那些我们该讨论的前端加密方法这篇文章介绍了前端开发中常用的加密方法并给出了其适用场景。包括 Base64 编码、哈希算法、加盐、慢哈希函数、密钥哈希、XOR 和加密（Encrypt）等加密方法， 一个由正则表达式引发的血案（解决版）正则表达式一直以来是广大码农处理字符串的福音，但与此同时，也容易引发血案。这篇文章从一则实例出发，对正则表达式可能引发的 CPU 爆表问题进行了分析，同时作者还介绍了一种遗传算法，该算法解决了如下问题： 给定一个正则引擎和一个正则表达式，为这个正则表达式找到一个攻击字符串，它可以最大化正则引擎的匹配时间。 感兴趣的童鞋可以认真研究一下这篇文章，或者作者发表的论文。 计算的本质：赋值和流的杂谈写了这么久的程序，不少人肯定会有疑问，计算的本质是什么？对一台图灵机来说，那就是无限长的纸带和能够自如移动的读写头，但这太抽象了。作者换了一种方式去理解计算并总结出了这篇文章，稍微有一些晦涩难懂，不过看完大有裨益。 算法漫画：什么是动态规划？以漫画的形式生动形象的解释了动态规划是什么，以及其解法。虽然篇幅较长，但是漫画看起来一点都不枯燥。 漫画：如何求根号2（爱奇艺面试题）用漫画的形式讲解了二分法和牛顿迭代法，最后还给出了源码 2018汇总数据结构算法篇用图文的方式对一些数据结构进行了通俗易懂的解释，内容非常基础和全面。 服务层相关node 基础面试事件环？微任务、宏任务？一篇带你飞这是一篇很干货的文章，作者介绍了 node 的应用场景以及特性，同时还顺带着介绍了同步/异步、阻塞/非阻塞、微任务/宏任务这些 node 面试中经常遇到的知识点，虽然篇幅不是很长，但是涵盖的范围比较广，对于刚入门前端的童鞋来说有比较大的难度，不过对于那些已使用 node 一段时间的童鞋来说是一篇不错的总结类文章。 Error Handling in Node.js关于 NodeJS 中异常的种类，以及应该如何处理异常方面的设计文章，比较长，而且是英文的，但比较受益。（有没有大佬翻译一把？） 开发者需要了解的 nodejs 中 require 的机制对 nodejs 中的模块加载进行了详细的讲解，同时对 exports 和 module.exports 的区别和正确使用方式也进行了讲解，是一篇非常不错的 nodejs 模块方面的文章，该文为译文，原文地址：https://medium.freecodecamp.org/requiring-modules-in-node-js-everything-you-need-to-know-e7fbd119be8 CDN 技术详解《CDN技术详解》绝对是带你进入 CDN 行业的那盏最亮的明灯。因此，虽然只是纯粹的重点抄录，作者还是把《CDN技术详解》中的精华总结成了这篇文章。 Mac相关EffectiveMac作者是在今日头条任职的 iOS 高级工程师，在这篇文章里介绍了 Mac 的一些使用技巧以及配置指南，包括 Vim、Git、Zsh 等工具的使用方式，是截止到目前为止我看过的最全面、最实用的 Mac 教程，经常用 Mac 的童鞋一定要抽空看一看！ 前沿GraphQL and Relay 浅析相信大部分人都没听说过 GraphQL 和 Relay 吧，这篇文章就对这两样东西进行了介绍，同时文章结尾还有一些扩展阅读链接 译文：Puppeteer 与 Chrome Headless —— 从入门到爬虫Puppeteer 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具。正因为这个官方声明，许多业内自动化测试库都已经停止维护，包括 PhantomJS。Selenium IDE for Firefox 项目也因为缺乏维护者而终止。 初探 Headless ChromeHeadless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序。相比于现代浏览器，Headless Chrome 更加方便测试 web 应用，获得网站的截图，做爬虫抓取信息等。相比于出道较早的 PhantomJS，SlimerJS 等，Headless Chrome 则更加贴近浏览器环境。 [译] React Native vs. Cordova、PhoneGap、Ionic，等等原文链接：https://learnreact.design/2018/02/14/react-native-vs-cordova-phone-gap-ionic-etc，主要解释了以下几个问题： 什么是原生应用？ 什么是 WebView UI ？ 更原生化的框架的优势和劣势分别是什么？原生化更少的框架呢？ React Native 与 Cordova 相比如何？ 求职如何写面向互联网公司的求职简历作者在 IT 公司工作了六年，有着三年面试官的经历。文章主要内容为： 简历的页数不要超过两页（最好一页） 删掉不必要的信息 如果你实在太牛逼，最多写 2 页 重要的信息写在最前面 你的联系方式 你最重要的工作经历 不要简单罗列工作经历 列出你的工作中有价值的细节（有哪些技术上的困难等） 不要写任何虚假或夸大的信息 类似精通 java，精通 C/C++ 等 不要附加任何可能带来负面印象的信息 不要加照片 不要写政治面貌 不要写奇怪的爱好（打游戏，喝酒，抽烟） 不要写参加过某某培训公司的 iOS 培训 尽量用专业邮箱 用 PDF 格式 让 BAT 的 Offer 不再难拿作者是软件工程专业，对 Web 前端感兴趣，目前从事 iOS 开发，对开发效率的提升以及工具的使用有很深入研究和思考，相信他总结的这篇面经一定不会让你失望。 一篇文章搞定前端面试这篇文章旨在用最通俗的语言讲述最枯燥的基本知识，文章提纲： TCP UDP 套接字 socket HTTP 协议 DNS 解析 HTTP 请求发起和响应 页面渲染的过程 页面的性能优化 OpenDoc - 前端简历评级标准美团团队从工作意向、工作经历、教育经历、技术栈、基础知识五个维度评价简历，仅供参考。 设计严选Redesign这篇文章来自站酷，介绍了网易严选的设计风格和思路，包括一些颜色规范、版面设计和图标选择\b等等。 移动端设计样式库-导航设计（二）作者对移动端界面设计中另一个常见的导航模式-瞬时导航进行了介绍，对导航的实现方式以及优缺点进行了十分详细的介绍。 斗鱼5.0全新升级来自站酷，文章篇幅较长，详细介绍了斗鱼 APP 和网页的设计思路。 文章集合奇文共欣赏，疑义相与析总结了很多不错的前端文章，领域包括ES6、前端基础、React、Webpack、TypeScript 等等，大概 100 篇左右，信息量很大。 年终回顾，为你汇总一份「前端技术清单」作者对前端基础相关好文以及前沿技术类文章进行了汇总，框架类的文章较少，期待作者继续补充完善。 微信网络技术的一些整理与思考在弱网情况下所有 app 中微信是几乎唯一一个能够正常工作的，大家都比较好奇为什么微信能够达到这样的效果。\b而作者收集了一些微信公开的网络优化相关的材料，特地分享于此。 五星推荐的系列文章清单大部分文章需要翻墙，文章有一些难度，需要一定的基础知识。 其他单点登录原理与简单实现很多产品中都会有 SSO（单点登录）的实现，而本篇文章就十分详尽的介绍了 SSO 的原理，同时介绍了实现方式。 区块链，将如何重新定义世界？&amp;version=12020710&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=n5qDpQUy1oJy2NzXnQPhCPTs4r%2B3crpBEs3qT4e1De3atGQPhxWzrqjAl8GTeDPC)最近，区块链真的很火，同时区块链结束被认为是继蒸汽机、电力、互联网之后，下一代颠覆性的核心技术。在这篇文章里，作者用最容易理解的方式解答了以下 4 个问题： 区块链的本质到底是什么？ 区块链技术带来的三大巨变。 区块链面临的两大技术挑战。 区块链技术未来的发展脉络。 不过，文章篇幅较长，做好心理准备…… 也许，这样理解 HTTPS 更容易作者从一个经常遇到的例子开始介绍为什么我们需要 HTTPS，同时推荐一本书《HTTP权威指南》 做为技术人员为什么要写博客技术人员写博客这件事本身就很据争议，有人认为真正的大牛是不需要写博客来博人眼球的，也有人认为水平不够还写博客就是个笑话。而这篇文章就为你解释了上面这两个问题，最后和这篇文章一样，附上一句名言：有些事情你现在不去做，可能以后都不会有机会了！ 从苹果公开 macOS 和 iOS 内核源码说起，分享一些开源知识聊了聊开源精神、介绍了些开源社区，分享了点开源项目，仅此而已（还嫌不够？） 高质量文章精选 - 收藏集 - 掘金掘金发到 segmentfault 上的高质量文章集合，涵盖了编程领域的各个方面 程序员字典：「牛逼」作者通过他在招人时的“奇葩”条件展开阐述了到底如何定义一个“牛逼”的程序员，从作者的字里行间可以看出，作者是一名资深程序员，同时更是一名资深面试官和 team leader，所以这篇文章对于入门级程序员和骨灰级程序猿来说都是极好的 给网站加 HTTPS 完全指南作者介绍了如何给自己的个人网站加 https，虽然具体是否可行我还没有尝试，但是如果你有这个需求，这篇文章也许会帮到你。 反击爬虫，前端工程师的脑洞可以有多大？对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。 而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是爬虫与反爬虫这一话题的由来。 作为前端工程师，我们可以增加一下游戏难度，设计出一些很(sang)有(xin)意(bing)思(kuang)的反爬虫策略。 [原创译文] 2016年学习Javascript是一种什么样的体验？与其说这是一篇好文章，还不如说这是一篇好吐槽，和上面那篇类似，作者想表达的都是“前端疲劳”这件事，只不过通过对话的形式让画风变得轻松愉快。 17 张程序员壁纸推荐不算是一篇好文章，但是这 17 张壁纸着实不错~ 前后端分离实践（一）很多人都不理解甚至误解了“前后端分离”这一概念，相信这篇文章可以让你搞明白到底什么是前后端分离以及我们在什么业务场景下需要前后端分离和如何做才算前后端分离。 程序员怎么升职？知乎上关于“程序员怎么升职”这个问题的回答，我认认真真的阅读了获得最高赞的那个回答，感觉说的很对，其中有很多道理是我一直保持认同的，希望每一位从事这个行业的人都可以花时间看一下并思考。 当你练习表达的时候，开场白是怎样去设计呢不管你从事什么职业，表达自己都是一项必备技能。而如何表达自己，如何吸引听众呢？这篇文章从生物学的角度阐述了开场白的重要性以及什么样的开场白才会吸引到听众，同时作者还有同一类型的其他文章，感兴趣的话可以多读读。 程序员的鄙视链如果你看了以上这些惨绝人寰的鄙视链之后，仍然没有击倒你想要学习 coding 的心，那我必须提醒你一件最重要的事：先去交一个女朋友，再来学写程序；因为一旦你成为软件工程师之后，就交不到女朋友了。 JavaScript 疲劳终极指南：我们行业的真相抱怨 JS 疲劳就像是在抱怨人类发明了太多解决问题的工具：从邮件到飞机到宇宙飞船。这篇文章的目的是希望改变你对软件工程行业的普遍的看法，助你在你可能工作的领域上一臂之力。 超大型 JavaScript 应用的设计哲学这篇文章为译文，基于 Malte Ubl 在 JSConf Australia 的演讲速记稿和现场视频整理而来，你可以在 YouTube 上观看完整演讲。这篇文章很长，文中讨论了前端领域很多热门的话题与技术，知识点很多很密集。 图解Git图解 git 中的最常用命令。如果你稍微理解 git 的工作原理，这篇文章能够让你理解的更透彻。 如何成为一名优秀的全栈工程师现在感觉“全栈工程师”已经成为了一个梗，然而，实际上全栈工程师是真实存在的，并且是一类对产品和业务发展起到很重要作用的工程师，该文章有点鸡汤，理论偏多。 路由器爱国上网、屏蔽广告与宽带提速作者介绍了利用小米路由器实现爱国上网的具体操作流程，而路由器经过改造之后，所有接入的终端就都可以实现爱国上网了，简直是一劳永逸，而且作者在文章末尾还介绍了宽带提速的方法，每月只要十几块钱，就可以享受 100M 网络了，效果非常明显。 中文文案排版指北提供统一中文文案、排版的相关用法，降低团队成员之间的沟通成本。 前端开发工程师必读书籍有哪些值得推荐？来自知乎，书荒的童鞋不妨一看。 提问的智慧原文网址：http://www.catb.org/~esr/faqs/smart-questions.html，文章比较长，但是看完会很有收获，提问也是有很多需要注意的地方的，好的提问方式不仅能够更快的获得想要的答案，还可以提高自己的情商，获得他人的认可。 个人分享–web 前端学习资源分享掘金-守候i分享的前端学习资源，包括一些不错的教程和文章、大牛博客、前端团队博客、推荐书籍、推荐社区、公众号、推荐关注项目和综合项目教程等等。 理解 OAuth 2.0OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。在这篇文章中，阮一峰对 OAuth 2.0 的设计思路和运行流程，做了一个简明通俗的解释。 以色列简史，简到崩溃，笑到流泪！以图文和人物对话的方式对巴以冲突的历史原因以及以色列的历史进行了介绍，风趣幽默，通过一种别样的方式了解历史，我很喜欢。 97 Things Every Programmer Should Know同事推荐的文章，97 个程序员需要知道的理论，文章内容较长，读起来可能比较枯燥，而且暂时没有看到中文版本。。 为什么你统计 PV 的方式是错的？翻译自 Google 工程师 Philip Walton 的文章。该文会帮你剖析为什么你常用的统计方式是错的？然后给出可行的解决方案。 编程语言拟人化作者将各种语言都拟人化了，并赋予了他们一些特征，很有意思。 入门前端一周年总结-我是如何快速入门前端的知识分享作者虽然入门前端才一年，但是已经有 14K star 的开源项目，面试了几十人，拥有丰富的面试经验，在这篇总结里作者分享了一下自己的学习方式和资源，值得学习与研究。","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://merrier.wang/tags/前端/"},{"name":"推荐","slug":"推荐","permalink":"http://merrier.wang/tags/推荐/"}]},{"title":"JS中的对象系统","slug":"JS中的对象系统","date":"2017-08-07T02:10:23.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170807/object-system-in-js.html","link":"","permalink":"http://merrier.wang/20170807/object-system-in-js.html","excerpt":"","text":"转载自简书-浅析JavaScript的对象系统 首先，你肯定在不少地方看到过这句话： JavaScript 中一切皆对象 这句话是很有道理的（废话，要不然能在不少地方都看到吗。。），你可能没有意识到，在 JavaScript（以下简称 JS）中，你声明一个变量 let a = 3，此时的 a 其实是一个对象，因为你可以将它当做对象一样去调用 toString() 方法，这其中的答案都在 JS 对象系统中，请看下面这张图： 下面我们就结合这张图来分析一下 JS 对象系统的结构 本地对象“本地对象”的说法可能比较陌生，也可以叫做“原生对象”、“内置对象”、“内建对象”，但其实指的都是 native object。ECMA-262 对于 native object 的定义为： 独立于宿主环境的 ECMAScript 实现提供的对象 我们知道，“宿主”一般指浏览器，而“独立于宿主环境”，也就是说与浏览器环境不相关，这就是说：native object 与浏览器不相关，只要这个浏览器按照 ECMAScript 规范实现了JS，那就必然实现了规范中的所有 native object。换句话说就是：本地对象（native object）是语言本身实现和提供的对象，和语言运行在哪个环境无关。也就是说，不管你的JS代码在哪里跑，你都可以 new 出 native object 并使用它。照此理解，我觉得其实把 native object 翻译成“原生对象”最合意。 object 到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且，Object 也是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。——《JavaScript高级程序设计（第3版）》 “万物从无到有”，JS 中的大多数引用类型值都是 Object 类型的实例，而 Object 的原型就是 null 了（可以在 chrome 控制台中打印 Object.prototype.__proto__），Object 是所有其他对象类型的基础类型，提供了 toString() 等基础方法 Array数组类型 Date日期类型 RegExp正则类型 Function 说起来 ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。——《J3》 没错，请注意大小写，Function 是一种对象类型，而 function 则是一个对象实例，见如下代码： 12console.log(Function() instanceof Function); //true(构造函数Function()是Function类型的实例)console.log(Function() instanceof Object); //true(构造函数Function()当然也是Object类型的实例) 事实上，任何一个函数都是函数对象的实例，而函数类型本身就是一种对象类型，所以：函数也是对象。 Error 等各种错误类对象Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 等错误类型的对象。 String、Number、Boolean之所以将这三类放到一起，是因为它们属于JS中的基本数据类型，但其实它们也是一种对象类型，这样你才能像使用对象一般操作字符串、数值、布尔值，见下面代码： 123var str = 'Hello World';str = str.substr(0,5); //调用substr()方法截取字符串，我是字符串，但实际上是一个对象console.log(str); //'Hello' 所以，当我们通过变量声明的方式去声明一个字符串、数字、布尔值的时候，其实后台帮我们创建了一个对象： 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据 ——《J3》 书上一语道明。注意一下这句话中的“读取”和“对应”两个词。“读取”是指进入读取模式，即从内存中去读取这个字符串值的时候；“对应”指的是基本类型值是哪种类型，后台自动给你创建的基本包装类型就是哪种对应的类型，比如这里的基本类型值是 String 类型，那后台创建的基本包装类型也就是 String 包装类型。 因为这一机制，上面代码的实际执行情况其实是这样的： 12345678var str = 'Hello World';//str = str.substr(0,5); //(str进入读取模式，准备创建基本包装类型对象)var _str = new String('Hello World');str = _str.substr(0, 5);_str = null; //使用完后台会立即将该包装对象销毁console.log(str); //'Hello' 这里只展示了 String 包装类型，其实 Number 和 Boolean 也是完全一样的原理 内置对象（单体内置对象）（built-in object）这个叫 built-in object，上面那个叫 native object，那么它们有什么区别呢，还是看一下《J3》这本书中的解释吧： ECMA-262 对内置对象的定义是：“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。——《J3》 这是 ECMA-262 对于 built-in object 的定义。对比 native object 的定义：“独立于宿主环境的 ECMAScript 实现提供的对象”，可以看出，built-in object 是更加特殊的 native object，built-in object 属于 native object。ECMA-262 定义了两种 built-in object：Global 对象、Math 对象。 Global 对象事实上，js 中并不存在所谓的全局变量以及完全独立的函数。没错，你定义的所有全局变量其实都是 Global 对象的属性，你在全局作用域下定义的所有函数其实都是 Global 对象的方法。 ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象” 来定义的。换句话说，不属于任何其他对象的属性和方法，终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。——《J3》 parseInt()、eval()、encodeURIComponent() 这些函数实际上都是 Global 对象的方法，在使用这些方法的时候无需通过对象去调用，直接就可以使用。引文说过：“这些对象在 ECMAScript 程序执行之前就已经存在了。”这也算 build-in object 的一个特别之处，《J3》将 build-in object 定义为“单体内置对象”，这个“单体”是否就是指无需手动实例化这一点？ Global 对象的所有属性如下表： 好吧，特殊值 undefined 居然是 Global 对象的一个属性值 - -。乍看之下可能会有点诧异，不过仔细想想，我们之所以说 JavaScript 中一切皆对象是有原因的，你看，就连 undefined 都是对象的属性值。从表中还可以看到，所有原生引用类型的构造函数也都是 Global 对象的属性。这怎么理解？其实也很好理解，比如说当你想要创建一个日期类型的变量时，直接上构造函数 var date = new Date(); 就可以了，可是你想过没有，Date() 构造函数本身是一个函数，而前面我们说过，JS并不存在完全独立的函数，任何函数其实都是挂在某个对象下的方法，哪怕它是一个构造函数。而这些原生构造函数，其“挂载”的对象正是 Global 对象。 介绍了这么多关于 Global 对象的内容，是不是还是不清楚它是个什么玩意儿？这是因为我们在浏览器中并不能直接访问这个对象。好在浏览器为我们实现了一个包含了 Global 对象的 window 对象。 ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性。——《J3》 window 对象包含了 Global 对象的所有内容，同时扩展了大量自身需要的属性和方法（比如常用的 alert()）。因此，在浏览器中我们可以通过 window 对象随意访问上述的属性和方法。请看下面代码并加以理解： 12var date = new window.Date(); //window是对Global对象的扩展实现，构造函数Date()确实是挂在window上面的console.log(date); //Mon Aug 07 2017 10:07:28 GMT+0800 (CST) 其实你也可以在控制台中打印一下 window，你就可以发现它确实包含了上述属性和构造函数 Math 对象Math 对象是一个保存着必要的数学操作的 build-in object。里面保存着常量 e、圆周率 π 等的值作为属性，同时提供了取整 Math.floor()、取随机数 Math.random()、求平方根等等数学方法。和 Global 对象一样，这些属性和方法都可以在任何时候任何地方直接访问和调用，只不过其形式统一为：Math.***。 宿主对象宿主对象是指宿主环境所实现和提供的对象。所有非本地对象（native object）都是宿主对象。我之所以在结构图中把自定义对象挂到了宿主对象下正是基于此，不过这并非定死的，你若将自定义对象拎出来和本地对象、宿主对象并列放也并非不可。 所谓宿主，就是指 JS 代码所在的运行环境。对于浏览器环境而言，我们显示一个页面需要 HTML，所以浏览器实现了 DOM 对象 —— window.document；我们还需要浏览器本身给我们提供一些必要的东西，比如 URL 地址相关的 location、设备屏幕相关的 screen 等，所以浏览器又为我们提供了 BOM 对象 —— window。这些对象，就是 host object。等等，怎么 window 对象又出场了？上面不是说过了，window 对象是浏览器对 Global 对象的扩展实现，是 Global 对象的超集，那这玩意儿究竟该挂到 build-in object 上，还是宿主对象下的 BOM 上？答案当然是后者。可以明确的是，window 对象本就是浏览器所实现的，那它当然属于浏览器对象模型（BOM）了！只不过，window 把 ECMAScript 规定的 Global 对象也给一并实现了而已。还有，DOM 对象即是 window.document，而 window.document 就是 DOM 的根节点，从这点来讲，我们可以理解为 BOM 包含了 DOM。 如此，我们终于找到最终对象了 - -，它正是 BOM —— window。你几乎可以在这个对象中找到一切。全局变量、自定义对象、JSON 对象（ECMA262-5 引入为规范）、Math 对象、原生构造函数、Global 的东西。。。 万物合一，世界清静了。 最后，可以把最开始给的图修正更新一下了： 从图上可以看到多了一个 JSON 对象，原因是 ECMA262-5 已经将 JSON 对象纳 入native object 了。","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"对象","slug":"对象","permalink":"http://merrier.wang/tags/对象/"}]},{"title":"let和var到底有什么区别？","slug":"let和var到底有什么区别？","date":"2017-08-04T08:10:14.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170804/the-difference-between-let-and-var.html","link":"","permalink":"http://merrier.wang/20170804/the-difference-between-let-and-var.html","excerpt":"","text":"问题来自于stackoverflow：What’s the difference between using “let” and “var” to declare a variable? 我们都知道 ES6 中引入了 let 声明，而 let 也一直被认为是声明“局部变量”，那么 let 和 var 到底有什么区别呢？ 定义首先，从其定义本身，其区别之一是起作用的范围： var 起作用的范围是其最近的方法体，而 let 起作用的范围是其最近的包围块，所谓的“包围块”是有可能比方法体小的。但是如果都是全局作用域上声明的话，var 和 let 起作用的范围其实是一样的 除此之外，用 let 声明的变量在它们被声明之前是无法访问到的（有点类似于严格模式），举个栗子： 1234console.log('globalVar: ' + globalVar);console.log('globalLet: ' + globalLet);var globalVar = 'globalVar'; //globalVar: undefinedlet globalLet = 'globalLet'; //Uncaught ReferenceError: globalLet is not defined 作为全局变量和 var 不同，用 let 声明的“全局变量”将不会作为属性赋给 window，简单的栗子： 1234let me = 'go';var i = 'able';console.log(window.me); // undefinedconsole.log(window.i); // 'able' 在函数中声明当它们在函数体中声明时是一样的： 1234function ingWithinEstablishedParameters() &#123; let funclet = 'funclet'; //作用域为函数体内部 var funcvar = 'funcvar'; //作用域为函数体内部&#125; 在循环体中声明当我们在循环体中声明变量（例如 for）时，var 和 let 是有显著区别的：let 只在循环体内部可访问，而 var 在整个方法体中都可访问。还是个栗子： 123456789101112131415161718function allyIlliterate() &#123; //tuce在这里不可访问 for( let tuce = 0; tuce &lt; 5; tuce++ ) &#123; //tuce只能在这里访问得到 //所以每次循环之后tuce的值都会变 &#125; //tuce在这里也不可访问&#125;function byE40() &#123; //nish在这里可以访问 for( var nish = 0; nish &lt; 5; nish++ ) &#123; //nish在整个方法体中都可以访问得到 &#125; //nish在这里也可以访问&#125; 声明覆盖在严格模式下，var 允许你重新给一个变量赋值，但是 let 不允许： 1234567'use strict';let me = 'foo';let me = 'bar'; // SyntaxError: Identifier 'me' has already been declared'use strict';var me = 'foo';var me = 'bar'; // 没毛病，现在me就是bar了 虽然 let 和 var 在某些情况下是一样的行为表现，但还是推荐大家多使用 let，逐渐放弃 var 的使用。","categories":[{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/categories/stackoverflow/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/tags/stackoverflow/"},{"name":"ES6","slug":"ES6","permalink":"http://merrier.wang/tags/ES6/"}]},{"title":"在JS中如何清空一个数组？","slug":"在JS中如何清空一个数组？","date":"2017-08-04T07:30:29.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170804/how-to-clear-an-array-in-js.html","link":"","permalink":"http://merrier.wang/20170804/how-to-clear-an-array-in-js.html","excerpt":"","text":"问题来源于stackoverflow：How do I empty an array in JavaScript?。更多关于JS中数组的相关操作参见：JS中数组方法总结 比如我有如下数组：A = \\[1, 2, 3, 4\\]; 我如何清空它？ A = [];这个答案应该很好想到，因为很符合“从问题本身出发”的逻辑，既然我们想清空数组 A，那就清空喽~ 但是这个方法有一个弊端：如果你之前通过引用的方式 copy 了数组A，那么即使通过 A = \\[\\] 将数组 A 清空了，你的引用变量也还是 A 原来的值，理论知识总是难理解，举个栗子： 12345var arr1 = \\['a', 'b', 'c', 'd', 'e', 'f'\\];var arr2 = arr1; //arr2是arr1的一个引用console.log(arr2 === arr1) //arr2和arr1共享内存地址arr1 = \\[\\];console.log(arr2); //\\['a', 'b', 'c', 'd', 'e', 'f'\\]，此时arr2和arr1就互相不认识了 A.length = 0因为在 JS 中数组其实也是一个对象（所谓的“数组对象”），而每个数组都有一个 length 属性，这是一个可读写的属性，将其置为 0 之后就可以清空数组。同时它的引用变量也将被清空： 123456var arr1 = \\['a','b','c','d','e','f'\\];var arr2 = arr1; // 我胡汉三又来引用了arr1.length = 0;console.log(arr1); //\\[\\]console.log(arr2); //\\[\\]console.log(arr1 === arr2) //true A.splice(0, A.length)和上面的通过 length 清空类似，该方法也将同时清空数组 arr2。不同点在于，.splice() 方法将返回一个数组 while 和 .pop()这是一个比较“愚蠢”的方法： 123while(A.length &gt; 0) &#123; A.pop();&#125; 该方法同样会清空数组 arr2，但是也是效率最低的一种方法 while和.shift()一般“愚蠢”的方法不止一种。。： 123while(A.length &gt; 0) &#123; A.shift();&#125; 性能比较可以点击这里查看这四种方法的性能测试结果，或者直接看下图： 从图中可以很明显的看出来，A.length = 0; 这种方法是效率最高的，效率最低的是 pop 和 shift（不出所料啊。。）","categories":[{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/categories/stackoverflow/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/tags/stackoverflow/"},{"name":"数组","slug":"数组","permalink":"http://merrier.wang/tags/数组/"}]},{"title":"jQuery事件：不要再(滥)用return false了","slug":"jQuery事件：不要再(滥)用return false了","date":"2017-08-03T10:25:21.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170803/jquery-event-stop-using-return-false.html","link":"","permalink":"http://merrier.wang/20170803/jquery-event-stop-using-return-false.html","excerpt":"","text":"无意中在 stackoverflow 上看到一个关于jQuery中event.preventDefault()和return false的提问，后来从评论中发现一篇关于这个问题的很不错的文章，遂翻译了一下，希望能够帮助大家更好的理解 jQuery 中的 return false；当你刚开始学习 jQuery 中的事件时，也许你首先碰到的知识点就是“取消浏览器的默认行为”这一概念。比如，一个讲 click 的初级教程里可能会有如下代码： 1234$(\"a.toggle\").click(function () &#123; $(\"#mydiv\").toggle(); return false; // 禁止浏览器访问'#'&#125;); 上面这个方法动态的控制 #mydiv 的显示与隐藏，然后取消了浏览器的默认行为——访问锚标签的 href，这是一个非常简单的例子，同时也让很多前端小白养成了使用 return false 取消浏览器默认行为的习惯。关于取消浏览器事件这一问题，我将从以下两个主题重点讲解： 使用正确的方法：return false、preventDefault、stopPropagation 和 stopImmediatePropagation 头部、底部或中间某个位置：我们应该在事件回调函数的哪个位置取消默认行为？ 使用正确的方法之所以 return false 被大量滥用，是因为它确实满足了我们的需求——超链接不再跳转，表单也不再提交等等，那么为什么我说好多人都误用了呢？ return false 到底做了什么首先，大部分人都没有搞明白的是，jQuery 中的 return false 其实做了下面三件事： event.preventDefault(); event.stopPropagation(); 阻止剩下的代码执行，同时立即返回 “等一下”。你是不是很惊讶，大部分人用 return false 其实只是为了阻止默认行为，也就是上面的第一件事，另外两件其实根本不需要。上面3件事中，只有 event.preventDefault() 会取消默认行为。除非你真的打算阻止事件冒泡，否则使用 return false 将大大增加你的代码的脆弱性。让我们来看看现实应用中这种滥用是如何产生的： 我们有如下HTML代码： 123456789101112&lt;div class=\"post\"&gt; &lt;h2&gt;&lt;a href=\"/path/to/page\"&gt;My Page&lt;/a&gt;&lt;/h2&gt; &lt;div class=\"content\"&gt; Teaser text... &lt;/div&gt;&lt;/div&gt;&lt;div class=\"post\"&gt; &lt;h2&gt;&lt;a href=\"/path/to/other_page\"&gt;My Other Page&lt;/a&gt;&lt;/h2&gt; &lt;div class=\"content\"&gt; Teaser text... &lt;/div&gt;&lt;/div&gt; 现在我们想实现这样的功能：当用户点击标题链接时，跳转到相应的 div.content 上面，我们可能会写出这样的 jQuery 代码： 123456789jQuery(document).ready(function ($) &#123; $(\"div.post h2 a\").click(function () &#123; var a = $(this), href = a.attr('href'), // \b获取href, content = a.parent().next(); content.load(href + \" #content\"); return false; // 取消链接跳转这种默认行为 &#125;);&#125;); 目前，我们的页面一切正常。然后，我们又想要添加一个功能：当 div.post（或者它的子元素）被点击时，给当前被点击的 div.post 添加一个 “active” 类。所以，我们需要添加一个 click 事件： 12345var posts = $(\"div.post\");posts.click(function () &#123; posts.removeClass(\"active\"); // \b移除所有div.post的active类 $(this).addClass(\"active\"); // 给当前的div.post添加active类&#125;); 现在测试一下，当我们点击标题链接的时候，它会起作用吗？不会！它不能起作用的原因是我们在点击事件中 return false 了。而 return false 实际上意味着执行了 event.preventDefault() 和 event.stopPropagation()。所以点击事件不会冒泡到 div.post 上，从而我们新添加的事件将不起作用。 当我们将正常绑定的事件和 live 以及 delegate 绑定的事件混用时，它也会出现问题： 12345678$(\"a\").click(function () &#123; // do something return false;&#125;); $(\"a\").live(\"click\", function () &#123; // 这里的代码将不起作用&#125;); 我们真正想要实现什么？preventDefault()在大多数场景下，当我们使用 return false 的时候，我们真正想要的其实是 e.preventDefault()。使用 preventDefault 的前提是你允许在你的函数中访问事件对象（在后面的例子中以 e 表示事件对象）： 1234$(\"a\").click(function (e) &#123; // e代表我们的事件对象 e.preventDefault();&#125;); 这个方法就可以是实现取消默认行为，但是它不能阻止事件冒泡。但是，代码的功能越单一，它的可维护性就更强 stopPropagation()有些时候我们只是想阻止事件冒泡，比如下面的栗子： 123&lt;div class=\"post\"&gt; Normal text and then a &lt;a href=\"/path\"&gt;link&lt;/a&gt; and then more text.&lt;/div&gt; 现在，比如我们有一个非常“奇特”的需求：我们想让用户点击 div 中除了链接之外的任何地方都干一件事（可能是重定向到其他页面），然后还想让用户点击链接的时候可以正常跳转（从可用性的角度来看，这是一个非常糟糕的 idea。因为如果用户本意想点击链接却点到了其他地方，接下来发生的事情可能会让用户很吃惊，影响用户体验） 123456789$(\"div.post\").click(function () &#123; // do something&#125;); $(\"div.post a\").click(function (e) &#123; // 在这里不要取消默认行为 // 需要阻止事件冒泡 e.stopPropagation();&#125;); 在这个例子中，如果我们用 return false，那 div 的点击事件将永远不会触发，这样用户就不会被引导到正确的页面。 stopImmediatePropagation()这个函数将阻止事件的进一步执行，即使是同一对象上绑定的不同事件。因为绑定到一个 dom 元素的所有事件都将按照它们被绑定的顺序执行。下面是一个栗子： 12345678910111213141516$(\"div a\").click(function () &#123; // Do something&#125;); $(\"div a\").click(function (e) &#123; // Do something else e.stopImmediatePropagation();&#125;); $(\"div a\").click(function () &#123; // 这里将不会执行&#125;); $(\"div\").click(function () &#123; // 这里也不会执行&#125;); 如果你认为这个例子看起来太假了，不得不说，是很假。然而，有时候这种情况确实会发生。当你构造更加复杂的代码时，代码结构会变得比较混乱，不同的组件和插件可能会给同一个 dom 元素添加事件。在这种情况下，正确的理解和使用 stopImmediatePropagation() 就显得尤为重要了。 return false只有当你同时需要 preventDefault() 和 stopPaopagation() 时，才需要使用 return false。与此同时，你的代码应该保证只有到回调函数的尾部才取消默认行为。我强烈反对您在为 jQuery 小白编写的实例中使用这个 return false。它会误导一些入门开发者，因为只有很清楚它的功能你才能正确的使用它。 头部，底部还是中间的某个地方？之前，当你(滥)用 return false 时，它总是出现在函数的底部，或者至少在某个特定逻辑行的结尾处，因为它会组织后面的代码执行。但是我们有 e.preventDefault，所以我们有了更多选择。e.preventDefault 可以在函数执行过程中的任何时候调用。那么应该把它放在哪里呢？ 在开发环境，它应该总是放在第一行对于一个表单，你想做的最后一件事往往是，你希望通过 ajax 的方式将表单提交到另一个网页，同时你尝试在回调函数中调试 JavaScript 产生的 bug 在生产环境，如果还有其他功能待开发，请将它放在回调函数的底部或者执行过程的末尾如果你是在一个开发完的页面上添加功能，那么你的链接点击事件或者表单提交事件需要对于不支持 JS 的浏览器的服务器端的反馈。这里的好处在于，与不支持 JS 的浏览器无关，而是你的代码在那些浏览器中会抛出错误。下面有一个示例： 12345678910var data = &#123;&#125;;$(\"a\").click(function (e) &#123; e.preventDefault(); // 取消默认行为 // 抛出一个错误，因为my是undefined $(\"body\").append(data.my.link); // 链接将不起作用 // JS的执行将终端，用户将不知所措&#125;); 现在，让我们看一下同样的问题出现在 preventDefault 放在末尾时候的表现： 123456789var data = &#123;&#125;;$(\"a\").click(function (e) &#123; // \b抛出错误，因为my是undefined $(\"body\").append(data.my.link); // 这里将不会执行，此时你的网页将使用“href” e.preventDefault(); // 取消默认行为&#125;); 这个例子同样适用于表单提交事件，可以让你有适当的回退选择。所以，千万不要指望你的代码永远都会正确执行。计划好回退方案比盼望着不会报错要好得多！ 在生产环境中，如果你的功能只与 JS 有关，请放在第一行它不一定是函数中的第一行，但是它应该在你的程序逻辑中的最开始位置。原因是这样的：如果功能的这一部分一开始是与 JS 相关的，那么回退就不是那么必要了。在这种情况下，回退只是会造成一个随机的“#”出现在 URL 中或者页面跳转的区别。很明显，我们需要做的事提供尽可能多的错误处理方案，从而确保用户不会觉得它们的努力是白费的。 结论我希望这篇文章在你对于取消事件进行选择时提供了足够多的信息。记住只有在你真正需要 return false 时采去使用它，同时确保在你的回调函数的正确位置取消了默认行为。程序员的目标就是让你的代码尽可能的灵活，所以不要再用 return false 了！","categories":[{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/categories/stackoverflow/"}],"tags":[{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/tags/stackoverflow/"},{"name":"jQuery","slug":"jQuery","permalink":"http://merrier.wang/tags/jQuery/"}]},{"title":"JS中的apply、call和bind","slug":"JS中的apply、call和bind","date":"2017-08-03T08:30:08.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170803/apply-call-bind-in-js.html","link":"","permalink":"http://merrier.wang/20170803/apply-call-bind-in-js.html","excerpt":"","text":"关于 JS 中的 apply、call 和 bind，网上的相关文章实在是太多了，但是对于我这种比较重视基础的人来说，感觉大部分文章都讲不到点子上，不乏无脑复制粘贴之辈，所以我在参考了一些资料之后，决定用比较容易理解的方式来讲解，同时会用更多的实例来说明它们之间的区别。 为什么会有它们仨首先，哲学中有一句话： 存在即合理 所以，JS 中为什么会有它们仨呢？让我们来一看一段代码： 12345678910function cat()&#123;&#125;cat.prototype=&#123; food:\"fish\", say: function()&#123; alert(\"I love \"+this.food); &#125;&#125;var blackCat = new cat;blackCat.say(); 这段代码很简单，也是我们经常会碰到的，就是我们定义了一个 cat 类，然后 blackCat 是 cat 类的一个实例， cat 类有一个 say 方法。那么问题来了，如果我们又有一个对象叫做 whiteDog={food:&quot;bone&quot;}，我们想让 whiteDog 也有 cat 类的 say 方法，那应该怎么办呢？所以这时候就体验出它们仨的作用了，我们可以通过下面的方式让 whiteDog 也有 say 方法： blackCat.say.call(whiteDog) blackCat.say.apply(whiteDog) blackCat.say.bind(whiteDog)() 通过上面这个“猫与狗”的栗子，我们可以总结出 apply、call 和 bind 的共同点，就是它们都是为了改变函数体内部 this 的指向，也就是为了改变某个函数运行时的上下文（context）而存在的（JavaScript 的函数存在【定义时上下文】、【运行时上下文】和【上下文是可以改变的】这样的概念，具体参见简书-波同学的文章：前端基础进阶（二）：执行上下文详细图解） bind 的独特性通过上面的调用方式你可能发现了一些端倪，就是 bind 在调用之后还需要加一个“()”，这就是 call、apply 它们和 bind 的区别了： 只传一个参数时，call 和 apply 都是对函数的直接调用 而 bind 方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以 也许你又有疑问了，一般我们的方法都会有参数的，如果有参数的话应该如何调用呢？我们再举个栗子： 12345678910111213141516var obj1 = &#123; name: 'asd', age: 29 , sayname: function(i, j)&#123; console.log( this.name + '是' + this.age+i+j); &#125; &#125;var obj2 =&#123; name:'aaa', age:30&#125;obj1.sayname.apply(obj2,\\['男',180\\]);obj1.sayname.call(obj2,'女',167);obj1.sayname.bind(obj2,'x',150)();obj1.sayname.bind(obj2)('y',110); 根据上面的代码，我们可以直观的总结出如下几个知识点： call 后面的参数与 sayname 方法中是一一对应的 apply 的第二个参数是一个数组，数组中的元素是和 sayname 方法中一一对应的（这其实就是和 call 最大的区别） bind 可以像 call 那样传参，但是由于 bind 返回的仍然是一个函数，还可以在调用的时候再进行传参 apply、call 的区别通过上面的栗子，我们可以看到，bind 和 apply、call 是有本质上的区别的，所以我们先讲 apply 和 call 这一对“近亲”。对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下： 123var func = function(arg1, arg2) &#123; console.log(arg1 + arg2);&#125;; 我们可以通过如下方式来调用： func.call(this, arg1, arg2); func.apply(this, [arg1, arg2]); 其中 this 是你想指定的上下文，它可以是任何一个 JavaScript 对象，而不同点在于：call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 因此，如果你的参数明确知道数量的话，就用 call。而不确定的时候用 apply，然后把参数 push 进数组再传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数，所以也有人用一句话区分 apply 和 call：foo.call(this, arg1, arg2, arg3) == foo.apply(this, arguments) == this.foo(arg1, arg2, arg3) 举个栗子JS 中存在一种名为伪数组的对象结构，比较特别的是 arguments 对象，还有像调用 getElementsByTagName，document.childNodes 之类的，它们返回 NodeList 对象都属于伪数组（也有文章描述这类对象为“类数组对象”），不能应用 Array 下的 push，pop 等方法。但是我们能够通过 Array.prototype.slice.call 将带有 length 属性的对象转换为真正的数组，这样 domNodes 就可以应用 Array 下的所有方法了。 一道面试题可能你还是不太理解上面的“当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数”这句话，下面通过一道面试题，来更深入的理解 apply 和 call： 123456//我们定义一个log方法，让它可以代理console.log方法function log(msg) &#123; console.log(msg);&#125;log(1); //1log(1,2); //1 上面定义的方法可以解决最基本的需求，但是有一个问题在于：当传入参数的个数是不确定的时候，上面的方法就失效了。这个时候，因为传入多少个参数是不确定的，所以使用 apply： 12345function log()&#123; console.log.apply(console, arguments);&#125;;log(1); //1log(1,2); //1 2 接下来我们又有一个需求，就是给每一个 log 信息添加一个 “(app)” 的前缀，比如 1log(\"hello world\"); //(app)hello world 我们该如何实现呢？这个时候需要想到 arguments 参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法 unshift，像这样： 12345function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift('(app)'); console.log.apply(console, args);&#125;; bind 详解apply 和 call 就介绍完了，下面我们再介绍一下有些特殊的 bind。MDN 上对于 bind 的解释是： bind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 我表示看完还是不懂，所以还是直接看实例来的痛快：在常见的单例模式中，通常我们会使用 _this, that, self 等保存 this，这样我们可以在改变了上下文之后继续引用到它。像这样： 123456789var foo = &#123; bar : 1, eventBind: function()&#123; var _this = this; $('.someClass').on('click',function(event) &#123; console.log(_this.bar); //1 &#125;); &#125;&#125; 由于 Javascript 特有的机制，上下文环境在 eventBind: function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题： 12345678var foo = &#123; bar : 1, eventBind: function()&#123; $('.someClass').on('click',function(event) &#123; console.log(this.bar); //1 &#125;.bind(this)); &#125;&#125; 在上述代码里，bind() 创建了一个函数，当这个 click 事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用 bind() 时传入的参数）。因此，这里我们传入想要的上下文 this (其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。 再来一个简单的栗子：123456789var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;bar(); // undefinedvar func = bar.bind(foo);func(); // 3 这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。 连续 bind()有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样： 1234567891011121314151617var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;var sed = &#123; x:4&#125;var func = bar.bind(foo).bind(sed);func(); //? var fiv = &#123; x:5&#125;var func = bar.bind(foo).bind(sed).bind(fiv);func(); //? 答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在 Javascript 中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind(),故第二次以后的 bind 是无法生效的。 总结一下最近发现“总结一下”很好用，因为可以堂而皇之的给自己的文章增加很多篇幅，同时还可以显得高大上： apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。 参考文章 【优雅代码】深入浅出 妙用Javascript中apply、call、bind javascript call apply bind this指向和区别 关于javascript中apply()和call()方法的区别 如何理解和熟练运用js中的call及apply？ What is the difference between call and apply?","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"}]},{"title":"理解JS中的内存分配","slug":"理解JS中的内存分配","date":"2017-08-03T02:06:42.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170803/understanding-memory-allocation-in-js.html","link":"","permalink":"http://merrier.wang/20170803/understanding-memory-allocation-in-js.html","excerpt":"","text":"原始值和引用值在 ECMAScript 中，变量可以存放两种类型的值，即原始值和引用值；原始值：原始数据类型（简单类型）的值，即undefined、null、Number、String、Boolean 类型所表示的值；引用值：复合数据类型（对象类型）的值，即Object、Function、Array 以及自定义对象等 栈和堆与原始值和引用值对应存在两种结构的内存，即栈和堆 栈和原始值栈是一种后进先出的数据结构，在 JS 中可以通过 Array（数组）来模拟栈的行为 原始值是存储在栈中的简单数据，也就是说，它们的值直接存储在变量访问的位置 堆和引用值堆是基于散列算法的数据结构，在 JS 中，引用值是存放在堆中的 引用值是存储在堆中的对象，也就是说，存储在变量处的值（即指向对象的变量，存储在栈中）是一个指针，指向存储在堆中的实际对象 举个栗子通过上面的讲解，我们可以得到如下简单的结论： 简单类型都放在栈里 对象类型都放在堆里，指向对象的指针放在栈里 假如我们有如下几个变量： 123456var a = 20;var b = 'abc';var c = true;var d = &#123; m: 20 &#125; //地址假设为0x0012ff7cvar e = &#123; m: 20 &#125; //重新开辟一段内存空间假设为0x0012ff8fconsole.log(e==d); //false 它们在实际存储时的内存空间占用是这样的： 看到这里，你可能会问：为什么引用值要放在堆中，而原始值要放在栈中，不都是在内存中吗，为什么不放在一起呢？接下来，让我们来探索问题的答案！ 首先，请允许我再举个栗子:） 1234567891011function Person(id, name, age)&#123; this.id = id; this.name = name; this.age = age;&#125;var num = 10;var bol = true;var str = \"abc\";var obj = new Object();var arr = \\['a','b','c'\\];var person = new Person(100,\"笨蛋的座右铭\",25); 然后，我们来看一下分析图： 从上图我们可以看到，我们无法直接操纵堆中的数据，也就是说我们无法直接操纵对象，但我们可以通过栈中对对象的引用来操纵对象。 答案揭晓现在让我们来回答为什么引用值要放在堆中，而原始值要放在栈中的问题： 记住一句话： 能量是守恒的，无非是时间换空间，空间换时间的问题 堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。 参考文章 从[]==![]为true来剖析JavaScript各种蛋疼的类型转换 理解js内存分配","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://merrier.wang/tags/数据结构/"},{"name":"内存","slug":"内存","permalink":"http://merrier.wang/tags/内存/"}]},{"title":"JS中的==、===和Object.is","slug":"JS中的==、===和Object.is","date":"2017-08-02T12:07:47.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170802/equal-symbol-in-js.html","link":"","permalink":"http://merrier.wang/20170802/equal-symbol-in-js.html","excerpt":"","text":"在查阅了很多资料之后，我将在这篇文章对于 JS 中的 ==、===、Object.is 进行详细的讲解，所以这很有可能是一篇很长很长的“唠叨文”，但是我相信你一定可以从这篇文章中收货很多，所以抖擞精神，往下看吧！ 比较操作首先，你需要知道 JavaScript 提供了三种不同的值比较操作： 严格相等（’triple equals’或’identity’），即 “===” 宽松相等（’double equals’），即 “==” Object.js（ECMAScript 2015/ES6 新特性） 现在考虑表达式 x==y，当 x 和 y 的类型相同时，x==y 可以转化为 x===y，而对于后者是很简单的，因为不涉及到类型转换，只需要注意： +0 ==(=) -0 //true NaN ==(=) NaN //false 对于上面这两种，你可以理解为 JavaScript 设计的问题（其实还是那句老话，王八的屁股——规定！），所以只需要死记硬背就可以了，当然还有两个长得像的 Object 也不相等，表现在： [] ==(=) [] //false {} ==(=) {} //false 之所以两个长得像的对象和数组都不相等，是因为在JS中，数组和对象是复杂数据类型，所以其实比较的是引用值，所以任意两个长得像的对象都不相等，具体参见：理解JS中的内存分配。ES6 中新增了 Object.is() 方法，它和 “===” 是基本相同的，除了下面这两种情况： Object.is(+0, -0) //false Object.is(NaN, NaN) //true 所以你可以理解为 Object.is() 其实是对 “===” 的修正。“===” 和 Object.is() 介绍完了，下面就着重介绍一下 “==”（因为 JS 中的 “==” 会将等号两边进行类型转换，所以情况比较复杂） ==“==” 在比较前会将比较的值转换为相同类型，在转换后（等式的一边或两边都可能被转换），最终的比较方式就等同于全等操作符 “===”。同时请注意，“===” 满足交换律，但是 “==” 不满足交换律（比如![]和{}）。先来看一张吊炸天的图： 我们接下来的讲解都建立在这张图上面： 有和无从这张图我们可以明显的看出，它们被分成了两个阵营： String、Number、Boolean 和 Object（对应左侧） undefined 和 null（对应右侧） 分组的依据是什么呢？就是左侧是一个存在的世界，右侧是一个空的世界。所以就有如下规则： 左侧任意 == 右侧任意 // false 也就是左右两个世界中的任意值做 “==” 比较的结果都是 false 空和空JavaScript 中的 undefined 和 null 是另一个经常让我们崩溃的地方。通常它被认为是一个设计缺陷，这一点我们不去深究。不过我曾听说，JavaScript 的作者最初是这样想的： 假如你打算把一个变量赋予对象类型的值，但是现在还没有赋值，那么你可以用 null 表示此时的状态(证据之一就是 typeof null 的结果是 ‘object’)；相反，假如你打算把一个变量赋予原始类型的值，但是现在还没有赋值，那么你可以用 undefined 表示此时的状态。 不管这个传闻是否可信，它们两者做 == 比较的结果是 true 是很合理的。(见上图中右侧垂直线上标的 true，也就是 undefined == null) P和N依然是上面那张图，从图中可以看到两个符号：大写字母 N 和 P：N 表示 ToNumber 操作，即将操作数转为数字。它是规范中的抽象操作，但我们可以用 JS 中的 Number() 函数来等价替代；P 表示 ToPrimitive 操作，即将操作数转为原始类型的值。它也是规范中的抽象操作，同样也可以翻译成等价的 JS 代码，但是会比 ToNumber 复杂一些，所以我们后面会详细解释。 ToPrimitive我们先讲 ToPrimitive，因为 ToNumber 中会用到 ToPrimitive，下面是关于 ToPrimitive 的规范： ToPrimitive 运算符接受一个值和一个可选的期望类型作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原始类型，可以使用可选的期望类型来暗示那个类型。根据下表完成转换： /daizhengli/[table id=32 /] 对于 Object 这种输入类型，上面的表格中的描述不够清楚，我查了一些资料，概括如下：MDN 上对于 ToPrimitive 的语法规范定位为： ToPrimitive(obj, preferredType) 在执行 ToPrimitive(obj, preferredType) 时如果第二个参数为空并且 obj 为 Date 的实例时，此时 preferredType 会被设置为 String，其他情况下 preferredType 都会被设置为 Number。如果 preferredType 为 Number，ToPrimitive 执行过程如下： 如果 obj 为原始值，直接返回； 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 否则调用 obj.toString()，如果执行结果是原始值，返回之； 否则抛异常。 如果 preferredType 为 String，将上面的第 2 步和第 3 步调换，即： 如果 obj 为原始值，直接返回； 否则调用 obj.toString()，如果执行结果是原始值，返回之； 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 否则抛异常。 接下来我们就开始介绍v alueOf() 和 toString() 以及原始值了： valueOf()valueOf 方法返回对象的原始值，可能是字符串、数值或 bool 值等，看具体的对象。还是看具体的例子吧： 1234567891011var obj = &#123; name: \"obj\"&#125;;console.log(obj.valueOf());//Object &#123;name: \"obj\"&#125;var arr1 = \\[1\\];console.log(arr1.valueOf());//\\[1\\]var date = new Date();console.log(date.valueOf());//1456638436303//如代码所示，三个不同的对象实例调用valueOf返回不同的数据 toString()toString 方法用来返回对象的字符串表示 12345678var obj = &#123;&#125;;console.log(obj.toString());//\\[object Object\\]var arr2 = \\[\\];console.log(arr2.toString());//\"\"，即空字符串 var date = new Date();console.log(date.toString());//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间) 这个方法具体的运行机制是个比较复杂的过程，我之后会专门写一篇文章讲解这两个方法，可以尝试搜索一下。（当然，也可以自己在控制台敲一下，加深印象） 原始值（Primitive）“原始值”这三个字虽然听上去很高大上，其实很容易理解，就是指 null、undefined、String、Boolean、Number 这五种基本数据类型之一。 花了这么大力气终于把 ToPrimitive 介绍完了，下面我们介绍一下 ToNumber： ToNumberToNumber 运算符根据下表将其参数转换为数值类型的值： /daizhengli/[table id=33 /] 上面表格已经很清楚了，但是还有个 ToNumber(String 类型)没有介绍： 字符转数字字符转数字的规则是这样的：把字符串两边的空白字符去掉，然后把两边的引号去掉，看它能否组成一个合法的数字。如果能，转化结果就是这个数字，否则结果就是 NaN。举个栗子： 1234Number('123') //结果123Number('1.2e3') //结果1200Number('123abc') //结果NaNNumber('\\\\r\\\\n\\\\t123\\\\v\\\\f') //结果123 当然也有例外，比如空白字符串转换为数字的结果是 0。即： 12Number('') // 结果+0Number('\\\\r\\\\n\\\\t \\\\v\\\\f') // 结果+0 到目前为止，我们介绍完了 ToPrimitive 和 ToNumber，所以上面那张图的内容基本上就介绍完了。但是还有个运算符没有讲，就是 “!” 取非操作，下面就介绍一下这个看似简单的取非操作： ToBoolean取非其实是执行了 ToBoolean 运算符之后再取反，ToBoolean 运算符根据下表将其参数转换为布尔值类型的值： /daizhengli/[table id=34 /] 没图你说个**相等操作符 (==) 对于不同类型的值，进行的比较如下图所示： 万物皆数我们再来看上面那张图，里面标有 N 或 P 的那几条连线是没有方向的。假如我们在这些线上表上箭头，使得连线从标有 N 或 P 的那一端指向另一端，那么就会得到： 聪明的你肯定发现了，在 == 运算过程中，所有类型的值都有一种向数字类型转化的趋势。毕竟有这样一句名言： 万物皆数 举个栗子前面废话一堆，还不如举个实例来的痛快： 123456789101112131415161718192021222324252627282930[] == ![]``` 首先你需要明确的是上面这段代码执行的顺序，这就涉及到运算符的优先级了：`! &gt; ==`。所以 ! 取反运算符的优先级会高于 ==，那让我们先来看等号右边的 “!\\[\\]”，根据上面的 ToBoolean，**\\[\\]是一个对象**，那么 ToBoolean(\\[\\]) 就是 true，!\\[\\] 就是 false 了 然后，我们根据上面那张图，等号左边的 \\[\\] 是 Object，等号右边的 !\\[\\] 是一个 Boolean 值，所以最终就成为了 ToPrimitive(\\[\\]) == ToNumber(false) 了；而 ToPrimitive 默认调用 toString 方法，于是 ToPrimitive(\\[\\]) 就是空字符串，而 ToNumber(false) 就是 0；那么最后就成为了 \"\" == 0，这种形态，此时是 String 和 Number 之间的比较，很明显就是 toNumber(\"\") == 0 的比较了，根据 ToNumber 的转换规则，toNumber(\"\")=0，于是 \\[\\] == !\\[\\] 最后成了 0 == 0 的问题，答案显而易见为 true。## 总结一下最后，我们总结一下 == 运算的规则：* undefined == null，结果是 true。且它俩与所有其他值比较的结果都是 false。* String == Boolean，需要两个操作数同时转为 Number。* String/Boolean == Number，需要 String/Boolean 转为 Number。* Object == Primitive，需要 Object 转为 Primitive(具体通过 valueOf 和 toString方法)。所以，其实只有 4 条规则！只要我们完全理解了这四条规则，以后再遇到 == 就不会头疼了！## 一些经典题目```javascript\\[\\]==\\[\\] //false&#123;&#125;==&#123;&#125; //false\\[\\]==!\\[\\] //true&#123;&#125;==!&#123;&#125; //false&#123;&#125;==!\\[\\] //VM1896:1 Uncaught SyntaxError: Unexpected token ==!\\[\\]==&#123;&#125; //false\\[\\]==!&#123;&#125; //trueundefined==null //true+0 === -0 //trueNaN == NaN //falseNaN !== false //true 更新自2017-8-4：根据stackoverflow上的一个讨论，我发现还有如下规则：2e308 === Infinity，原因是2e308 &gt; Number.MAX_VALUE，所以其相当于是无穷大，负无穷大同理。 参考文章 JavaScript 中的相等性判断 JS比较表 从[]==![]为true来剖析JavaScript各种蛋疼的类型转换 通过一张简单的图，让你彻底地、永久地搞懂JS的==运算 Javascript 中 == 和 === 区别是什么？","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/tags/计算机基础/"},{"name":"运算符","slug":"运算符","permalink":"http://merrier.wang/tags/运算符/"}]},{"title":"函数声明VS函数表达式","slug":"函数声明VS函数表达式","date":"2017-08-02T07:16:07.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170802/function-declaration-vs-function-expression.html","link":"","permalink":"http://merrier.wang/20170802/function-declaration-vs-function-expression.html","excerpt":"","text":"本篇文章译自某大牛的文章：Function Declarations vs. Function Expressions，推荐英语不是很差的童鞋点击前面链接看原文。首先先做个小测验，下面四个例子的 alert 输出分别是什么？ 例子一： 12345678910function foo()&#123; function bar() &#123; return 3; &#125; return bar(); function bar() &#123; return 8; &#125;&#125;alert(foo()); 例子二： 12345678910function foo()&#123; var bar = function() &#123; return 3; &#125;; return bar(); var bar = function() &#123; return 8; &#125;;&#125;alert(foo()); 例子三： 12345678910alert(foo());function foo()&#123; var bar = function() &#123; return 3; &#125;; return bar(); var bar = function() &#123; return 8; &#125;;&#125; 例子四： 12345678910function foo()&#123; return bar(); var bar = function() &#123; return 3; &#125;; var bar = function() &#123; return 8; &#125;;&#125;alert(foo()); 我就直接公布答案了：8，3，3 和 [Type Error:bar is not a function]。如果你没有完全答对或者直接翻到这里看答案，那你可以继续往下看了。 什么是函数声明(function declaration)函数声明定义了一个命名的函数变量，而不需要变量赋值。函数声明是一种独特的结构，并且不能嵌套在非函数体中。我们可以将函数声明看做是变量声明的另一种形式，就像变量声明必须以 “var” 开头一样，函数声明必须以 “function” 关键字开头。下面就是一个很简单的函数声明实例： 123function bar() &#123; return 3;&#125; ECMA 5(13.0) 中对于函数声明的定义： function_Identifier_ ( _FormalParameterList_opt ) { FunctionBody } 需要注意的是，函数名在它本身的作用于以及它的父级作用域都是可见的（这是一个很不错的规则，因为不然的话在外面将无法访问到该函数）： 1234567function bar() &#123; return 3;&#125; bar() //3bar //functionbar === window.bar //true 什么是函数表达式(function expression)函数表达式将一个函数定义为一个很长的表达式的一部分（通常是一个变量赋值表达式）。以“函数表达式”方式命名的函数可以是命名的也可以是匿名函数。函数表达式不能以 “function” 关键字开头（所以下面的第三个表达式需要用 “()” 包裹）： 1234567891011121314//匿名函数表达式var a = function() &#123; return 3;&#125; //命名函数表达式var a = function bar() &#123; return 3;&#125; //自调用函数表达式(function sayHello() &#123; alert(\"hello!\");&#125;)(); 和函数声明相反，函数表达式的函数名（如果有的话）在它的作用域之外是不可见的 那函数语句(function statement)又是什么呢？函数语句有时候只是函数声明的另一种叫法。然而，按照Kangax的说法，Mozilla 认为函数语句是对于函数声明的扩展，它允许在任何允许使用语句的地方使用函数声明这种语法。但是，这是非行业标准，所以不推荐用于生产环境。 好像忘了上面四个例子让我们回到文章开头那四个例子 首先，例子一是两个函数声明，所以这两个函数声明被“提升”了 等一下，什么叫做被“提升”？援引 Ben Cherry文章中的一段话： Function declarations and function variables are always moved (‘hoisted’) to the top of their JavaScript scope by the JavaScript interpreter 翻译一下就是：函数声明和函数变量总会被 Javascript 解释器移动（提升）到它们的 JavaScript 作用域的顶端（我希望你能够认认真真的理解一下上面这句话，如果还是不理解，没关系，继续向下看）;当函数声明被提升时，整个函数体都将随之提升。所以在解释器对例子一中的代码进行解析过后，它其实是这样的（建议回过头看一下例子一的代码，对比着看会更容易理解）： 1234567891011121314// 例子一实际执行时的代码function foo()&#123; //\b第一次定义函数bar function bar() &#123; return 3; &#125; //第二次定义函数bar，将之前的定义覆盖 function bar() &#123; return 8; &#125; //return调用结果 return bar(); //8&#125;alert(foo()); 但是，我们一直以来的“常识”是return语句后面的代码是不会执行的啊？ 这就涉及到“执行上下文”和“执行过程”的概念了，ECMA5 将“执行上下文”分为“词法环境”、“变量环境 ”和“绑定 this”，而“执行过程”是指最终的代码执行过程。当执行到声明语句的时候，此时的声明语句就会进入到“变量环境”，它们与语句（比如说 return 语句）是不同的，是不受所谓的“前面代码先执行，后面代码后执行”的约束的。 （“执行上下文”这一概念对于本篇文章来说是个重点，如果依然不理解的话，可以读一下汤姆大叔和简书-波同学的文章加深理解） 那么，函数表达式也会提升吗这取决于表达式本身，让我们继续看以下例子二中的第一个表达式： 123var bar = function() &#123; return 3;&#125;; 左边的 var bar 是一个变量声明。根据上面的规则，变量声明会被提升，但是赋值表达式却没有（和函数声明不同，函数声明会将整个函数体提升）。因此当 bar 这个变量被提升时，解释器会将 bar 初始化为 undefined：var bar = undefined。所以例子二中的代码实际上以下面的顺序执行： 1234567891011121314// 例子二实际执行时的代码function foo()&#123; //函数表达式的变量声明（被提升，同时被解释器赋初始值undefined） var bar = undefined; var bar = undefined; //第一个函数表达式被执行 bar = function() &#123; return 3; &#125;; //第一个函数表达式创建的函数被执行了 return bar(); //第二个函数表达式将不会执行（但是变量声明被提升了，就在上面）&#125;alert(foo()); //3 目前你应该已经理解的差不多了，但是如果你在 Firebug 中运行例子三的代码会不符合预期，这又是为什么呢？你可以试着将例子三的代码保存在一个 HTML 文件中，然后用 firefox 浏览器打开，或者在 IE 8，Chrome 或者 Safari 的 console 中执行。你就会发现，Firebug 的 console 并没有像其他浏览器一样在全局作用域（其实并不是全局作用域，而是特殊的 “Firebug” 作用域。。可以试着在 firebug 的控制台中打印一下 “this == window” 你就明白了）中有函数体提升的表现 所以，抛开 firefox 的“灵异表现”不管，例子三和例子一其实是相同的道理，只不过是函数 foo 被提升了而已。 现在我们可以看一下例子四了很明显，例子四是没有函数提升的，但是变量提升是存在的（而且是两个），那么此时 bar 的声明就会提升，但是它的值没有定义（undefined），所以最后相当于执行 undefined()。最后当然就会报错了：bar is not a function。 那还应该注意些什么呢？目前，你应该能完全理解上面的四个例子了。还需要注意的一点是，函数声明在非函数体（如 if）中是被明令禁止的。然而，所有的浏览器其实都允许这样做，并且更可怕的是，每个浏览器对这种不符合规定的语法的解释还不同！，举个栗子，下面的代码片断在 firefox 3.6 中会抛出一个错误，因为它将函数声明解析为函数语句（函数语句已经在上面介绍过了），所以 x is not defined。然而在 IE8，Chrome5 和 Safari5 中，函数 x 被正常 return 了（就像标准的函数声明一样）。当然，鉴于这篇文章的原文年代比较久远，具体的还是要自己在 dev tool 中运行一下才能得出结论（可以试着将 if 中的 true 替换为 false 再运行一下看看） 1234567function foo() &#123; if(true) &#123; function x() &#123;&#125;; &#125; return x;&#125;alert(foo()); 既然函数声明会造成混论，那它的好处在哪里？通过上面的讨论，你会发现函数声明是“宽松”的——如果你在某个函数声明之前就调用它，“函数提升”的机制将使函数得到正常调用而不会报错。但是这种“宽松”缺乏严谨性，同时从长远来看，禁止“声明前调用”将更有利于开发者的编程习惯的养成（就像所谓的“弱类型”）。毕竟，开发者需要养成以特定的顺序编写代码的习惯。 函数表达式的优势呢？说出来你可能不信:）首先，函数声明的方式好像在模仿 Java 中的方法声明，然而 Java 的方法和 JS 中的函数是两码事啊（原文是：Java methods are very different animals）：在 JavaScript 中，函数是具有值的 living object，而 Java 中的方法只是元数据存储结构。下面的两段代码片断都定义了函数但是只有函数表达式表明我们在创建一个对象： 1234//函数声明function add(a, b) &#123;return a + b&#125;;//函数表达式var add = function(a, b) &#123;return a + b&#125;; 其次，函数表达式的用途更多。一个函数声明只能解释为一段孤立的语句。它能做的仅仅是创建一个以当前作用域为父域的变量对象。与之相反，函数表达式是一种更复杂的结构。如果你想创建一个匿名函数或者将某个函数分配给一个原型对象亦或作为某个其他对象的属性的话，你就可以用函数表达式来实现。每当你使用高阶应用程序（比如 curry 或 compose）创建一个函数时，你其实都是在应用函数表达式。所以，函数表达式和函数编程其实是密不可分的。 12//函数表达式var sayHello = alert.curry(\"hello!\"); 函数表达式有缺点吗？一般情况下，通过函数表达式方式创建的函数都是匿名的。比如下面这段代码创建的函数是匿名的，today 只是对于匿名函数的引用： 1var today = function() &#123;return new Date()&#125; 那匿名不匿名关系大吗？大多数情况下是没有的，但是正如 Nick Fitzgerald 所说，使用匿名函数进行调试有可能会很痛苦。所以他建议使用命名函数表达式（NFEs）作为一种替代方案： 1var today = function today() &#123;return new Date()&#125; 然而，正如 Asen Bozhilov 所说（以及 Kangax 的文章），NFEs 在 IE9 以下的浏览器中无法正常运行（在我看来，这并不是个大问题） MD终于到结尾了在错误的位置进行函数声明会误导别人，而且很少有（如果有）这种情况，就是你不能通过函数表达式的方法创建函数而必须用函数声明。当然，如果你必须要用函数声明，请将它们放在作用域顶端，这样可以减小误导性。同时，我绝不会在 if 语句中进行函数声明（这是明令禁止的）。 说了这么多（译者注：确实很多，翻译了好几个小时），你可能依然觉得有时候还是宁愿用函数声明。这其实很正常，盲目的遵守某些规则是愚蠢的，而且有时候会导致自己的代码很“丑陋”。最重要的是，你理解了上面介绍的这些概念和知识点，从而能够让你做出明智的决定。我希望这篇文章在这个方面能够对你有所帮助。 欢迎评论，如果你觉得我哪里说得不对（或者翻译的不对:））以及还有哪里需要补充的，欢迎留言或者通过其他方式联系我。","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"},{"name":"函数","slug":"函数","permalink":"http://merrier.wang/tags/函数/"}]},{"title":"为什么随机字符串“chucknorris”会被识别为红色？","slug":"为什么随机字符串“chucknorris”会被识别为红色？","date":"2017-08-01T10:35:30.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170801/why-is-the-random-string-chucknorris-recognized-as-red.html","link":"","permalink":"http://merrier.wang/20170801/why-is-the-random-string-chucknorris-recognized-as-red.html","excerpt":"","text":"这个问题来源于 stackoverflow，就是有位学者无意中发现随机字符串会被 html 识别为特定的一些颜色，于是就在 stackoverflow 发起了讨论，这个问题也引起了我的兴趣，虽然是一个比较偏的知识点，但是了解一下还是没坏处的。 题目解释从下图我们可以看到，“chucknorris” 是一个随机的字符串，但是 body 却被渲染成了红色，是不是很有趣？ 原理首先你需要知道 css 中的颜色值是十六进制的（比如最通常的白色：”#FFFFFF”，黑色：”#000000”），所以对于随机的字符串来说，其中有可能会包含不属于十六进制字母的那些字母（比如 h、u、k 等等），那么就会有如下的规则对“随机字符串颜色”进行替换（以随机字符串 “chucknorris” 为例）： 首先，用’0’替换所有的非十六进制字母chucknorris -&gt; c00c0000000 然后将替换后的字符串分为三组（从前往后进行划分，不能平分就在后面加 ‘0’，比如上面的 “c00c0000000” 就只有 11 个字母，需要在尾部添加一个 ‘0’）c00c 0000 0000 最后，对于每一组内的字符串，只取前两位字母作为最终的 “R”、“G”、“B” 的值c00c 0000 0000 -&gt; RGB(c0, 00, 00) 所以，最终的结果是 #c00000/rgb(192,0,0),就是最开始那张图显示的深红色。 还没完所以这个问题的答案就是一个歇后语：王八的屁股——规定！当然了，对于那种不足六个字母的颜色值来说，就会有额外的处理规则了：#aaa -&gt; #aaaaaa、#aaa3 -&gt; #aaa300、#aaa35 -&gt; #aaa350，有一个“很有想法”的哥们专门为这个转换做了一个网页，可以点击这里试玩一下，输入任意的字符串可以看到背景颜色的变化，同时可以看到最终的颜色值","categories":[{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/categories/stackoverflow/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/tags/stackoverflow/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/tags/计算机基础/"}]},{"title":"JS中判断字符串中是否含有一个子串","slug":"JS中判断字符串中是否含有一个子串","date":"2017-08-01T07:33:27.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170801/judging-whether-a-string-contains-a-substring-in-js.html","link":"","permalink":"http://merrier.wang/20170801/judging-whether-a-string-contains-a-substring-in-js.html","excerpt":"","text":"题目我就不过多解释了，这篇文章是对 stackoverflow 上一个问题的总结，如果英文不是特别差的话，推荐大家点击上面链接看大家对这个问题的详细讨论 实现方案indexOf123var string = \"foo\", substring = \"oo\";string.indexOf(substring) !== -1; String 的原型方法，返回一个字符串在另一个字符串中的位置，如果没有找到的话就返回 -1；也是大家经常用的方案 ES6 的 includes123var string = \"foo\", substring = \"oo\";string.includes(substring); ES6 中新增的 String 原型方法（其实 Array 原型也有 includes 方法），可以点击这里查看文档 search123var string = \"foo\", expr = /oo/;string.search(expr); String.prototype.search() 执行正则表达式和 String 对象之间的一个搜索匹配，所以参数需要是正则表达式，点击这里查看中文文档 lodash 的 includes123var string = \"foo\", substring = \"oo\";_.includes(string, substring); lodash 是一个前端库，其提供了一些更加拥抱未来的方法，其中就有 _.includes(str,substr) RegExp 和 test123var string = \"foo\", expr = /oo/; // no quotes hereexpr.test(string); “正则表达式是万能的”，RegExp.prototype.test(str) match123var string = \"foo\", expr = /oo/;string.match(expr); 和上面的 test 正好相反，match 方式是 String 的原型方法，String.prototype.match(expr) 性能比较既然有这么多方法都可以实现，那么哪一种才是“性能最优”的方法呢？早就有前辈替我们做了测试，可以点击这里查看测试结果，或者直接看下面这张图片： 不出所料，果然原生方法 indexOf() 是最快的，所以我们以后就还尽量用 indexOf() 吧！","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://merrier.wang/tags/stackoverflow/"}]},{"title":"总有那么一句话……","slug":"总有那么一句话……","date":"2017-08-01T03:34:27.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170801/there-is-always-a-sentence.html","link":"","permalink":"http://merrier.wang/20170801/there-is-always-a-sentence.html","excerpt":"","text":"曾经有记者问朴灵：如果不做程序员，你最想做什么职业？朴灵是这样回答的：“如果不做程序员，我可能想做一个写作者。或者是教师。觉得骨子里有种将好东西分享出去的冲动。”其实在这一点上，我和朴灵是类似的，虽然高考语文只考了 108 分，但是我如果没有踏进互联网大门的话，可能会将更多的时间用在写作分享上。所以，这篇文章就是我用来和大家分享我想到、听到、看到的那些“一句话真言”，或哲理、或深刻、或讽刺、或扎心。你可以在闲暇时来看一下这篇文章，因为这篇文章会持续更新…… 叩首问路，码梦为生 细心的同学可能发现了，我的个人博客的 title 就是这句话，这句话出自朴灵，后来被很多“文艺型码农”引用： 钱总要挣，家总要成，奔走红尘，莫忘曾经是书生 这句话是一副对联的下联，原对联是“史亦尝考，文亦尝校，答辩近了，犹思几度改论稿；家总要成，钱总要挣，奔走红尘，莫忘曾经是书生。”出自复旦大学教授陈正宏，提醒我们在众多红尘琐事之外不要丢了书生本色。 来了不后悔，走了不想再来 这是微信公众号“十一姐的涂鸦馆”一篇文章中的一句话，说的是衡中人对于衡中的评价，衡中在近几年一直受到“关注”，同时每年的高考时段也成为了衡中的批斗大会召开时间，但是作为一名衡中人，对于网上的种种言论我都是报以“无力吐槽”的心态，因为国内的舆论环境就是这样的，人云亦云，不乏找存在感的无量群众。 TL;DR 经常逛大牛的博客，有时候就会看到上面这句话，充满好奇心的我就查了一下，其实是 “Too Long;Don’t Read” 的意思，在一些国外的网站用来告诉读者：下面的叙述太长了，你要是没耐心就别读了。而在国内呢，大多数学者都将其理解为“长话短说”的意思，所以和国外相反，一般这句话下面的文章都会言简意赅…… Winter is coming! 来自很黄很暴力的《冰与火之歌》，中文翻译为“凛冬将至”，具体可以查看知乎：“winter is coming”这句话该怎么翻译？ 经不住流年似水，逃不过此间少年 来自《此间的少年》，寓意珍惜时间，让我想起了另外一句诗“有花堪折直须折，莫待无花空折枝” 炫耀从来不是我写作的动机，好奇才是 这是阮一峰老师的一句话，其实写作就是这样的，尤其是技术类的文章，就算你阅读了很多资料，时间仍然是你最大的敌人，因为技术更新换代实在太快了，我相信每一位写技术博客的作者都是抱着这种心态去写作的，我更不例外，所以希望大家能够多多评论，如果发现有哪些地方写的不严谨或者不正确的，欢迎留言指出，我会认真改正的。 好看的皮囊千篇一律，有趣的灵魂万里挑一 这句话的具体出处不详，有人说是高晓松，有人说是王尔德，具体是谁说的已经不重要了，重要的是这句话已经成为许多人口中的情话，你学到了吗？ 愿你走出半生，归来仍是少年 出自一位初中生的作文，引发了很多人的共鸣。 生活不止眼前的苟且，还有诗和远方 也许我们的教育还要再加一门课——“抗挫折”，不管现在过得怎样，不管过去如何迷茫，未来总是不确定的，所以抬起头，面向远方吧。 命运以痛吻我，我愿报之以歌。 这是模仿了泰戈尔诗集里面的一句话：世界以痛吻我，我要报之以歌。 原文的意思是：面对这个世界的苦难和人生的挫折，我们需要满怀希望，用积极乐观的心态去面对。 英文版：Destiny with pain kiss me, I will come with songs 生而为人，请务必善良 这句话初听上去有点“无病呻吟”的感觉，但是经历的多了，就会发现，善良是一件简单但奢侈的东西。你可以不善良，但是请不要去伤害。 每一个你想抵达的地方，都有人和你一样想逃离。 来自杜蕾斯团队给京东做的新广告的文案&amp;version=12020710&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=RyQZPMFy992DYlP1WXqhj%2FrCinnfljISztXgcD61wOwacxE1vMmUAufT5bFtUVHa)；我最喜欢的一句话是“知足常乐”，很多人都会因为羡慕（or 嫉妒 or 恨）别人而闷闷不乐，其实每个人都有专属自己的“小幸福”，知足才能常乐。 卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭 这句话是诗人北岛《回答》里面很著名的两句，有学者解读为：社会黑白不分，道德沦丧。这让我想到了电影《熔炉》里的一句话：我们要的不是改变世界，而是不让世界改变我们。（这个电影也很好看，是一部改变了韩国法律的电影） Stay hungry. Stay foolish. 这句话最初是《Whole Earth Catalog》创办人斯图尔特·布兰特（Stewart Brand）说的；而后因为 2005 年乔布斯在斯坦福的演讲中引用过而出名，后来就开始被各方神圣引用；同时这句话的中文版本也有很多： 保持饥饿。保持愚蠢。 我傻我知道，我穷我努力。 求知若饥，虚心若愚。 求知。守拙。 不知足。不卖弄。 谦。虚。 物有所不足，智有所不明。 致虚极，守静笃。 做个吃货，做个二货。 功成不息，坚守痴心。 守拙归园田。 留在饥饿里。留在白痴里。 保持渴望，固执愚见。 朝三守四，二尽一来。 保持饥渴觅成功，固守愚钝得精进。 当然，如果你问我更倾向于哪种翻译，我想上面的加粗字体已经告诉了你答案~ 你说我是错的，那你最好证明你是对的 —— King of Pop 这是 QQ 邮箱登录时看到的一句话，而 King of Pop 大家应该能猜出来了吧，说的就是迈克尔·杰克逊，这是 MJ 的一句歌词，原文是 “You say I’m wrong, but you’d better prove you’re right.”，而张小龙之所以选择这句话也是个蛮有意思的故事，大家看知乎上关于这句话的讨论就够了~ 在真正的开放社会里，人类没有 bug，只有 feature。 最近关于同性恋是否属于“性变态”的话题上了热搜，其实在很早之前大家都认为同性恋是一种“疾病”，而到现在，大家都已经欣然接受了这一部分人群的存在，从一定程度上讲，这表明了社会的进步和真正的开放。 待我代码编成，娶你为妻可好 一个大牛说的一句话，为此还有个我没看懂的小故事。。 佛为心，道为骨，儒为表，大度看世界； 技在手，能在身，思在脑，从容过生活。 南怀瑾大师的一句话，用来指导在家的修行人的， 告诉他们如何在现代快速发展的经济社会中生活、修行。我等凡夫俗子是参悟不到其中的真谛了。。 Talk is cheap, show me the code. 翻译成中文就是：屁话少说，放码过来。——来自知乎 无人与我立黄昏，无人问我粥可温 其实这是一句歌词，因七堇年的短文《浮生六记》而被众人误解，以为这一句出自沈复的《浮生六记》。原作者于 2015 年 5 月 30 日发表长微博解释。七堇年也发表了道歉微博。是陌緒（微博名）在 2012 年 6 月写的《寄芸》里的一句词。这首歌于 2012 年 8 月 27 日首发在5sing，署名为墨绪。知乎上有更多信息。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://merrier.wang/categories/杂谈/"}],"tags":[{"name":"生活","slug":"life","permalink":"http://merrier.wang/tags/life/"}]},{"title":"关于CSS Reset那些事","slug":"关于CSS Reset那些事","date":"2017-07-30T12:47:49.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170730/things-about-css-reset.html","link":"","permalink":"http://merrier.wang/20170730/things-about-css-reset.html","excerpt":"","text":"CSS Resetcss reset，顾名思义，就是重置样式。那么为什么我们需要重置样式呢，这一切还要“归功于”前端领域的特点，就是跨平台、跨客户端；众所周知，现在所使用的主流浏览器对于一些标签的默认属性并没有做到统一，所以我们有时候会发现，某个页面在 chrome 浏览器上样式表现很正常，但是到了 firefox 上面却有着其他的样式表现（就更不用提IE了），这就是经常提到的“兼容性问题”，而 css reset 就是解决默认样式不兼容问题的办法之一 CSS Reset发展历程第一份查阅了一些资料，也看了一些大牛的博客，目前比较一致地认为最早的一份 CSS reset 来自Tantek 的 undohtml.css，时间应该是 2004 年，很简单的代码（注释都比代码多），Tantek 根据自己的需要，对浏览器的默认样式进行了一些重置，同时从这一份 CSS reset 也可以窥探出“重置样式”需要考虑的标签有哪些。 YUI 团队业界领袖 YUI 团队在 Tantek 的基础上将 css reset 变得更加充实，当然代码的核心部分仍然是对样式进行重置，可以直接点击这里查看，YUI 团队 2014 年给出的 css reset 代码（随着 Yahoo 光荣不再，估计这份 css reset 的版本也会停留在 3.18.1 了吧），从代码中可以看出我们如果想引用这套 css reset，还需要加一个 yui3-cssreset 类，或者修改其源码，将 .yui3-cssreset 全部删掉。YUI 不仅支持 css reset，还配套了 cssfonts.css 和 cssbase.css。cssreset.css 只负责清除默认样式,而 cssfonts.css 和 cssbase.css 则负责将一些元素的默认样式再重设回来 Eric Meyer相比 YUI 团队的 css reset 方案，Eric Meyer 的方案就显得有些繁重了，而且这套代码最新版本是 2011 年公开的，考虑到年代久远，就不予评论了。 html5reset相比前面的这些方案，这个团队给出的方案就更显臃肿了，而且也不太出名，当然了，css reset 并不是用来全盘照搬的，找到自己需要的才是最聪明的办法 国产 CSS reset以上都是国外的大牛或团队给出的 css reset 方案，那么作为互联网行业发展最突飞猛进的中国，就没有人或团队做过 css reset 方面的尝试吗？肯定有啊（要不然我这一部分怎么写？）： 阿里 Kissy 框架阿里在 2009 年就已经给出了自己的 css reset 方案，这应该是国内的第一份 css reset，是玉伯和另外一位前辈完成的，向他们致敬。但是由于距离现在已经有将近十年了，源码的链接已经失效，我将各种版本的 css reset 代码都上传到了我的 github，可以点击这里查看国内第一份 css reset。 张鑫旭的方案我不希望你看到这个标题的第一感觉是：张鑫旭是谁。因为如果你连张鑫旭都不认识，前端界真是白混了！作为一位资深 css 研究学者，张鑫旭对于 css reset 也有自己独到的理解，下面就是他给出的方案： 12345678910111213141516171819202122body&#123; line-height:1.4; color:#333; font-family:arial; font-size: 12px;&#125;input,textarea,select&#123; font-size:100%; font-family:inherit;&#125;body,h1,h2,h3,h4,h5,h6,p,ul,ol,form&#123; margin:0;&#125;h4,h5,h6&#123; font-size:1em;&#125;ul,ol&#123; padding-left:0; list-style-type:none;&#125;/\\*image with no-border\\*/img&#123;border:0;&#125; 可以看到，非常的简短，当然了，对于这份方案，张鑫旭在他的文章中也进行了解释 替代品 Normalize.css历史的车轮滚滚向前，时过境迁，中国的前端职位越发的火热，开发者们也变得更为专业，CSS Reset 泛滥使用逐渐淡出的前端的视野，被取而代之就是 Normalize.css，关于对 CSS Reset 与 Normalize.css 的区别？可以引用知乎上张小核桃的一个回答： CSS Reset 是革命党，CSS Reset 里最激进那一派提倡不管你小子有用没用，通通给我脱了那身衣服，凭什么你 body 出生就穿一圈 margin，凭什么你姓 h 的比别人吃得胖，凭什么你 ul 戴一胳膊珠子。于是 *{margin:0;} 等等运动，把人家全拍扁了。看似是众生平等了，实则是浪费了资源又占不到便宜，有求于人家的时候还得贱贱地给加回去，实在需要人家的默认样式了怎么办？人家锅都扔炉子里烧了，自己看着办吧。 所以，normalize.css 的产生是有一定历史原因的（css reset 的滥用），normalize.css 是@necolas和@jon_neal 两位大牛花了几百个小时来研究不同浏览器的默认样式的差异而得出的结晶，感谢前辈们的贡献。 关于 normalize.css 的更多内容，就不在本篇文章里过多赘述了，因为它不是主角啊！有兴趣的童鞋可以点击下面的链接查看： Github 官方介绍 官方介绍（中文） 总结最后引用张鑫旭文章中的一段话作为结束： 武侠的最高境界是什么？ – 无招胜有招 设计的最高境界是什么？ – 减少设计 所以，最少的 CSS 代码，最少的渲染，最少的重置就是最好的CSS样式代码，这反应了您的 CSS 层次。说句不好听的话，CSS reset 是用来让那些 CSS 菜鸟，对 CSS 不太了解的人准备的。 参考文章 关于CSS Reset 那些事（一）之 历史演变与Normalize.css 我是如何对网站CSS进行架构的 CSS reset的重新审视 – 避免样式重置 HTML5 css reset CSS:认识 css reset","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"性能优化","slug":"性能优化","permalink":"http://merrier.wang/tags/性能优化/"}]},{"title":"JS 中的浅拷贝和深拷贝","slug":"JS中的浅拷贝和深拷贝","date":"2017-07-30T10:17:35.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170730/shallow-and-deep-copies-in-js.html","link":"","permalink":"http://merrier.wang/20170730/shallow-and-deep-copies-in-js.html","excerpt":"","text":"浅拷贝 VS 深拷贝浅拷贝和深拷贝也成为浅复制和深复制，是在很多编程语言中经常用到的方法。另外，本文只会涉及到 js 中复杂数据类型的拷贝问题（Object, Array 等），不讨论基本数据类型（null, undefined, string, number 和 boolean），因为基本数据类型不存在引用值的情况。浅拷贝和深拷贝都可以实现在已有对象的基础上再生一份的作用，但是对象的实例是存储在堆内存中然后通过一个引用值去操作对象，由此拷贝的时候就存在两种情况了：拷贝引用和拷贝实例，这也是浅拷贝和深拷贝的区别所在：浅拷贝：只会将对象的各个属性进行依次复制，并不会进行递归复制，而JS中存储对象都是存地址的，所以浅拷贝会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址 深拷贝：不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。 NOTE：如果对象比较大，层级也比较多，深拷贝会带来性能上的问题。在遇到需要采用深拷贝的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅拷贝更为常用。 浅拷贝的实现方式从以上的对比可以总结出：浅拷贝就是简单的引用复制，有以下几种实现方式： jQuery.extend(false,…)jQuery.extend 的第一个参数可以是布尔值，用来设置是否深度拷贝，设置为 false 或设置为空时就可以实现浅拷贝 Object.assign()ES6 中的 Object.assign(…) 方法可用来实现浅拷贝–它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到目标对象，最后返回目标对象。 NOTE：这里有一篇stackoverflow的文章，是关于jQuery.extend()和Object.assign()区别的，当然你也可以直接点击这里通过实例比较两者区别 Underscore 的 _.clone()在 Underscore 中有这样一个方法：_.clone()，这个方法实际上是一种浅拷贝，所有嵌套的对象和数组都是直接复制引用，但是它比直接赋值来得“深”一些，因为它创建了一个新的对象，可以看下面例子： 1234567891011var x = &#123; a: 1, b: &#123; z: 0 &#125;&#125;;var y = _.clone(x);y === x // falsey.b === x.b // truex.b.z = 100;y.b.z // 100 Array 的 slice 和 concatArray 的 slice 和 concat 方法都会返回一个新的数组实例，但是这两个方法对于数组中的对象元素却没有执行深拷贝，而只是复制了引用。（和上面的 _.clone() 类似） for…in…利用 for…in… 遍历对象就可以实现浅拷贝，代码如下： 12345678910function shallowCopy(p,c)&#123; var i; c = c||&#123;&#125;; for(i in p)&#123; if(p.hasOwnProperty(i))&#123; c\\[i\\] = p\\[i\\]; &#125; &#125; return c;&#125; 深拷贝的实现方式浅拷贝的实现方式如上所述，浅拷贝适合用在开发 jQuery 插件或者 redux 中返回 new state，而我们有时需要的是深拷贝，就是保证拷贝的对象与源对象完全隔离： jQuery.extend(true,…)将 jQuery.extend 的第一个参数设置为 true 即可实现深度拷贝。但是缺点是无法深拷贝 JSON 对象以外的对象 NOTE：jQuery 中有一个叫做 $.clone() 的方法，可是它并不是用于一般的 JS 对象的拷贝，而是用于 DOM 对象的克隆，所以不要被它的名字骗到~ 借助 JSON 全局对象相比于使用插件，使用 JSON 全局对象的 parse 和 stringify 方法来实现深复制也算是一个简单讨巧的方法： 1234function jsonClone(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125;var clone = jsonClone(&#123; a:1 &#125;); 然而这种方法有一些隐藏的坑： 只能处理能够被json直接表示的数据结构：Number, String, Boolean, Array, 扁平对象；而对于正则表达式、Date 和 Function这种特殊的 Object 就无能为力了 如果对象中存在循环引用的情况，这个方法也无法正确处理 lodash 的 _.clone() / _.cloneDeep()在 lodash 中关于复制的方法有两个，分别是 _.clone() 和 _.cloneDeep()。其中 _.clone(obj, true) 等价于 _.cloneDeep(obj)。看了源码会发现，lodash 中与深拷贝相关的代码有上百行，而 jQuery 却只有 60 多行，这是为什么呢？原因是 lodash 花了大量的代码来实现 ES6 引入的大量新的标准对象。更厉害的是，lodash 针对存在环的对象的处理也是非常出色的。 所以，loadsh 在深拷贝上下了很多功夫，是一个很完美同时更拥抱未来的一个第三方库 各个深拷贝方法的比较stackoverflow 上有一个提问，讨论了 JS 中各个深拷贝方法的效率问题，然后有位大牛借助 jsben 对各个深拷贝方法进行了实例测试，强烈推荐大家看一下这个提问下的讨论以及实例测试的结果，相信看完后你对 JS 中的深拷贝会有更深刻的理解~ 参考文章 也来谈一谈js的浅复制和深复制 javascript中的深拷贝和浅拷贝？ 深入剖析 JavaScript 的深复制","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/tags/计算机基础/"},{"name":"数据结构","slug":"数据结构","permalink":"http://merrier.wang/tags/数据结构/"}]},{"title":"读书笔记系列（8）——CSS Secrets","slug":"读书笔记系列（8）——CSS Secrets","date":"2017-07-06T10:21:45.000Z","updated":"2019-01-17T13:21:55.962Z","comments":true,"path":"20170706/css-secrets.html","link":"","permalink":"http://merrier.wang/20170706/css-secrets.html","excerpt":"","text":"这本书被誉为近十年来最出色的一本 CSS 相关书籍，作者是被誉为 “CSS一姐” 的 Lea Verou，是 W3C CSS 工作组特邀专家，而我看的是这本书的译本（翻译为 CSS 揭秘），作者叫张鹏，是百姓网的前端架构师；译者翻译的不错，同时还加入了自己的注解，如果对这本书有任何疑问，可以点击这里查看译者的注解。作者通过示例介绍了 CSS 的 47 个技巧，并将其归类至 7 大类中，由于这本书的绝大部分内容都是很值得学习的，所以关于这本书的读书笔记可能会比较长，强烈推荐你认真阅读一下这本书，是一本不可多得的 CSS 进阶教材。 引言currentColor这是一个特殊的颜色关键字，它是 CSS 中有史以来的第一个变量，举个例子，加入我们想让所有的水平分割线（所有 &lt;hr&gt; 元素）自动与文本的颜色一致，可以这样写： 1234hr&#123; height: .5em; background: currentColor;&#125; currentColor 其实不仅仅可以用到 background 属性，还可以用在 border-color、outline-color、text-shadow 和 box-shadow 等等 避免不必要的媒体查询 使用百分比长度来取代固定长度，如果实在做不到这一点，也应该尝试使用与视口相关的单位（vw、vh、vmin 和vmax） 当你需要在较大分辨率下得到固定宽度时，使用 max-width 而不是 width，因为它可以适应较小的分辨率，而无需使用媒体查询。 不要忘记为替换元素(比如 img、object、video、iframe 等)设置一个 max-width，值为 100%。 假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化，background-size: cover 这个属性都可以做到。但是，我们也要时刻牢记——带宽并不是无限的，因此在移动网页中通过 CSS 把一张大图缩小显示往往是不太明智的。 当图片(或其他元素)以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局(即 Flexbox)或者 display: inline-block 加上常规的文本折行行为，都可以实现这一点。 在使用多列文本时，指定 column-width(列宽)而不是指定 column-count(列数)，这样它就可以在较小的屏幕上自动显示为单列布局。 合理使用简写以下两行 CSS 代码并不是等价的： 12background: rebeccapurple;background-color: rebeccapurple; 前者是简写，它可以确保你得到 rebeccapurple 纯色背景 但是如果你用的是展开式的单个属性（background-color），那这个元素的背景最终有可能会显示为一个粉色的渐变图案、一张猫的图片或其他任何东西，因为同时可能会有一条 background-image 声明在起作用。所以展开式属性并不会帮助你清空所有相关的其他属性，从而有可能会被其他属性所干扰。 预处理器不是完美无缺的 CSS 的文件体积和复杂度可能会失控 调试难度会增加（但是 SourceMap 正是为了解决这个痛点而生的，它会告诉浏览器哪些编译生成的 CSS 代码对应哪些预处理器 CSS 代码，精确到行号） 预处理器在开发过程中引入了一定程度的延时 学习成本变高 预处理器是由人类写出来的，就像所有由 人类写出来的大型程序一样，它们有它们自己的 bug 预处理器中不可能做到的变量玩法123ul &#123; --accent-color: purple; &#125;ol &#123; --accent-color: rebeccapurple; &#125; li &#123; background: var(--accent-color); &#125; 上面这段代码的意图是：在有序列表中，列表项的背景色将是 rebeccapurple；但在无序列表中，列表项的背景色将是 purple 背景与边框半透明边框假设我们想给一个容器设置一层白色背景和一道半透明白色边框，body 的背景会从它的半透明边框透上来。我们最开始的尝试可能是这样的: 12border: 10px solid hsla(0,0%,100%,.5); background: white; 但实际上，上面这段代码让 body 的背景从半透明白色边框处透了上来，这实际上得到的效果跟纯白实色的边框看起来完全一样。 所以我们可以通过 background-clip 属性来调整上述默认行为所带来的不便，这个属性的初始值是 border-box，意味着背景会被元素的 border box(边框的外沿框)裁切掉。如果不希望背景侵入边框所在的范围，我们要做的就是把它的值设为 padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。 123border: 10px solid hsla(0,0%,100%,.5); background: white;background-clip: padding-box; 多重边框box-shadowbox-shadow 还接受第四个参数（称作”扩张半径”），通过指定正值或负值，可以让投影面积加大或者减小。一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的“投影”其实就像一道实线边框。这并没有什么了不起的，因为你完全可以用 border 属性来生成完全一样的边框效果。不过 box-shadow 的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影，但是多重投影方案有一些注意事项： 投影不会影响布局，也不会受到 box-sizing 属性的影响。不过，你可以通过内边距或外边距(这取决于投影是内嵌和还是外扩的)来额外模拟出边框所需要占据的空间。 通过 box-shadow 创建出的假”边框’出现在元素的外圈，它们并不会响应鼠标事件，比如悬停或点击。可以通过给 box-shadow 加上 inset 关键字，来使投影绘制在元素的内圈，此时还需要额外的内边距来腾出足够的空隙 ouline在某些情况下，你可能只需要两层边框，那就可以先设置一层常规边框，再加上 outline(描边)属性来产生外层的边框。这种方法的优点在于边框样式十分灵活（box-shadow 无法产生虚线边框），而且可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，但是同样有一些需要注意的地方： 只适用于双层”边框”的场景，因为 outline 不接受逗号 outline 产生的边框不一定会贴合 border-radius 产生的圆角 对于 outline 的表现，各个浏览器可能会有所不同，最好在不同浏览器中完整地测试最终效果 灵活的背景定位background-positionbackground-position 允许我们指定背景图片距离任意角的偏移量，只要我们在偏移量前面指定关键字： 12background: url(code-pirate.svg) no-repeat #58a; background-position: right 20px bottom 10px; background-origin背景图片的 background-position 属性是默认相对于 padding box 的左上角的，但是 background-origin 可以改变这种行为： 123padding: 10px;background: url(\"code-pirate.svg\") no-repeat #58abottom right; /* 或 100% 100% */ background-origin: content-box; 此时，background-position 将以内容区的边缘作为基准，也就是此时图片距离边角的偏移量就跟内边距保持一致了 calc把背景图片定位到距离底边 10px 且距离右边 20px 的位置。如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个 100% - 20px 的水平偏移量，以及 100% - 10px 的垂直偏移量。calc() 函数可以完美地在 background-position 属性中使用： 12background: url(\"code-pirate.svg\") no-repeat; background-position: calc(100% - 20px) calc(100% - 10px); 边框内圆角有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状，如下图所示： 如果只需要达成简单地实色效果，我们可以只用一个元素： 12345background: tan; border-radius: .8em; padding: 1em;box-shadow: 0 0 0 .6em #655; outline: .6em solid #655; 上面这段代码产生的视觉效果如下图所示： 我们受益于两个事实：描边并不会跟着元素的圆角走(因而显示出直角)，但 box-shadow 却是会的。因此，如果我们把这两者叠加到一起，box-shadow 会刚好填补描边和容器圆角之间的空隙，这两者的组合达成了我们想要的效果。 条纹背景假如我们有一条基本的垂直现行渐变，颜色从 #fb3 过渡到 #58a： 1background: linear-gradient(#fb3 20%, #58a 80%); 水平条纹现在容器顶部的 20% 区域被填充为 #fb3 实色，而底部 20% 区域被 填充为 #58a 实色。真正的渐变只出现在容器 60% 的高度区域。如果我们把两个色标重合在一起（改为 50% 和 50%）， 会发生什么? 1background: linear-gradient(#fb3 50%, #58a 50%); 所以，本质上，我们通过垂直线性渐变创建了两条巨大的水平条纹 我们还可以通过 background-size 来调整其尺寸，然后由于背景在默认情况下是重复平铺的，整个容器其实已经被填满了水平条纹： 12background: linear-gradient(#fb3 50%, #58a 50%); background-size: 100% 30px; 还有一条规范是：如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。这意味着，如果我们把第二个色标的位置值设置为 0，那它的位置就总是会被浏览器调整为前一个色标的位置值： 12background: linear-gradient(#fb3 30%, #58a 0); background-size: 100% 30px; 如果要创建超过两种颜色的条纹，也是很容易的。举例来说，下面的代码可以生成三种颜色的水平条纹： 12background: linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0);background-size: 100% 45px; 垂直条纹我们只需要在开头加上一个额外的参数来指定渐变的方向（但是我们还需要把 background-size 的值颠倒一下）： 12background: linear-gradient(to right, /* 或 90deg */ #fb3 50%, #58a 0);background-size: 30px 100%; 斜向条纹我们需要用单个贴片包包含四条条纹，而不是两条，只有这样才可能做到无缝拼接： 12background: linear-gradient(45deg,#fb3 25%, #58a 0, #58a 50%,#fb3 0, #fb3 75%, #58a 0); background-size: 30px 30px; 但是，如果我们想得到条纹宽度为 15px 的背景，则需要借助勾股定理进行计算，具体原理就不在赘述，看上面图应该能看出来 更好的斜向条纹一个鲜为人知的真相是 linear-gradient() 和 radial-gradient() 还各有一个循环式的加强版：repeating-linear-gradient() 和 repeating-radial-gradient()。 它们的工作方式跟前两者类似，只有一点不同：色标是无限循环重复的，直到填满整个背景。 1background: repeating-linear-gradient(60deg,#fb3, #fb3 15px, #58a 0, #58a 30px); 在这个方法中，不论条纹的角度如何，我们在创建双色条纹时都需要用到四个色标 灵活的同色系条纹如果我们想要的条纹图案并不是由差异极大的几种颜色组成的，而是属于同一色系，只是在明度方面有轻微差异的话，我们可以把最深的颜色指定为背景色，同时把半透明白色的条纹叠加在背景色之上来得到浅色条纹： 12345background: #58a;background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px); 我们现在只需要修改一个地方就可以改变所有颜色了。我们还得到了一个额外的好处，对于那些不支持 CSS 渐变的浏览器来说，这里的背景色还起到了回退的作用 复杂的背景图案网格做法：把水平和垂直的条纹叠加起来；在某些情况下，我们希望网格中每个格子的大小可以调整，而网格线条的粗细同时保持固定。此时可以使用长度而不是百分比作为色标。 123background: #58a; background-image:linear-gradient(white 1px, transparent 0),linear-gradient(90deg, white 1px, transparent 0); background-size: 30px 30px; 波点径向渐变能够创建的最简单的图案是圆点的阵列；我们可以生成两层圆点阵列图案，并把它们的背景定位错开，这样就可以得到真正的波点图案： 1234background: #655;background-image: radial-gradient(tan 30%, transparent 0),radial-gradient(tan 30%, transparent 0); background-size: 30px 30px;background-position: 0 0, 15px 15px; 棋盘棋盘图案是可以通过平铺生成的，平铺成这个图案的典型贴片包含两种不同颜色的方块，且相互间隔，这里的窍门在于用两个直角三角形来拼合出我们想要的方块 12345678background: #eee; background-image: linear-gradient(45deg, #bbb 25%, transparent 0), linear-gradient(45deg, transparent 75%, #bbb 0), linear-gradient(45deg, #bbb 25%, transparent 0), linear-gradient(45deg, transparent 75%, #bbb 0);background-position: 0 0, 15px 15px,15px 15px, 30px 30px;background-size: 30px 30px; CSS3图案库lea.verou.me/css3patterns，展示了 CSS 渐变早在 2011 年就能够实现的效果： SVG图案库philbit.com/svgpatterns，这个网站是 CSS 图案库的 SVG 版实现 Bennett Feely 的图案库http://bennettfeely.com/gradients，采用混合模式生成的 CSS 图案库 伪随机背景重现大自然的随机性是一个挑战，因为 CSS 本身没有提供任何随机功能。 为了更真实地模拟条纹的随机性，我们接下来可能会想到，把这组条纹从一个平面拆散为多个图层:一种颜色作为底色，另三种颜色作为条纹，然后再让条纹以不同的间隔进行重复平铺： 123456background: hsl(20, 40%, 90%); background-image: linear-gradient(90deg, #fb3 10px, transparent 0), linear-gradient(90deg, #ab4 20px, transparent 0), linear-gradient(90deg, #655 20px, transparent 0);background-size: 80px 100%, 60px 100%, 40px 100%; 但是我们很容易发现：各层背景图像以不同间距重复数次后再次统一对齐，而贴片的尺寸实际上就是所有 background-size 的最小公倍数，而 40、60 和 80 的最小公倍数正是 240。 所以为了模拟随机，我们需要把贴片的尺寸最大化：为了让最小公倍数最大化，这些数字最好是“相对质数”。这个技巧被 Alex Walker 定名为“蝉原则”，他最先提出了通过质数来 增加随机真实性的想法。请注意这个方法不仅适用于背景，还可以用于其他 涉及有规律重复的情况： 在照片图库中，为每幅图片应用细微的伪随机旋转效果时，可以使 用多个 :nth-child(a) 选择符，且让 a 是质数。 如果要生成一个动画，而且想让它看起来不是按照明显的规律在 循环时，我们可以应用多个时长为质数的动画。 连续的图像边框有时我们想把一幅图案或图片应用为边框，而不是背景，达到下面的展示效果： 此时 border-image 是不可能做到的，因为它无法随着元素宽高和边框厚度的变化而变化。所以我们的思路是在石雕背景图片之上，再叠加一层纯白的实色背景。为了让下层的图片背景透过边框区域显示出来，我们需要给两层背景指定不同的 background-clip 值。最后一个要点在于，我们只能在多重背景的最底层设置背景色，因此需要用一道从白色过渡到白色的 CSS 渐变来模拟出纯白实色背景的效果： 123456padding: 1em;border: 1em solid transparent; background: linear-gradient(white, white),url(stone-art.jpg); background-size: cover;background-clip: padding-box, border-box; background-origin: border-box; 老式信封样式的边框将上面的技巧用在渐变图案上： 123456789padding: 1em;border: 1em solid transparent;background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, red 0, red 12.5%, transparent 0, transparent 25%, #58a 0, #58a 37.5%, transparent 0, transparent 50%) 0 / 5em 5em; 蚂蚁行军边框为了创建蚂蚁行军效果，我们将会用到“老式信封”技巧的一个变种。我们将把条纹转变为黑白两色，并把边框的宽度减少至 1px，然后再把 background-size 改为某个合适的值。最后，我们把 background-position 以动画的方式改变为 100%，就可以让它滚动起来了 12345678910@keyframes ants &#123; to &#123; background-position: 100% &#125; &#125;.marching-ants &#123; padding: 1em; border: 1px solid transparent; background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, black 0, black 25%, white 0, white 50% ) 0 / .6em .6em; animation: ants 12s linear infinite; &#125; 脚注我们可以用 border-image 搭配渐变图案实现顶部边框被裁切的效果，就像一般的脚注那样，我们所需要的就是 border-image 属性再加上一条由渐变生成的垂直条纹，并把要裁切的长度在渐变中写好。边框线的粗细交给 border-width 来控制： 123border-top: .2em solid transparent;border-image: 100% 0 0 linear-gradient(90deg,currentColor 4em,transparent 0);padding-top: 1em; 形状自适应的椭圆我们想要达到这样效果：如果宽高相等，就显示为一个圆；如果宽高不等，就显示为一个椭圆 border-radius 可以单独指定水平和垂直半径，用一个斜杠（/）分隔这两个值即可；同时，它不仅可以接受长度值，还可以接受百分比值，这个百分比值会基于元素的尺寸进行解析。这意味着相同的百分比可能会计算出不同的水平和垂直半径，因此可以这样实现自适应椭圆： 1border-radius: 50%; 半椭圆 我们可以为四个角提供完全不同的水平和垂直半径，这意味着当 border-radius 的值为 10px / 5px 20px 时，其效果相当于 10px 10px 10px 10px / 5px 20px 5px 20px；所以我们很容易写出半椭圆的 CSS 代码： 1border-radius: 50% / 100% 100% 0 0; 举一反三，沿纵轴劈开的半椭圆： 1border-radius: 100% 0 0 100% / 50%; 四分之一椭圆（其中一个角的水平和垂直半径值都需要是 100%，而其他三个角都不能设为圆角）： 1border-radius: 100% 0 0 0; 但是很遗憾，border-radius 是无法生成八分之一椭圆，三分之一椭圆的！ 平行四边形我们可以通过 skew() 的变形属性来对某个矩形进行斜向拉伸，但是这回导致它的内容也发生了斜向变形。所以我们的思路是把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形： 123456789101112.button &#123; position: relative; /\\* 其他的文字颜色、内边距等样式...... */&#125; .button::before &#123; content: ''; /* 用伪元素来生成一个矩形 */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; /* 防止伪元素的背景遮住内容 */ background: #58a; transform: skew(45deg); &#125; 这个技巧适用于其他任何变形样式，当我们想变形一个元素而不想变形它的内容时就很有用： 可以用在IE下实现多重背景 实现“边框内圆角”效果 可以用来为某一层“背景”单独设置类似opacity这样的属性 模拟多层边框 菱形图片主要思路是使用 clip-path 属性，它最大的缺陷在于其浏览器支持程度还很有限。但是，它可以平稳退化（只是没有裁切效果而已），因此它至少有资格成为我们的备选方案 我们将会使用 polygon()（多边形）函数来指定一个菱形。实际上，它允许我们用一系列（以逗号分隔的）坐标点来指定任意的多边形。我们甚至可以使用百分比值，它们会解析为元素自身的尺寸： 1clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); clip-path 所能创造的奇迹还不止于此。这个属性甚至可以参与动画，只要我们的动画是在同一种形状函数(比如这里是 polygon())之间进行的，而且点的数量是相同的。因此，如果我们希望图片在鼠标悬停时平滑地扩展为完整的面积，只需要这样做： 1234567img&#123; clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); transition: 1s clip-path;&#125;img:hover&#123; clip-path: polygon(0 0, 100% 0, 100% 100%,0 100%);&#125; MDN 关于 clip-path 的文档：https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path 切角效果把角切掉不仅是为了省钱，它还是一种非常流行的设计风格，不论是在印刷媒介还是在网页设计中都是如此。 用渐变实现假设我们只需要一个角被切掉，以右下角为例，可以充分利用渐变的一大特性：渐变可以接受一个角度（比如 45deg）作为方向，而且色标的位置信息也可以是绝对的长度值，不受容器尺寸的影响；综上，我们需要一个线性渐变，把一个透明色标放在切角处，然后在相同位置设置另一个色标，并且把它的颜色设置为我们想要的背景色： 12background: #58a;background: linear-gradient(-45deg, transparent 15px, #58a 0); 左下角和右下角都有切角效果： 1234567background: #58a;background: linear-gradient(-45deg, transparent 15px, #58a 0) right, linear-gradient(45deg, transparent 15px, #58a 0) left;background-size: 50% 100%; background-repeat: no-repeat; 四个角都有切角效果： 123456789101112background: #58a; background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right, linear-gradient(45deg, transparent 15px, #58a 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat; 上面这段代码的可维护性并不理想，使用预处理器的 mixin 可以帮助我们减少代码的重复度 弧形切角很多人也把这种效果成为“内凹圆角”，因为它看起来就像是圆角的反向版本。唯一的区别在于，我们会用径向渐变来替代上述线性渐变： 123456789101112background: #58a; background: radial-gradient(circle at top left, transparent 15px, #58a 0) top left, radial-gradient(circle at top right, transparent 15px, #58a 0) top right, radial-gradient(circle at bottom right, transparent 15px, #58a 0) bottom right, radial-gradient(circle at bottom left, transparent 15px, #58a 0) bottom left;background-size: 50% 50%; background-repeat: no-repeat; clip-path 实现切角裁切路径最神奇的地方在于我们可以同时使用百分比数值（它会以元素自身的宽高作为基数度进行换算）和绝对长度值，从而提供巨大的灵活性。举个例子，如果用裁切路径将一个元素切出 20px 大小的斜面切角，代码如下： 123456background: #58a; clip-path: polygon( 20px 0, calc(100% - 20px) 0, 100% 20px, 100% calc(100% - 20px), calc(100% - 20px) 100%, 20px 100%, 0 calc(100% - 20px), 0 20px); 但是它有一个很明显的缺点，就是当内边距不够宽时，它会裁切掉文本，因为它只能对元素做统一的裁切，并不能区分元素的各个部分 梯形标签页一直以来，梯形都是众所周知难以用 CSS 生成的形状，网页开发者如果没有用精心设计的背景图片来实现梯形，那多半就是在用伪元素的边框来模拟梯形两侧的斜边，而我们的思路是通过 3D 变形，将矩形进行3D旋转，就可以创建一个梯形。但由于旋转之后，元素的尺寸会变小，同时会稍微下移，所以我们需要让其在3D空间旋转时固定底边（transform-origin），同时通过 scale() 方法改变它的尺寸： 12transform: scaleY(1.3) perspective(.5em) rotateX(5deg);transform-origin: bottom; 同时，我们只需要把 transform-origin 改成 bottom left 或 bottom right，就可以立即得到左侧倾斜或右侧倾斜的标签页 简单的饼图我们可以通过渐变来将一个圆形的左右两半设置为不同的颜色，然后通过伪元素的旋转不同角度来实现不同角度的简单饼图： 由于已经找到了实现任意比率的方法，我们甚至可以用 CSS 动画来实现一个饼图从 0 变化到 100% 的动画，从而得到一个炫酷的进度指示器: 12345678910111213141516@keyframes spin &#123; to &#123; transform: rotate(.5turn); &#125;&#125;@keyframes bg &#123; 50% &#123; background: #655; &#125;&#125;.pie::before &#123; content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; transform-origin: left; animation: spin 3s linear infinite, bg 6s step-end infinite;&#125; 如果我们需要一个静态的任意比率的饼图，可以利用负的动画延时来直接跳至动画中的任意时间 点，并且定格在那里。举例来说，如果动画持续时间定为 6s，我们只需要把 animation-delay 设置为 -1.2s，就能显示出 20% 的比率。最终的效果：play.csssecrets.io/pie-static 我们还可以通过 SVG 实现简单的饼图，与伪元素相比，SVG 的方案具有不少优点： 增加第三种颜色非常容易 不需要特别担心打印，因为 SVG 元素本身被视为页面内容 可以用内联样式指定颜色这意味着我们可以通过脚本控制颜色 SVG 方案实现的效果：play.csssecrets.io/pie-svg 视觉效果单侧投影解决方案来自 box-shadow 鲜为人知的第四个长度参数，称作扩张半径。这个参数会根据你指定的值去扩大或 (当指定负值时)缩小投影的尺寸。举例来说，一个 -5px 的扩张半径会把投影的宽度和高度各减少 10px(即每边各 5px)。如果给投影应用一个正的垂直偏移量，我们就会在元素的底部看到一道投影，而元素的另外三侧是没有投影的： 1box-shadow: 0 5px 4px -4px black; 邻边投影把一个 black、6px 的投影设置到右侧和底部可以这样做： 1box-shadow: 3px 3px 6px -3px black; 双侧投影唯一的办法是用两块投影（每边各一块）来达到目的： 12box-shadow: 5px 0 5px -5px black, -5px 0 5px -5px black; 不规则投影当我们想给一个矩形或其他能用 border-radius 生成的形状加投影时，box-shadow 的表现都堪称完美。但是，当元素添加了一些伪元素或半透明的装饰之后，它就有些力不从心了，因为 border-radius 会无耻地忽视透明部分： 我们的解决方案是利用 filter 的新属性来指定滤镜效果，比如上面的投影效果可以这样来写： 1filter: drop-shadow(2px 2px 10px rgba(0,0,0,.5)); 实现效果：play.csssecrets.io/drop-shadow 染色效果首先可以去CSSConf 官网欣赏一下讲师照片的染色效果，当鼠标悬停或获得焦点时，照片将显示为全彩的样式 基于滤镜的方案filter 属性提供了多种关于色调调整的方法，下面的代码可以实现染色效果的过渡动画： 12345678img &#123; transition: .5s filter; filter: sepia(1) saturate(4) hue-rotate(295deg);&#125;img:hover, img:focus &#123; filter: none; &#125; 基于混合模式的方案使用 background-blend-mode 属性可以让每层背景跟它的下层背景进行混合： HTML 代码： 123&lt;div class=\"tinted-image\" style=\"background-image:url(tiger.jpg)\"&gt;&lt;/div&gt; CSS 代码： 1234567891011.tinted-image &#123; width: 640px; height: 440px; background-size: cover; background-color: hsl(335, 100%, 50%); background-blend-mode: luminosity; transition: .5s background-color;&#125;.tinted-image:hover &#123; background-color: transparent;&#125; 毛玻璃效果我们想要达到下面这种效果： 我们的实现方案是利用伪元素实现模糊背景，但由于模糊效果在接近边缘处会逐渐消退，所以我们需要让伪元素相对其宿主元素的尺寸再向外扩大至少模糊半径的距离，然后再对宿主元素应用 overflow:hidden 来将多余的模糊区域裁切掉，最终代码如下所示： 123456789101112131415body, main::before &#123; background: url(\"tiger.jpg\") 0 / cover fixed;&#125;main &#123; position: relative; background: hsla(0,0%,100%,.3); overflow: hidden;&#125;main::before &#123; content: ''; position: absolute; top: 0; right: 0; bottom: 0; left: 0; filter: blur(20px); margin: -30px;&#125; 折角效果45°折角的解决方案我们先根据“切角效果”一节中的渐变方案实现一个右上角的斜面切角，然后增加另一层渐变来生成一个三角形并将其定位在右上角，从而实现翻折效果，需要注意的是这个渐变的两个色标需要在正中央重合： 1234567background: #58a; /* 回退样式 */ background: linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,.4) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg, transparent 1.5em, #58a 0); 其他角度的解决方案由于其他角度的切角需要旋转一定角度，所以我们需要借助伪元素来实现，同时还需要借助一些数学知识来计算角度和距离，具体实现过程比较复杂，大家可以看书中的解释或者直接看实现效果，最终代码如下所示： 12345678910111213141516171819202122.note &#123; position: relative; background: #58a; /* 回退样式 */ background: linear-gradient(-150deg, transparent 1.5em, #58a 0); border-radius: .5em;&#125; .note::before &#123; content: ''; position: absolute; top: 0; right: 0; background: linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,.2) 0, rgba(0,0,0,.4)) 100% 0 no-repeat; width: 1.73em; height: 3em; transform: translateY(-1.3em) rotate(-30deg); transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15);&#125; 字体排印连字符断行text-align:justify 可以实现两端对齐，但是对于英文字体来说，很容易出现“单词孤岛”现象，这样不仅看起来很糟糕，而且损伤了可读性。在打印媒介中，两端对齐总是和连字符断行相辅相成的，这样文本看起来就自然很多。 CSS 文本（第三版）引入了一个新的属性 hyphens： hyphens: none | manual | auto manual 是它的初始值， 其行为正好对应了现有的工作方式：我们可以在任何时候手工插入软连字符，来实现断词折行的效果。很显然 hyphens: none; 会禁用这种行为；而最为神奇的是，只需这短短一行 CSS 就可以产生我们梦寐以求的效果： 1hyphens: auto; 为了确保它奏效，你需要在 HTML 标签的 lang 属性中指定合适的语言 如果需要更细粒度地控制连字符的行为（比如在简短的引文中），你仍然可以通过一些软连字符（&amp;shy;）来辅助浏览器进行断词。这个 hyphens 属性会优先处理它们，然后再去计算其他可以断词的地方 插入换行HTML代码： 12345678&lt;dl&gt; &lt;dt&gt;Name:&lt;/dt&gt; &lt;dd&gt;Lea Verou&lt;/dd&gt; &lt;dt&gt;Email:&lt;/dt&gt; &lt;dd&gt;lea@verou.me&lt;/dd&gt; &lt;dt&gt;Location:&lt;/dt&gt; &lt;dd&gt;Earth&lt;/dd&gt; &lt;/dl&gt; 我们想让 dt 和后面的 dd 在同一行，每个dt所在的内容都单独占一行。 有一个 Unicode 字符是专门代表换行符的:0x000A1。在 CSS 中， 这个字符可以写作 “\\000A”，或简化为 “\\A”。我们可以用它来作为 ::after 伪元素的内容，并将其添加到每个 &lt;dd&gt; 元素的尾部 但是由于我们是在 HTML 代码中插入了换行符，所以这些换行符会和相邻的其他空白符进行合并，此时我们希望保留源代码中的这些空白符和换行，我们会用到 white-space:pre。然而如果你的结构代码在多个连续的 &lt;dd&gt; 之间包含了(未加注释的)空白符，那么逗号前面会有一个空格。有很多方法可以修复这个问题，但都不够完美。其中一种方法是利用负外边距。最终 CSS 代码： 12345678910111213141516dt,dd&#123; display: inline;&#125;dd&#123; margin: 0; font-weight: bold;&#125;dd + dt::before &#123; content: '\\\\A'; white-space: pre; &#125;dd + dd::before &#123; content: ', '; margin-left: -.25em; font-weight: normal; &#125; 文本行的斑马条纹我们可以通过 :nth-child() / :nth-of-type() 伪类来实现表格的“斑马条纹”： 123tr:nth-child(even)&#123; background: rgba(0,0,0,.2);&#125; 然而，这种实现方式无法应用到文本行。我们可以在 CSS 中用渐变直接生成背景图像，而且可以用 em 单位来设定背景尺寸，这样背景就可以自动适应 font-size 的变化了。水平条纹背景的 background-size 需要设置为 line-height 的两倍，因为每个背景贴片需要覆盖两行代码。同时我们希望让背景自动跟着内边距的宽度走，所以就需要 background-origin 告诉浏览器在解析 background-position 时以 content box 的外沿作为基准： 1234567padding: .5em;line-height: 1.5;background: beige;background-size: auto 3em;background-origin: content-box;background-image: linear-gradient(rgba(0,0,0,.2) 50%, transparent 0); 唯一可能破坏效果的情况可能就是在改变 line-height 时忘了相应地调整 background-size 调整tab的宽度我们通常使用 &lt;pre&gt; 和 &lt;code&gt; 元素来显示代码，但是浏览器会把 tab 的宽度显示为8个字符！ 而在 CSS 文本（第三版）中，一个新的 CSS 属性 tab-size 可以控制这个情况。这个属性接受一个数字(表示字符数)或者一个长度值(这个不那么实用)。我们通常希望把它设置为4(表示 4 个字符的宽度)或 2，后者是最近更为流行的缩进尺寸。 123pre &#123; tab-size: 2;&#125; 连字什么是连字？（右侧为左侧连字写法）i 的圆点往往会与 f 的升部发生冲突，导致两者都显示不清；为了缓解这个问题，字体设计师通常会在字体中包含一些额外的字形，称作连字。这些字形被设计为双字形或三字形的单一组合体，专门提供给排版软件使用，代为显示特定的字符组合： 支持连字解决方案在 CSS 字体（第三版）中，原有的 font- variant 被升级成了一个简写属性，由很多新的展开式属性组合而成。其中之一叫作 font-variant-ligatures，专门用来控制连字效果的开启和关闭。如果要启用所有可能的连字，需要同时指定这三个标识符: 123font-variant-ligatures: common-ligatures discretionary-ligatures historical-ligatures; font-variant-ligatures 还接受 none 这个值，它会把所有的连字效果都关掉。千万不要使用 none，除非你绝对清楚自己是在做什么。如果要把 font-variant-ligatures 属性复位为初始值，应该使用 normal 而不是 none。 华丽的 &amp; 符号我们想要用另一种字体来单独美化某个特定字符（或是某个区间内的多个字符）： 首先，@font-face 规则中的 src 描述符是可以接受 local() 函数的，用于指定本地字体的名称： 1234567@font-face&#123; font-family: Ampersand; src: local('Baskerville'), local('Goudy Old Style'), local('Garamond'), local('Palatino');&#125; 但是，整段文本会都被应用为我们指定的字体，所以需要一个描述符来声明我们想用这款字体来显示哪些字符，这个描述符叫做 unicode-range；它是基于 “Unicode 码位”的，所以需要知道你想指定的字符的十六进制码位，你可以在控制台打印下面JS代码获取： 1\"&amp;\".charCodeAt(0).toString(16); // 返回26 还需要在前面加上 U+ 作为前缀，所以最终声明方式为： 1unicode-range: U+26; 如果你想指定一个字符区间，还是要加上 U+ 前缀，比如 U+400-4FF。实际上对于这个区间来说，你还可以使用通配符，以这样的方式来写：U+4??。同时指定多个字符或多个区间也是允许的，把它们用逗号隔开即可，比如 U+26, U+4??, U+2665-2670 最后，为了指定某些字体的斜体版本，我们需要直接指定字体中我们想要的单个风格/字重所对应的 “PostScript 名称”： 12345678910@font-face &#123; font-family: Ampersand; src: local('Baskerville-Italic'), local('GoudyOldStyleT-Italic'), local('Palatino-Italic'), local('BookAntiqua-Italic'); unicode-range: U+26; &#125;h1 &#123; font-family: Ampersand, Helvetica, sans-serif;&#125; 自定义下划线text-decoration:underline 实现的文本下划线不能够定制，同时在不同浏览器下的渲染效果大相径庭。所以为了得到更加定制化的下划线，我们可以通过 background-image 及其相关属性来实现（CSS 渐变） 实线下划线123background: linear-gradient(gray, gray) no-repeat; background-size: 100% 1px;background-position: 0 1.15em; 防止下划线穿过文本的降部1234background: linear-gradient(gray, gray) no-repeat; background-size: 100% 1px;background-position: 0 1.15em;text-shadow: .05em 0 white, -.05em 0 white; 虚线下划线123background: linear-gradient(90deg, gray 66%, transparent 0) repeat-x;background-size: .2em 2px; background-position: 0 1em; 波浪型的下划线（两层渐变）12345background: linear-gradient(-45deg, transparent 40%, red 0, red 60%, transparent 0) 0 1em, linear-gradient(45deg, transparent 40%, red 0, red 60%, transparent 0) .1em 1em;background-repeat: repeat-x;background-size: .2em .1em;text-shadow: .05em 0 white, -.05em 0 white; 现实中的文字效果凸版印刷效果我们通过 text-shadow 使人产生物体从平面上凸起的错觉 当我们在浅色背景上使用深色文字时，在底部加上浅色投影通常效果最佳： 123background: hsl(210, 13%, 60%);color: hsl(210, 13%, 30%);text-shadow: 0 1px 1px hsla(0,0%,100%,.8); 当我们在深色背景上使用浅色文字时，在底部加上深色投影通常效果最佳： 123background: hsl(210, 13%, 40%); color: hsl(210, 13%, 75%); text-shadow: 0 -1px 1px black; 空心字效果我们一般使用多个 text-shadow 来模拟文字描边： 1234background: deeppink;color: white;text-shadow: 1px 1px black, -1px -1px black, 1px -1px black, -1px 1px black; 但是，目前比较理想的方案是使用 SVG，HTML 代码可能是这样的： 1234&lt;h1&gt;&lt;svg width=\"2em\" height=\"1.2em\"&gt; &lt;use xlink:href=\"#css\" /&gt; &lt;text id=\"css\" y=\"1em\"&gt;CSS&lt;/text&gt;&lt;/svg&gt;&lt;/h1&gt; CSS： 1234567891011121314h1 &#123; font: 500%/1 Rockwell, serif; background: deeppink; color: white;&#125;h1 text &#123; fill: currentColor;&#125;h1 svg &#123; overflow: visible &#125;h1 use &#123; stroke: black; stroke-width: 6; stroke-linejoin: round;&#125; 文字外发光效果文字外发光效果常用于凸显标题，或给链接添加鼠标悬停效果。它是最容易生成的文字美化效果之一。这种方法有一个最简单的版本:你只需要准备几层重叠的 text-shadow 即可，不需要考虑偏移量，颜色也只需跟文字保持一致： 1234567891011121314background: #203;color: #ffc;text-shadow: 0 0 .1em, 0 0 .3em;或者使用CSS滤镜：a&#123; background: #203; color: white; transition: 1s;&#125; a:hover &#123; filter: blur(.1em); &#125; 文字凸起效果思路就是使用一长串累加的投影，不设模糊并以 1px 的跨度逐渐错开，使颜色逐渐变暗，然后在底部加一层强烈模糊的暗投影，从而模拟完整的立体效果： 12345678background: #58a;color: white;text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px black; 模拟复古标志牌：123456color: white;background: hsl(0,50%,45%);text-shadow: 1px 1px black, 2px 2px black, 3px 3px black, 4px 4px black, 5px 5px black, 6px 6px black, 7px 7px black, 8px 8px black; 环形文字目前我们没有很好的纯 CSS 方案实现环形问题，只能借助内联 SVG 来实现这种效果； 在 SVG 中，让文本按照路径排列的基本方法就是用一个 &lt;textPath&gt; 元素来包裹住这段文本，再把它们装进一个 &lt;text&gt; 元素中。这个 &lt;textPath&gt; 元素还需要在它的 ID 属性中引用一个 &lt;path&gt; 元素，然后就可以用这个 &lt;path&gt; 元素来定义我们想要的路径 12345&lt;div class=\"circular\"&gt; &lt;svg viewBox=\"0 0 100 100\"&gt; &lt;path d=\"M 0,50 a 50,50 0 1,1 0,1 z\" id=\"circle\" /&gt; &lt;/svg&gt;&lt;/div&gt; 这个效果的实现比较复杂，所以直接点击上面标题链接查看吧。。 用户体验选用合适的鼠标光标在CSS 基本UI 特性（第三版）中，我们获得了一大批新的内建光标： 扩大可点击区域Fitts法则：人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数；所以将可点击区域（热区）向外扩张往往可以带来可用性的提升，我们还需要了解：伪元素同样可以代表其宿主元素来响应鼠标交互 所以，我们可以在按钮的上层覆盖一层透明的伪元素，并让伪元素在四个方向上都比宿主元素大出 10px： 12345678910button &#123; position: relative; /\\* \\[其余样式\\] */ &#125;button::before &#123; content: ''; position: absolute; top: -10px; right: -10px; bottom: -10px; left: -10px;&#125; 这个基于伪元素的解决方案极为灵活，我们基本上可以把热区设置为任何想要的尺寸、位置或形状，甚至可以脱离元素原有的位置! 自定义复选框知识点：伪类选择符 :checked 和属性选择符 [checked] 之间的区别是后者是不会根据用户的交互行为进行更新的，因为用户的交互并不会影响到 HTML 标签上的属性。 下面是作者实现的效果： 自定义复选框 开关式按钮 通过阴影来弱化背景很多时候，我们需要通过一层半透明的遮罩层来把后面的一切整体调暗，以便凸显某个特定的 UI 元素，引导用户关注 伪元素方案我们可以通过伪元素来添加： 123456789body.dimmed::before &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1; background: rgba(0,0,0,.8);&#125; 伪元素方案的缺点：伪元素无法绑定独立的JavaScript事件处理函数；同时 ::before 伪元素有可能已经被占用；还需要一点 JavaScript 来给 &lt;body&gt; 添加 dimmed 这个类 box-shadow方案box-shadow 的扩张参数可以把元素的投影向各个方向延伸放大。具体做法就是生成一个巨大的投影，不偏移也不模糊，简单而拙劣地模拟出遮罩层的效果: 1box-shadow: 0 0 0 50vmax rgba(0,0,0,.8); 但是它也存在两个非常严重的问题：当我们滚动页面时，遮罩层的边缘就露出来了；它只能在视觉上起到引导注意力的作用，却无法阻止鼠标交互 backdrop 方案\b如果你想引导用户关注元素就是一个模态的 &lt;dialog&gt; 元素，那么根据浏览器的默认样式，它会自带一个遮罩层。借助 ::backdrop 伪元素，这个原生的遮罩层也是可以设置样式的，比如可以把它变得更暗一些： 123dialog::backdrop &#123; background: rgba(0, 0, 0, .8);&#125; 唯一需要注意的地方在于，浏览器对它的支持还极为有限 通过模糊来弱化背景我们需要一个额外的 HTML 元素来实现这个效果：需要把页面上除了关键元素之外的一切都包裹起来，这样就可以只对这个容器元素进行模糊处理了： 12345&lt;main&gt;Bacon Ipsum dolor sit amet...&lt;/main&gt; &lt;dialog&gt; O HAI, I'm a dialog. Click on me to dismiss.&lt;/dialog&gt;&lt;!\\-\\- 其他对话框都写在这里 --&gt; 接下来，每当弹出一个对话框，都需要给 &lt;main&gt; 元素增加一个类，以便对它应用模糊滤镜： 123main.de-emphasized &#123; filter: blur(5px);&#125; 滚动提示我们需要实现的效果类似 Google Reader 中的一种用户体验模式：当侧边栏的容器还有更多内容时，一层淡淡的阴影会出现在容器的顶部和 / 或底部，用来提示侧边栏需要滚动才能看到完整的内容 我们可以用纯 CSS 实现这种效果，利用的就是 background-attachment 属性的一个关键字：local，但是我们需要两层背景：一层用来生成那条阴影，另一层基本上就是一个用来遮挡阴影的白色矩形，其作用类似于遮罩层。生成阴影的那层背景将具有默认的 background-attachment 值(scroll)，因为我们希望它总是保持在原位。我们把遮罩背景的 background-attachment 属性设置为 local，这样它就会在我们滚动到最顶部时盖住阴影，在向下滚动时跟着滚动，从而露出阴影。 12345background: linear-gradient(white 30%, transparent), radial-gradient(at 50% 0, rgba(0,0,0,.2),transparent 70%); background-repeat: no-repeat;background-size: 100% 50px, 100% 15px; background-attachment: local, scroll; 但是为了完整地实现这个效果，我们还需要再用两层渐变来实现底部的阴影和它配套的遮罩，具体实现可以点击上面的链接查看 交互式的图片对比控件有时，我们需要展示两张图片的外观差异，通常是“之前和之后”形式的对比 CSS resize方案resize 属性可以让某个元素的大小变得可调整，我们的第一个念头可能是列出两个 &lt;img&gt; 元素。但是，直接对一个 &lt;img&gt; 元素应用 resize 看起来会很怪异，因为直接调整图片大小会导致其变形失真。如果用一个 &lt;div&gt; 作为它的容器，再对这个容器应用 resize 属性，那就合理多了： 123456&lt;div class=\"image-slider\"&gt; &lt;div&gt; &lt;img src=\"adamcatlace-before.jpg\" alt=\"Before\" /&gt; &lt;/div&gt; &lt;img src=\"adamcatlace-after.jpg\" alt=\"After\" /&gt; &lt;/div&gt; resize 起作用的前提条件是它的 overflow 属性不是 visible；同时我们可以通过伪元素改变调节手柄的样式；最后，我们可以对这两张图片应用 user-select: none，这样即使用户在没有点中调节手柄的情况下拖动鼠标，也不会误选图片： 1234567891011121314151617181920212223242526.image-slider &#123; position:relative; display: inline-block;&#125;.image-slider &gt; div &#123; position: absolute; top: 0; bottom: 0; left: 0; width: 50%; max-width: 100%; overflow: hidden; resize: horizontal; &#125;.image-slider &gt; div::before &#123; content: ''; position: absolute; bottom: 0; right: 0; width: 12px; height: 12px; padding: 5px; background: linear-gradient(-45deg, white 50%, transparent 0); background-clip: content-box; cursor: ew-resize;&#125;.image-slider img &#123; display: block; user-select: none; &#125; 范围输入控件方案上面的 CSS resize 方案有一些不足之处： 对键盘来说不可访问 调整上层图片的唯一方法就是拖动 用户只能在右下角进行调整大小的操作 我们可以将原生的滑块控件（HTML 范围输入控件）覆盖在图片上，用它来控制上层图片的伸缩，这样就可以解决上述三个问题，同时为了让范围输入控件在视觉上与整个控件更加统一，可以用混合模式和滤镜来实现，最终实现效果： 结构与布局自适应内部元素众所周知，如果不给元素指定一个具体的 height，它就会自动适应其内容的高度。假如我们希望 width 也具有类似的行为，该怎么做呢? CSS 内部与外部尺寸模型（第三版）为 width 和 height 属性定义了一些新的关键字，其中最有用的应该就是 min-content 了。这个关键字将解析为这个容器内部最大的不可断行元素的宽度(即最宽的单词、图片或具有固定宽度的盒元素)。这正是我们梦寐以求的！为了给那些旧版浏览器提供一个平稳的回退样式，我们需要在使用这个技巧的同时，提供一个固定的 max-width 值： 123456figure &#123; max-width: 300px; max-width: min-content; margin: auto;&#125;figure &gt; img &#123; max-width: inherit; &#125; 关于 width 和 height 的新关键字，还有 max-content，它的行为类似于我们在前面看到的 display: inline-block；而 fit-content 的行为与浮动元素是相同的(和 min-content 的效果通常一致，但也有例外)。 精确控制表格列宽对于不固定的内容来说，表格的布局是很难预测的，这是因为列宽根据其内容进行调整，即使我们显式地指定了 width。解决方案来自于 CSS 2.1 中一个鲜为人知的属性，叫做 table-layout，它的默认值是 auto，其行为模式被称作自动表格布局算法，也就是我们最为熟悉的表格布局行为。不过，它还接受另外一个值 fixed，这个值的行为要明显可控一些，使用也很简单： 1234table &#123; table-layout: fixed; width: 100%;&#125; 根据兄弟元素的数量来设置样式在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。 对于只有一个列表项的特殊场景来说，解决方案显然就是 :only-child： 123li:only-child &#123; /\\* 只有一个列表项时的样式 */&#125; 实际上，:only-child 等效于 :first-child:last-child，道理就是：如果第一项也是最后一项，那它就是唯一的那一项；而 :first-child:nth-last-child(4) 会匹配到一个正好有四个列表项的列表中的第一个列表项，所以下面的选择符就相当于在这个列表正好包含四个列表项时，命中它的每一项： 1234li:first-child:nth-last-child(4), li:first-child:nth-last-child(4) ~ li &#123; /\\* 当列表正好包含四项时，命中所有列表项 */ &#125; 利用选择符的表达式，我们可以在列表项的总数是4或更多时选中所有列表项： 1234li:first-child:nth-last-child(n+4), li:first-child:nth-last-child(n+4) ~ li &#123; /\\* 当列表至少包含四项时，命中所有列表项 */ &#125; 同理，-n+b 这种形式的表达式可以选中开头的 b 个元素。因此，我们可以在列表项的总数是 4 个或更少时选中所有列表项： 1234li:first-child:nth-last-child(-n+4), li:first-child:nth-last-child(-n+4) ~ li &#123; /\\* 当列表最多包含四项时，命中所有列表项 */&#125; 当然，我们还可以把这两种技巧组合起来使用，不过代码也会变得更加复杂。假设我们希望在列表包含 2 ~ 6 个列表项时命中所有的列表项，可以这样写: 1234li:first-child:nth-last-child(n+2):nth-last-child(-n+6), li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ li &#123; /\\* 当列表包含2~6项时，命中所有列表项 */ &#125; 满幅的背景，定宽的内容背景宽度满幅，内容宽度固定的设计手法在网页的页脚中经常看到： 绝大多数的网页设计师/工程师都是用两层元素来实现的，那么能不能用一层元素实现呢？其实我们可以用 calc() 来实现内容的居中： 123456footer &#123; max-width: 900px; padding:1em; /* 回退样式 */ padding: 1em calc(50% - 450px); background: #333;&#125; 垂直居中 44 年前我们就把人类送上月球了，但现在我们仍然无法在 CSS 中实现垂直居中 —— James Anderson 几种十分流行的技巧： 表格布局法 行内块法 Chris Coyier 写的“不为人知的居中方法”详细讲述了这两种技巧 基于绝对定位的解决方案早期的垂直居中方法，它要求元素具有固定的宽度和高度： 123456789main &#123; position: absolute; top: 50%; left: 50%; margin-top: -3em; /* 6/2 = 3 */ margin-left: -9em; /* 18/2 = 9 */ width: 18em; height: 6em;&#125; CSS 领域有一个很常见的现象，真正的解决方案往往来自于我们最意想不到的地方。当我们在 translate() 变形函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的，所以就解除了对固定尺寸的依赖： 123456main &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 上面这个方法有一些需要注意的地方： 有时不能选用绝对定位 如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视口裁切掉 在某些浏览器中，这个方法可能会导致元素的显示有一些模糊 基于视口单位的解决方案123456main &#123; width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translateY(-50%);&#125; 基于 Flexbox 的解决方案这是毋庸置疑的最佳解决方案： 12345678body &#123; display: flex; min-height: 100vh; margin: 0; &#125;main &#123; margin: auto;&#125; 当我们使用 Flexbox 时，margin:auto 不仅在水平方向上将元素居中，垂直方向上也是如此 紧贴底部的页脚这是一个相当常见的问题：我们希望内容很长时，页脚在内容的尾部；而如果内容很短，页脚会在视口的底部。 一些解决方案（仍然有局限之处）： https://css-tricks.com/snippets/css/sticky-footer/ https://pixelsvsbytes.com/2011/09/sticky-css-footers-the-flexible-way/ 固定高度的解决方案我们可以通过计算给内容指定最小高度，然后就可以将页脚“固定”到底部： 1234main &#123; min-height: calc(100vh - 7em); /* 7em为页脚高度 */ box-sizing: border-box;&#125; Flexbox 的解决方案我们需要对 &lt;body&gt; 元素设置 display:flex，然后将其 min-height 属性指定为 100vh，这样它就至少会占据整个视口的高度；此时我们所期望的是，页头和页脚的高度由其内部元素来决定，而内容区块的高度应该可以自动伸展并占满所有的可用空间。我们只要给 &lt;main&gt; 这个容器的 flex 属性指定一个大于 0 的值(比如 1 即可)，就可以实现这个效果了: 123456body &#123; display: flex; flex-flow: column; min-height: 100vh; &#125;main &#123; flex: 1; &#125; 过渡与动画缓动效果在现实世界中，物体从 A 点到 B 点的移动往往不是完全匀速的 弹跳动画CSS 提供了一个 cubic-bezier() 函数，允许我们指定自定义的调速函数，借助该函数，我们可以近乎完美的实现回弹动画： 123456789101112@keyframes bounce &#123; 60%, 80%, to &#123; transform: translateY(400px); animation-timing-function: ease; &#125; 70% &#123; transform: translateY(300px); &#125; 90% &#123; transform: translateY(360px); &#125; &#125;.ball &#123; /\\* 外观样式 */ animation: bounce 3s cubic-bezier(.1,.25,1,.25); &#125; 弹性过渡同样是 cubic-bezier() 函数的使用： 12345678input:not(:focus) + .callout &#123; transform: scale(0); transition: .25s transform;&#125;.callout &#123; transform-origin: 1.4em -.4em; transition: .5s cubic-bezier(.25,.1,.3,1.5) transform;&#125; 逐帧动画在很多时候，我们需要一个很难（或不可能）只通过某些 CSS 属性的过渡来实现的动画。但由于 GIF 不具备透明的特性，所以下面的加载提示只能用CSS动画实现： 而如何实现这种逐帧动画效果呢？秘诀就是 steps() 这个调速函数，steps() 函数会使整个动画在帧与帧之间硬切，所以只需把动画的代码修改为下面的形式： 1animation: loader 1s infinite steps(8); 闪烁效果这里涉及到的知识点是 animation-direction 中的 alternate 属性，它的作用是反转第偶数个循环周期（包括调整函数）： animation-direction: normal | alternate | reverse | alternate-reverse 打字动画CSS 值与单位规范引入了一个新单位，表示“0”字形的宽度，叫做 ch ；在等宽字体中，“0” 字形的宽度和其他所有字形的宽度是一样的，所以如果我们用 ch 单位来表达一段文本的宽度，那取值实际上就是字符的数量；最后，我们可以借助上面的闪烁动画的原理来实现文字后面闪烁的光标 状态平滑的动画我们需要根据用户的交互行为来暂停动画和继续之前的动画状态，从而避免生硬的跳回现象，而 animation-play-state 正是为这种暂停动画的需求专门设计的： 12345678910111213@keyframes panoramic &#123; to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url(\"img/naxos-greece.jpg\"); background-size: auto 100%; animation: panoramic 10s linear infinite alternate; animation-play-state: paused;&#125;.panoramic:hover, .panoramic:focus &#123; animation-play-state: running;&#125; 沿环形路径平移的动画我们需要让一个元素沿着环形路径动起来，同时元素中的内容（图片、文字）不能发生旋转 需要两个元素的解决方案我们让元素旋转，同时让其中的内容以相反的方向进行自转，从而可以抵消元素旋转的影响，由此可见，我们可以用 animation-direction 来实现这样的效果： 1234567891011@keyframes spin &#123; to &#123; transform: rotate(1turn); &#125;&#125;.avatar &#123; animation: spin 3s infinite linear; transform-origin: 50% 150px; /* 150px = 路径的半径 */&#125;.avatar &gt; img &#123; animation: inherit; animation-direction: reverse;&#125; 单个元素的解决方案 “transform-origin 只是一个语法糖而已。实际上你总是可以用 translate() 来代替它。” ——Aryeh Gregor","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"CSS布局问题总结","slug":"CSS布局问题总结","date":"2017-07-04T10:17:27.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170704/summary-of-css-Layout-problems.html","link":"","permalink":"http://merrier.wang/20170704/summary-of-css-Layout-problems.html","excerpt":"","text":"本文主要对 CSS 中常见的布局问题进行了总结，同时提供了解决方案和一些参考链接，涉及到三栏式布局（圣杯、双飞翼），居中布局等等；感兴趣的童鞋可以点击来源链接查看原文，因为本文是基于原文进行整理的，所以内容会比原文精简。 基础知识 学习CSS布局（排版和配色比较舒服，简短不深入，适合入门） 10个文档学布局（通过十个例子讲解布局，主要涉及相对布局，绝对布局和浮动） 三栏式布局涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想： 圣杯布局介绍圣杯：父盒子包含三个子盒子（左，中，右） 中间盒子的宽度设置为 width: 100%; 独占一行； 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行； .left {margin-left:-100%;} 把左边的盒子拉上去 .right {margin-left：-右边盒子宽度px;} 把右边的盒子拉上去 父盒子设置左右的 padding 来为左右盒子留位置； 对左右盒子使用相对布局来占据 padding 的空白，避免中间盒子的内容被左右盒子覆盖； HTML结构123456&lt;div class=\"container\"&gt; &lt;!\\-\\- 中间的div必须写在最前面 --&gt; &lt;div class=\"middle\"&gt;中间内容区&lt;/div&gt; &lt;div class=\"left\"&gt;左边栏&lt;/div&gt; &lt;div class=\"right\"&gt;右边栏&lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324252627282930313233343536*&#123; margin:0; padding: 0; height:300px;&#125;.container&#123; /*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/ padding:0 200px 0 180px; height:100px;&#125;.middle&#123; float:left; width:100%;/*左栏上去到第一行*/ height:100px; background:blue;&#125;.left&#123; float:left; width:180px; height:100px; margin-left:-100%; background:#0c9; /*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/ position:relative; left:-180px;&#125;.right&#123; float:left; width:200px; height:100px; margin-left:-200px; background:#0c9; /*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/ position:relative; right:-200px;&#125; 双飞翼布局双飞翼：父盒子包含三个子盒子（左，中，右），中间的子盒子里再加一个子盒子。 中间盒子的宽度设置为 width: 100%; 独占一行； 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行； 在中间盒子里面再添加一个 div，然后对这个 div 设置 margin-left 和 margin-right来为左右盒子留位置； HTML结构12345678&lt;div class=\"container\"&gt; &lt;!\\-\\- 中间的div必须写在最前面 --&gt; &lt;div class=\"middle\"&gt; &lt;div class=\"middle-inner\"&gt;中间弹性区&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;左边栏&lt;/div&gt; &lt;div class=\"right\"&gt;右边栏&lt;/div&gt;&lt;/div&gt; CSS1234567891011121314151617181920212223242526272829*&#123; margin:0; padding: 0&#125;.middle&#123; float: left; width: 100%;&#125;.middle-inner&#123; margin: 0 210px; background-color: rgba(33, 114, 214, 0.8); height: 500px&#125;.left&#123; width: 200px; float: left; background-color: rgba(255, 82, 0, 0.8); margin-left: -100%; height: 200px&#125;.right&#123; width: 200px; height: 200px; margin-left: -200px; float: left; background-color: rgba(90, 243, 151, 0.8);&#125; 圣杯和双飞翼异同圣杯布局和双飞翼布局解决的问题是一样的，都是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。 两种方法基本思路都相同：三栏全部 float 浮动。首先让中间盒子 100% 宽度占满同一高度的空间，在左右两个盒子被挤出中间盒子所在区域时，使用 margin-left 的负值将左右两个盒子拉回与中间盒子同一高度的空间。接下来进行一些调整避免中间盒子的内容被左右盒子遮挡。 主要区别在于 如何使中间盒子的内容不被左右盒子遮挡： 圣杯布局的方法：设置父盒子的 padding 值为左右盒子留出空位，再利用相对布局对左右盒子调整位置占据 padding 出来的空位； 双飞翼布局的方法：在中间盒子里再增加一个子盒子，直接设置这个子盒子的 margin 值来让出空位，而不用再调整左右盒子。 简单说起来就是双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了，少设置几个属性。 参考文章 CSS三栏布局——中间固定两边自适应宽度：w3cplus 的文章，使用了双飞翼和浮动实现两侧定宽、中间自适应，也实现了两侧自适应、中间定宽 简书 - 圣杯布局和双飞翼布局（前端面试必看）：只讲了圣杯，不过特别详细 In Search of the Holy Grail：圣杯布局的来源 百度前端学院笔记 - 三栏式布局之双飞翼与圣杯：百度前端学院学员的前端学习笔记 简书 - margin为负值产生的影响和常见布局应用：包括对自身的影响，对文档流的影响，以及一些在布局中的应用技巧(比如去除列表右边框，负边距+定位实现水平垂直居中，去除列表最后一个 li 元素的 border-bottom，多列等高) 居中布局强烈推荐Centering in CSS: A Complete Guide这篇文章，非常全面的居中定位博客，包括各种情况下的水平居中，垂直居中和水平垂直居中方案。有展示示例及相应的 HTML 和 CSS 代码，这篇文章翻译总结如下： 水平居中 对于行内元素(inline)：text-align: center; 对于块级元素(block)：设置宽度且 marigin-left 和 margin-right 是设成 auto 对于多个块级元素：对父元素设置 text-align: center;，对子元素设置 display: inline-block;；或者使用 flex 布局 垂直居中 对于行内元素(inline) 单行：设置上下 pandding 相等；或者设置 line-height 和 height 相等 多行：设置上下 pandding 相等；或者设置 display: table-cell; 和 vertical-align: middle;；或者使用 flex 布局；或者使用伪元素 对于块级元素(block)：下面前两种方案，父元素需使用相对布局 已知高度：子元素使用绝对布局 top: 50%;，再用负的 margin-top 把子元素往上拉一半的高度 未知高度：子元素使用绝对布局 position: absolute; top: 50%; transform: translateY(-50%); 使用 Flexbox：选择方向，justify-content: center; 水平垂直居中 定高定宽：先用绝对布局 top: 50%; left: 50%;，再用和宽高的一半相等的负 margin 把子元素回拉 高度和宽度未知：先用绝对布局 top: 50%; left: 50%;，再设置 transform: translate(-50%, -50%); 使用 Flexbox：justify-content: center; align-items: center; 扩展阅读利用HTML和CSS实现常见的布局","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"利用Github Pages搭建自己的个人博客","slug":"利用Github Pages搭建自己的个人博客","date":"2017-07-04T04:03:49.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170704/build-your-own-personal-blog-with-github-pages.html","link":"","permalink":"http://merrier.wang/20170704/build-your-own-personal-blog-with-github-pages.html","excerpt":"","text":"这篇文章以我的亲身实验为基础，为大家讲解如何利用 Github Pages 搭建一个自己的个人博客，由于我的个人博客已经拿 wordpress 搭建完成好久了，所以我就拿我 [github] (https://github.com/merrier/)中的另外一个项目作为试验，一步一步的截图引导大家将自己的 github 中的项目放到网上供其他人浏览，请注意，这都是免费的哦！不需要你购买域名和服务器，因为 github 帮你搞定了一切，最终实现的效果是下面这样的（可以看到，域名是 merrier.github.io，这是 github 为你提供的域名，\b该页面可以点击这里查看）： 准备工作 你需要有一个 github 账号 如果想看到效果的话，你需要一个有 README.md / index.html 的项目 好戏开场gh-pages 分支基于上面的准备工作，我认为你现在应该在自己的 github 中有了一个用来向他人展示的项目，然后进入自己的项目，切换到 gh-pages 分支，没有的话创建一个就可以了： Theme选择然后点击上面的 Settings 按钮，向下找到 Github Pages 模块： 然后在这里你可以选择一个主题（点击 Change theme 按钮，然后你就可以跳转到选择主题的页面），这些主题都是 github 给你免费提供的，我选择的是下面这款蓝色的主题，效果就是文章开头截图那样的： Done选择完主题之后再回到刚才有 Github Pages 的页面，github 会提示你现在可以通过某个URL访问你的页面了，此时你通过 github 提示的 URL 进行访问的话，显示的就是你项目根目录的 README.md / index.html 文件中的内容，这样就完成了！是不是很 easy！： 注意事项现在已经不需要新建gh-pages分支了，任意分支都可以 在你选择完主题之后，github 会自动在你的项目根目录下创建一个 _config.yml 文件，内容大概是下面这个样子，合并代码时需要注意一下： 1theme: jekyll-theme-architect 在 Github Pages 模块，你可以设置你自己的 custom domain比如设置成 www.example.com，此时别人就可以通过访问 www.example.com 访问到你刚刚用 Github Pages 搭建的个人博客了 扩展阅读一步步在GitHub上创建博客主页","categories":[{"name":"Git","slug":"Git","permalink":"http://merrier.wang/categories/Git/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://merrier.wang/tags/Github/"}]},{"title":"Git撤销操作","slug":"Git撤销操作","date":"2017-06-29T02:46:13.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170629/revocation-operation-in-git.html","link":"","permalink":"http://merrier.wang/20170629/revocation-operation-in-git.html","excerpt":"","text":"Git中提供了几个相关的撤销操作的命令，如 clean、checkout、reset和revert；在看这篇文章之前，我希望你能够浏览一下我的另一篇文章：Git工作区、暂存区和历史记录区，看完之后理解这篇文章会更简单一些 git cleangit clean 命令用来从你的工作目录中删除所有没有 tracked 过的文件 参数说明1git clean -n 是一次 clean 的演习， 告诉你哪些文件会被删除。 记住他不会真正的删除文件， 只是一个提醒。 1git clean -f 删除当前目录下所有没有 track 过的文件。 他不会删除 .gitignore 文件里面指定的文件夹和文件， 不管这些文件有没有被 track 过。 1git clean -f &lt;path&gt; 删除指定路径下的没有被 track 过的文件。 1git clean -df 删除当前目录下没有被 track 过的文件和文件夹。 1git clean -xf 删除当前目录下所有没有 track 过的文件。 不管他是否是 .gitignore 文件里面指定的文件夹和文件。 应用场景假如你要删除所有工作目录下面的修改，包括新添加的文件：12git reset --hardgit clean -df 运行后，工作目录和缓存区回到最近一次 commit 时候一摸一样的状态， git status 会告诉你这是一个干净的工作目录，又是一个新的开始了。 git checkoutgit checkout 命令用来丢弃本地修改 参数说明1git checkout -- files 把文件从暂存区域复制到工作目录，用来丢弃本地修改 1git checkout . 会用暂存区全部的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动 1git checkout HEAD . 会用 HEAD 指向的 master 分支中的全部文件替换暂存区以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动 应用场景有时候我们的工作区会增加一些不想要的文件（多数为隐藏文件），比如 .idea/、.DS_Store 文件，此时我们不想将这些无关紧要的文件添加到暂存区，所以就像将它们从工作区丢弃，此时就可以利用下面的命令将该文件夹丢弃： 1git checkout .idea/ 当然，这种总是会自动生成的文件最好写到 .gitignore 里，否则每次都要 checkout 会很烦的 git resetgit reset 命令撤销对于暂存区 / 历史记录区的修改，也就是撤销你本地的 add，commit 操作 参数说明1git reset 撤销所有暂存区域文件 1git reset -- files 用来撤销最后一次的 git add files（因为每 git add file 一次，暂存区的文件都会被更改一次） 1git reset --mixed &lt;commit id&gt; 会保留源码，只是将 git commit 和 index 信息回退到了某个版本。（相当于撤销了 add 和 commit 操作，提交的修改都回到了工作区） 1git reset --soft &lt;commit id&gt; 保留源码，只回退 commit 信息到某个版本，不涉及index的回退，如果还需要提交，直接commit即可。（也就是只撤销了commit，并没有撤销add） 1git reset --hard &lt;commit id&gt; 源码也会回退到某个版本，commit 和 index 都回回退到某个版本。(注意，这种方式是改变本地代码仓库源码)，当然有人在 push 代码以后，也可以使用 reset --hard &lt;commit id&gt; 回退本地的代码到某个版本之前，但是这样会有一个问题，你线上的代码没有变，线上 commit，index 都没有变，当你把本地代码修改完提交的时候你会发现全是冲突。。（此时就需要用到下面要介绍的 git revert 了） 应用场景当我们在使用 pull 的时候，可能会出现冲突，就需要 merge，而在冲突状态下，需要解决冲突的文件会从 index 暂存区打回到工作区，如果我们想放弃 index 和工作区的改动，就可以执行下面这条命令：1git reset --hard HEAD 上面这条命令用来撤销还没 commit 的 merge，就放弃了 index 暂存区和工作区的改动 当我们在本地进行了 add 和 commit 操作之后，发现本地的修改都是错误的，想要回到前一版本，就可以执行下面这条命令：1git reset --hard HEAD^ 上面这条命令用来撤销已经 commit 的内容（等价于 git reset --hard HEAD~1）。原理就是放弃工作区和 index 的改动，同时 HEAD 指针指向前一个 commit 对象 如果我们已经用 add 命令将某个文件加入暂存区了，此时想撤销对这个文件的 add 操作，就可以用下面的命令：1git reset HEAD &lt;file&gt; 上面这条命令用来撤销对单个文件的 git add，执行之后该文件会从暂存区回到工作区中 git revertgit revert 用于反转提交，执行 revert 命令时要求工作树必须是干净的。git revert 用一个新提交来消除一个历史提交所做的任何修改。 ###参数说明 1git revert &lt;commit id&gt; revert 使用，需要先找到你想回滚版本唯一的 commit 标识代码，可以用 git log 进行查看，commit id 是一串 40 位的字符串，通常用前几位即可（6 位就差不多保证唯一了）；执行完之后，revert 的那一次 commit 被撤销，原理是 git revert 用一次逆向的 commit “中和”之前的提交，所以此时 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容；这样在日后合并老的 branch 时，导致这部分改变不会再次出现，就不会出现类似 git reset 带来的冲突问题 应用场景对于已经把代码 push 到线上仓库，但是此时发现 push 的代码有问题，你想回退本地代码的同时也回退线上代码，回滚到某个指定的版本，使得线上和线下代码保持一致：1git revert &lt;commit id&gt; 执行完此命令之后，再执行 git push 就可以将线上代码回滚到某个指定版本，同时不会像 git reset 一样可能会导致一大堆冲突 git 的其它删除命令这些命令类似于 Linux 的命令，是一种物理层面的删除，也会经常遇到： 1git rm --cached readme.txt 只从缓存区中删除readme.txt，保留物理文件 1git rm readme.txt 不但从缓存区中删除，同时删除物理文件 1git mv a.txt b.txt 把a.txt改名为b.txt 参考文章 git clean(转载) git reset revert 回退回滚取消提交返回上一版本 详解Git工作区、暂存区、历史记录区以及git reset、git revert、git checkout等撤销命令的区别","categories":[{"name":"Git","slug":"Git","permalink":"http://merrier.wang/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://merrier.wang/tags/git/"}]},{"title":"Git工作区、暂存区和历史记录区","slug":"Git工作区、暂存区和历史记录区","date":"2017-06-28T12:13:42.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170628/workspace-temporary-zone-and-history-zone-in-git.html","link":"","permalink":"http://merrier.wang/20170628/workspace-temporary-zone-and-history-zone-in-git.html","excerpt":"","text":"三个区域可以将 git 简单的分为三个区域： 工作区（working directory） 暂存区（stage index） 历史记录区（history） 如图： 简单解释工作区：就是我们能看到的区域，也是我们经常修改代码的目录暂存区：文件在本地修改之后，需要提交到暂存区之后才能提交到版本库，作为过渡层；可以避免误操作和保护工作区和版本库历史记录区：可以理解为版本库，我们从暂存区提交之后的记录会保存在这里 详细解释当我们执行 git add files 时，我们把当前工作目录中的文件放入了暂存区域，这其实做了两件事： 将本地文件的时间戳、长度，当前文档对象的id等信息保存到一个树形目录中去（index，即平时说的暂存区） 将本地文件的内容做快照并保存到 Git 的对象库。 所以，暂存区实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等），文件的内容并不存储其中，而是保存在 Git 对象库（.git/objects）中，文件索引建立了文件和对象库中对象实体之间的对应。如下图所示： 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个“游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下 三个区域与 git 命令git add当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中 git commit当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 git status当执行 “git status” 命令扫描工作区改动的时候，先依据 .git/index 文件中记录的（工作区跟踪文件的）时间戳、长度等信息判断工作区文件是否改变。如果工作区的文件时间戳改变，说明文件的内容可能被改变了，需要打开文件，读取文件内容，和更改前的原始文件相比较（本地文件和与之对应的 object 库中的文件的内容进行对比），判断文件内容是否被更改。如果文件内容没有改变，则将该文件新的时间戳记录到 .git/index 文件中。因为判断文件是否更改，使用时间戳、文件长度等信息进行比较要比通过文件内容比较要快的多，所以 Git 这样的实现方式可以让工作区状态扫描更快速的执行，这也是 Git 高效的因素之一。 git diff filesgit diff files 用来进行具体文件的变动对比，通常用来进行工作区与暂存区之间的对比，实质上是用 git objects 库中的快照与工作区文件的内容的对比。 参考文章 详解Git工作区、暂存区、历史记录区以及git reset、git revert、git checkout等撤销命令的区别","categories":[{"name":"Git","slug":"Git","permalink":"http://merrier.wang/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://merrier.wang/tags/git/"}]},{"title":"Chrome扩展程序推荐&(伪)开发指南","slug":"Chrome扩展程序推荐&(伪)开发指南","date":"2017-06-28T09:25:28.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170628/chrome-extension-recommendation-and-pseudo-development-guide.html","link":"","permalink":"http://merrier.wang/20170628/chrome-extension-recommendation-and-pseudo-development-guide.html","excerpt":"","text":"chrome 作为 Google 公司研发的一款网页浏览器，其诞生之初就备受关注，从一开始的全年占有率上升幅度最大到如今的全球使用人数最多，chrome 成为了 Google 最值得骄傲的产品之一；而作为前端工程师，和浏览器打交道是最多的，所以如何用好浏览器就成为了一项潜在的技能。chrome 本身就基于其他开源软件所撰写（WebKit、Blink），所以其丰富的扩展程序成为了另一大杀器，下面就分享一下我用的一些扩展程序（排名不分先后，如果你也有用着很爽的插件，欢迎在评论中分享哦～），同时简单的介绍一下自己如果想开发一个 Chrome 扩展程序，应该从何下手。 扩展程序推荐React Developer Tools之所以将这款插件排在第一位，那是因为 react 实在是太火了，颇有一统前端框架之势（想多了，怎么可能），所以就首先推荐这款插件了。这款插件是 facebook 官方推荐的（Github 地址），目前已经有 64W 用户下载使用，所以其性能方面是不容置疑的，不过由于我目前还没有更深入的接触 react，所以这款插件自从下载之后就没有实际用过，具体怎样就没办法描述了。。 JSONView这款插件其实功能很简单，就是能够让你在浏览器中更方便地看 JSON 类型的数据，我们前端工程师常会有这样的困扰：后台提供了一个接口，返回的是 JSON 数据，但是我们通过 URL 直接在浏览器中打开的话，中文会显示乱码，而且如果其中有类似 URL 这种格式的数据，也没有办法点击跳转；此时，这款插件就派上了用场，虽然其提供的功能很简单，但是 105W+ 的用户量已经说明了一切，截图神马的最有说服力了： JSONView之前 JSONView之后 Set Character Encoding这款插件的功能也很简单，就像它的名字一样，是用来改变网页编码格式的，相信用最新版本 Chrome 的童鞋会发现，右键改编码格式的日子一去不复返了，甚至连高级设置中都没有办法改编码格式了，那么如何修改万恶的编码格式呢？这款插件就派上了用场，使用很简单：安装之后在你想要改变编码格式的网页右键，就会出现下面这个东东： 使用起来就是如此的简单，还在担心乱码吗？赶紧安装一下试试吧！ 印象笔记·剪藏印象笔记作为一款最受欢迎的笔记类应用之一，其本身提供的功能已经足够惊艳了，但是它的这款 chrome 插件更是好用到爆，安装之后在浏览网页时点击它的大象 logo 就会在你的网页右上角弹出如下弹框： 该弹框基本上涵盖了你所需要的所有功能，包括命名、内容选择、存储位置、标签、注释等等，可以让你很方便的保存你所浏览的任何内容（可以点击这里查看这款插件的玩法介绍），如果你是印象笔记的用户或潜在用户，一定要安装试一下，童叟无欺哦～ YSlowYSlow（why slow）是雅虎基于网站优化规则推出的工具，帮助你分析并优化网站性能。说到雅虎，就不得不提一下雅虎军规了，雅虎军规在十几个方面给你的网站提出优化建议，YSlow 会根据这些规则分析你的网站，并给出评级。雅虎作为一家对前端性能追求卓越的公司，虽然已光辉不再，但是 YSlow 这款插件（Firefox 也有相应插件）对于前端开发者来说还是能提供很多思路的，官方网站：http://developer.yahoo.com/yslow/ 我的个人博客用YSlow的评分结果。。： 花瓣网页收藏工具这是花瓣网官方提供的扩展，这个扩展程序可以让你方便地从任意网站上采集喜欢的图片、视频或者网页截图，并且可以全部保存下来，甚至可以追溯到这张图片的源网页继续查看。从某种角度而言，是一款不仅仅适合设计师的插件 Check my links该插件会检查当前页面中链接的有效性，会告诉你哪些地方的链接已经是死链等等，对 SEO 很有帮助，下图是这个插件的主界面： Host Switch Plus快速切换 Domain-IP 配置而不需要编辑 Hosts 文件，并方便的添加、修改、分组（批量开关）。对于程序员来说也是一大神器啊！其实有一个软件也是用来切换 hosts 的，叫做 SwitchHosts ，感兴趣的话可以试用一下，同样很简洁。 Fatkun图片批量下载就像名字一样，它的功能是找出当前页面的所有图片并下载，提供按分辨率、链接等筛选图片，是一款十分简洁但又功能强大的扩展程序。可能更适合设计师吧？！ Extension Source Locator这是一款神奇的扩展程序，翻译成中文就是“扩展程序源码定位器”，它是干什么的呢，根据被翻译过来的不太准确的大中华语可以大概知道这玩意儿可以定位到一个你已经在谷歌浏览器上安装了的扩展程序的源码，或者说源文件 ，在你电脑磁盘的哪个地方。更重要的是它让我们可以修改一些自己喜欢的扩展程序，让其更加适合自己的使用。具体参见这篇介绍文章 Vimium首先，不知道为什么叫这个名字。。用惯 vim 的人可能习惯用键盘操控一切了，那么这款插件一定能够满足你，它让你能够通过键盘控制浏览器，包括跳转，点击某个按钮，翻页以及所有你能想到的浏览器功能，实在是佩服这款插件的开发者，可以先看一下它的宣传视频（来自油管，需要翻墙~）压压惊 一键管理所有扩展名字已经说明了一切，当我们安装了很多扩展程序的时候，一键管理就派上用场了，快速激活、禁用插件。可以安装多个插件，切换使用，缓解 Chrome 的吃内存问题 Adblock Plus去除广告的插件，满天飞的弹窗广告相当烦人啊。具体效果还没有试验，但是看到“\b去除广告”这四个字的时候，我就决定要安装一下了 WEB 前端助手(FeHelper)提供了很多前端开发者经常用到的功能，包括字符串编解码、图片 base64 编码、代码压缩、时间戳转换、二维码生成、页面性能检测等等功能，具体看下图吧： 新浪微博图床简单好用的图片上传工具，支持选择、拖拽、粘贴、上传图片，并且生成图片地址、HTML、UBB 和 Markdown 等格式，同时还支持批量上传等功能，很适合那些需要把图片放网上供其他人浏览的场景 惠惠购物助手剁手党的神器！虽然名字起得像一个垃圾广告，但是功能还是蛮实用的。。可以自动显示淘宝、京东、当当等各大网上商城的报价（安装它之后，必须要进入扩展选项设置，不然这货会弹出广告！） 更新自2017-9-10：突然发现，这个插件会在后来运行，然后在有优惠信息时，会在右上角弹出推送消息（和 service worker 类似），如下图： Octotree这是一款非常方便的 github 扩展，安装了这款插件之后，你可以在 Github 项目页面的左侧看到相应项目树状结构图，对于项目管理以及具体的文件跳转来说非常方便（同时还可以一键下载某文件，这个功能我最喜欢了！）： BuiltWith Technology Profiler这款插件很适合充满好奇心的“极客”，它可以帮你探测出当前网站所用的技术栈并按类型分类，从此再也不用去看代码推测技术栈了！ User-Agent Switcher for Chrome有时候我们需要同时在不同设备上测试网页的自适应情况，而有了这款插件，你可以随时更换 UA，节省了“检查元素”窗口的空间，同时还显得自己是一个很厉害的“前端工程师”~ 更新自2017-09-11：偶然间发现一篇文章：大家注意了 Chrome 的插件 User-Agent Switcher 是个木马，但是这篇文章里面说的插件是 User-Agent Switcher for Google Chrome，所以大家安装插件的时候一定要擦亮眼睛啊~ Always Clear Downloads自动清理下载记录和关闭令人厌烦的必须手动关闭的下载栏；但是我安装之后发现没有什么变化，是我的姿势不对吗？ Imagus鼠标停在小图片上即可显示出原图大小的图片，从此刷微博不必点击展开图片，刷淘宝、京东不必点击到商品页面细看，但是我安装之后还是看不了，难道我的姿势又不对了吗？ 更新于2017-09-07：我发现有的图片它不会放大，可能没有压缩过的图片它不会显示原图吧，不过用过之后感觉还是蛮好用的。 主题创建者为谷歌浏览器创建自定义主题。可以为每个区域选择颜色和背景。追求个性化浏览器的童鞋可以尝试一下。 Proxy SwitchyOmega轻松快捷地管理和切换多个代理设置。很适合程序猿的一款扩展，不仅可以全局代理，还可以通过正则或其他规则进行局部代理，除此之外还可以加载 PAC 脚本，翻墙神器，你不可错过。 Video DownloadHelper通过名字就可以看出来，这是一款用来下载视频的扩展，可以下载多种格式的视频，同时其提供了多种额外的功能，有兴趣的童鞋可以自行了解。 Smart TOC Add a table of contents for web article or documentation 这个插件的作用很难用语言来描述。。大致的作用就是给当前网页生成一个“目录”，同时支持锚链接，当我们再看那种“老太太裹脚布”的文章的时候，这个扩展就可以大展身手了，类似下图： 斗鱼HTML5播放器替换斗鱼TV的 Flash 播放器, 并支持弹幕, 送礼等功能. 目前是测试版本, 可能无法播放部分直播间. 基于 flv.js(https://github.com/Bilibili/flv.js)(感谢谦谦) Tampermonkey这个插件属于必装的插件之一，大家通常称其为“油猴脚本”，有了这个，你会发现新世界大门向你打开，里面有各种秀出天际的脚本：百度网盘直接下载助手、VIP 视频破解、解决百度云大文件下载限制等等，安装脚本很简单，第一次安装该插件时会有一个简单的教程，还可以去greasyfork.org下载更多更厉害的脚本，从此上网之路会变得异常酷爽！ Onetab用电脑经常用着用着就不知觉地打开了很多页面，用了多年的扎扎电脑很容易就出现浏览器崩溃的状况。装上这个 onetab 插件后，点击一下就可以把当前浏览器打开的所有标签页集中到一个页面，又可以开始愉快地浏览了，然后可以单独或全部恢复这些标签页。 或者可以打开一组相关的页面，点击后作为一个合集分享出去，工作上分享资料可以用到。 最重要的是能够节省高达95％的内存： Infinity新标签页(Pro)这个自定义的标签页颜值颇高，同时还提供了谷歌邮件自动提醒功能，还有精美天气，待办事项，印象笔记一样的记事应用，高清壁纸，必应，百度，谷歌搜索，让你的使用更加简单方便快捷。还有高清壁纸库，从 3 万多张超清壁纸中一张一张搭配图标，精心挑选出 365 张，形成每日一图，当然你也可以从你自己电脑上选择图片作为壁纸。这是它的官网，可以说是居家必备良品了。 Copyfish一款免费的 OCR文字识别插件，可以帮助我们快速地从网页中进行区域选定识别文字。Copyfish 可以从图像，PDF甚至是视频中识别提取文本，使用方法也很简便。非常适合用于那些不能复制文字的网页，选定后则会自动进行识别，弹出识别结果。还可以在设置中进行翻译语言设置等，识别后一键翻译。 掘金可以让你的新标签页变成掘金文章列表，包含 Android、前端、产品、设计、iOS、后端六大频道，每个频道内都有一到多个为你精心准备的优质内容源。同时还可以添加 Github、Dribbble 的内容，为设计师、程序员、产品经理每日发现优质内容。当然，如果你不想作为新标签页使用的话，还可以使用其网页版，其功能和新标签页是一模一样的，可以说是十分贴心了。 Momentum这也是一款改造新标签页的扩展程序，从下面的截图中可以看到，改造之后非常的炫酷，关键是每一天的壁纸都不一样，而且还可以添加 todoList 等更多功能，如果感兴趣的话可以自行探索。 New Tab Dribbble这个就更厉害了，可以说是设计师的必备，你每次打开新的标签页都会第一时间把每日精品设计作品展示出来，你每天都能看到来自大神的作品，简直是灵感的源泉，作品都来自 Dribbble。 Isometric Contributions这个应该是程序员专属，它可以让我们 Github 的贡献图变成 3D 效果，非常适合用来装逼有没有，是不是很高大上： GitHub Repository Size这款插件也是 Github 相关的一款辅助工具，它可以直接将仓库的大小以及仓库中各个文件的大小显示出来： DarknessDarkness为热门网站提供精美的深色主题，可以显著减轻由明亮的电脑屏幕引起的眼睛负担和疲劳： 云盘万能钥匙官网地址：https://ypsuperkey.meek.com.cn/，这款插件可以自动识别百度网盘提取密码，标识已失效的网盘链接，网盘分享从此更加简单。不过这款插件之所以会有如此能力，是因为它会在你提交百度网盘分享链接提取密码时收集提取密码信息，可能会涉及到隐私问题。除了 Chrome 浏览器，它还支持其他大部分浏览器，包括火狐、360、QQ、搜狗、UC 等等。 沙拉查词涵盖所有主流词典，多重划词模式，极致交互体验，灵活导出生词本，高度可配置，支持 PDF，兼容 Vimium 全键盘操作。对于想学英语的童鞋来说是一个很好的工具。 GayHub首先，请忽略这个扩展的名字。。它的主要功能是优化 Github 的阅读体验： 文件目录树：把 Vscode 的精美的侧边栏完美移植到 github 上 TOC导航：能完美解析当前内容的所有嵌套标题，性能优越，滑动起来如丝滑般流畅。 夜间暗色主题 图片全屏预览 一键复制代码 其他人推荐的扩展程序以上是我自己使用过或在使用的一些扩展程序，还有一些扩展程序可能我自己并没有使用但是其他人推荐了，我也列举在下方，方便大家查看和选择： 优秀程序员都在用哪些Chrome拓展工具？ 如果因为某些显而易见的问题，无法从应用商店安装插件的话，可以尝试到扩展迷官网下载。 开发指南其实 Chrome 扩展程序的开发并不是很难，只要你有前端的一些基础知识（HTML、CSS、JavaScript）就足够了，剩下的一些就是按照官方的文档或其他教程一步一步的编写+理解就可以了，下面是一些推荐的教程，相信看过之后你一定可以开发出一个类似天气、股票、PM2.5 这样的扩展程序： Chrome 扩展及应用开发 -&gt; 来自图灵社区的免费电子书，适合入门。 Chrome扩展开发文档 -&gt; 来自 360 极速浏览器翻译的官方文档（比较老了，不是很推荐）。 Chrome 插件开发官方文档(英文) -&gt; 前两个适合入门，实际开发的时候还是推荐官方的，查API啥的都很方便，况且这篇文档写的很赞，也简单易懂，强烈推荐。 ChokCoco-手把手教你开发扩展程序 -&gt; ChokCoco 老师的扩展程序开发教程，讲的挺好的，五星推荐！ Publish in the Chrome Web Store -&gt; Chrome官方出的发布自己的扩展程序的教程 Chrome插件开发全攻略 -&gt; 作者花了将近一个多月的时间断断续续写下这篇博文，并精心写下了这个完整 demo，里面包含的内容很多，包括了大部分的配置项，同时还附有源码，是一篇很不错的入门文章。 一篇文章教你顺利入门和开发chrome扩展程序（插件） -&gt; 前面部分大多数是一些基础介绍，和别人的资料大同小异，但是用的是通俗的语言或者作者自己理解来描述的，不是拷贝官方的描述，更方便读者理解；后面部分多为一些作者在项目中总结的方法。","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://merrier.wang/tags/Chrome/"},{"name":"指南","slug":"指南","permalink":"http://merrier.wang/tags/指南/"},{"name":"推荐","slug":"推荐","permalink":"http://merrier.wang/tags/推荐/"}]},{"title":"Git配置别名","slug":"Git配置别名","date":"2017-06-28T03:04:28.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170628/git-configuration-alias.html","link":"","permalink":"http://merrier.wang/20170628/git-configuration-alias.html","excerpt":"","text":"git 提供了各种各样的操作方法，但是我们常常会陷入“敲 git 命令敲的手疼”的困境，此时为 git 配置别名就显得尤为重要了，尤其是当我们的项目有各种各样的分支（master、dev、test…）时，经常需要 merge、rebase、add、commit，如果能用一两个字母代替这些命令的话，我相信会减轻很多打字的负担。 方法一：临时修改我们只需要敲一行命令，告诉 git，以后 st 就表示 status： 1git config --global alias.st status –global 参数是全局参数，也就是这一行命令在这台电脑的所有 git 仓库下都有用；当然，如果你想只在当前项目中使用简写命令，可以在项目的目录下使用 git config 命令而不带 –global 选项，这样会在你当前项目目录下的 .git/config 文件增加一节 [user] 内容： 123[user] name = Merrier eamil = 953075999@qq.com 只改了 status 不过瘾？没关系，我们还有别的命令可以简写，很多人用 co 表示 checkout，ci 表示 commit，br 表示 branch（每个人都有自己的简写习惯，不过最好和别人相同，否则别人在你的电脑上提交代码的话可能会有不必要的麻烦） 123git config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branch 当然，除了上面这些简单的命令之外，我们还可以为一些复杂的命令设置别名，比如配置一个 git last，让其显示最后一次提交信息： 1git config --global alias.last 'log -1' 这样，我们用 git last 就能显示最近一次的提交： 1234567$ git lastcommit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2Merge: bd6ae48 291bea8Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py 方法二：修改 .gitconfig如果我们拿到的是一台新电脑，像上面那样一行一行敲设置简写的命令的话会将一件本来让自己方便的事变得很麻烦，所以有没有一次性设置全部简写命令的方法呢？当然是有的了（要不然我这个方法二从何而来），就是修改 .gitconfig 文件，其实我们上面那些命令就是在一次次的修改 .gitconfig 文件；.gitconfig 文件在哪呢？理论上就在你的主目录下： 从上图可以看到，可以通过 cat ~/.gitconfig 查看自己电脑的 .gitconfig 文件内容，而由于我已经设置了 git 别名，所以该文件中会有 [alias] 内容，那么你就可以通过在这个文件中添加类似的内容来配置你自己的别名了： 1234567891011[alias] co = checkout ci = commit st = status pl = pull ps = push dt = difftool l = log --stat cp = cherry-pick ca = commit -a b = branch 和方法一一样，如果你只想要在某些项目中使用简写，可以进入项目的目录，然后编辑 .git/config 文件，加入上面的内容就可以了","categories":[{"name":"Git","slug":"Git","permalink":"http://merrier.wang/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://merrier.wang/tags/git/"}]},{"title":"搜狐研究院前端散招面试题总结","slug":"搜狐研究院前端散招面试题总结","date":"2017-05-19T02:06:37.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170519/summary-of-the-front-end-interview-questions-of-sohu-research-institute.html","link":"","permalink":"http://merrier.wang/20170519/summary-of-the-front-end-interview-questions-of-sohu-research-institute.html","excerpt":"","text":"首先，搜狐媒体大厦还是蛮阔气的，但是门口的保安让我在沙发区稍等一会儿的时候，我看到那里有 5 个类似员工的人在打王者荣耀。。果然“大公司”的员工氛围就是不一样啊。。后来等了大概 10 分钟左右，一个挂有实习工作牌的女士把我带到了 9 楼，这里应该是搜狐员工办公的地方，两边都有比较大的办公区，然后中间有一块稍微小一点的地方用来面试和聊天，hr 姐姐首先让我做了一下搜狐的笔试题，然后说大概一个小时，如果做完了就给她打电话，然后就自己走开了（连杯水都没有倒，实习生就是这样的吗。。）， 做完了之后就有一位男士拿着我的简历过来了，整个面试的过程堪称尴尬，因为我的简历上写有“关注ES6”，所以这位年轻的面试官就开始各种问 ES6 相关的东西，还问我和 react 相关的东西，比如让我讲一下 react 的设计思想啊什么的。。难道这就是“关注ES6”想要表达的意思吗？后来他可能感觉也比较尴尬了，就问了一些 JS 相关的东西，比如 self 和 this 的区别啊什么的，但是我的水平实在有限，这位面试官的前端水平实在是在我之上太多，所以我也是基本上全程蒙蔽，更别提让我用 jQuery 实现一个 promise 对象了（对了，这位面试官连 jQ 的 when() 方法都不知道。。），就这样结束了一面，当然由于我的水平实在太低，所以就直接让我走人了（不过我也比较饿了，想回学校吃点东西了。。） 笔试题一、不定项选择题我不知道笔试题能不能拍照，但是我还是冒着被批评和留下不好印象的风险拍了一下，总体来说难度还是适中的，其中有些题还是蛮经典的，大家可以自行消化 1. 以下元素为块级元素的有： p strong span section 2. 以下可以使元素不可见的有： display: none width:0; height:0; overflow:hidden visibility: hidden display: inline 3. 以下正确的有： Number.MIN_VALUE &gt; 0 Number(1) == new Number(1) null == undefined NaN == NaN 4. 以下会有错误发生的有： 9..toString() //“9” alert(a) //a is not defined eval(‘a’) //a is not defined console.log(Number) 5. 以下哪些情况会促发 BFC？ float 不为 none position 为 fixed display 为 static overflow 为 scroll 6. 哪些元素会生成 BFC： 根元素 float 属性不为 none position 为 absolute 或 fixed display 为 inline-block, table-cell, table-caption, flex, inline-flex overflow 不为 visible 二、填空题1. 一个 div 垂直居中于整个 body 的 css 代码：123456789.center&#123; position: absolute; height: 400px; width: 400px; margin-top: -200px; margin-left: -200px; left: 50%; top: 50%;&#125; 2. 以下代码的打印结果为：10 10 10 10 10 10 10 10 10 1012345for(var i=1;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0);&#125;; 3. 匹配邮箱的正则表达式：1^\\[a-z0-9\\]+(\\[._\\\\\\-\\]*\\[a-z0-9\\])*@(\\[a-z0-9\\]+\\[-a-z0-9\\]*\\[a-z0-9\\]+.)&#123;1,63&#125;\\[a-z0-9\\]+$ 对于该正则表达式的解释：比较正宗的验证邮箱的正则表达式js代码详解 4. 对纯数字数组中每个元素进行乘以 2 后再取数组中的最小值12345function doubleMin(arr)&#123; return Math.min.apply(null,arr.map(function(item)&#123; return item*2; &#125;))&#125; 关于数组 map() 方法的讲解：js 数组 map方法 5. 对以下数组按照拼音首字母排序 arr: [‘研发中心’,’视频中心’,’焦点部门’,’新闻部门’]1234567891011arr.sort(function(a,b)&#123; var af = a.charAt(0); var bf = b.charAt(0); if(af.localeCompare(bf) &gt; 0)&#123; return 1; &#125;else if(af.localeCompare(bf) &lt; 0)&#123; return -1; &#125;else&#123; return 0; &#125;&#125;) 三、简答题1. 实现：var a = add(10)(3)(2) // a打印结果为15这是一道关于类型转换的问题：一道面试题引发的对 javascript 类型转换的思考 2. 实现一个加载的动画(该动画有至少三个小圆，分别变大变小富有层次感)（只能使用 css）利用关键帧动画 @keyframes 就可以达到，网上有好多关于加载动画实现的文章，推荐一下类似这道题想要的效果的文章：CSS 实现加载动画之八-圆点旋转、6种CSS3加载动画 3. HTTP 是一个无状态的协议，那网站是如何记住用户信息的呢？请写出详细过程；同时谈谈 localStorage 和 sessionStorage 的区别，对离线缓存，甚至是 indexDB 的理解网站是如何记住用户信息的：无状态协议中认证状态保持方案的一些思考 4. 请用 JS 实现一个简单的列表(List)类，使得其具有 show(展示该 list 的所有元素)，add(向 list 添加一个元素，无返回)，delete(删除指定位置的元素，并返回删除成功否)，clear(清空 list)；在 JS 中是没有类的，所以其实是用 function 来间接实现，这类实现在我的另一篇文章里大量提到：JS 实现复杂数据结构 5. 请分别实现一个菱形，一个倒三角，一个椭圆形的答案（只能使用 css 和 html，不考虑兼容性）在 css 中，通过 border 和旋转可以实现很多种图形，我在这个方面也是比较白痴的，所以推荐以下文章：CSS3实现32种基本图形、利用css样式画各种图形–初步、进阶、高级（一）（感觉这两篇文章的排版和图片都不是很好，找时间我会自己再总结一下） 6. 简要回答你对跨域的理解，为什么要跨域，如何跨域跨域这种问题应该是老生常谈了，其实就是浏览器的一种“同源策略”，为了保证安全而采取的措施，具体大家自行搜索吧，关于跨域的文章实在是太多了 一面1. localStorage 和 sessionStorage 的区别 localStorage 和 sessionStorage 一样都是用来存储客户端临时信息的对象。 他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。 localStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的 UI 上清除 localStorage 信息，否则这些信息将永远存在。 sessionStorage 生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过 sessionStorage 存储的数据也就被清空了。 不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。 2. JS中self和this的区别不知道为什么面试官会问这个问题，因为 self 好像在 react 才会经常用到吧？。。但是我还是查了一下，网上对这两个的区别的解释很少，大致就是：self 指向本窗口，this 指向就比较广泛了 3. 如何实现 JS 中的防抖动和节流阀这个功能其实经常用到，但是面试官给我的答案是 underscore.js 源码中有，然后说 jQuery 的第三方库应该也有。。估计是这位面试官经常用 underscore.js 解决重复点击的问题，然后至于怎么实现的自己也不知道。。（我就没好意思再问了，以免造成尴尬的局面），推荐一下解释的很清楚的文章（这是一篇中文译文，英文原文可以点击下面这篇文章中的原文链接）：实例解析防抖动（Debouncing）和节流阀（Throttling） 4. HTML5 使任何元素变为可编辑的属性1contenteditable=&quot;true&quot; 5. 当给 line-height 设置为 5rem、5em、5px、5pt、500%、5 时的计算公式在张鑫旭的慕课网讲解视频（深入理解 CSS 系列）中曾经讲到过这些单位的含义和作用，具体可以点击下面链接查看我对他的讲解的总结：CSS 深入理解之 line-height，具体计算公式和作用如下： 5rem：按照 html 的 font-size 进行计算 5em：按照自身的 font-size 进行计算 5px：相对长度单位，像素 5pt：绝对长度单位，点 Points (1点 = 1/72英寸) 500%：按照自身的 font-size 进行计算 5：同样按照自身的 font-size 进行计算 可以看出，line-height 的值如果不是具体数值，都是按照 font-size 进行计算的，同时 500%/5em/5 有什么区别呢？在张鑫旭的讲解中也提到了，500%/5em 会根据自身的 font-size 进行计算，得到具体数值后将行高继承给后代元素，而 5 只会将比例继承给后代元素，后代元素会根据自己的 font-size 重新计算行高 更新自2017-10-11：突然发现小程序中有一个很有趣的长度单位 rpx，具体参见这篇文章：谈谈像素以及微信小程序的 rpx 6. oninput 事件和 onchange 事件的区别onchange 事件经常用到（图片、文件上传），但是 oninput 事件却没有用过了，推荐：总结oninput、onchange与onpropertychange事件的用法和区别","categories":[{"name":"前端","slug":"frontend","permalink":"http://merrier.wang/categories/frontend/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://merrier.wang/tags/前端/"},{"name":"面试","slug":"面试","permalink":"http://merrier.wang/tags/面试/"}]},{"title":"今日头条前端散招内推面试经验总结","slug":"今日头条前端散招内推面试经验总结","date":"2017-05-17T07:33:40.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170517/summary-of-Experience-in-interview-in-headlines.html","link":"","permalink":"http://merrier.wang/20170517/summary-of-Experience-in-interview-in-headlines.html","excerpt":"","text":"笔试题可能是内推的缘故，在面试之前前台工作人员给了一套前端的笔试题，然后就分配了一个小房间开始做题，虽然没有指明不可以手机搜索，但是为了保证最起码的诚信，我全程都没有看手机，完全凭自己的水平答题，虽然最后面试官把原题拿走了，但是我还是能靠记忆回想起一些题目，总结如下： 1. 替换元素和非替换元素有哪些，它们的差异是什么？替换元素替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。 比如：&lt;input type=&quot;text&quot;/&gt;，这是一个文本输入框，换一个其他 type 的时候，浏览器显示就不一样，HTML 中的 &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt; 都是替换元素，这些元素都没有实际的内容。 非替换元素HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。 比如 &lt;p&gt;merrier.wang&lt;/p&gt;、&lt;label&gt;Merrier&lt;/label&gt; 浏览器将把这段内容直接显示出来。 2. offsetWidth、clientWidth、scrollWidth 如何计算？offsetWidth 无 padding 无滚动无 border offsetWidth = clientWidth = 盒子的宽度 有 padding 无滚动有 border offsetWidth = 盒子的宽度 + 盒子 padding 2 + 盒子边框 2 = clientWidth + 边框宽度*2 有 padding 有滚动，且滚动是显示的，有 border offsetWidth = 盒子宽度 + 盒子 padding 2 + 盒子边框 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2 clientWidth 无 padding 无滚动 ：clientWidth = 盒子的 width 有 padding 无滚动 ：clientWidth = 盒子的 width + 盒子的 padding * 2 有 padding 有滚动 ：clientWidth = 盒子和 width + 盒子的 padding * 2 - 滚动轴宽度 scrollWidth无滚动轴时： scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2 有滚动轴时： scrollWidth = 实际内容的宽度 + padding * 2 scrollHeight = 实际内容的高度 + padding * 2 更多关于 JS 中的宽高可以狠狠的点击这里：JS 宽高的理解和应用 3. JS 中的标准事件模型是什么？是所有的事件都会冒泡吗？不是的话请举例DOM2 标准事件模型：每一个 DOM 元素所触发的事件都要经历三个阶段： 捕获阶段 目标对象本身的事件处理程序调用阶段 冒泡阶段 在 IE8 以上的版本以及其他的浏览器中通过 e.stopPropagation() 方式阻止事件的冒泡；在 IE8 以下的浏览器中通过 e.cancleBubble = true 阻止事件冒泡；jQ 中的 mouseenter 和 mouseleave 也是默认不冒泡 4. CSS 选择器的优先级是什么？!important &gt; 内联 &gt; id &gt; class &gt; 标签(p、a、div) &gt; 通配符(*) &gt; 浏览器自定义 更多关于 CSS 选择器的的内容：前端面试系列（4）——CSS选择器 5. IFC 是什么？它的作用是什么？What’s FC？FC 的全称是：Formatting Contexts，是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 IFCIFC(Inline Formatting Contexts) 直译为”内联格式化上下文”，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding / margin 影响)，IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。IFC 中是不可能有块级元素的，当插入块级元素时（如 p 中插入 div），会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。 那么IFC一般有什么用呢？ 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。 BFCBFC(Block Formatting Contexts) 直译为”块级格式化上下文”。Block Formatting Contexts 就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。 如何产生 BFC？ float 的值不为 none。 overflow 的值不为 visible。 position 的值不为 relative 和 static。 display 的值为 table-cell, table-caption, inline-block 中的任何一个。 那BFC 一般有什么用呢？ 比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 CSS2.1 中只有 BFC 和 IFC，CSS3 中才有 GFC 和 FFC，更多关于这些 FC 的内容可以查看：小科普：到底什么是BFC、IFC、GFC和FFC，次奥？ 6. 如何实现一个自适应正方形这个问题在我前不久的一篇文章里有总结过，可以点击这里查看 7. http://mp.toutiao.com 向 http://toutiao.com 发送请求的话，跨域了吗，能收到请求吗，是什么样的请求？判断跨域的指标：域名、协议、端口，只要有其中一项不一致就会发生跨域 8. 请介绍一下 XSS 和 CSRF 的区别，如何防御？XSSXSS 全称“跨站脚本”（Cross-site scripting），是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。 CSRFCSRF 的全称是“跨站请求伪造”（Cross-site request forgery），而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。 严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。 防御 XSS 攻击可以通过以下两方面操作： 对用户表单输入的数据进行过滤，对 javascript 代码进行转义，然后再存入数据库； 在信息的展示页面，也要进行转义，防止 javascript 在页面上执行。 CSRF 攻击的防御可以通过以下两方面操作： 所有需要用户登录之后才能执行的操作属于重要操作，这些操作传递参数应该使用 post 方式，更加安全； 为防止跨站请求伪造，我们在某次请求的时候都要带上一个 csrf_token 参数，用于标识请求来源是否合法，csrf_token 参数由系统生成，存储在 SESSION 中。 更多关于 XSS 和 CSRF 的解释： 浅析XSS和CSRF攻击及防御 如何用简洁生动的语言理清XSS和CSRF的区别？ 9. JSBridge 是什么，它的作用是什么？在开发中我们经常需要 web 和 native 进行交互，也就是要用到经常听到的 “JSBridge”。由于我对这个东西也是停留在概念层面，所以推荐其他人的一篇文章吧：理解JSBridge 10. TCP 和 UDP 的区别，以及如何进行拥塞控制？ TCP 面向连接（如打电话要先拨号建立连接）；UDP 是无连接的，即发送数据之前不需要建立连接 TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付 TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等） 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信 TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节 TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道 更多关于 TCP 和 UDP 的区别：TCP和UDP的最完整的区别 拥塞控制防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 更多关于拥塞控制：TCP/IP详解–拥塞控制 &amp; 慢启动 快恢复 拥塞避免 11. 有一无序数组，数组个数为 m，如何从这 m 个数里面找到 N 个数，使这 N 个数的和为 M；并阐述时间复杂度和空间复杂度这个属于比较经典的 01背包问题，网上有很多关于这种问题的求解方式，基本上包括递归、动态规划、无脑循环等方法，推荐以下比较靠谱的解法：动态规划（JS）、无脑循环 一面一面的时间很长，大概有将近一个小时的感觉，所以问的问题涉及的领域和方面也比较多，所以我就想到什么写下什么了，另外也不赋答案了，实在有点多。。 __proto__ 是什么意思 JS 实现继承的方式 object.defineproprety() 方法的参数和含义 setTimeout(func,0) 中设置延时为 “0” 的目的 jQuery 中对 Promise() 的 when() 方法的实现原理 HTTP 和 TCP 的关系 TCP 三次握手 HTTP 如何达到在下一次连接时不用再 TCP 三次握手的 如何实现一个自适应正方形 浏览器渲染的过程 重排和重绘的触发时机和区别 层叠上下文起作用的前提 前端路由和后端路由的区别 首屏加载完毕之后 &lt;script&gt;&lt;/script&gt; 代码的加载顺序 vue.js 的设计思想 如果用 jQuery 实现双向数据绑定，应该如何实现 当 content-length 过长时，应该如何传输数据 JS 文件中的代码执行顺序 详细讲解一下 JS 中宏任务和微任务的判断机制 如果有别的库中也用到了 “$”，如何解决和 jQuery 的冲突 二面二面相对于一面来说，就简单随意了很多，问了一些项目的事情，还问了技术选型方面的问题，最后出了一道算法题让我做，我思考了大概 15 分钟，感觉真心写不出代码，就和面试官简单的讲了一下思路，面试官思考了一段时间之后就告诉我二面结束了，可以 hr 面了；至此，技术面就全部结束了。","categories":[{"name":"前端","slug":"frontend","permalink":"http://merrier.wang/categories/frontend/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://merrier.wang/tags/前端/"},{"name":"面试","slug":"面试","permalink":"http://merrier.wang/tags/面试/"}]},{"title":"纯CSS实现自适应正方形","slug":"纯CSS实现自适应正方形","date":"2017-05-16T09:00:27.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170516/realization-of-adaptive-square-in-pure-css.html","link":"","permalink":"http://merrier.wang/20170516/realization-of-adaptive-square-in-pure-css.html","excerpt":"","text":"首先，自适应正方形是指宽度和高度随着屏幕宽度（不管是移动端还是 PC 端）进行等比例变化的正方形，在处理移动端页面时，我们有时会需要将 banner 图做成与屏幕等宽的正方形以获得最佳的体验效果，如 Flipbord的移动页面，而在 PC 端，我们也可能需要实现一个随屏幕宽度变化的正方形，从而达到某些效果；那么应该怎么使用纯 CSS 制作出能够自适应大小的正方形呢？ 方案一：CSS3 vw 单位CSS3 中新增了一组相对于可视区域百分比的长度单位 vw, vh, vmin, vmax。其中vw是相对于视口宽度百分比的单位，1vw = 1% viewport width，vh是相对于视口高度百分比的单位，1vh = 1% viewport height；vmin 是相对当前视口宽高中较小的一个的百分比单位，同理 vmax 是相对当前视口宽高中较大的一个的百分比单位。该单位浏览器兼容性如下： 代码实现1&lt;div class=\"placeholder\"&gt;&lt;/div&gt; 1234.placeholder&#123; width: 50vw; height: 50vw;&#125; 优点：简洁方便 缺点：浏览器兼容不好 实现效果方法二：设置垂直方向的 padding 撑开容器在 CSS 盒模型中，一个比较容易被忽略的就是 margin, padding 的百分比数值计算。按照规定，margin, padding 的百分比数值是相对父元素宽度的宽度计算的。由此可以发现只需将元素垂直方向的一个 padding 值设定为与 width 相同的百分比就可以制作出自适应正方形了： 代码实现1234.placeholder&#123; width: 100%; padding: bottom:100%;&#125; 如果正方形中没有内容（相当于只是一个几何里面的正方形，并没有展示其他任何内容），一切看起来都很正常；但是，如果正方形中有其他内容（这种情况会更常见一些，比如说有一些文本和图片），此时容器的高度就会被拉伸，因为盒子模型中的 padding 是不包含在 content 中的，所以我们可以通过 height:0 解决这个问题；这种方案简洁明了，且兼容性好；但是除了填充内容后会出现问题以外，还有可能碰上max-height不收缩，于是第三种方案来了： 方案三：利用伪元素的 margin(padding)-top 撑开容器在方案二中，我们利用百分比数值的 padding-bottom 属性撑开容器内部空间，但是这样做会导致在元素上设置的 max-height 属性失效；而失效的原因是 max-height 属性只限制于 height，也就是只会对元素的 content height 起作用。那么我们是不是能用一个子元素撑开 content 部分的高度，从而使 max-height 属性生效呢？我们来试试： 12345678.placeholder &#123; width: 100%;&#125;.placeholder:after &#123; content: ''; display: block; margin-top: 100%; /* margin 百分比相对父元素宽度计算 */&#125; 一刷新页面，啊嘞？怎么什么也没有？ 这里就涉及到 margin collapse 的概念了，由于容器与伪元素在垂直方向发生了外边距折叠，所以我们想象中的撑开父元素高度并没有出现。而应对的方法是在父元素上触发 BFC： 123.placeholder &#123; overflow: hidden;&#125; 实现效果总结以上就是三种制作自适应正方形的方案，除去 CSS3 中的视口相对单位，主要利用到 margin, padding 的百分比数值相对父元素宽度的宽度计算得出来制作宽高相等、且相对视口宽度自适应的正方形。如果需求是制作相对视口高度自适应的正方形，估计就只能使用 vh 单位了吧~","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"Sublime Text插件推荐","slug":"Sublime Text插件推荐","date":"2017-05-14T12:44:19.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170514/sublime-text-plugin-recommendation.html","link":"","permalink":"http://merrier.wang/20170514/sublime-text-plugin-recommendation.html","excerpt":"","text":"安装sublime text2 插件的方法直接安装安装 Sublime text 2 插件很方便，可以直接下载安装包解压缩到 Packages 目录（菜单 -&gt; preferences -&gt; packages）。 使用 Package Control 组件安装也可以安装 package control 组件，然后直接在线安装： 按 Ctrl+` 调出 console（注：安装有 QQ 输入法的话这个快捷键会有冲突，输入法属性设置-输入法管理-取消热键切换至 QQ 拼音） 粘贴以下代码到底部命令行并回车： 1import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed\\_packages\\_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) 重启 Sublime Text 2。 如果在 Perferences -&gt; package settings 中看到 package control 这一项，则安装成功。 用 Package Control 安装插件的方法 按下 Ctrl + Shift + P 调出命令面板 输入 install，调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 不爽的是，有的网络环境可能会不允许访问陌生的网络环境从而设置一道防火墙，而 Sublime Text 2 貌似无法设置代理，可能就获取不到安装包列表了。好，方法介绍完了，下面是本文正题，推荐一些 Sublime Text 2 插件： 插件推荐EmmetHTML / CSS 代码快速编写神器，Emmet 的前身是大名鼎鼎的 Zen coding，如果你从事 Web 前端开发的话，对该插件一定不会陌生。它使用仿 CSS 选择器的语法来生成代码，大大提高了 HTML / CSS代码编写的速度，比如下面的演示： 关于这一插件的牛逼之处就不再多言，这里有一篇讲解 Emmet 的文章讲的很详细：Emmet：HTML/CSS代码快速编写神器 Gitgit 应该是必备的插件之一，而 sublime 对于 git 的支持也是很好的，关于如何在 sublime 中使用 git，可以查看下面这篇文章：sublime中git的使用，我就不再过多描述了 Vue Syntax Highlight这是一款可以让你的 .vue 文件也可以高亮的插件，鉴于最近在自学 vue，所以还是推荐一下这款插件吧，在 Package 里面搜索 vue 即可","categories":[{"name":"工具","slug":"工具","permalink":"http://merrier.wang/categories/工具/"}],"tags":[{"name":"推荐","slug":"推荐","permalink":"http://merrier.wang/tags/推荐/"},{"name":"sublime","slug":"sublime","permalink":"http://merrier.wang/tags/sublime/"}]},{"title":"与MySQL的零距离接触","slug":"与MySQL的零距离接触","date":"2017-05-09T02:02:40.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170509/zero-distance-contact-with-mysql.html","link":"","permalink":"http://merrier.wang/20170509/zero-distance-contact-with-mysql.html","excerpt":"","text":"MySQL 基础由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司，MySQL 是一个开源的关系型数据库管理系统，分为社区版和企业版 MySQL 一些常用参数mysql 参数 /daizhengli/[table id=24 /] MySQL退出 mysql &gt; exit; mysql &gt; quit; mysql &gt; \\q; 修改 MySQL 提示符连接客户端时通过参数指定提示符： 1shell&gt;mysql -uroot -proot --prompt 连接上客户端后，通过 prompt 命令修改提示符：mysql&gt;prompt，MySQL 提示符修改时可以用到的一些参数： /daizhengli/[table id=25 /] 修改数据表的默认存储引擎找到 MySQL 配置文件：default-storage-engine=INNODB，修改完之后需要重启 MySQL MySQL 语句的规范 关键字与函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL 语句必须以分号结尾 数据类型 字符型 整型 浮点型 日期时间型 MySQL 常用命令 显示当前服务器版本：SELECT VERSION(); 显示当前日期时间：SELECT NOW(); 显示当前用户：SELECT USER(); 创建数据库 |：表示可以互换的两项 []：表示可选项 {}：表示必选项 1CREATE &#123;DATABASE | SCHEMA&#125; \\[IF NOT EXISTS\\] db\\_name \\[DEFAULT\\] CHARACTER SET \\[=\\] charset\\_name DATABASE | SCHEMA：这两个完全相同，任选其一即可IF NOT EXISTS：可选项，如果存在就不创建，不存在才会创建CHARACTER：设置编码格式，例如 utf-8，gbk 查看当前服务器下的数据表列表1SHOW &#123;DATABASES | SCHEMAS&#125; \\[LIKE 'pattern' | WHERE expr\\] 修改数据库1ALTER &#123;DATABASE | SCHEMA&#125; \\[db\\_name\\] \\[DEFAULT\\] CHARACTER SET \\[=\\] charset\\_name 通过以上语句可以修改某个数据库的编码格式 删除数据库1DROP &#123;DATABASE | SCHEMA&#125; \\[IF EXISTS\\] db_name 打开数据库1USE db_name 创建数据表1CREATE TABLE \\[IF NOT EXISTS\\] table\\_name( column\\_name data_type, .... ) 查看数据表列表1SHOW TABLES \\[FROM db_name\\] \\[LIKE 'pattern' | WHERE expr\\] FROM db_name：不仅可以查看当前数据库中的数据表，还可以查看其他数据库中的数据表 查看数据表结构1SHOW COLUMNS FROM tbl_name tbl_name：数据表的名称 插入记录1INSERT \\[INFO\\] tbl\\_name \\[(col\\_name,...)\\] VALUES(val,...) 如果省略 col_name (列名称)，就必须为所有字段都赋值 记录查找1SELECT expr,... FROM tbl_name expr：表达式 字段属性设置空值与非空 NULL：字段值可以为空（默认值） NOT NULL：字段值禁止为空 1CREATE TABLE tbl_name(username VARCHAR(20) NOT NULL,age TINYINT UNSIGNED NULL); 表级约束与列级约束对一个数据列建立的约束，称为列级约束 对多个数据列建立的约束，称为表级约束 列级约束既可以在列定义时声明，也可以在列定义后声明 表级约束只能在列定义后声明 主键约束PRIMARY KEY：每张数据表只能存在一个主键，主键保证记录的唯一性，主键自动为 NOT NULL，主键不一定和下面的自动编号一起使用，但是不能赋相同的值 自动编号AUTO_INCREMENT：必须与主键组合使用，默认情况下，起始值为 1，每次的增量为 1，该字段的数据类型必须为数字，如果是浮点数必须小数位数为 0 唯一约束UNIQUE KEY：可以保证记录的唯一性，字段可以为空值（NULL），每张数据表可以存在多个唯一约束 默认约束DEFAULT：当插入记录时，如果没有明确为字段赋值，则自动赋予默认值 1sex enum('1','2','3') DEFAULT '3' 外键约束FOREIGN KEY：保持数据一致性和完整性，实现一对一或一对多关系 外键约束的要求 父表和子表必须使用相同的存储引擎，而且禁止使用临时表 数据表的存储引擎只能为 InnoDB 外键列和参照列必须具有相似的数据类型，其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同 外键列和参照列必须创建索引，如果外键列不存在索引的话，MySQL 将自动创建索引 外键约束的参照操作 CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行 SET NULL：从父表删除或更新行，并设置子表中的外键列为 NULL。如果使用该选项，必须保证子表列没有指定NOT NULL RESTRICT：拒绝对父表的删除或更新操作 NO ACTION：标准 SQL 的关键字，在 MySQL 中与 RESTRICT 相同 pid INT,FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE =&gt; pid 为外键约束，参照数据表 provinces 中的 id 字段；并且删除时的参照操作为 CASCADE 修改数据表添加单列1ALTER TABLE tbl\\_name ADD \\[COLUMN\\] col\\_name column\\_definition \\[FIRST | AFTER col\\_name\\] FIRST：新添加的列将置于最前面AFTER col_name：新添加的列将置于某一列后面如果省略以上两项，新添加的列将位于所有列最后面 添加多列1ALTER TABLE tbl\\_name ADD \\[COLUMN\\] (col\\_name column_definition,...) 添加多列时无法指定位置，只能位于最后面 删除列1ALTER TABLE tbl\\_name DROP \\[COLUMN\\] col\\_name ALTER TABLE tbl_name DROP age,DROP password =&gt; 可以同时删除 age 列和 password 列 添加约束添加主键约束1ALTER TABLE tbl\\_name ADD \\[CONSTRAINT \\[symbol\\] \\] PRIMARY KEY \\[index\\_type\\] (index\\_col\\_name,...) 添加唯一约束1ALTER TABLE tbl\\_name ADD \\[CONSTRAINT \\[symbol\\] \\] UNIQUE \\[INDEX | KEY\\] \\[index\\_name\\] \\[index\\_type\\] (index\\_col_name,...) 唯一约束可以给多列添加 添加外键约束1ALTER TABLE tbl\\_name ADD \\[CONSTRAINT \\[symbol\\] \\] FOREIGN KEY \\[index\\_name\\] (index\\_col\\_name,...) reference_definition 添加/删除默认约束1ALTER TABLE tbl\\_name ALTER \\[COLUMN\\] col\\_name &#123;SET DEFAULT literal | DROP DEFAULT&#125; SET DEFAULT literal：添加默认约束DROP DEFAULT：删除默认约束 删除约束删除主键约束1ALTER TABLE tbl_name DROP PRIMARY KEY 删除唯一约束1ALTER TABLE tbl\\_name DROP &#123;INDEX | KEY&#125; index\\_name 一张表可以有多个唯一约束，所以需要查看约束的名字 =&gt; SHOW INDEXES FROM tbl_name [\\G]; 删除外键约束1ALTER TABLE tbl\\_name DROP FOREIGN KEY fk\\_symbol fk_symbol：约束的名字，需要提前查看 =&gt; SHOW CREATE tbl_name 修改列定义1ALTER TABLE tbl\\_name MODIFY \\[COLUMN\\] col\\_name column\\_definition \\[FIRST | AFTER col\\_name\\] 可以修改数据类型以及数据列的位置 修改列名称1ALTER TABLE tbl\\_name CHANGE \\[COLUMN\\] old\\_col\\_name new\\_col\\_name column\\_definition \\[FIRST | AFTER col_name\\] 修改列名称的同时也可以修改列类型和位置，所以其功能要强大于修改列定义 数据表更名尽量少更改数据表和数据列名字，因为如果创建过索引和约束，会影响到正常使用 方法11ALTER TABLE tbl\\_name RENAME \\[TO | AS\\] new\\_tbl_name 方法21RENAME TABLE tbl\\_name TO new\\_tbl\\_name \\[,tbl\\_name2 TO new\\_tbl\\_name2\\] ... 总结 记录操作插入记录第一种1INSERT \\[INTO\\] tbl\\_name \\[(col\\_name,...)\\] &#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,...&#125;,(...),... 可以插入一条记录，也可以插入多条记录 INSERT users VALUES(NULL,’John’,’456’,25,1); =&gt; NULL 为空值，也可以为自增字段赋值（DEFAULT也可以） INSERT users VALUES(\bDEFAULT,’Tom’,’123’,3*7-5,1),(NULL,’Rose’,md5(‘123’),DEFAULT,0); =&gt; 插入多条记录，可以用表达式，也可以用函数、NULL、DEFAULT 第二种1INSERT \\[INTO\\] tbl\\_name SET col\\_name=&#123;expr | DEFAULT&#125;,... 与第一种方式的区别在于，此方法可以使用子查询(SubQuery)，但是此方法只能插入一条记录INSERT users SET username=’Ben’,password=’456’; =&gt; 将这两条数据列插入users，其他数据列为默认值INSERT test(username) SELECT username FROM users WHERE age&gt;=30; =&gt; 将 users 数据表中的 age &gt;= 30 的记录中的 username 数据列插入到 test 的 username 数据列中 第三种1INSERT \\[INTO\\] tbl\\_name \\[(col\\_name,...)\\] SELECT ... 此方法可以将查询结果插入到指定数据表 更新记录（单表更新）1UPDATE \\[LOW\\_PRIORITY\\] \\[IGNORE\\] table\\_reference SET col\\_name1=&#123;expr1 | DEFAULT&#125; \\[,col\\_name2=&#123;expr2 | DEFAULT&#125;\\] ... \\[WHERE where_condition\\] UPDATE users SET age=age-id,sex=0 WHERE id%2=0; =&gt; 将 id 为偶数的记录的 age 设置为 age-id，sex 设置为 0 删除记录（单表删除）1DELETE FROM tbl\\_name \\[WHERE where\\_condition\\] 查找记录查找记录占据了 MySQL 语句的 80% 频率 1SELECT select\\_expr \\[,select\\_expr ...\\] \\[ FROM table\\_references \\[WHERE where\\_condition\\] \\[GROUP BY &#123;col\\_name | position&#125; \\[ASC | DESC\\],...\\] \\[HAVING where\\_condition\\] \\[ORDER BY &#123;col\\_name | expr | position&#125; \\[ASC | DESC\\],...\\] \\[LIMIT &#123;\\[offset,\\] row\\_count | row_count OFFSET offset&#125;\\] \\] select_expr查询表达式 每一个表达式表示想要的一列，必须有至少一个 多个列之间以英文逗号分隔 星号()表示所有列；tbl_name. 可以表示命名表的所有列 查询表达式可以使用 [AS] alias_name 为其赋予别名 1SELECT username AS uname FROM users; 别名可用于 GROUP BY,ORDRE BY 或 HAVING 子句 WHERE条件表达式 对记录进行过滤，如果没有指定WHERE子句，则显示所有记录 在 WHERE 表达式中，可以使用 MySQL 支持的函数或运算符 GROUP BY查询结果分组 1\\[GROUP BY &#123;col_name | position&#125; \\[ASC | DESC\\], ...\\] 既可以指定列名，也可以指定列的位置 ASC 为升序（默认），DESC 为降序 HAVING分组条件 1\\[HAVING where_condition\\] ORDER BY对查询结果进行排序 1\\[ORDER BY &#123;col_name | expr | position&#125; \\[ASC | DESC\\],...\\] 可以指定多个数据列进行排序，当第一个数据列的值相同时，按照第二个数据列进行排序，以此类推…… LIMIT限制查询结果返回的数量 1\\[LIMIT &#123;\\[offset,\\] row\\_count | row\\_count OFFSET offset&#125;\\] SELECT * FROM users LIMIT 3,2; =&gt; 从索引值为 3（第四条记录）的记录开始返回两条记录 子查询子查询(Subquery)是指出现在其他 SQL 语句内的 SELECT 子句SELECT FROM t1 WHERE col1 = (SELECT col2 FROM t2); =&gt; 其中SELECT FROM t1 称为 Outer Query/Outer Statement,SELECT col2 FROM t2 称为 SubQuery 子查询指嵌套在查询内部，且必须始终出现在圆括号内 子查询可以包含多个关键字或条件，如 DISTINCT、GROUP BY、ORDER BY、LIMIT 函数等 子查询的外层查询可以是：SELECT，INSERT，UPDATE，SET 或 DO 子查询返回值子查询可以返回标量、一行、一列或子查询 使用比较运算法的子查询=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt; 语法结构1operand comparison_operator subquery 用 ANY、SOME 或 ALL 修饰的比较运算符 operand comparison_operator ANY (subquery) operand comparison_operator SOME (subquery) operand comparison_operator ALL (subquery) 运算符和关键字相结合之后的结果类型： 使用 [NOT] IN 的子查询语法结构1operand comparison_operator \\[NOT\\] IN (subquery) =ANY 运算符与 IN 等效 !=ALL 或 &lt;&gt;ALL 运算符与 NOT IN 等效 使用 [NOT] EXISTS 的子查询如果子查询返回任何行，EXISTS 将返回 TRUE，否则为 FALSE 多表操作多表更新1UPDATE table\\_references SET col\\_name1 = &#123;expr1 | DEFAULT&#125; \\[,col\\_name2= &#123;expr2 | DEFAULT&#125;\\] ...\\[WHERE where\\_condition\\] CREATE…SELECT创建数据表同时将查询结果写入到数据表 1CREATE TABLE \\[IF NOT EXISTS\\] tbl\\_name \\[(create\\_definition,...)\\] select_statement CREATE TABLE tdb_goods_brands(brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name; =&gt; 创建表 tdb_goods_brands 的同时将 tdb_goods 中的 brand_name 数据列的值赋给新表 tdb_goods_brands 中的 brand_name 数据列 表的连接1table\\_reference &#123;\\[INNER | CROSS\\] JOIN | &#123;LEFT | RIGHT&#125; \\[OUTER\\] JOIN&#125; table\\_reference ON conditional_expr table_reference：连接的两张表的名字conditional_expr：连接条件，使用 ON 关键字来设定连接条件，也可以使用 WHERE 来代替：通常使用 ON 关键字来设定连接条件，使用 WHERE 关键字进行结果集记录的过滤 连接类型 INNER JOIN，内连接，在 MySQL 中，JOIN，CROSS JOIN 和 INNER JOIN 是等价的 LEFT [OUTER] JOIN，左外连接 RIGHT [OUTER] JOIN，右外连接 UPDATE tdb_goods AS g INNER JOIN tdb_goods_brands AS b ON g.brand_name=b.brand_name SET g.brand_name=b.brand_id; =&gt; 按照 tdb_goods_brands (设置别名为 b)表更新 tdb_goods (设置别名为 g)表，连接条件为表 g 的brand_name 和表 b 的 brand_name 字段值相等，更新操作为将 g 中的 brand_name 更改为 b 中的 brand_id 内连接仅显示左表及右表符合连接条件的记录（交集、公共部分） 左（右）外连接显示左（右）表的全部记录及右（左）表符合连接条件的记录 A LEFT JOIN B join_condition 如果数据表 A 的某条记录符合 WHERE 条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行 多表删除1DELETE tbl\\_name\\[.*\\] \\[,tbl\\_name\\[.*\\]\\] ... FROM table\\_references \\[WHERE where\\_condition\\] 系统内置函数字符函数/daizhengli/[table id=26 /] CONCAT()SELECT CONCAT(first_name,last_name) AS fullname FROM test; =&gt; 将数据表 test 中的 first_name 和 last_name 中的数据连接到一起进行输出，并命名为 fullname FORMAT()SELECT FORMAT(12560.75,2); =&gt; 转换成 12,560.75（千分位）SELECT FORMAT(12560.75,1); =&gt; 转换成 12,560.8（四舍五入）SELECT FORMAT(12560.75,0); =&gt; 转换成 12,561（取整） TRIM()除了删除首尾空格，还可以删除指定其他字符 SELECT TRIM(LEADING ‘?’ FROM ‘??MySQL???’); =&gt; MySQL???，LEADING 关键字代表前导，所以这句话的含义是删除字符串前面的’?’字符；将 LEADING 换为 TRAILING 表示去掉尾部相应字符，换为 BOTH 表示去掉首尾相应字符 [NOT] LIKESELECT FROM test WHERE first_name LIKE ‘%o%’; => tom%，%相当于，所以 LIKE 有点类似于正则匹配 数值运算符与函数/daizhengli/[table id=27 /] TRUNCATE()数字截取，不会进行运算，TRUNCATE(125.89,0); => 125，TRUNCATE(125.89,-1); => 120 比较运算符与函数/daizhengli/[table id=28 /] 日期时间函数/daizhengli/[table id=29 /] DATE_ADD()DATE_ADD(‘2014-3-12’,INTERVAL 3 \bWEEK); =&gt; 2014-04-02DATE_ADD(‘2014-3-12’,INTERVAL -365 DAY); =&gt; 2013-3-12 DATEDIFF()DATEDIFF(‘2013-3-12’,’2014-3-12’); =&gt;-365 DATE_FORMAT()DATE_FORMAT(‘2014-3-2’,’%m/%d/%Y’); =&gt;03/02/2014 信息函数/daizhengli/[table id=30 /] LAST_INSERT_ID()当使用该函数时，当前数据表中必须存在一个自增的字段，字段名可以不为 id，当同时写入多条记录时，只返回插入的第一条记录的 ID 值 聚合函数/daizhengli/[table id=31 /] AVG()SELECT AVG(age) FROM test; =&gt; 返回 test 数据表中的 age 平均值 自定义函数用户自定义函数（user-defined function,UDF）是一种对 MySQL 扩展的途径，其用法与内置函数相同 必要条件 参数（理论上不超过 1024 个参数） 返回值 函数可以返回任意类型的值，同样可以接收这些类型的参数 创建自定义函数1CREATE FUNCTION function\\_name RETURNS &#123;STRING | INTERGER | REAL | DECIMAL&#125; routine\\_body CREATE FUNCTION f1() RETURNS VARCHAR(30) RETURN DATE_FORMAT(NOW(),’%Y年%m月%d日 %H点:%i分:%s秒’); =&gt; 不带有参数的函数，返回格式为 ‘2017年05月09日 21点:26分:15秒’ 关于函数体 函数体由合法的 SQL 语句构成 函数体可以是简单的 SELECT 或 INSERT 语句 函数体如果为复合结构，则使用 BEGIN…END 语句 复合结构可以包含声明，循环，控制结构 删除函数1DROP FUNCTION \\[IF EXISTS\\] function_name MySQL命令执行过程 存储过程存储过程是 SQL 语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理 存储过程的优点 增强 SQL 语句的功能和灵活性 实现较快的执行速度 减少网络流量 创建存储过程1CREATE \\[DEFINER = &#123;user | CURRENT\\_USER&#125;\\] PROCEDURE sp\\_name (\\[proc\\_parameter\\[,...\\]\\]) \\[characteristic ...\\] routine\\_body 和创建自定义函数类似，最大的不同就是参数部分不同 1proc\\_parameter:\\[IN | OUT | INOUT\\] param\\_name type IN -&gt; 表示该参数的值必须在调用存储过程时指定OUT -&gt; 表示该参数的值可以被存储过程改变，并且可以返回INOUT -&gt; 表示该参数的调用时指定，并且可以被改变和返回 过程体 过程体由合法的 SQL 语句构成 过程体可以是任意 SQL 语句 过程体如果为复合结构则使用 BEGIN…END 语句 复合结构可以包含声明，循环，控制结构 调用存储过程 CALL sp_name([parameter[,…]]) CALL sp_name[()] 修改存储过程1ALTER PROCEDURE sp_name \\[characteristic ...\\] COMMENT 'string' | &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125; 删除存储过程1DROP PROCEDURE \\[IF EXISTS\\] sp_name 实例CREATE PROCEDURE sp1() SELECTION VERSION(); -&gt; 创建存储体CALL sp1; -&gt; 调用存储体","categories":[{"name":"慕课网","slug":"慕课网","permalink":"http://merrier.wang/categories/慕课网/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://merrier.wang/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://merrier.wang/tags/数据库/"}]},{"title":"JS宽高的理解和应用","slug":"JS宽高的理解和应用JS宽高的理解和应用","date":"2017-05-01T14:49:51.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170501/understanding-and-application-of-JS-width-and-height.html","link":"","permalink":"http://merrier.wang/20170501/understanding-and-application-of-JS-width-and-height.html","excerpt":"","text":"window 和 documentdocument 是 window 对象的一部分：document.body -&gt; window.document.body，浏览器的 HTML 文档称为 document 对象window.location === document.location：window 对象的 location 属性引用的是 location 对象，表示该窗口中当前显示文档的 URL，document 对象的 location 属性也是引用了 location 对象 window.screenwindow.screen 包含有关用户屏幕的信息，它包括： window.screen.width window.screen.height window.screen.availHeight window.screen.availWidth window.screenTop window.screenLeft 与 window 相关的宽高 window.innerWidth 内部的宽度 window.innerHeight 内部的高度 window.outWidth 外部的宽度 window.outHeight 外部的高度 与 document 相关的宽高与 client 相关的宽高 document.body.clientWidth 元素宽度（可视内容区+内边距） document.body.clientHeight 元素高度（可视内容区+内边距） 该属性指的是元素的可视部分宽度和高度，即 padding+content 如果没有滚动条，即为元素设定的宽度和高度 123456789body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; 12console.log(document.body.clientWidth); // 350+padding(80) = 430console.log(document.body.clientHeight); // 500 + padding(80) = 580 如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高 1234567#exp2 &#123; width:200px; height:200px; background:red; border:1px solid #000; overflow:auto;&#125; 123var test = document.getElementById(\"exp2\");console.log(test.clientHeight); // 200console.log(test.clientWidth); // document.body.clientLeft document.body.clientTop 这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是 0 123456789body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; 12console.log(document.body.clientLeft); // 20console.log(document.body.clientTop); // 20 小结 无 padding 无滚动 ：clientWidth = 盒子的 width 有 padding 无滚动 ：clientWidth = 盒子的 width + 盒子的 padding * 2 有 padding 有滚动 ：clientWidth = 盒子和 width + 盒子的 padding * 2 - 滚动轴宽度 clientTop = border-top clientLeft = border-left 与 offset 相关的宽高 document.body.offsetWidth（元素的border + padding + content的宽度） document.body.offsetHeight（元素的border + padding + content的高度） 该属性和其内部的内容是否超出元素大小无关，只和本来设定的 border 以及 width 和 height 有关 123456789body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; 12console.log(document.body.offsetWidth); // 470 = padding\\*2 + 350 + border\\*2console.log(document.body.offsetHeight); // 620 = padding\\*2 + 500 + border\\*2 document.offsetLeft document.offsetTop 了解这两个属性我们必须先了解它，什么是 offsetParent 如果当前元素的父级元素没有进行 CSS 定位（position 为 absolute 或 relative）,offsetParent 为 body. 假如当前元素的父级元素中有 CSS 定位，offsetParent 取最近的那个父级元素 offsetLeft 的兼容性问题 在 IE6/7 中 offsetLeft = offsetParent 的 padding-left + 当前元素的 margin-left 在 IE8/9/10 以及 chrome 中 offsetLeft = offsetParent 的 margin-left + offsetParent 的 border 宽度 + offsetParent 的 padding-left + 当前元素的 margin-left 在 FireFox 中 offsetLeft = offsetParent 的 margin-left + 当前元素的 margin-left + offsetParent 的padding-left 123456789101112131415161718body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; #exp &#123; width:400px; height:200px; padding:20px; margin:10px; background:red; border:20px solid #000; overflow:auto;&#125; 在 IE8 / 9 / 10 以及 chrome 中： div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 + margin10 + border20 = 80 div.offsetTop = 本身的 margin10 + 父级元素的 padding40 + margin10 + border20 = 80 在 FireFox：（相比 chrome 中少了 border） div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 + margin10 = 60 div.offsetTop = 本身的 margin10 + 父级元素的 padding40 + margin10 = 60 在 IE6/7 中：（相比在 FireFox，不但少了 border 还少了父级元素的 margin） div.offsetLeft = 本身的 margin10 + 父级元素的 padding40 = 50 div.offsetTop = 本身的 margin10 + 父级元素的 padding40 = 50 小结 无 padding 无滚动无 border offsetWidth = clientWidth = 盒子的宽度 有 padding 无滚动有 border offsetWidth = 盒子的宽度 + 盒子 padding 2 + 盒子边框 2 = clientWidth + 边框宽度 * 2 有 padding 有滚动，且滚动是显示的，有 border offsetWidth = 盒子宽度 + 盒子 padding 2 + 盒子边框 2 = clientWidth + 滚动轴宽度 + 边框宽度 * 2 与 scroll 相关的宽高 document.body.scrollWidth document.body.scrollHeight document.body 的 scrollWidth 和 scrollHeight 与 div 的 scrollWidth 和 scrollHeight 是有区别的 123456789body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; 12document.body.scrollHeight; // document.body.scrollWidth; // 当给定宽高小于浏览器窗口的宽高 scrollWidth = 通常是浏览器窗口的宽度 scrollHeight = 通常是浏览器窗口的高度 当给定宽高大于浏览器窗口的宽高，且内容小于给定宽高的时候 scrollWidth = 给定宽度 + 其所有的 padding + margin + border scrollHeight = 给定高度 + 其所有的 padding + margin + border 当给定宽高大于浏览器窗口宽高，且内容大于给定宽高 scrollWidth = 内容宽度 + 其所有的 padding + margin + border scrollHeight = 内容高度 + 其所有的 padding + margin + border 在某 div 中的 scrollWidth 和 scrollHeight无滚动轴时： scrollWidth = clientWidth = 盒子宽度 + 盒子 padding * 2 有滚动轴时： scrollWidth = 实际内容的宽度 + padding * 2 scrollHeight = 实际内容的高度 + padding * 2 document.body.scrollLeft document.body.scrollTop 与前面不同的是，这对属性是可读写的，指的是当元素其中的超出其宽高的时候，元素被卷起来的高度和宽度 123456789#exp &#123; width:400px; height:200px; padding:20px; margin:10px; background:red; border:20px solid #000; overflow-y:scroll;&#125; 123456var mydiv = document.getElementById(\"exp\");mydiv.scrollTop ; // 默认情况下是0 mydiv.scrollLeft ; // 默认情况下是0 // 可以改写它mydiv.scrollTop = 20;console.log(mydiv.scrollTop) obj.style.width 和 obj.style.height对于一个 DOM 元素，它的 style 属性返回的是一个对象，这个对象的任意一个属性是可读写的，style.width 等于 css 属性中的宽度。style.height 等于 css 属性中的高度 documentElement 和 body 的关系是父子级的关系 123console.log(document); //documentconsole.log(document.documentElement); //htmlconsole.log(document.body); //body 兼容问题推荐使用，获取浏览器窗口可视区域大小： 12document.body.clientWidth || document.documentElement.clientWidth;document.body.clientHeight || document.documentElement.clientHeight; Event 对象的 5 种坐标 clientX 和 clientY：相对于浏览器（可视区左上角0,0）的坐标 screenX 和 screenY：相对于设备屏幕左上角（0,0）的坐标 offsetX 和 offsetY：相对于事件源左上角（0,0）的坐标 pageX 和 pageY：相对于整个网页左上角（0,0）的坐标 X 和 Y：本来是 IE 属性，相对于用CSS动态定位的最内层包容元素 JS各种宽高的应用 可视区域加载 判断网页滚动到顶部或者底部 DIV滚动到底部时加载剩余内容 计算滚动轴的宽高 JS中的宽高属性总结 参考文章 JavaScript及jQuery中的各种宽高属性图解","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"}]},{"title":"读书笔记系列（7）——JavaScript半知半解","slug":"读书笔记系列（7）——JavaScript半知半解","date":"2017-04-25T15:33:09.000Z","updated":"2019-01-17T13:21:55.962Z","comments":true,"path":"20170425/javaScript-semi-knowledgeable-and-semi-knowledgeable.html","link":"","permalink":"http://merrier.wang/20170425/javaScript-semi-knowledgeable-and-semi-knowledgeable.html","excerpt":"","text":"这本书是我无意中看到的一本电子版书籍，但是第一章就吸引到了我，然后就对作者展开了深入“挖掘”，通过作者的个人博客发现作者是一个很厉害的技术开发人员，不管是前端还是后台都有所涉猎，所以推荐大家去他的个人博客逛逛，同时推荐他的两本书籍：《JavaScript半知半解》和《Web实战》，一定会有所收获 1. 完整的 JavaScript完整的 JavaScript 实现由下列三个不同的部分组成： 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） 2. &lt;script&gt; 元素向 HTML 页面中插入 JavaScript 的主要方法，就是使用 &lt;script&gt; 元素。&lt;script&gt; 中定义了下列 6 个属性： async：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效 charset：可选，表示通过 src 属性指定的代码的字符集，比较少用。 defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。 language：已废弃 src：可选，表示包含要执行代码的外部文件 type：可选，表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。在 HTML5 中，默认是 text/javascript，所以不需要设置。 3. 在使用 &lt;script&gt; 嵌入 JavaScript 代码时，切记不要在代码中的任何地方出现 &lt;/script&gt;执行下面的代码时，会产生一个错误： 12345&lt;script&gt;function loadScript()&#123; alert('&lt;/script&gt;');&#125;&lt;/script&gt; 4. JavaScript 代码的执行顺序只要不存在 defer 和 async 属性，JavaScript 代码就会从上至下依次解析。带有 src 属性的 &lt;script&gt; 元素不应该在其 &lt;script&gt; 和 &lt;/script&gt; 标签之间再包含额外的 JavaScript 代码，嵌入代码会被忽略。只要不存在 defer 和 async 属性，浏览器都会按照 &lt;script&gt; 出现的先后顺序对它们依次进行解析。 一般将全部 JavaScript 引用放在 &lt;body&gt; 元素中页面的内容后面。 5. 延迟脚本当给 &lt;script&gt; 元素添加了 defer 属性时，src 指向的外部文件会立即下载，但包含的脚本会延迟到浏览器遇到 &lt;/html&gt; 标签（整个页面解析完毕）后再执行（按添加顺序执行），会先于 DOMContentLoaded 事件执行。 12&lt;script defer=\"defer\" src=\"example.js\"&gt;&lt;/script&gt;&lt;script async src=\"example2.js\"&gt;&lt;/script&gt; 会先执行 example.js，然后执行 example2.js。 注意：defer 只适合外部脚本文件。 6. 异步脚本async 与 defer 属性类似，都用于改变处理脚本的行为，适用于外部脚本文件，并告诉浏览器立即下载，但标记为 async 的脚本并不保证按照指定它们的先后顺序执行。 12&lt;script async src=\"example.js\"&gt;&lt;/script&gt;&lt;script async src=\"example2.js\"&gt;&lt;/script&gt; 两个执行顺序不定。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。 注意：异步脚本不要在加载期间修改 DOM。 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。 7. 元素当浏览器不支持 JavaScript 或被禁用时，显示里面的内容。 123&lt;noscript&gt; 本页面需要浏览器支持（启用）JavaScript&lt;/noscript&gt; 8. 关键字和保留字ECMA-262 描述了一组具有特定用途的关键字，这些关键字可用于控制语句的开始或结束，或者用于执行特定操作等，不能用作标识符。 break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try ECMA-262 还描述了一组不能用作标识符的保留字： abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public 如果使用关键字作标识符，会导致 “Identifier Expected” 错误。 有些时候，我们不得不用到保留字货关键字的，比如 CSS 样式中的 float，这时就需要这样： 1style.cssFloat 9. 隐式全局变量在下面的代码中，由于从右至左的操作符优先级，所以表达式 “b=0” 是先执行的，而此时b未经过声明，所以它会成为全局变量。 123456function test() &#123; var a = b = 0;&#125;test();console.log(b); // 0console.log(a); // ReferenceError: a is not defined 关于全局变量： 使用 var 创建的全局变量不能删除。 不是 var 创建的隐含全局变量可以使用 delete 删除（因为它并不是真正的变量，而是全局对象 window 的属性） 12345678function test() &#123; var a = b = 0; delete a; delete b; console.log(a); // 0 console.log(b); // ReferenceError: b is not defined&#125;test(); 10. 变量提升变量提升是指所有变量的声明语句，都会被提升到代码的头部。 在函数内也一样，函数中的所有变量声明会在函数执行时被“提升”至函数体顶端： 1234567console.log(a); // undefinedvar a = 1;function test()&#123; console.log(a); // undefined var a = 2;&#125;test(); 结果是不是有点出乎你的意料。其实 JavaScript 的执行环境分为声明阶段和执行阶段，因此对于上面的代码，JavaScript 会这样解释代码： 123456789var a;console.log(a); // undefineda = 1;function test()&#123; var a; console.log(a); // undefined a = 2;&#125;test(); 11. typeof 操作符typeof操作符用来检测给定变量的数据类型，可能的返回值： “undefined” –&gt; 这个值未定义 “boolean” –&gt; 这个值是布尔值 “string” –&gt; 这个值是字符串 “number” –&gt; 这个值是数值 “object” –&gt; 这个值是对象或 null “function” –&gt; 这个值是函数 12. undefined 和 null 类型Undefined 类型只有一个值，即特殊的 undefined；Null 类型也是只有一个值的数据类型，这个特殊值就是 null；null 和 undefined 没有属性，甚至连 toString() 这种标准方法都没有；undefined 其实是派生自 null 值： 1console.log(null == undefined); // true 13. Boolean()要将一个值转换为其对应的 Boolean 值，可以使用转型函数 Boolean()； 12var name = 'tg';console.log(Boolean(name); // true 可以对任何类型的值调用 Boolean 函数，而且总会返回一个 Boolean 值（true 或 false）转换规则： 对于 true 或 false，返回原值（true 或 false） 对于 String 类型的值，任何非空字符串返回 true，空字符串（””）返回 false 对于 Number 类型的值，任何非零数字值（包括无穷大），返回 true；0 和 NaN 返回 false 对于 Object 类型的值，任何对象返回 true，null 返回 false 对于 Undefined 类型，undefined 返回 false（只有一个值） 14. 浮点数值保存浮点数值需要的内存空间是保存整数值的两倍。 默认情况下，ECMAScript 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示的数值。 浮点数的最高精度是 17 位小数（所以浮点数的比较比较麻烦）。 10.1 + 0.2 = 0.3000000000000004; // 不是等于0.3 15. 数值范围ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE（最小值）中，这个值是 5e-324；能够表示的最大数值保存在 Number.MAX_VALUE（最大值）中，这个值是 1.7976931348623157e+308 注意：Infinity 是不能参与计算的数值。用 isFinite() 来判断这个值是否无穷，该函数接受一个参数。如果参数位于最小与最大数值之间，返回 true。 12console.log(isFinite(1)); //trueconsole.log(isFinite(Infinity)); // false 16. NaNNaN（Not a Number）表示非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 注意点： 任何涉及 NaN 的操作都会返回 NaN。 NaN 与任何值都不相等，包括 NaN 本身。 任何操作数与 NaN 比较，都会返回 false 1console.log(NaN == NaN); //false 我们可以用 isNaN() 函数来判断是否非数值，该函数接受一个参数，可以是任何类型。isNaN() 在接收到\b这个参数之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，比如：字符串 “10” 或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。 123console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // falseconsole.log(isNaN('blue')); // true 17. Number()Number() 函数的转换规则： 如果是 Boolean 值，true 和 false 将分别转换为 1 和 0 如果是数字值，只是简单的传入和返回 如果是 null 值，返回 0 如果是 undefined，返回 NaN 如果是字符串，遵循下列规则： （ 如果是字符串中只包含数字（包括前面带正负号），则将其转换为十进制数值（前导的零会被忽略） 如果字符串中包含有效的浮点格式，如 1.1，则将其转换为对应的浮点数值 如果字符串中包含有效的十六进制，如 0xf，则将其转换为相同大小的十进制数值 如果字符串是空的，返回0 如果字符串中包含上述格式以外的字符，返回 NaN ） 如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回字符串值 1234console.log(Number('tg')); // NaNconsole.log(Number('')); // 0console.log(Number('0011')); // 11console.log(Number(true)); //1 一元加操作符的操作与 Number 函数规则相同 18. parseInt() 和 parseFloat()parseInt() 会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回 NaN。如果第一个字符是数字字符，就会继续解析，直到解析完所有后续字符或者遇到了一个非数字字符。 parseInt() 也能识别八进制（在 ECMAScript 5 中无法识别，将开头的 0 当作 0）和十六进制，最后会转换成十进制。 12345console.log(parseInt('123tg')); // 123console.log(parseInt('')); // NaNconsole.log(parseInt('070')); // 70console.log(parseInt('0xf')); //15console.log(parseInt(22.5)); // 22 我们还可以为 parseInt() 提供第二个参数，指定需要转换的进制（刷算法题的时候经常用到）： 12345console.log(parseInt('0xAF',16)); // 175console.log(parseInt('AF',16)); // 175console.log(parseInt('AF')); // NaNconsole.log(parseInt('070',8)); // 56console.log(parseInt('70',8)); // 56 parseFloat() 和 parseInt() 类似，也是从第一个字符（位置 0）开始解析每个字符，而且一直解析到字符串末尾，或者解析到遇到一个无效的浮点数字字符为止，换句话说，字符串中的第一个小数点是有效的，后面的小数点是无效的，它还会忽略前导的零，只会解析十进制值。 12345console.log(parseFloat('123tg')); // 123console.log(parseFloat('22.12.4')); // 22.12console.log(parseFloat('070')); // 70console.log(parseFloat('0xf')); //0console.log(parseFloat(22.5)); // 22.5 19. Object 类型在 ECMAScript 中，Object 类型是所有对象的基础。Object 的每个实例都具有下列属性和方法： Constructor：保存着用于创建当前对象的函数，比如上面的例子，构造函数就是 Object() hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在（而不是在实例的原型中），参数必须是字符串形式 isPrototypeOf(object)：用于检查传入的对象是否是另一个对象的原型 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚举，参数必须是字符串形式 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应 toString()：返回对象的字符串表 valueOf()：返回对象的字符串、数值或布尔值表示，通常和 toString() 返回的值相同 20. 递增和递减递减和递增操作符会遵循下列规则： 当操作数是一个包含有效数字字符的字符串，系统会将其转换为数字值，再执行递减或递增。 当操作数是一个不包含有效数字字符的字符串，系统将变量的值设置为 NaN 当操作数是布尔值，会将其转为数值（true 转为 1，false 转为 0）再操作。 当操作数是浮点数值，直接执行递减或递增 当操作数是对象，先调用对象的 valueOf() 方法取得一个可供操作的值，然后再遵循上面的三条规则。如果结果是 NaN，则在调用 toString() 方法后再遵循上面的规则转换。 1234567891011121314var a = '2';var b = 'a';var c = false;var d = 1.1;var o = &#123; valueOf: function() &#123; return -1; &#125;&#125;;a++; // 3b++; // NaNc--; // -1d--; // 0.10000000000000009 （浮点数操作结果，类似0.1+0.2 != 0.3）o--; -2 21. 按位非（NOT）位运算符并不直接操作 64 位的值，而是先将 64 位的值转换为 32 位，然后执行操作，最后将结果转换回 64 位。按位非（否运算）就是一个数与自身的取反值相加，等于 -1。 ~3 + 3 = -1 =&gt; -1 - 3 = -4 == ~3 22. 位运算符位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。 ##23. 逻辑与（&amp;&amp;） 逻辑与（&amp;&amp;）有两个操作数，如果是布尔值，只有两个都是 true 时，才会返回 true，否则返回 false；逻辑与操作属于短路操作，也就是说如果第一个操作数能够决定结果（等于 false 时），就不会再对第二个操作数求值，如果不是布尔值，它遵循下面的规则： 如果第一个操作数是对象，则返回第二个操作数 如果第二个操作数是对象，则只有在第一个操作数的求值为 true 时才会返回第二个操作数 如果有一个操作数是 null，则返回 null 如果有一个操作数是 NaN，则返回 NaN 如果有一个操作数是 undefined，则返回 undefined 逻辑与操作符也就是先将第一个操作数转换为 Boolean 类型判断是 true 或 false，再根据结果决定是否执行第二个操作数 120 &amp;&amp; 'tg' ; // 0&#123;&#125; &amp;&amp; 'tg'; // \"tg\" 24. 乘法运算符乘法运算符(*)，用于计算两个数值的乘积。 处理特殊值时，乘法运算符会遵循下列规则： 如果操作数都是数值，但乘积超过了 ECMAScript 数值范围，则返回 Infinity 或 -Infinity 如果有一个操作数是 NaN，结果是 NaN 如果是 Infinity 乘以 0，结果是 NaN 如果是 Infinity 与非 0 数值相乘，结果是 Infinity 或 -Infinity，取决于非0数值的符号 如果是 Infinity 与 Infinity 相乘，结果是 Infinity 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则 1234console.log(1 * NaN); // NaNconsole.log( Infinity * 2); // Infinityconsole.log(Infinity * 0); // NaNconsole.log(Infinity * Infinity); // Infinity 24. 除法运算符除法运算符（/），执行第二个操作数除第一个操作数计算。 处理特殊值，规则如下： 如果操作数都是数值，但商超过了 ECMAScript 的表示范围，则返回 Infinity 或 -Infinity 如果有一个操作数是 NaN，结果是 NaN 如果是 Infinity 被 Infinity 除，结果是 NaN 如果是零被零除，结果是 NaN 如果是非零的有限数被零除，结果是 Infinity 或 -Infinity，取决于有符号的操作数 如果是 Infinity 被任何非零数值除，结果是 Infinity 或 -Infinity 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。 123456console.log(NaN / 1); // NaNconsole.log(0 / 0); // NaNconsole.log(1 / 0); // Infinityconsole.log(2 / Infinity); // 0console.log(Infinity / Infinity); // NaNconsole.log(Infinity / 2); // Infinity 25. 求模求模（余数）运算符（%） 处理特殊值，规则如下： 如果被除数是无穷大值而除数是有限大的数值，结果是 NaN 如果被除数是有限大的数值而除数是零，结果是 NaN 如果是 Infinity 被 Infinity 除，结果是 NaN 如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数 如果被除数是零，结果是零 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后遵循上面的规则。 1console.log(5 % 3); // 2 26. 减法减法运算符（-） 对于特殊值，减法操作会遵循下列规则： 如果有一个操作数是 NaN，结果是 NaN 如果 Infinity 减 Infinity，结果是 NaN 如果是 -Infinity 减 -Infinity，结果是 NaN 如果是 Infinity 减 -Infinity，结果是 Infinity 如果是 -Infinity 减 Infinity，结果是 -Infinity 如果是 +0 减 +0，结果是 +0 如果是 -0 加 -0，结果是 +0 如果是 +0 减 -0，结果是 -0 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 将其转换为数值，然后遵循上面的规则进行计算。 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值；如果该对象没有 valueOf() 方法，则调用其 toString() 方法将得到的字符串转换为数值，然后遵循上面的规则进行计算。 1235 - true; // 4 （true转换成1）5 - '2' // 35 - null; // 5（null转换成0） 27. 逗号运算符逗号运算符多用于声明多个变量。逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项： 1var num = (1,5,3); // num的值为3 28. 标签语句语句是可以添加标签的，标签是由语句前的标识符和冒号组成： label : statement label 语句定义的标签一般由 break 或 continue 语句引用。加标签的语句一般要与 for 等循环语句配合使用。 123456789var num = 0;tip : for(var i = 0; i &lt; 10; i++)&#123; num += i; console.log(i); // 轮流输出：0、1、2、3、4、5 if(i ==5) &#123; break tip; &#125;&#125;console.log(num); // 15 当执行到 i = 5 时，会跳出循环，也就是 tip 对应的层，然后执行其下方的代码。 29. with 语句with 语句用于临时扩展作用域链，也就是将代码的作用域设置到一个特定的对象中。 123with(object)&#123; statement &#125; 将 object 添加到作用域链的头部，然后执行 statement，最后把作用域链恢复到原生状态。 12345678var o = &#123; name: 'tg', age: 24&#125;;with(o)&#123; console.log('name：' + name); // name：tg console.log('age：' + age); // age：24&#125; with 里面的 name 相当于 o.name。 注意：在严格模式中是禁止使用 with 语句的，因为 with 语句性能非常差，不推荐使用。 30. debugger 语句debugger 语句用来产生一个断点（breakpoint），JavaScript 代码的执行会停止在断点的位置。一般用来调试代码。 31. 对象键名：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。 123var o = &#123; '1a' : 'a' &#125; 上面的代码中，如果键名 ‘1a’ 不用引号引起来，就会报错。注意：为了避免这种歧义，JavaScript 规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 32. 创建对象在 JavaScript 中，有三种方法创建对象 对象直接量： var o={}; 关键字new： var o=new Object(); Object.create() 函数： var o=Object.create(null) 提取方法如果对对象中的方法进行提取，则会失去与对象的连接。 1234567891011var obj = &#123; name: 'a', get: function() &#123; console.log(this.name); &#125;&#125;;console.log(obj.get()); // \"a\"var func = obj.get;console.log(func()); // undefined 在上面的例子中，object 对象中有一个方法 get()，用来获取 obj 对象中的 name，而当 get() 方法赋值给一个变量 func，再调用 func() 函数时，此时的 this 是指向 window 的，而非 obj 的。注意：如果在严格模式下，this 会是 undefined。 属性特性 可写（writable attribute）：可设置该属性的值。 可枚举（enumerable attribute）：可通过 for / in 循环返回该属性。 可配置（configurable attribute）：可删除或修改属性。 查看所有属性查看一个对象本身的所有属性，可以使用 Object.keys 方法，返回一个数组。 123456var o = &#123; name : 'a', age : 12&#125;Object.keys(o) // ['name','age'] 删除属性delete 运算符可以删除对象的属性。 12345var o=&#123; name : 'a'&#125;delete o.name //trueo.name //undefined 注意：delete 运算符只能删除自有属性，不能删除继承属性。 删除一个不存在的属性，delete 不报错，而且返回 true。只有一种情况，delete 命令会返回 false，那就是该属性存在，且不得删除。 33. 序列化对象对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 在 JavaScript 中，提供了内置函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。NaN、Infinity 和 -Infinity 序列化的结果是 null 1234567var o = &#123; name : 'a', age : 12, intro : \\[false,null,''\\]&#125;s= JSON.stringify(o) // s &#123;\"name\":\"a\",\"age\":12,\"intro\":[false,null,\"\"]&#125;p=JSON.parse(s) // p是o的深拷贝 注意：JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。 34. 原型每一个 JavaScript 对象（null 除外）都和另一个对象相关联，也可以说，继承另一个对象。另一个对象就是我们熟知的“原型”（prototype），每一个对象都从原型继承属性。只有 null 除外，它没有自己的原型对象。所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。比如：通过 new Object() 创建的对象继承自 Object.prototype；通过 new Array() 创建的对象的原型就是 Array.prototype。没有原型的对象为数不多，Object.prototype 就是其中之一，它不继承任何属性。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。 35. 空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。 12var arr = [,,];arr.length // 2 36. 类数组对象在 JavaScript 中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用 length 属性，但是它们并不是数组，无法使用一些数组的方法。类数组对象有一个特征，就是具有 length 属性。换句话说，只要有 length 属性，就可以认为这个对象类似于数组。但是，对象的 length 属性不是动态值，不会随着成员的变化而变化。典型的类似数组的对象是函数的 arguments 对象，以及大多数 DOM 元素集，还有字符串。 37. 函数表达式采用函数表达式声明函数时，function 命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 123var f = function(x)&#123; console.log(x); &#125; 38. 函数被提前就像变量的“被提前”一样，函数声明语句也会“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。在函数提升中，函数体也会跟着提升（不像变量一样，只会提升变量声明），这也是我们可以引用后面声明的函数的原因。 此外，以表达式定义的函数并没有“被提前”，而是以变量的形式“被提前”。 123f(); var f = function ()&#123;&#125;; // TypeError: f is not a function 变量其实是分为声明，赋值两部分的，上面的代码等同于下面的形式 123var f;f();f = function() &#123;&#125;; 39. 实参对象arguments 类数组中每一个元素的值会与对应的命名参数的值保持同步，这种影响是单向的，也可以这样说，如果是修改 arguments 中的值，会影响到命名参数的值，但是修改命名参数的值，并不会改变 arguments 中对应的值。 1234567function f(x)&#123; console.log(x); // 1 arguments[0] = null; console.log(x); // null&#125;f(1); arguments 并不是真正的数组，它只是类数组对象（有 length 属性且可使用索引来访问子项）。但我们可以借助 Array 类的原型对象的 slice 方法，将其转为真正的数组： 123Array.prototype.slice.call(arguments, 0);// 更简洁的写法[].slice.call(arguments, 0); 40. 函数的属性、方法name 属性name 属性返回紧跟在 function 关键字之后的那个函数名。 12function f()&#123;&#125;f.name // f length 属性函数的 length 属性是只读属性，代表函数形参的数量，也就是在函数定义时给出的形参个数。 12function f(x,y)&#123;&#125;f.length //2 41. 立即调用的函数表达式（IIFE）通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个： 一是不必为函数命名，避免了污染全局变量； 二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 42. Object 对象的静态方法Object.keys() 方法和 Object.getOwnPropertyNames() 方法一般用来遍历对象的属性，它们的参数都是一个对象，返回一个数组，该数组的项都是对象自身的（不是继续原型的）的所有属性名。两者的区别在于， Object.keys() 只返回可枚举的属性，Object.getOwnPropertyNames() 方法还返回不可枚举的属性名。 123var arr = ['a', 'b'];console.log(Object.keys(arr)); // [\"0\", \"1\"]console.log(Object.getOwnPropertyNames(arr)); // [\"0\", \"1\", \"length\"] 43. splice()splice() 用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素，该方法会改变原数组。第一个参数是删除的起始位置，如果是负数，就表示从倒数位置开始删除 第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如只是单纯地插入元素，splice 方法的第二个参数可以设为 0。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。 1234567891011var arr = ['a','b','c','d'];console.log(arr.splice(1,1)); // [\"b\"]console.log(arr); // [\"a\", \"c\", \"d\"]var arr = ['a','b','c','d'];console.log(arr.splice(1,1,'f')); // [\"b\"]console.log(arr); // [\"a\", \"f\", \"c\", \"d\"]var arr = ['a','b','c','d'];console.log(arr.splice(1,0,'h')); // []console.log(arr); // [\"a\", \"h\", \"b\", \"c\", \"d\"] 44. some()、every()some() 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是 true，则整个 some 方法的返回值就是 true，否则 false。 12345var arr = [1,2,3];var bool = arr.some(function(v)&#123; return (v == 3);&#125;);console.log(bool); // true every() 用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是 true，才返回 true，否则 false。 12345678910var arr = [1,2,3];var bool = arr.every(function(v)&#123; return (v == 3);&#125;);console.log(bool); // falsevar bool2 = arr.every(function(v)&#123; return (v &gt; 0);&#125;);console.log(bool2); // true some 和 every 方法还可以接受第二个参数，用来绑定函数中的 this 关键字。 45. 基本包装类型ECMAScript 提供了三个基本包装类型：Boolean、Number、String。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能过调用一些方法来操作这些数据。执行步骤如下： 创建那个类型的一个实例 在实例上调用指定的方法 销毁这个实例 引用类型与基本包装类型的区别在于对象的生存期：使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁，这也是我们不能再运行时为基本类型值添加属性和方法的原因。 123var s = 'tg';s.age =10;console.log(s.age); // undefined 上面代码执行输出的是 undefined，这是音乐第二行创建的 String 对象在执行第三行代码时已经被销毁了，第三行又创建自己的 String 对象，而该对象没有 age 属性。 46. Boolean 类型即使你使用 false 创建一个 Boolean 实例对象，当进行逻辑运算时，它会被转为 true，因为它是一个对象，而所有对象在逻辑运算中都会返回 true。 12345var bool = new Boolean(false);if(bool)&#123; console.log(true);&#125;// true 47. document.referrerdocument.referrer 属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。 注：HTTPS 默认会关闭 referrer，需要通过 meta 来设置，设置方法如下： 1&lt;meta name=\"referrer\" content=\"always\"&gt; 48. 数据集（dataset）属性在 HTML5 文档中，任意以 “data-” 为前缀的小写的属性名字都是合法的。 HTML5 还在 Element 对象上定义了 dataset 属性。该属性指代一个对象，它的各个属性对应于去掉前缀的 data-属性。因此 dataset.x 应该保存 data-x 属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test 属性就变成 dataset.jqueryTest 属性。 1&lt;div id=\"top\" data-tip=\"title\"&gt;&lt;/div&gt; 123var t=document.getElementById('top');t.dataset.tip //titlet.dataset.tip = 'title2' 注意：dataset 属性是元素的 data-属性 的实时、双向接口。设置或删除 dataset 的一个属性就等同于设置或移除对应元素的 data-属性。 49. addEventListener()调用 addEventListener() 并不会影响 onclick 属性的值。 1&lt;button id=\"mybutton\"&gt;点击&lt;/button&gt; 123var v = document.getElementById('mybutton');v.onclick = function() &#123;alert('1');&#125;v.addEventListener('click',function()&#123;alert('2');&#125;,false); 上面的代码中，单击按钮会产生两个 alert() 对话框。 能通过多次调用 addEventListener() 方法为同一个对象注册同一事件类型的多个处理程序函数。 50. 调用顺序文档元素或其他对象可以指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照下面的规则调用所有的事件处理程序： 通过设置对象属性或 HTML 属性注册的处理程序一直优先调用。 使用 addEventListener() 注册的处理程序按照它们的注册顺序调用。 使用 attachEvent() 注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。 51. 进度事件进度事件用来描述一个事件进展的过程。比如 XMLHttpRequest 对象发出的 HTTP 请求的过程，&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt; 加载外部资源的过程。下载和上传都会发生进度事件。进度事件有以下几种： abort 事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。 error 事件：由于错误导致资源无法加载时触发。 load 事件：进度成功结束时触发。 loadstart 事件：进度开始时触发。 loaden d事件：进度停止时触发，发生顺序排在 error 事件 / abort 事件 / load 事件后面。 progress 事件：当操作处于进度之中，由传输的数据块不断触发。 timeout 事件：进度超过限时触发。 52. JSON 语法JSON 对值的类型和格式有严格的规定： 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和 null（不能使用 NaN, Infinity, -Infinity 和 undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 53. 上传文件如果要允许选择多个文件，可设置 file 控件的 multiple 属性。 1&lt;input type=\"file\" multiple/&gt; 54. 同源策略同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 &lt;iframe&gt; 元素或打开其他浏览器窗口的时候，这一策略通常就会发挥作用。所谓“同源”指的是”三个相同“。 协议相同 域名相同 端口相同 从不同 Web 服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用 http:协议 载入的文档和使用 https:协议 载入的文档具有不同的来源，即使它们来自同一个服务器。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 55. 获取表单元素获取表单元素一般有两种方式： 通过 id 来获取，比如获取一个 id 名为 form1 的表单元素： 1document.getElementById('form1'); 通过 docuemnt.forms 获取 name 名为 form1 的表单元素： 1document.forms[\"form1\"] document.forms 可以获取到当前页面中所有的表单元素，我们又可以通过方括号表示法获取某个属性，传入数值索引或 name 值。 56. 重置表单重置表单也有两种方式： 重置按钮12&lt;input type=\"reset\" /&gt;&lt;button type=\"reset\"&gt;&lt;/button&gt; 当点击重置按钮时，会触发 reset 事件： 12form1.onreset = function()&#123;&#125; 通过 reset() 方法1form1.reset(); 与调用 submit() 不同，调用 reset() 方法时也会触发 reset 事件。 57. 离线检测HTML5 定义了一个 navigator.onLine 属性，用来检测设备是在线还是离线，为 true 时表示设备能上网，否则表示设备离线。 检测代码： 12345if (navigator.onLine)&#123; // 正常工作&#125; else &#123; // 设备已离线&#125; 除了 navigator.onLine 属性，HTML5 还为检测网络是否可用提供了两个事件：online 和 offline。 online：当网络从离线变为在线时触发 offline：当网络从在线变为离线时触发 58. 应用缓存HTML5 的应用缓存（application cache），简称：appcache，是专门为开发离线 Web 应用而设计的。 Appcache 就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 123456789101112131415CACHE MANIFESTCACHE:# 需要缓存的列表test.csstest.jpgtest.jsNETWORK:# 不需要缓存的test2.jpgFALLBACK:# 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件 *.html /offline.html2.jpg/3.jpg 注意：manifest 文件的 MIME 类型必须是 “text/cache-manifest”。 描述文件的扩展名以前推荐用 manifest，现在推荐用 appcache 59. localStorage 和 sessionStoragelocalStorage 和 sessionStorage这两个属性都代表同一个 Storage 对象（一个持久化关联数组，数组使用字符串来索引，存储的值都是字符串形式的）。 localStorage通过 localStorage 存储的数据是永久性的，除非Web应用刻意删除存储的数据或用户通过设置浏览器设置来删除，否则数据将一直保留在用户的电脑里，永不过期。localStorage 的作用域是限定在文档源（document origin）级别。 同源的文档间共享同样的 localStorage 数据。 sessionStoragesessionStorage 的作用域同样是限定在文档源中，不过它被限定在窗口中。也就是说，如果同源的文档在不同的浏览器标签页中，那它们互相之间拥有的是各自的 sessionStorage 数据，无法共享。 注意：基于窗口作用域的 sessionStorage 指的窗口只是顶级窗口。如果一个浏览器标签页包含多个 &lt;iframe&gt; 元素，它们包含的文档是同源的，两者之间的 sessionStorage 是可共享的。 60. finally 子句当使用 finally 子句时，其代码无论如何都会执行，也就是说，不管是正常执行还是出错了，finally 子句都会执行。甚至 return 语句，也不会阻止 finally 子句的执行。看下面的例子： 123456789101112131415function test()&#123; try&#123; console.log('a'); return 2; &#125;catch(error)&#123; console.log('b'); &#125;finally&#123; console.log('c'); &#125;&#125;console.log(test()); //结果ac2 从运行结果，我们可以看到，return 语句并没有阻止 finally 子句的执行，而且是在 finally 子句执行后才会返回 return 语句的值。","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"JS中的传值与传址","slug":"JS中的传值与传址","date":"2017-04-25T12:36:04.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170425/passing-value-and-address-in-js.html","link":"","permalink":"http://merrier.wang/20170425/passing-value-and-address-in-js.html","excerpt":"","text":"在 JS 中，有两种不同的方式可以操作数据的值，这两种技术分别叫做传值和传址。 数据值的操作要知道传址跟传址，首先我们先了解下数据值的操作。 复制：可以把它赋值给一个新的变量 传递：可以将他传递给一个函数或者方法 比较：可以与另外一个值比较，判断是否相等 概念介绍传值：在赋值过程中，首先对值进行了一份拷贝，而后将这份拷贝存储到一个变量、对象属性或数组元素中。拷贝的值和原始的值是完全独立、互不影响的。当一份数据通过值传递给一个函数，实际上被传递的不是数据本身，而是数据的一份拷贝。因此，如果函数修改了这个值，影响到的只是数据的那份拷贝，而并不影响数据本身。 传址：在赋值过程中，变量实际上存储的是数据的地址（对数据的引用），而不是原始数据或者是数据的拷贝。如果值通过一个地址发生了改变，这个改变也会通过原始地址表现出来。 参阅对比表/daizhengli/[table id=21 /] 数据类型根据操作数据方式的不同，我们可以把数据类型分为两类：基础类型和引用类型。 基础类型主要有：数字(Number)、布尔类型(Boolean)；其操作方式为传值。 引用类型主要有：对象(Object) —— 数组(Array)、函数(Function)；其操作方式为传址。 数字和布尔类型是基础类型，它们是由很小的，固定数目字节组成，所以可以通过传值来操作；而数组和函数，是对象的特殊类型，也是引用类型。由于对象没有固定大小，所以无法通过传值进行操作。 实例传值（赋值操作）12var a = 1, b = a, a = 2;console.log(\"a=\" + a + \",b=\" + b); a 先是被赋值为 1，接着把 a 的值赋给 b，这时会进行值的拷贝，因此b = 1；然后又把 a 赋值为 2。在没有执行 a = 2 之前，我们试试下列代码： 1console.log(a === b); // 输出为true. 可见它们在内存中是指向同一个位置的。 传值（基础类型）12345678910var a = 1;var b = a; // 将a复制给bfunction add1(x,y) &#123; // 函数修改参数的值 x = x + y; // 虽然这个里面将值进行相加，但是仅仅是值的独立拷贝，进行相加，在函数外面没有影响&#125;add1(a,b); // 数字类型为传值alert(\"a:\" + a + \"n\" + \"b:\" + b); // a为1，b为1 (a == b) ? c = \"true\" : c = \"false\"; alert(c); // c = \"true\" 传址（引用类型）1234567891011121314var a = [\"a\", \"b\", \"c\", \"d\"]; // 定义数组，引用类型var b = a; // 将a复制给bfunction add(x) &#123; // 函数修改参数的值 x[0] = \"tt\";&#125;add(b); // 数组对象为传址 alert(\"a:\" + a[0] + a[1] + a[2] + a[3] + \"n\" + \"b:\" + b[0] + b[1] + b[2] + b[3]); // b对象修改，则a也会修改，传址(a == b) ? q = \"true\" : q = \"false\"; // 判断 a=b ，返回truealert(q);var a = [\"a\", \"b\", \"c\", \"d\"];var b = [\"a\", \"b\", \"c\", \"d\"];(a == b) ? q = \"true\" : q = \"false\"; // 这里定义了两个对象，虽然值一样，但是不是同样的地址，所以为falsealert(q); // 输出\"false\" 函数内的特殊引用按值传递一个参数给函数就是制作该参数的一个独立复本，即一个只存在于该函数内的复本。即使按引用传递对象和数组时，如果直接在函数中用新值覆盖原先的值，在函数外并不反映新值。只有在对象的属性或者数组的元素改变时，在函数外才可以看出 1234567891011var a1 = [1, 2, 3];function add(a, b) &#123; var newa = Array(); newa[0] = a[0] + b; newa[1] = a[1] + b; newa[2] = a[2] + b; a = newa; // 重新覆盖了引用，所以外部是不可见的 alert(a[0]); // 11&#125;add(a1, 10); alert(a1[0]); // 1 字符串类型前面看了这么多类型，一直都没有介绍字符串类型，它不好直接分为基础类型和引用类型，因为字符串\b可以是任意的长度，看上去应该是引用类型，可是他却不是对象，所以也不可作为引用类型；总结一下，字符串是按引用(即地址)复制和传递的，但是是按值来比较的。 请注意，假如有两个 String 对象（用 new String(“something”) 创建的），按引用比较它们，但是，如果其中一个或者两者都是字符串值的话，按值比较它们 /daizhengli/[table id=22 /] 参考文章 JS 基础知识2 传值和传址 图解JS的传值与传址 JS 传值与传址","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/tags/计算机基础/"},{"name":"面试","slug":"面试","permalink":"http://merrier.wang/tags/面试/"}]},{"title":"浏览器中输入url后发生了什么","slug":"浏览器中输入url后发生了什么","date":"2017-04-24T13:18:56.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170424/what-happened-after-url-was-entered-into-the-browser.html","link":"","permalink":"http://merrier.wang/20170424/what-happened-after-url-was-entered-into-the-browser.html","excerpt":"","text":"本文转载自简书-浏览器中输入url后发生了什么，其实这个问题在前端面试中经常遇到，所以网上有很多关于这个问题的文章，但是我感觉这篇文章是表达的最清晰的，感兴趣的童鞋可以点击上面的链接查看原文，不过在本文中，我又补充了一些其他文章中的相关内容，同时加入了一些我自己的理解，争取让初学者更容易看懂 先上一张思维导图： 上面这张图用非常简练的语言总结了浏览器中输入 url 后发生的事情以及顺序，下面按照执行顺序分为六步进行描述： 1. DNS 域名解析 在浏览器 DNS 缓存中搜索 在操作系统 DNS 缓存中搜索 读取系统 hosts 文件，查找其中是否有对应的 ip 向本地配置的首选 DNS 服务器发起域名解析请求 以上四个步骤其实都是 DNS 的解析过程，总结一下就是先看有没有缓存，如果没有就发起DNS域名解析请求，具体过程其实比较复杂，可以查看DNS原理及解析过程进行更深入的了解 2.建立 TCP 连接为了准确地传输数据，TCP 协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有 SYN/ACK(acknowledegment) 标志的数据包以示传达确认信息。最后发送方再回传一个带 ACK 标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP 会再次发送相同的数据包。TCP 是一个端到端的可靠的面向连接的协议，所以 HTTP 基于传输层 TCP 协议不用担心数据的传输的各种问题。当然，TCP 三次握手也是一个可以展开的问题，而且为什么使用三次握手也是大有学问，可以去我的另外一篇文章：前端面试系列（8）——TCP的三次握手与四次分手中寻找答案 3. 发起 HTTP 请求HTTP 的请求方法（method）有以下几种： GET: 获取资源 POST: 传输实体主体 HEAD: 获取报文首部 PUT: 传输文件 DELETE: 删除文件 OPTIONS: 询问支持的方法 TRACE: 追踪路径 其中最常用的就是 GET 和 POST 了，请求报文格式如下所示（HTTP/1.1）： 4. 接受响应结果客户端在发出请求之后，服务器会在接收到请求之后返回客户端响应结果，该结果就是服务器告知客户端的当前状态，下面是状态码的分类，更多关于状态码的详细内容请移步前端面试系列（6）——HTTP请求的状态码： 1**：信息性状态码 2**：成功状态码 3**：重定向状态码 4**：客户端错误状态码 5**：服务器错误状态码 响应报文： 5. 浏览器解析 html浏览器按顺序解析 html 文件，构建 DOM 树，在解析到外部的 css 和 js 文件时，向服务器发起请求下载资源，若是下载 css 文件，则解析器会在下载的同时继续解析后面的 html 来构建 DOM 树，但是在下载 js 文件和执行它时，解析器会停止对 html 的解析。这便出现了 js 阻塞问题。 预加载器：当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的 html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索 HTML 标签中的 URL，无法检测到使用脚本添加的 URL，这些资源要等脚本代码执行时才会获取。（注: 预解析并不改变 Dom 树，它将这个工作留给主解析过程），浏览器解析 css，形成 CSSOM 树，当 DOM 树构建完成后，浏览器引擎通过 DOM 树和 CSSOM 树构造出渲染树（Render 树）。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head 元素和 display 值为 none 的元素） 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 6. 浏览器布局渲染 布局（Layout）：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。 绘制（Paint）：将计算好的每个像素点信息绘制在屏幕上 在页面显示的过程中会多次进行 Reflow 和 Repaint 操作，而 Reflow 的成本比 Repaint 的成本高得多的多。因为 Repaint 只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的 display 属性由 block 改为 none 则需要 Reflow。如何减少 rpaint 和 reflow 也是前端优化需要考虑的问题： 参考文章 浏览器中输入url后发生了什么 浏览器的渲染原理简介 了解html页面的渲染过程 老生常谈-从输入url到页面展示到底发生了什么 异步脚本载入提高页面性能 扩展阅读 浅谈前端页面渲染机制","categories":[{"name":"前端","slug":"frontend","permalink":"http://merrier.wang/categories/frontend/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://merrier.wang/tags/前端/"},{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/tags/HTTP/"}]},{"title":"CSS深入理解之border","slug":"CSS深入理解之border","date":"2017-04-23T14:39:19.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170423/border-of-css-in-depth-understanding.html","link":"","permalink":"http://merrier.wang/20170423/border-of-css-in-depth-understanding.html","excerpt":"","text":"1. 不支持百分比单位的属性 border-width outline box-shadow text-shadow 2. border-width 支持关键字 thin –&gt; 1px medium（默认值）–&gt; 3px thick –&gt; 5px 3. border-style solid：实线 dashed：虚线，但是 IE 和 Chrome / FireFox 的虚线比例不同，IE 会更密一些 dotted：点线，Chrome / FireFox 下点线是方形，IE 下是圆形 double：双线，宽度实现规律为双线宽度永远相等，而中间间隔 ±1 inset：内凹，在 css 里很少用，基本上被淘汰了 groove：沟槽 ridge：山脊 inset、groove、ridge 风格过时 + 兼容性差，所以基本上处于被淘汰的状态 4. 利用 IE7 中的 border-style:dotted 实现圆角效果12345678910.box&#123; width: 150px; height: 150px; overflow: hidden;&#125;.dotted&#123; width: 100%; height: 100%; border: 149px dotted #cd0000;&#125; 5. 利用 border-style:double 实现三道杠123456.three &#123; width:120px; height:20px; border-top:60px double; border-bottom:20px solid;&#125; 6. border-color 与 color当没有指定 border-color 的时候，会使用 color 作为边框色，类似的还有 box-shadow、text-shadow 和 outline，都是默认使用 color 的颜色 7. border 与 background-position 定位background-position 默认相对于左上进行定位，所以如果想相对于右边进行定位的话，其中一个方法就是借助于 border（设置为 100% 默认不计算 border 区域）： 12border-right: 50px solid transparent;background-position: 100% 40px; 8. border-color 的分配123456.triangle&#123; width: 100px; height: 100px; border: 100px solid; border-color: red green blue orange;&#125; 效果展示： 9. border 的应用透明边框优雅增加响应区域大小（复选框）原来视觉区域大小（不含边框）是 16px * 16px，经过使用透明边框，可以使复选框点击区域扩大到 20px * 20px 甚至更大 1234567.checkbox&#123; border: 2px solid transparent; box-shadow: inset 0 1px, inset 1px 0, inset -1px 0, inset 0 -1px; background-color: #fff; background-clip: content-box; color: #d0d0d5;&#125; 实现两栏等高布局利用很长的 border 构造另外一个盒子，然后利用 margin 负值进行定位，但是不支持百分比宽度（margin 和 padding实现支持百分比宽度） html： 12345678&lt;div class=\"box\"&gt; &lt;nav class=\"left\"&gt; &lt;h3&gt;导航1&lt;/h3&gt; &lt;/nav&gt; &lt;section&gt; &lt;div class=\"module\"&gt;模块1&lt;/div&gt; &lt;/section&gt;&lt;/div&gt; css： 12345678.box&#123; border-left: 300px solid #222;&#125;.left&#123; width: 300px; margin-left: -300px; float: left;&#125; 实现效果： 绘制三角形根据上面 border-color 的分配，实现方案为将 border 的其中一个方向的颜色设置为预期颜色，将其余三个方向设置为透明，然后 border-width 就是三角形的大小 123456.triangle&#123; width: 0; height: 0; border: 100px solid; border-color: red transparent transparent transparent;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解系列","slug":"CSS深入理解系列","date":"2017-04-21T13:52:56.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170421/css-in-depth-understanding-series.html","link":"","permalink":"http://merrier.wang/20170421/css-in-depth-understanding-series.html","excerpt":"","text":"此系列的文章是我对张鑫旭的讲解的总结，张鑫旭作为很早入行前端的代表人物，其对 html 以及 css 的理解很深刻，所以他的系列文章“深入理解 CSS”是一个不错的前端基础教材，虽然我将其讲解进行了总结，但是还是希望你有时间能够看一下他的视频，风趣幽默又不失教学性，一定会有所收获。 CSS深入理解之line-height CSS深入理解之margin CSS深入理解之padding CSS深入理解之z-index CSS深入理解之relative CSS深入理解之vertical-align CSS深入理解之absolute CSS深入理解之overflow CSS深入理解之float CSS深入理解之border","categories":[{"name":"系列专栏","slug":"series","permalink":"http://merrier.wang/categories/series/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之float","slug":"CSS深入理解之float","date":"2017-04-21T13:41:31.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170421/float-of-css-in-depth-understanding.html","link":"","permalink":"http://merrier.wang/20170421/float-of-css-in-depth-understanding.html","excerpt":"","text":"1. float 的历史浮动设计的初衷: 实现文字环绕 2. float 感性认知float 具有包裹性和破坏性 具有包裹性的小伙伴: display: inline-block / table-cell / … position: absolute(近亲) / fixed / sticky overflow: hidden / scroll 具有破坏性的小伙伴: (父级元素容器塌陷，高度变为 0) display: none position: absolute(近亲) / fixed / sticky 3. 如何解决浮动让父元素高度塌陷的问题浮动的破坏性只是单纯为了实现文字环绕效果而已关于浮动塌陷：给父元素设置了宽高，那么父元素不会塌陷；如果设置了宽度没有设置高度，会塌陷，宽度值还是设定的值，高度为0；如果没有设置宽高，发生塌陷，宽度为页面宽度，高度为0。 4. 清除浮动底部插入 clear:both12345678910.clearfix:after&#123; content: ''; display: block; height: 0; overflow: hidden; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; 更好的方法： 12345678.clearfix:after&#123; content: ''; display: table; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; 5. BFCBFC：Block Formatting Context，块级格式化上下文，一个独立的块级渲染区域，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关 产生条件：满足其一即可： html 根元素 float 的值不为 none display 的值为 inline-block、table-cell、table-caption position 的值为 absolute 或 fix 约束规则： 生成 BFC 元素的子元素会一个接着一个防止垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的 margin 特性。在 BFC 中相邻的块级元素外边距会折叠，同属一个 BFC 的两个相邻 Box 的 margin 会发生重叠。 生成 BFC 元素的子元素中，每一个子元素左外边距与包含块的左边界接触，即使浮动元素也是如此（除非这个子元素自身也是一个浮动元素）。 BFC 的区域不会与 float 的元素区域重叠。 计算 BFC 高度时，浮动元素也参与计算。 BFC 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。 6. 浮动的优劣浮动的影响 元素 block 块状化(砖头化) 破坏性造成的紧密排列特性(去空格化，和 inline-block 不同) 浮动存在的问题: 容错性比较糟糕，容易出问题 全部用固定尺寸，代码不易重用 与 IE7 及以下版本不兼容 7.两侧自适应布局123456789.left&#123; // 左侧 float: left;&#125;.right&#123; // 右侧 width: max-width; *width: auto; display: table-cell; *display: inline-block&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之overflow","slug":"CSS深入理解之overflow","date":"2017-04-21T13:29:13.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170421/overflow-of-css.html","link":"","permalink":"http://merrier.wang/20170421/overflow-of-css.html","excerpt":"","text":"1. overflow 起作用的前提 非 display:inline水 平 对应方位的尺寸限制 .width / height / max-width / max-height / absolute 拉伸 对于单元格 td 等，还需要 table 为 table-layout:fixed 状态才行 Tips: 如果 overflow-x，overflow-y 相同，则等同于 overflow；如果不同，其中一个为 visible，另外一个为 auto / hidden / scroll，则 visible 会重置为 auto 2. JS 与滚动高度无论什么浏览器，默认滚动条均来自 &lt;html&gt;，而不是 &lt;body&gt; 标签.所以，如果想要去除页面默认滚动条，只需要 html{ overflow: hidden }，而没必要把 &lt;body&gt; 也拉下水。 关于scrollTopChrome 浏览器: document.body.scrollTop其他浏览器: document.documentElement.scrollTop 目前，两者不会同时存在，建议使用: 1var st = document.body.scrollTop || document.documentElement.scrollTop 3. 水平居中跳动问题的修复由于滚动条会使网页可用内容宽度变小，所以水平居中的页面出现滚动条时会有跳动的问题，解决方案： html{ overflow-y: scroll } // 滚动栏一直存在 container{ padding-left: calc(100vw - 100%) } // 100vw-浏览器宽度;100%-可用内容宽度 4. iOS 原生滚动回调效果:1-webkit-overflow-scrolling:touch; 会使滚动出现缓冲效果 5. overflow 与块状格式上下文两栏自适应布局123456.cell&#123; display: table-cell; width: 2000px; // IE8+ BFC特性 display: inline-block; width: auto; // IE7- 伪BFC特性&#125; 只适用于 block 属性的元素，之间的空隙推荐使用浮动元素的 margin 来实现 父元素设置 overflow: scroll; overflow: auto; overflow:hidden，可以解决父元素因内部浮动塌陷问题。更多请参见：overflow 与布局上下文（BFC） 6. overflow 与 absolute 绝对定位overflow: hidden 在子元素绝对定位失效，可以理解成，父元素与子元素所在的层级不一样了，子元素完全脱离文档流了，因而无法被剪裁。而给父元素加上除 static 以外的定位属性（使之成为包含块），只不过是提高了父元素的层级，从而约束绝对定位的表现。使之可以被溢出隐藏 如何避免 overflow 失效? overflow 元素自身为包含块; overflow 元素的子元素为包含块; 任意合法 transform 声明当作包含块; overflow 元素自身 transform: IE9+/Firefox √ Chrome/Safari(win)/Opera × overflow 子元素 transform IE9+/Firefox √ Chrome/Safari(win)/Opera √ 动态渲染异常: Chrome 包含块重定位 / Opera 同，但点击重绘自修正 / Safari 非定位 overflow 元素左上角 overflow 失效妙用右侧图片会紧挨左侧内容，并实现自适应跟随，&amp;nbsp 可以辅助将图片设置在右方；将 &amp;nbsp 的高度设置为 0 以及 overflow: hidden 可以让 &amp;nbsp 不影响布局，但图片是绝对定位，不会受 overflow: hidden 影响： 7. 依赖 overflow 的样式表现resize可以拉伸元素尺寸，但是，此声明要想起作用，元素的 overflow 属性值不能是 visible text-overflow:ellipsis文本溢出时用 … 代替，经常与 white-space: nowrap 一起使用，但是，不设置 overflow: hidden 属性，无法实现效果 8. overflow 与锚点技术锚点定位:寻找妹子5: &lt;a href=&quot;#mm5&quot;&gt; 锚点定位实现的前提: 容器可滚动; 锚点元素在容器内; 锚点定位的本质 触发锚点定位; 锚点元素通过 scrollTop 值改变向上偏移定位; 锚元素的上边缘和可滚动容器上边缘对齐 锚点定位的触发 url 地址中的锚链与锚点元素; 可 focus 的锚点元素处于 focus 态 锚点定位的作用 快速定位 选项卡技术(有严重的不足)","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之absolute","slug":"CSS深入理解之absolute","date":"2017-04-21T13:11:24.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170421/abslute-of-css-in-depth-understanding.html","link":"","permalink":"http://merrier.wang/20170421/abslute-of-css-in-depth-understanding.html","excerpt":"","text":"1. 超越 overflow独立的 absolute 可以摆脱 overflow 的限制，无论是滚动还是隐藏 2. 无依赖的 absolute不受 relative 限制的 absolute 定位，行为表现上是不使用 top / right / bottom / left 任何一个属性或使用 auto 作为值 3. 定位的行为表现 脱离文档流 去浮动：absolute 生效的时候，float 是失效的 位置跟随：原来是什么位置，绝对定位后依然是什么位置(元素是 block，absolute 之后依然是 block，inline 时 absolute 后依然是 inline) 可以配合 margin 来精确定位 注释 &lt;!\\-\\- --&gt; 可以消除换行后的空白，同时保持代码可读性 4. 居中以及边缘对齐定位居中采用 text-align:center 使 div 中的空格居中，利用 absolute 的跟随性 配合 margin 负值自身宽度 50% 实现居中。 html： 123&lt;div class=\"course-loading-x\"&gt; &lt;img src=\"http://img.mukewang.com/5453077400015bba00010001.gif\" class=\"course-loading\" alt=\"加载中...\"&gt;&lt;/div&gt; css： 1234567891011.course-loading-x &#123; height: 0; margin-top: 20px; text-align: center; letter-spacing: -.25em; overflow: hidden; &#125;.course-loading &#123; position: absolute; margin-left: -26px; &#125; 边缘定位采用 text-align:right 使 div 中的空格居右(fixed 是直接相对于窗口定位，而直接用 absolute 和 right，bottom 是会受到父级 relative 限制的。所以为了避免受到父级影响，使用fixed) html： 123456&lt;div class=\"course-fixed-x\"&gt; &lt;div class=\"course-fixed\"&gt; &lt;a href=\"http://www.imooc.com/activity/diaocha\" class=\"goto_top_diaocha\"&gt;&lt;/a&gt; &lt;a href=\"http://www.imooc.com/user/feedback\" class=\"goto_top_feed\"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; css： 1234567891011.course-fixed-x &#123; height: 0; text-align: right; overflow: hidden; &#125;.course-fixed &#123; display: inline; position: fixed; margin-left: 20px; bottom: 100px; &#125; 5. 处理对齐、溢出技巧处理文字前的星号将星号绝对定位后其不占据任何空间，方便后面的文字左对齐 html： 123&lt;label class=\"regist-label\"&gt; &lt;span class=\"regist-star\"&gt;*&lt;/span&gt;登录密码&lt;/label&gt; css： 123456.regist-star &#123; position: absolute; margin-left: -1em; font-family: simsun; color: #f30; &#125; 图片与文字垂直对齐对图标设置绝对定位，并设置 margin 为负值 html： 123&lt;span class=\"regist-remark regist-warn\"&gt; &lt;i class=\"icon-warn\"&gt;&lt;/i&gt;邮箱格式不准确（演示）&lt;/span&gt; css： 12345678.regist-warn &#123; padding-left: 20px; color: #be3948; &#125;.regist-warn &gt; .icon-warn &#123; position: absolute; margin-left: -20px; &#125; 处理文字溢出利用 absolute 绝对定位使 span 不占据任何空间，从而使其不换行（注 &lt;span&gt; 必须紧跟前一个标签，不能有空格） html： 1&lt;span class=\"regist-remark\"&gt;请输入6-16位密码，区分大小写，不能使用空格&lt;/span&gt; css： 123456.regist-remark &#123; position: absolute; line-height: 21px; padding-top: 9px; color: #666; &#125; 6. 脱离文档流回流与重绘由于回流与重绘的缘故，动画尽量作用在绝对定位元素上 垂直空间的等级z-index 潜在『误区』:绝对定位元素都需要 z-index 控制等级以确定其显示的位置 absolute 是 z-index 无依赖的： 如果只有一个绝对定位元素，则会自动覆盖普通元素 如果有两个绝对定位，可以控制 DOM 流的前后顺序达到覆盖效果(后来居上) 如果多个绝对定位交错（非常少见），则用 z-index：1 控制 如果非弹框类的绝对定位元素 z-index &gt; 2，必定 z-index 冗余，需要优化 7. absolute 的 top / right / bottom / left 和 width / heightabsolute 元素使用 top / right / bottom / left 可以让元素在容器内自由定位但是遇到属性为 position: relative / absolute / fixed / sticky 的 &lt;div&gt; 时，则只能到这一层为止，无法突破这一层。 使用 top / right / bottom / left 实现『拉伸』当绝对定位的方向是『对立』的(如 left 和 right)，则不是瞬间位移，而是『拉伸』效果 『position: absolute;left: 0;top: 0;width: 50%』等价于『position: absolute;left: 0;top: 0;right: 50%』 没有宽度和高度声明实现的全屏自适应效果：123456789.overlay &#123; position: absolute; left: 0; top: 0; right: 0; bottom: 0; background-color: #000; opacity: .5; &#125; 高度自适应的九宫格效果12345678910111213.page&#123; position: absolute; left: 0; top: 0; right: 0; bottom: 0;&#125;.list &#123; float: left; height: 33.3%; width: 33.3%; position: relative;&#125; left / right 和 width 同时存在相互支持性： 容器无需固定 width / height 值，内部元素亦可拉伸(可实现图片上一张 / 下一张的遮盖层效果) 容器拉伸，内部元素支持百分比 width / height 值 优先级：width / height &gt; left / right","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之line-height","slug":"CSS深入理解之line-height","date":"2017-04-21T08:56:36.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170421/line-height-of-css-in-depth-understanding.html","link":"","permalink":"http://merrier.wang/20170421/line-height-of-css-in-depth-understanding.html","excerpt":"","text":"1. baseline 与 line-height两条 baseline 之间的距离即为行高(不同的字体所在位置不同，可能偏离基线) 2. 行内框盒子模型一共有 4 种模型： 内容区域(content area)，是一种围绕文字看不见的盒子。”内容区域”(content area)的大小与 font-size 的大小相关； 内联盒子(inline boxes)，内联盒子不会让内容成块显示，而是排成一行。如果外部含 inline 水平的标签(span，a，em等)，则属于内联盒子。如果是个光秃秃的文字，则属于匿名内联盒子； 行框盒子(line boxes)，每一行就是一个行框盒子，每个行框盒子又是由一个一个内联盒子组成； &lt;p&gt; 标签所在的包含盒子(containing box)，此盒子由一行一行的行框盒子组成； 3. line-height 与内联元素的高度机制 内联元素的高度是由 line-height 决定的； 行高由于其继承性，影响无处不在，即使单行文本也不例外； 行高只是幕后黑手，高度的表现不是行高，而是内容区域和行间距； 内容区域高度(content area) + 行间距(vertical spacing) = 行高(line-height)； 内容区域高度只与字号以及字体有关，与 line-height 没有任何关系；在 simsun 字体下，内容区域高度等于文字大小值； 行间距上下拆分，就有了”半行间距”； 行高决定内联盒子高度;行间距墙头草，可大可小(甚至负值)，保证高度正好等同于行高； 含多个行框盒子的包含容器–多行文本的高度就是单行文本高度累加。 4. line-height 各类属性值normal默认属性值.跟着用户的浏览器走，且与元素字体关联 &lt;number&gt;使用数值作为行高值，根据当前元素的 font-size 大小计算 &lt;length&gt;使用具体长度值作为行高值，如 1.5em; 1.5rem; 20px; 20pt &lt;percent&gt;相对于设置了该 line-height 属性的元素的 font-size 大小计算 inherit继承，input 框等元素默认行高是 normal，使用 inherit 可以让文本框样式可控性更强 5. line-height 设置为 1.5 / 150% / 1.5em 有何区别计算上无差别，但是 150% / 1.5em 是根据父元素的 font-size 计算的，1.5 是根据自身的 font-size 计算；也就是 150% / 1.5em 是会将行高继承给后代元素的，而 1.5 只会将比例继承给后代元素，后代元素会根据自己的 font-size 重新计算行高 6. body 全局数值行高使用经验1234body&#123; font-size: 14px; line-height: ?;&#125; 为了方便心算，所以我们将行高设置为 20px，此时的 line-height 为：line-height = 20px / 14px ≈ 1.4287 -&gt; line-height: 1.4286 7. line-height 与图片的表现行高不会影响图片实际占据的高度图片外面有隐藏的“幽灵”文本节点，所以 text-align: center 会使图片在p标签中居中 内联元素的 vertical-align 默认为 baseline，所以文字的基线与图片的最下方对齐，但由于文字有行高，所以图片下方会有空隙： 如何消除图片底部间隙图片块状化-无基线对齐1img&#123; display: block; &#125; 块状化的元素没有 vertical-align 属性 图片底线对齐1img&#123;vertical-align: bottom&#125; vertical-align 不再是 baseline，文本的最下方与图片的最下方对齐 行高足够小-基线位置上移1.box&#123; line-height: 0; &#125; 基线位置上移到图片的最下方 小图片和大文字基本上高度受行高控制 8. line-height 的实际应用图片水平垂直居中1234567.box &#123; line-height: 300px; text-align: center;&#125;.box&gt;img &#123; vertical-align: middle;&#125; 多行文本水平垂直居中多行文字水平垂直居中实现的原理跟上一页图片的实现是一样的，区别在于要把多行文本所在的容器的 display 水平转换成和图片一样的，也就是 inline-block，以及重置外部继承的 text-align 和 line-height 属性值 12345678910.box &#123; line-height: 250px; text-align: center;&#125;.box&gt;.text &#123; display: inline-block; line-height: normal; text-align: left; vertical-align: middle;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之vertical-align","slug":"CSS深入理解之vertical-align","date":"2017-04-21T08:40:08.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170421/vertical-align-of-css-in-depth-understanding.html","link":"","permalink":"http://merrier.wang/20170421/vertical-align-of-css-in-depth-understanding.html","excerpt":"","text":"1. vertical-align 支持的属性值 线类：baseline，top，middle，bottom 文本类：text-top，text-bottom 上标下标类：sub，super 数值百分比类：20px，2em，20%，… 其中，默认为 baseline，百分之值是相对于 line-height 计算的 2. vertical-align 起作用的前提应用于 inline 水平和 table-cell 元素（图片，按钮，文字，单元格） inline 水平： inline：&lt;img&gt;，&lt;span&gt;，&lt;strong&gt;，&lt;em&gt;，未知元素，… inline-block：&lt;input&gt;(IE8+)，&lt;button&gt;(IE8+)，… table-cell 元素 table-cell：&lt;td&gt; 3. 个数不定文字与图片垂直对齐html： 1234&lt;div class=\"test-list\"&gt; &lt;span&gt;文字&lt;/span&gt; &lt;img src=\"小公主.jpg\"&gt;&lt;/div&gt; css： 12345678.test-list&gt;span &#123; display: inline-block; width: 210px; vertical-align: middle;&#125;.test-list&gt;img &#123; vertical-align: middle;&#125; 4. vertical-align 与 line-height任何内联元素都会受到 vertical-align 与 line-height 的影响 图片没有居中显示，因为受到了 vertical-align 与 line-height 的影响，此时的默认属性为vertical-align: baseline;line-height: 1.5;font-size: 24px 如何消除这种影响 消灭 vertical-align：display: block; margin: auto 改变 vertical-align：vertical-align: top / middle / bottom 改变 line-height：line-height: 0; font-size: 0; inline-block 的基线inline-block 的基线是正常流中最后一个 line box 的基线，除非，这个 line box 里面既没有 line boxes 或者本身 ‘overflow’ 属性的计算值不是 ‘visible’，这种情况下基线是 margin 底边缘 左边的元素基线为边框下边缘，右边的元素基线为 X 文字下边缘 5. vertical-align 线性类属性值表现vertical-align: bottom inline / inline-block元素: 元素底部和整行的底部对齐 table-cell 元素: 单元格底 padding 边缘和表格行的底部对齐 vertical-align: top inline / inline-block 元素: 元素顶部和整行的顶部对齐 table-cell 元素: 单元格顶 padding 边缘和表格行的顶部对齐 vertical-align: middle inline / inline-block 元素: 元素垂直中心点和父元素基线上 1/2x - height 处对齐 文字具有下沉的特性，而父容器的高度是由文字撑开的，所以父容器的中心点与元素垂直中心点是不重合的，可以设置 font-size: 0 解决这个问题 table-cell 元素: 单元格填充盒子相对于外面的表格行居中对齐 6. vertical-align 文本类属性值vertical-align: text-top盒子的顶部和父级 content area 的顶部对齐 vertical-align: text-bottom盒子的底部和父级 content area 的底部对齐 vertical-align 垂直对齐的位置与前后的元素都没有关系; 元素 vertical-align 垂直对齐的位置与行高 line-height 没有关系，只与字体大小 font-size 有关 7. vertical-align 前后不一致的行为表现关注当前元素和父级，因为前后并没有直接影响 在 img 后面加一个内联元素，并且设置 vertical-align: middle 就可以实现图片的垂直居中 8. vertical-align 的实际应用小图片和文字对齐vertical-align 设置为负值 不定尺寸图片和多行文字的垂直居中三个步骤： 主体元素 inline-block化; 0 宽度 100% 高度辅助元素; vertical-align: middle; 如果已经是 inline-block（img）水平元素，就不需要额外设置 display 属性","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之relative","slug":"CSS深入理解之relative","date":"2017-04-21T07:33:18.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170421/relative-of-css-in-depth-understanding.html","link":"","permalink":"http://merrier.wang/20170421/relative-of-css-in-depth-understanding.html","excerpt":"","text":"1. relative 和 absolute 的相煎关系 限制 left / top / right / bottom 定位； 限制 z-index 层级：relative 中的 absolute 层级不起作用，只看 relative 层级； 限制在 overflow 下的嚣张气焰：消除 absolute 不受 overflow 限制的能力 2. relative 和定位 相对自身：top: 100px; left: 100px 为相对于自身原位置移动 无侵入：不会影响到其他元素，可应用于自定义拖拽 同时设置 top / bottom / left / right 的行为表现：绝对定位是拉伸，相对定位是斗争–top &gt; bottom，left &gt; right 3. relative 与 z-index 提高层叠上下文 新建层叠上下文与层级 z-index：auto 是不会产生层叠上下文的 4. relative 的最小化影响原则尽量避免使用relativeabsolute 定位不依赖使用 relative，不要为了使用 absolute 而设置 relative 最小化原则如果必须要使用 relative，就把 absolute 定位的元素放进一个空 div 里，使 relative 的 div 只有定位为 absolute 的子元素 123456789&lt;div style=\"position:relative\"&gt; &lt;img src=\"pig_head.png\" style=\"position:absolute;top:0;right:0;\"&gt;&lt;/div&gt;&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; ......&lt;/div&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之z-index","slug":"CSS深入理解之z-index","date":"2017-04-20T15:38:25.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170420/z-index-of-css-in-depth-understanding.html","link":"","permalink":"http://merrier.wang/20170420/z-index-of-css-in-depth-understanding.html","excerpt":"","text":"1. z-index 基础z-index 含义z-index 属性指定了元素及其子元素的 [z顺序]，而 [z顺序] 可以决定当元素发生覆盖的时候，哪个元素在上面.通常一个较大 z-index 值的元素会覆盖较低的那一个 属性值 auto –&gt; 默认值 &lt;integer&gt; –&gt; 整数值 inherit –&gt; 继承 基本特性 支持负值 支持 CSS3 animation 动画 1234@keyframes zIndex &#123; 0%&#123; z-index:-1; &#125; 100%&#123; z-index:51; &#125;&#125; 在 CSS2.1 时代，需要和定位元素配合使用 如果不考虑 CSS3，只有定位元素(position:relative / absolute / fixed / sticky，没有 static)的 z-index 才有作用！在 CSS3 中有例外…… 2. z-index 与定位元素如果定位元素 z-index 没有发生嵌套 后来居上 哪个大，哪个在上面 如果定位元素发生嵌套祖先优先原则（前提：z-index 为数值，不是 auto）： 3. 层叠上下文层叠上下文(stacking context)是 HTML 元素中的一个三维概念，表示元素在 z 轴上有了”可以高人一等”的能力，含义： 皇帝(你) 当官(层叠上下文元素) 家族(嵌套) 层叠上下文是表示普通老百姓 HTML 元素当官了，离皇帝更近了 产生层叠上下文： 页面根元素天生具有层叠上下文，称之为”根层叠上下文” –&gt; 皇亲国戚 z-index 值为数值的定位元素也具有层叠上下文 –&gt; 科考入选 其他属性 –&gt; 其他当官途径 层叠上下文特性 层叠上下文可以嵌套，组合成一个分层次的层叠上下文 一个家里，爸爸可以当官，孩子也是可以同时当官的。这个家族的官就当得比较有层次 每个层叠上下文和兄弟元素独立: 当进行层叠变化或渲染的时候，只需要考虑后代元素 自己当官，兄弟不沾光。有什么福利或者变故只会影响自己的孩子们 每个层叠上下文是自成体系的: 当元素的内容被层叠后，整个元素被认为是在父层的层叠顺序中 每个当官的都有属于自己的小团体。当子孙或属下发生的排辈摩擦什么的，都是自己宅院的事情，不会影响官员自己和皇帝之间的距离 4. 层叠水平层叠上下文中的每个元素都有一个层叠水平(stacking level)，决定了同一个层叠上下文中元素在 z 轴上的显示顺序，遵循”后来居上”和”谁大谁上”的层叠准则 层叠水平和 z-index 不是一个东西。普通元素也有层叠水平，每一个当官的家里儿孙啊，仆人什么的，都有一个论资排辈(即层叠水平)，决定了在一起的时候，谁排在前面，离官员更近。 5. 层叠顺序元素发生层叠时候有着特定的垂直显示顺序，即内容 &gt; 布局 &gt; 装饰 6. z-index 与层叠上下文 定位元素默认 z-index: auto，同时可以看成是 z-index: 0; z-index 不为 auto 的定位元素会创建层叠上下文; z-index 层叠顺序的比较止步于父级层叠上下文; 7. 其他 CSS 属性与层叠上下文其他参与层叠上下文的属性们 z-index 值不为 auto 的 flex 项（父元素display：flex | inline-flex） 元素的 opacity 值不是 1 元素的 transform 值不是 none 元素 mix-blend-mode 值不是 normal 元素的 filter 值不是 none 元素的 isolation 值是 isolate position: fixed 声明 will-change 指定的属性值为上面任意一个 元素的 -webkit-overflow-scrolling 设为 touch 8. z-index 与其他 CSS 属性层叠上下文不支持 z-index 的层叠上下文元素的层叠顺序均是 z-index: auto 级别 依赖 z-index 值创建层叠上下文的情况 position 值为 relative / absolute 或 fixed(部分浏览器) display: flex | inline-flex 容器的子 flex 项 9. z-index 相关实践最小化影响原则 避免使用定位属性； 定位属性从大容器平级分离为私有小容器 不犯二原则对于非浮层元素(浮层元素为弹框，蒙版之类)，避免设置 z-index 值，z-index 值没有任何道理需要超过 2–不犯二准则； 组件层级计数器通过 js 获得 body 下子元素的最大 z-index 值 可访问性隐藏z-index 负值元素在层叠上下文的背景之上，其他元素之下","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之margin","slug":"CSS深入理解之margin","date":"2017-04-20T14:58:44.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170420/margin-of-css.html","link":"","permalink":"http://merrier.wang/20170420/margin-of-css.html","excerpt":"","text":"1. margin 与容器的尺寸 适用于没有设定 width / height 的普通 block 水平元素(float 元素，absolute / fixed 元素，inline 水平，table-cell 元素虽然 block 化，但是不是普通的 block 水平元素) 只适用于水平方向尺寸 一侧定宽的自适应布局 滚动容器内上下留白 外部容器设置 padding 值，只有 chrome 才会有留白，此时可以在给内部容器设置 margin 值 2. margin 与百分比单位计算规则普通元素的百分比 margin 都是相对于容器的宽度计算的，绝对定位元素的百分比 margin 是相对于第一个定位祖先元素(relative / absolute / fixed)的宽度计算的 应用-宽度 2:1 自适应矩形由于 margin 百分比的计算规则是相对于容器进行计算的，而 margin 又可以影响普通 block 水平元素的可视尺寸，所以当设置为 margin: 50% 时，由于 margin 重叠特性，所以会让元素的宽高始终保持 2:1 的比例 3. margin 重叠通常特性发生在 block 水平元素（不包括 float 和 absolute 元素） 不考虑 writing-mode，只发生在垂直方向（margin-top / margin-bottom） 3 种情境相邻的兄弟元素 父级和第一个 / 最后一个子元素下面这3种书写形式的效果是相同的，都是子元素向下偏移了 80px，而父级的尺寸并没有改变 父子 margin 重叠的其他条件 margin-top 重叠： 父元素非块状格式化上下文元素 父元素没有 border-top 设置 父元素没有 padding-top 值 父元素和第一个子元素之间没有 inline 元素分隔 margin-bottom 重叠： 父元素非块状格式化上下文元素 父元素没有 border-bottom 设置 父元素没有 padding-bottom 值 父元素没有和最后一个子元素之间没有 inline 元素分隔 父元素没有 height，min-height，max-height 限制 空的 block 元素 空的 block 元素 margin 重叠其他条件： 元素没有 border 设置 元素没有 padding 值 里面没有 inline 元素 没有 height，或者 min-height margin 重叠计算规则 正正取大值：50 和 20 –&gt; 50 正负值相加：50 和 -20 –&gt; 30 负负最负值：-50 和 -30 –&gt; -50 margin 重叠的意义 连续段落或列表之类，如果没有 margin 重叠，首尾项间距会和其他兄弟标签 1:2 关系，排版不自然 web 中任何地方嵌套或直接放入任何裸 div，都不会影响原来的布局 遗落的空任意多个 &lt;p&gt; 元素，不要影响原来的阅读排版 善用 margin 重叠 4. margin auto如果一侧定值，一侧 auto，auto 为剩余空间大小；如果两侧都是 auto，则平分剩余空间(居中显示)，但是不能计算负值 writing-mode 与垂直居中更改流为垂直方向，实现垂直方向的 margin: auto 居中 12345678910.father &#123; height: 200px; width: 100%; writing-mode: vertical-lr;&#125;.son &#123; height: 100px; width: 500px; margin: auto;&#125; absolut 与 margin 居中top:0; right:0; bottom:0; left:0; 会使子元素的宽度和高度拉伸到与父元素相同大小，当没有 width / height 属性时，absolute 元素自动填满了容器；但设置了 width / height 属性后，会限制 absolute 元素自动填满容器，此时 margin: auto 就会自动平分被变更的尺寸空间，从而实现子元素的水平垂直居中 1234567891011121314.father &#123; height: 200px; position: relative;&#125;.son &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 500px; height: 100px; margin: auto;&#125; 5. margin 负值定位margin 负值下的两端对齐margin 可以改变元素尺寸 margin 负值下的等高布局margin 改变元素占据空间：给每个框设置大的底部内边距，然后用数值相似的负外边距消除这个高度。这会导致每一列溢出容器元素，如果把外包容器的 overflow 属性设为 hidden，列就在最高点被裁切 margin 负值下的两栏自适应布局元素占据空间跟随 margin 移动 6. margin 无效情形解析inline 元素的垂直 margin 无效前提： 非替换元素：替换元素为 &lt;img&gt; &lt;button&gt; 元素 正常书写模式 margin 重叠上面讲过了 display: table-cell 与 marginMDN上的解释： 除了 display 为 table 相关类型（不包括 table-caption，table 以及 inline-table）的所有，甚至也可应用于 ::first-letter position: absolute 与 margin绝对定位元素非定位方位的 margin 值”无效”，绝对定位的 margin 值一直有效，只是不像普通元素那样，可以和兄弟元素插科打诨! 鞭长莫及导致的 margin 无效浮动元素和绝对定位元素会破坏布局，此时的 margin-left 会从整个父容器的左侧开始算起，所以当 margin-left 值小于图片的宽度的时候，会看不到效果，但其实是有效的 内联特性导致的 margin 无效内联元素默认基线对齐(vertical-align: baseline)，当 margin-top 是一个很大的负值的时候，由于字母 x (内敛元素)的拖累(x 没有添加任何样式，所以不会跑到父容器外面)，内联元素仍然在与 x 基线对齐的位置 7. margin-start 和 margin-end正常流下： margin-start –&gt; margin-left margin-end –&gt; margin-right margin-before –&gt; margin-top margin-after –&gt; margin-bottom 如果水平流是从右往左，margin-start 等同于 margin-right在垂直流下（writing-mode: vertical-*），margin-start 等同于 margin-top 8. margin-collapse决定 margin 重叠时该如何表现 -webkit-margin-collapse: | | collapse（默认-重叠） discard（取消）–&gt; 此时 margin 将变为 0 separate（分隔）–&gt; 此时 margin 将不再重叠，而是相加","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"CSS深入理解之padding","slug":"CSS深入理解之padding","date":"2017-04-20T12:30:24.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170420/padding-of-css-in-depth-understanding.html","link":"","permalink":"http://merrier.wang/20170420/padding-of-css-in-depth-understanding.html","excerpt":"","text":"1. padding 和元素尺寸的关系对于 block 水平元素 padding 太大时，一定会影响尺寸 width 非 auto，padding 影响尺寸 width 为 auto 或 box-sizing 为 border-box，同时 padding 值没有过大，此时不会影响尺寸 对于 inline 水平元素水平 padding 影响尺寸，垂直 padding 不影响尺寸，但是会影响背景色(占据空间) inline 元素 padding 特性应用 &gt;&gt; 高度可控的分割线 直接使用字符：注册 | 退出登录 inline-block 控制：注册丨退出登录 使用 inline 和 padding：注册丨退出登录 1注册&lt;sapn&gt;&lt;/span&gt;退出登录 123456span&#123; padding: 16px 6px 1px; margin-left: 12px; border-left: 2px solid; font-size: 0;&#125; 2. padding 负值padding 不支持任何形式的负值 3. padding 百分比值padding 百分比均是相对于宽度计算的，所以可以用来实现一个正方形（padding: 50%） inline 元素的 padding 百分比值 同样相对于宽度计算 默认的高度宽度细节有差异 padding 会断行 因为文字的换行导致表现诡异，当 padding 变小以至于文字不会换行时就会正常表现 空 inline 元素 + padding 高度也不等(高度大于宽度)，此时如果设置 font-size: 0 就可以正常表现了 原因：inline 元素的垂直 padding 会让”幽灵空白节点”显现，也就是规范中的 “strut” 出现 4. 标签元素的内置 paddingol / ul 列表 ol / li 元素内置 padding-left，但是单位是 px 不是 em； 例如 Chrome 浏览器下是 40px； 如果字号很小，间距就会很开； 如果字号很大，序号会爬到容器外面； 表单元素 所有浏览器 input / textarea 输入框内置 padding 所有浏览器 button 按钮内置 padding 部分浏览器 select 下拉内置 padding，如 FireFox、IE8+ 可以设置 padding 所有浏览器 radio / checkbox 单复选框无内置 padding button 按钮元素的 padding 最难控制 button按钮Chrome 浏览器可以完美设置 padding FireFox 浏览器设置 padding: 0 左右依然有 padding，只能通过： 123button::-moz-focus-inner &#123; padding: 0;&#125; IE 浏览器IE7 文字越多，左右 padding 逐渐变大，解决方案： 123button &#123; overflow: visible;&#125; 4.padding 与高度计算的不兼容12345button &#123; line-height: 20px; padding: 10px; border: none;&#125; IE7: 45px IE8+: 40px FireFox: 42px Chrome: 40px button 按钮会有以上的各种 bug，所以建议是通过 label 按钮模拟按钮 12&lt;button id=\"btn\"&gt;&lt;/button&gt;&lt;label for=\"btn\"&gt;按钮&lt;/label&gt; 12345label &#123; display: inline-block; line-height: 20px; padding: 10px;&#125; 5. padding 与图形绘制三道杠第一道杠用 border-top，第二道杠用 background-color，第三道杠用 border-bottom，中间空白用padding： 白眼效果中间大的圆用 background-color，最外面的环用 border，中间空白用 padding 6. padding 与布局使用百分比单位构建固定比例布局结构移动端 1:1 头图布局 配合 margin 等高布局 两栏自适应布局padding 在容器上 padding 在子元素上","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"一些常用邮箱的IMAP&SMTP&POP3地址","slug":"一些常用邮箱的IMAP&SMTP&POP3地址","date":"2017-04-20T02:05:49.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170420/imap-smtp-pop3-addresses-for-some-common-mailboxes.html","link":"","permalink":"http://merrier.wang/20170420/imap-smtp-pop3-addresses-for-some-common-mailboxes.html","excerpt":"","text":"我们在客户端设置邮箱或者使用 PHPMailer 发送邮件的时候，我们都会去查找这些邮箱的 IMAP / SMTP / POP3 地址，这里列出了一些常用邮箱的这些地址，方便自己和大家以后设置邮箱时候使用。 GmailGmail 的 IMAP / SMTP / POP3 协议默认都是开启，它的详细地址如下： /daizhengli/[table id=15 /] QQ邮箱QQ邮箱的 IMAP / SMTP / POP3 协议默认是不开启的，你需要登陆到 QQ邮箱，然后到“设置” &gt; “账户” 将其开启。 /daizhengli/[table id=16 /] 163 邮箱/daizhengli/[table id=17 /] 阿里云邮箱/daizhengli/[table id=18 /] 139邮箱/daizhengli/[table id=19 /] sina邮箱/daizhengli/[table id=20 /] 扩展阅读 常用邮箱的 IMAP/POP3/SMTP 设置","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"SMTP","slug":"SMTP","permalink":"http://merrier.wang/tags/SMTP/"},{"name":"邮箱地址","slug":"邮箱地址","permalink":"http://merrier.wang/tags/邮箱地址/"}]},{"title":"一篇绝对能看懂的Git入门教程","slug":"一篇绝对能看懂的Git入门教程","date":"2017-04-17T13:35:16.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170417/introduction-to-Git.html","link":"","permalink":"http://merrier.wang/20170417/introduction-to-Git.html","excerpt":"","text":"不管你是从事什么方面的程序猿，只要你属于这个神秘组织，就必须要对 SVN 或 Git 这种版本控制系统有所了解；和大部分人一样，当初项目负责人告诉我需要学 Git 的时候，只说了这样一句话：“网上很多教程，自己看着学吧”，当然，这句话直到今天我也无力反驳，因为对于一个新鲜的程序猿来说，只需要懂一些 Git 的基本指令就可以了，一些高端指令可能永远都用不到，所以，我就查阅了一些 Git 的教程和手册，整理出这篇对于新手很友好的 Git 入门教程 工作区与暂存区很多 Git 教程都把这一部分的讲解放到很靠后的位置，所以我当初学习的时候并没有把这一部分放在心上；但是现在我觉得，这一部分才是最需要明白的，因为这一部分是非常“真实”的，对于一个之前从来没接触过命令行或一直在 windows 上打游戏、看直播的程序猿来说，这一部分也是最容易理解的 工作区：通俗易懂的来说就是你电脑里面的能看到的目录，比如 learngit 的目录。版本库：工作区有一个隐藏的目录 .git，这是 Git 的版本库。版本库中存了很多东西，其中最重要的就是stage(index)的 暂存区。 下面这张图非常清晰的表明了这三者的关系，我就不多说了： 请牢牢记住这三\b个概念，因为下面会经常用到 初始化生成 ssh通过下面的指令可以生成 id_rsa 和 id_rsa.pub 两个文件，不同操作系统这两个文件所在位置不同，id_rsa.pub 里面的所有内容就是你的公钥，直接复制到 GitHub 的 Add SSH key 页面就可以愉快的进行玩耍了 1ssh-keygen -t ras -C \"email@xxx\" ssh 是一种协议，而 Git 目前支持4种协议——ssh协议，http/s协议，git 协议，本地协议，ssh 协议配置简单，权限管理也比较全面，更重要的是无需密码和 linux 内置（git 是 linus 写的软件，linus 是 linux的作者，所以你懂得），至于 ssh 究竟怎么做的就不在本文介绍了，可以去阮一峰的博客中查找相关资料 设置用户名和现实世界类似，你想和别人进行数据通信，首先得让别人知道你是谁，你的联系方式吧，而和现实世界不同的是，这里的联系方式只能填写邮箱，填写微信或者 QQ 号是木有用的 12git config --global user.name \"cc\"git config --global user.email \"cc@xx\" 初始化当前目录的项目1git init 还记得上面我们提到的三个概念吗，这里的初始化就是为了在本地目录中添加本地版本库，然后才可以后续的 git 操作。比如初始化之前你的目录是这样的（当前目录为空是因为我是在一个空文件夹的基础上进行初始化的，而实际情况是这里面会有你的项目文件）： 而执行初始化操作之后： 从上图可以看到，当前目录中多了 .git 文件夹，这个文件夹就是你的本地的版本库了，里面存储着很多东西，其中包括暂存区；通过短短的一行命令，初始化操作就已经完成了，同时 Git 也为我们创建了第一个分支 master，和一个指向 master 的指针 HEAD，接下来就是一些常用的命令 常用命令查看工作区状态1git status 这是一条需要经常使用的命令，因为有时候工作区的改变可能会是“隐性”的，比如你的编辑器自己添加的文件或者其他类型的隐藏文件，而经常查看状态也是检验某些 git 命令是否执行的方法。通过执行这一命令，我们在终端中可能会看到： 从终端的第四行我们可以看到，当我们查看状态时，Git 告诉我们当前分支为 master；第八行的意思是我们没有什么可以 commit 的，说明我们在当前目录下并没有进行修改，所以我们需要进行修改之后再进行后续操作： 从上图我们可以看到，我在当前目录中新添加了一个文件 octocat.txt，然后我们再通过 git status 查看一下当前工作区的状态： 这次好像和上次不一样了，Git 告诉我们有一个文件 untracked files 叫做 octocat.txt，同时还提醒你通过 git add &lt;file&gt;... 进行提交，那这里就稍微提一下 git status 时可能看到的当前工作区的文件的状态 staged：已经添加到暂存区，等待提交的文件 unstaged：已经发生了改变，但是还没有提交 untracked：Git 都不知道还有这个文件，所以说明这是一个新添加的文件（就像上面的 octocat.txt） deleted：已经从本地删除的文件 提交工作区修改到暂存区 git add . // 将工作区所有修改添加到暂存区 git add filename // 将指定文件添加到暂存区 还是一开始我们提到的那三个概念，我们在本地进行了修改（新建、修改、删除），但是此时还只是我们自己知道发生了哪些改变，Git 根本都不知道（本地的 Git 都不知道，更别提远程），所以需要进行提交；那么你可能有疑问了，为什么提交到暂存区？直接提交给远程不就完了吗？这里就是 Git 设计的巧妙之处，通过暂存区可以防止你的错误提交（事实证明，这一点很重要）。经过 git add 后，我们再通过 git status 查看一下状态： Git 告诉我们它看到了一个新的文件 octocat.txt，并且 to be committed，那么你可能会问了，假如我当前的目录里有好多文件都需要 add 怎么办，难道一次次执行命令吗？当然不需要，从上面的代码块中可以看到，我们可以通过 git add . 提交所有修改，但是不推荐这种操作，因为有可能会将一些不想提交的隐藏文件也提交到暂存区了；假如我们当前目录下有很多 .txt 文件等待提交： 我们可以使用 “*.txt” 匹配到所有的 txt 文件，然后就可以将它们全部提交了： 1git add '*.txt' 将暂存区修改添加到本地仓库1git commit -m '备注信息' 经过多次的 git add，此时的暂存区有好多本地的修改，通过上面的 commit 可以将所有的暂存区的修改添加到本地仓库，所以你可以简单理解为：需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 push 到远程经过上面的一顿折腾，仍然只有本地的 “Git” 知道了我们都做了些什么，如果想让远程仓库也知道，我们需要先和远程仓库建立联系： 1git remote add origin https://github.com/try-git/try_git.git 在这里遇到一个问题：每次 push 都要输入用户名和密码，原因是我们是通过 https 方式进行 push，解决方法如下： 12git remote rm origin // 移除git remote add origin git@github.com:try-git/test.git // 添加 此后就不用再输入用户名和密码了，同时我们和远程建立联系以后就不用再 git remote add 了，这就好比你去别人家串门，第一次可能需要你需要查一下地图，第二次的话就直接去找他就行了。接下来就是 push 到远程了： 1git push -u origin master 第一次 push 是需要加 -u 参数的，这个参数是告诉远程我是谁（git push的-u参数具体含义），还是刚才串门的例子，第一次去别人家串门肯定需要表明身份的，第二次就不再需要了，因为已经知道你是谁了： 1git push origin master 从远程 pull1git pull origin master 如果别人提交了他们的修改到远程仓库，我们需要从远程 pull 修改到我们的本地，从而保证大家的进度保持同步，比如别人提交了一个 yellow_octocat.txt 文件到远程，我们 git pull 之后： Git 告诉我们，你 pull 成功了，新增加了一个文件叫做 yellow_octocat.txt，此时我们的当前目录就多了一个 yellow_octocat.txt（.git 也就是本地版本库也知道了这个文件） 查看修改的内容1git diff 有可能别人和我对同一文件进行了修改，所以在 pull 之后需要查看一下都发生了哪些修改: 其实，git diff 的用法不仅只有这一种，还可以查看暂存区的修改都有哪些： 1git diff --staged 撤销修改丢弃工作区的修改假如我们对之前的一个文件 readme.txt 进行了修改，但是现在我发现对这个文件进行的修改都是错的（经常会发生），此时我不想要我对这个文件的修改了，就可以执行下面的命令，然后 readme.txt 就可以回退到我修改之前的样子 1git checkout readme.txt 丢弃暂存区的修改和刚才不一样的是，我已经将我的修改提交到暂存区了（也就是说已经执行了 git add readme.txt 命令），此时我想把这个文件的修改从暂存区放回到工作区，就需要执行下面的命令，然后此时的暂存区就不再有 readme.txt 的修改，就像没 git add 过 1git reset HEAD readme.txt 分支相关除了 Git，其他版本控制系统如 SVN 中也有分支管理，但是 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。但是截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即master 分支。HEAD 严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以，HEAD 指向的就是当前分支。每次提交，master 分支都会向前移动一步，这样，随着你不断提交，master 分支的线也越来越长。 新建分支1git branch clean_up 此时我们在本地创建了一个分支叫做 clean_up，对于 Git 来说，相当于新建了一个指针叫 clean_up，指向和 master 相同的提交，但是此时的 HEAD 仍然指向 master，因为此时我们只是新建了一个分支，并没有切换到 clean_up 分支 切换分支1git checkout clean_up 我们新创建了 clean_up 分支后，可以通过上面的命令将本地的分支切换到 clean_up，此时的 HEAD 就会指向 clean_up 删除文件为了后面的分支命令展示，我们通过下面的命令将 .txt 文件（注意此时所在的分支仍然是 clean_up）删除 1git rm '*.txt' 然后，我们将删除这些文件的修改进行提交（add + commit），此时本地的 clean_up 分支就没有这些 .txt 文件了： 此时我们再切换到 master 分支（git checkout master）： 通过上面两张图片，我们可以清晰的看到分支的作用，其实相当于两个平行世界（branch），而你所扮演的就是上帝的角色，想让哪个世界继续进行，就 checkout 哪个分支就可以了。此时如果我们想让\b clean_up 分支上做出的改变合并到 master 分支该怎么办呢？ 合并分支1git merge clean_up 上面这段命令执行的前提是你当前的分支是 master，而通过 git merge 某分支可以将某分支的改变合并到当前分支： 我们通过上面的结果可以看到此时的 master 分支已经没有了 .txt 文件 删除分支1git branch -d clean_up 既然我们已经把 clean_up 分支的改变合并到了 master 分支，所以此时我们就不再需要 clean_up 分支了，通过上面的命令可以将该分支删除 版本相关较为复杂的分支命令的介绍就告一段落了，下面介绍一下和版本相关的一些常用命令 查看提交的历史记录1git log 我们可以通过 git log 查看提交的历史记录（每一次 commit 都是一次记录）： 从上面的图片可以看到，我们有两次 commit 记录，他们的 id 是很长的黄色字符串，这个 id 和每次提交是一一对应的，同时也对应着相应的版本，而除了 commit id，我们还可以看到提交的作者、日期以及备注信息（这里就体现出了备注信息是多么的重要） 回退版本1git reset --hard HEAD^ 通过上面的命令，我们可以回退到上个版本，HEAD 为当前版本，HEAD^ 为上一个版本，HEAD^^ 为上上个版本，如果有 100 个版本 HEAD~100。当然，我们也可以通过上面提到的 commit id 来回到过去的某个版本 1git reset --hard commit_id 是不是更感觉自己像是一个上帝了，在 Git 中，你可以随意控制平行世界的发展，需要做的只是输出一行命令而已 其他命令上面就是一些我们最常用的 Git 命令，但是 Git 的强大之处远不止这些，下面就简单介绍几种我们可能会用到的命令： 建立本地分支与远程分支的追踪关系当在本地新建分支的时候，可能远程并没有这个分支，所以你需要建立追踪关系，这样你 push 的时候才不会 push 到别的分支上去 12git branch --set-upstream-to=&lt;remote&gt;/branchName // 建立本地分支与远程分支的追踪关系git branch --track branchName [remote branch] // 新建一个分支，并与远程建立追踪关系 cherry-pick这是 Git 的又一神奇命令，它可以让你将任何一次 commit 的修改合并到当前分支 1git cherry-pick commitId // 将与 commitId 对应的提交合进当前分支 bug 分支当我们修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除分支；但是如果我们的手头工作没有完成呢，就需要暂时放弃当前没有提交的修改，然后去修复bug，修复完之后再回来恢复原样继续做刚才的工作 12git stash // 暂时放弃未提交的修改git stash pop // 恢复 实践步骤/daizhengli/[table id=23 /] 扩展阅读 图解Git 廖雪峰-Git教程 在线练习git命令 Pro Git 实用Git Workflow Git Community Book 中文版 另外一些关于 Git / Github 入门的文章 大白话解释 Git 和 GitHub git - the simple guide GitHub: the beginner’s guide","categories":[{"name":"Git","slug":"Git","permalink":"http://merrier.wang/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://merrier.wang/tags/git/"},{"name":"教程","slug":"教程","permalink":"http://merrier.wang/tags/教程/"}]},{"title":"前端面试系列（12）——前端性能优化","slug":"前端面试系列（12）——前端性能优化","date":"2017-04-16T14:20:57.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170416/front-end-performance-optimization.html","link":"","permalink":"http://merrier.wang/20170416/front-end-performance-optimization.html","excerpt":"","text":"近几年的前端发展异常火爆，各种框架各种技术层出不穷，而所有的前端框架面临着同一个问题：怎样才能缩短首屏时间，让用户以最快的速度看到页面最想展现的内容；所以，前端性能优化这一问题成为所有前端开发人员需要考虑的需求。下面我将从 html、css、js 等方面介绍前端性能优化的一些方式，考虑到篇幅原因，只会以列表的形式进行简单概括，具体做法可以自行查阅，在这里强烈推荐雅虎军规，Yahoo Rules 是对于前端性能优化的全面总结，有时间一定要看一看 HTML 的优化使用相对 URL某些 href、src 属性如果与当前页面处于同一域名下，则使用相对 URL 能够节省至少一个域名的长度。 删除 HTTP 或者 HTTPS绝对 URL 都以 HTTP 或 HTTPS 等协议头开始，如果能确定 URL 的协议与当前页面 URL 的协议是一致的，或者说该 URL 在多种协议下均是可用的，则可以考虑删除这个协议头。 删除注释考虑不必要的 IE 条件注释和 CDATA 注释及自定义注释。 压缩空白符对于多数标签，可以通过删除多余的空白符来减少 HTML 体积，但是对于 pre 等是例外。 压缩 inline css &amp; Javascript不管 inline 还是 external，都需要压缩，这是减小体积的最直接的方式。 CSS &amp; Javascript 尽量外链不仅可以减少体积，还能够充分利用浏览器的缓存机制。 删除元素默认属性在 HTML 规范中，很多 HTML 元素的属性是有默认值的，对于这些默认值可以抹去不写。 避免使用 Iframe创建 iframe 元素的开销要比创建其他类型的 DOM 元素高 1~2 个数量级 避免空链接属性可以看做是上面“删除元素默认属性”的特例，即使图片的地址为空，浏览器依旧会以默认的规则去请求空地址 避免节点深层级嵌套由于浏览器构建 DOM 文档的机制，深层级嵌套的节点在初始化构建时往往需要更多的内存占用，并且在遍历节点时也会更慢些 避免 Table 布局构建 table 的开销也很大 显示指定文档字符集如果浏览器不能获知页面的编码字符集，一般都会在执行脚本和渲染页面前，把字节流缓存，然后再搜索可进行解析的字符集，或以默认的字符集来解析页面代码，这会导致消耗不必要的时间。为了避免浏览器把时间花费在搜寻合适的字符集来进行解码，所以最好在文档中总是显式的指定页面字符集。 CSS 的优化把 CSS 放到代码页上端加快渲染 避免 CSS 表达式表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给 CSS 表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到 10000 次以上的计算量。 使用 &lt;link&gt; 而不是 @import在外部的 CSS 文件中使用 @import 会使得页面在加载时增加额外的延迟。虽然规则允许在样式中调用 @import 来导入其它的 CSS，但浏览器不能并行下载样式，就会导致页面增添了额外的往返耗时。比如，第一个 CSS 文件 first.css 包含了以下内容：@import url(“second.css”)。那么浏览器就必须先把 first.css 下载、解析和执行后，才发现及处理第二个文件 second.css。 避免通配选择器CSS 选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免需要消耗更多匹配时间的选择器。比如这种反例： 1.selected * &#123;color: red;&#125; 由于 CSS 选择器从右到左匹配的机制，浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 selected 的元素，直到文档的根节点，因此其匹配开销是非常大的，通常比开销最小的 ID 选择器高出 1~3 个数量级，所以应避免使用关键选择器是通配选择器的规则。 避免单规则的属性选择器属性选择器根据元素的属性是否存在或其属性值进行匹配，如下例规则会把 herf 属性值等于 ”#index” 的链接元素设置为红色： 1.selected [href=”#index”] &#123;color: red;&#125; 但其匹配开销是非常大的，浏览器先匹配所有的元素，检查其是否有 href 属性并且 herf 属性值等于 ”#index”， 然后分别向上逐级匹配 class 为 selected 的元素，直到文档的根节点。所以应避免使用关键选择器是单规则属性选择器的规则。 避免类正则的属性选择器CSS3 添加了复杂的属性选择器，可以通过类正则表达式的方式对元素的属性值进行匹配。当然这些类型的选择器定是会影响性能的，正则表达式匹配会比基于类别的匹配会慢很多。大部分情况下我们应尽量避免使用 *=， |=， ^=， $=，和 ~= 语法的属性选择器。 JavaScript 的优化脚本放到 HTML 代码页底部加快渲染，当然如果你的 js 会影响 dom 建立，那放在哪都是一样的了 移除重复脚本封装方法是一个前端开发人员最基本的技能 减少 DOM 访问使用 JavaScript 访问 DOM 元素是比较慢的，因此为了提升性能，应该做到： 缓存已经查询过的元素； 线下更新完节点之后再将它们添加到文档树中； 避免使用 JavaScript 来修改页面布局； 使用事件代理有时候我们会感觉到页面反应迟钝，这是因为 DOM 树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用事件代理是一种好方法了。如果你在一个 div 中有 10 个按钮，你只需要在 div 上附加一次事件句柄就可以了，而不用去为每一个按钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。 缓存选择器查询结果选择器查询是开销很大的方法。所以，使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。 不要使用： 12jQuery('#top').find('p.classA');jQuery('#top').find('p.classB'); 而是使用： 123var cached = jQuery('#top');cached.find('p.classA');cached.find('p.classB'); 使用微类库通常开发者都会使用 JavaScript 类库，如 jQuery、Mootools、YUI、Dojo 等，但是开发者往往只是使用 JavaScript 类库中的部分功能。为了更大的提升性能，应尽量避免使用这类大而全的类库，而是按需使用微类库来辅助开发。 扩展阅读 [Absolute HTML Compressor](http://www.alentum.com/ahc/ “Absolute HTML Compressor”）：HTML 的优化工具，压缩效果比较理想 Even Faster Web Sites：关于前端优化的书，本人没看过，但是豆瓣评分 8.6 的它应该还不错吧 参考文章 不应忽视的HTML优化 Yahoo Rules 前端性能优化黄金法则 网站性能优化工具大全 WEB前端性能优化常见方法","categories":[{"name":"前端","slug":"frontend","permalink":"http://merrier.wang/categories/frontend/"}],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"},{"name":"前端","slug":"前端","permalink":"http://merrier.wang/tags/前端/"},{"name":"性能优化","slug":"性能优化","permalink":"http://merrier.wang/tags/性能优化/"}]},{"title":"JS中的一些小技巧，精妙且实用","slug":"JS中的一些小技巧，精妙且实用","date":"2017-04-13T01:33:29.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170413/some-tips-in-js.html","link":"","permalink":"http://merrier.wang/20170413/some-tips-in-js.html","excerpt":"","text":"这里总结了我在项目中经常会用到的一些 JS 小技巧，同时参考了其他开发者对于 JS 小技巧的总结，从而形成了这篇文章，如果在日后我发现了更多的小技巧，我会及时更新 使用 !! 操作符转换布尔值有时候我们需要对一个变量检查其是否存在或者检查值是否有一个有效值，如果存在就返回 true 值。为了做这样的验证，我们可以使用 !! 操作符来实现是非常的方便与简单。对于变量可以使用 !!variable 进行检测 只要变量的值为：0、null、” “、undefined 或者 NaN 都将返回的是 false，反之返回的是 true。 使用 “+” 或 “-“ 转化数值这个技巧非常有用，其非常简单，可以将字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回 NaN 12345function toNumber(strNumber)&#123; return +strNumber;&#125;console.log(toNumber(\"1234\")); // 1234console.log(toNumber(\"ACB\")); // NaN 检测对象中属性当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用 document.querySelector() 来选择一个 id，并且让它能兼容 IE6 浏览器，但是在 IE6 浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例： 12345if('querySelector' in document)&#123; document.querySelector(\"#id\");&#125;else&#123; document.getElementById(\"id\");&#125; 在这个示例中，如果 document 不存在 querySelector 函数，那么就会调用 docuemnt.getElementById(“id”)。 数组截断这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有 10 个元素，但你只想只要前五个元素，那么你可以通过 array.length = 5 来截断数组。如下面这个示例： 12345var array = [1,2,3,4,5,6];console.log(array.length); // 6array.length = 3;console.log(array.length); // 3console.log(array); // [1,2,3] 合并数组如果你要合并两个数组，一般情况之下你都会使用 Array.concat() 函数： 123var array1 = [1,2,3];var array2 = [4,5,6];console.log(array1.concat(array2)); // [1,2,3,4,5,6]; 然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之下，可以使用 Array.pus().apply(arr1,arr2) 来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用： 123var array1 = [1,2,3];var array2 = [4,5,6];console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6]; 将 NodeList 转换成数组如果你运行 document.querySelectorAll(“p”) 函数时，它可能返回 DOM 元素的数组，也就是 NodeList 对象。但这个对象不具有数组的函数功能，比如 sort()、reduce()、map()、filter() 等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用 [].slice.call(elements) 来实现： 123var elements = document.querySelectorAll(\"p\"); // NodeListvar arrayElements = [].slice.call(elements); // Now the NodeList is an arrayvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array 数组元素随机排序利用随机数模拟随机排序 12var list = [1, 2, 3];console.log(list.sort(function()&#123;Math.random() - 0.5&#125;)); // [2,1,3] 其实利用 Math.random() 得到的结果并不是真正的随机排序，参见我的另外一篇文章：JS中数组方法总结，这篇文章中的数组随机排序方法是比较好的一个方法 从数组中获取一个随机项很难说这是一个技巧，如果你的前端水平还算可以的话，这个应该难不倒你： 12var items = [12, 548 , 'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' , 2145 , 119];var randomItem = items[Math.floor(Math.random() * items.length)]; 在特定范围内获取一个随机数这个在生成测试数据的时候非常有用，比如一个在最小最大值之间的一个随机薪水值 1var x = Math.floor(Math.random() * (max - min + 1)) + min; 生成一个随机的数字字母字符串有时候，我们需要给某个元素赋一个唯一的 id，这个时候随机字符串就可以派上用场了，在这个技巧里，你可以见识到 js 中的 toString() 方法是多么的强大；Math.random() 生成 0 到 1 之间的随机数，number.toString(36) 是将这个数字转换成36进制（0-9，a-z），最后 substr 去掉前面的 “0.” 字符串 1234567function generateRandomAlphaNum(len) &#123; var rdmstring = \"\"; for ( ;rdmString.length &lt; len; ) &#123; rdmString += Math.random().toString(36).substr(2)); &#125; return rdmString.substr(0, len);&#125; 更快的四舍五入见到过双波浪线 “~~” 操作符吗？它有时也被称为 double NOT 运算符。你可以更快的使用它来作为 Math.floor() 替代品。为什么呢？单位移 ~ 将 32 位转换输入 -(输入+1)，因此双位移将输入转换为 -(-(输入+1))，这是个趋于 0 的伟大的工具。对于输入的数字，它将模仿 Math.ceil() 取负值和 Math.floor() 取正值。如果执行失败，则返回 0，这可能在用来代替 Math.floor() 失败时返回一个 NaN 的时候发挥作用。 12345678910111213// 单位移console.log(~1337) // -1338// 双位移console.log(~~47.11) // -&gt; 47console.log(~~-12.88) // -&gt; -12console.log(~~1.9999) // -&gt; 1console.log(~~3) // -&gt; 3//失败的情况console.log(~~[]) // -&gt; 0 console.log(~~NaN) // -&gt; 0console.log(~~null) // -&gt; 0//大于32位整数则失败console.log(~~(2147483647 + 1) === (2147483647 + 1)) // -&gt; 0 虽然 ~~ 可能有更好的表现，不过为了可读性，还是推荐使用 Math.floor()。 测量一个 JavaScript 代码块的性能快速测量一个 JavaScript 块的性能，我们可以使用控制台的功能像 console.time(label) 和console.timeEnd(label) 12345678console.time(\"Array initialize\");var arr = new Array(100), len = arr.length, i;for (i = 0; i &lt; len; i++) &#123; arr[i] = new Object();&#125;;console.timeEnd(\"Array initialize\"); // 输出: Array initialize: 0.711ms 自调用函数这个经常被称为自调用匿名函数（Self-Invoked Anonymous Function）或者即时调用函数表达式（IIFE-Immediately Invoked Function Expression)。这是一个在创建后立即自动执行的函数，可以用于数据回填以及窗口 resize() 事件，我在项目中屡试不爽，示例如下： 1234567(function()&#123; // some private code that will be executed automatically&#125;)();(function(a, b)&#123; var result = a + b; return result;&#125;)(10, 20) 实现 String 的 trim 函数在 Java、C#、PHP 和很多其他语言中都有一个经典的 trim 函数，用来去除字符串中首尾的空格符，而在 JavaScript 中并没有，所以我们需要在 String 对象上加上这个函数： 1String.prototype.trim = function()&#123;return this.replace(/^\\s+|\\s+$/g, \"\");&#125;; 将 arguments 对象转换成一个数组arguments 对象是一个类数组对象，但不是一个真正的数组 1var argArray = Array.prototype.slice.call(arguments); 验证是否是数字这是一个可以称得上技巧的 js 方法，当然你也可以用正则表达式 123function isNumber(n) &#123; return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#125; 验证是否是数组call() 这个方法在 js 里如同神技，而这里也是它的一个应用 123function isArray(obj)&#123; return Object.prototype.toString.call(obj) === '[object Array]' ;&#125; 不要使用 delete 来删除一个数组中的项使用 splice 而不要使用 delete 来删除数组中的某个项。使用 delete 只是用 undefined 来替换掉原有的项，并不是真正的从数组中删除。 不要使用这种方式： 12345var items = [12, 548, 'a', 2, 5478, 'foo', 8852, , 'Doe', 2154, 119];items.length; // return 11delete items[3]; // return trueitems.length; // return 11/* items will be equal to [12, 548, \"a\", undefined × 1, 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119] */ 而使用： 12345var items = [12, 548, 'a', 2, 5478, 'foo', 8852, , 'Doe', 2154, 119];items.length; // return 11items.splice(3,1);items.length; // return 10/* items will be equal to [12, 548, \"a\", 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119] */ delete 方法应该被用来删除一个对象的某个属性。 使用逻辑 AND / OR 做条件判断这个技巧在一定程度上降低了可读性 123var foo = 10;foo == 10 &amp;&amp; doSomething(); // 等价于 if (foo == 10) doSomething();foo == 5 || doSomething(); // 等价于 if (foo != 5) doSomething(); 使用逻辑 OR 为函数参数设置默认值这个技巧实用到爆，尤其是开发插件的时候 不过 ES6 语法已经支持默认值了 123function doSomething(arg1) &#123; Arg1 = arg1 || 10; // 如果 arg1 没有被设置的话，Arg1 将被默认设成 10&#125; 浮点数问题这是一个需要注意的地方，但是计算机专业的人应该早就知道了吧 1230.1 + 0.2 === 0.3 // is false9007199254740992 + 1 // is equal to 90071992547409929007199254740992 + 2 // is equal to 9007199254740994 为什么会这样？ 0.1 + 0.2 等于 0.30000000000000004。这是因为，所有的 JavaScript 数字在内部都是以 64 位二进制表示的浮点数，符合 IEEE 754 标准。更多的介绍，可以阅读这篇博文。你可以使用 toFixed() 和 toPrecision() 方法解决这个问题。 使用 for-in 遍历一个对象内部属性的时候注意检查属性下面的代码片段能够避免在遍历一个对象属性的时候访问原型的属性 12345for (var name in object) &#123; if (object.hasOwnProperty(name)) &#123; // do something with name &#125;&#125; isFinite()在使用这个方法之前需要验证一下参数，因为 null 的存在 1234567isFinite(0/0) ; // falseisFinite(\"foo\"); // falseisFinite(\"10\"); // trueisFinite(10); // trueisFinite(undifined); // falseisFinite(); // falseisFinite(null); // true !!! 在调用 setTimeout() 和 setInterval() 的时候传入函数，而不是字符串如果你将字符串传递给 setTimeout() 或者 setInterval()，这个字符串将被如使用 eval 一样被解析，这个是非常耗时的 不要使用： 12setInterval('doSomethingPeriodically()', 1000);setTimeOut('doSomethingAfterFiveSeconds()', 5000) 而用: 12setInterval(doSomethingPeriodically, 1000);setTimeOut(doSomethingAfterFiveSeconds, 5000); 用 JavaScript 获取伪元素 (pseudo-element) 属性大家都知道如何通过一个元素的 style 属性获取它的 CSS 样式值，但能获取伪元素 (pseudo-element) 的属性值吗？可以的，使用 JavaScript 也可以访问页面中的伪元素。 123456789// Get the color value of .element:beforevar color = window.getComputedStyle( document.querySelector('.element'), ':before').getPropertyValue('color');// Get the content value of .element:beforevar content = window.getComputedStyle( document.querySelector('.element'), ':before').getPropertyValue('content'); classList API很多的 JavaScript 工具库里都有 addClass，removeClass 和 toggleClass 等方法。为了对老式浏览器的兼容，这些类库采用的方法都是先搜索元素的 className，追加和删除这个类，然后更新 className。其实有一个 API 提供了添加，删除和反转 CSS 类属性的方法，叫做 classList： 123myDiv.classList.add('myCssClass'); // Adds a classmyDiv.classList.remove('myCssClass'); // Removes a classmyDiv.classList.toggle('myCssClass'); // Toggles a class 直接对样式表进行添加和删除样式规则我们都非常熟悉使用 element.style.propertyName 来修改样式，使用 JavaScript 能帮助我们做到这些，但你知道如何新增或修一个现有的 CSS 样式规则吗？其实非常的简单。 1234567891011function addCSSRule(sheet, selector, rules, index) &#123; if(sheet.insertRule) &#123; sheet.insertRule(selector + \"&#123;\" + rules + \"&#125;\", index); &#125; else &#123; sheet.addRule(selector, rules, index); &#125;&#125;// Use it!addCSSRule(document.styleSheets[0], \"header\", \"float: left\"); 加载 CSS 文件延迟加载图片、JSON、脚本等是用来加快页面显示速度的好方法。我们可以使用 curl.js 等这样 JavaScript 加载器来延迟加载这些外部资源，可你知道 CSS 样式表也可以延迟加载吗，而且在加载成功后回调函数会给予通知。 1234567891011curl( [ \"namespace/MyWidget\", \"css!namespace/resources/MyWidget.css\" ], function(MyWidget) &#123; // 你可以对MyWidget进行操作 // 这里没有对这个CSS文件引用，因为不需要; // 我们只需要它已经加载到页面上了 &#125;&#125;); CSS 鼠标指针事件CSS 鼠标指针事件 pointer-events 属性非常的有趣，它的功效非常像 JavaScript，当你把这个属性设置为 none 时，它能有效的阻止禁止这个元素，你也许会说“这又如何？”，但事实上，它是禁止了这个元素上的任何 JavaScript 事件或回调函数！ 1.disabled &#123; pointer-events: none; &#125; 点击这个元素，你会发现任何你放置在这个元素上的监听器都不会触发任何事件。一个神奇的功能——你不再需要为了防止某个事件会被触发而去检查某个 css 类是否存在。 拓展阅读 45个实用的JavaScript技巧、窍门和最佳实践 5种你未必知道的JavaScript和CSS交互的方法","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://merrier.wang/tags/技巧/"},{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"}]},{"title":"前端可以这样玩儿！","slug":"前端可以这样玩儿！","date":"2017-04-12T13:36:41.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170412/front-end-can-play-like-this.html","link":"","permalink":"http://merrier.wang/20170412/front-end-can-play-like-this.html","excerpt":"","text":"本文总结了一些前端冷知识，相信看完之后的你一定会觉得前端为什么如此好玩儿？！（源自 Quora 上的一个帖子，同时又查阅了一些其他资料） HTML 篇浏览器地址栏运行 JavaScript 代码这个相信很多人是知道的，在浏览器地址栏可以直接运行 JavaScript 代码，做法是以 javascript: 开头后跟要执行的语句。比如： 1javascript:alert('hello \bMerrier :)'); 将以上代码贴到浏览器地址栏回车后 alert 正常执行，一个弹窗神现。需要注意的是如果是通过 copy paste 代码到浏览器地址栏的话，IE 及 Chrome 会自动去掉代码开头的 javascript:，所以需要手动添加起来才能正确执行，而 Firefox 中虽然不会自动去掉，但它根本就不支持在地址栏运行 JS 代码，sigh~ 浏览器地址栏运行 HTML 代码如果说上面那条小秘密知道的人还算多的话，这条秘笈知道的人就要少一些了，在非 IE 内核的浏览器地址栏可以直接运行 HTML 代码！比如在地址栏输入以下代码然后回车运行，会出现指定的页面内容。 1data:text/html,&lt;h1&gt;Hello, world!&lt;/h1&gt; 你造么，可以把浏览器当编辑器还是浏览器地址栏上做文章，将以下代码贴到地址栏运行后浏览器变成了一个原始而简单的编辑器，与 Windows 自带的 notepad 一样，吼吼。 1data:text/html, &lt;html contenteditable&gt; 归根结底多亏了 HTML5 中新加的 contenteditable 属性，当元素指定了该属性后，元素的内容成为可编辑状态。 整个页面变得可编辑将以下代码放到 console 执行后，整个页面将变得可编辑，随意践踏吧~ 1document.body.contentEditable='true'; 利用 a 标签自动解析 URL很多时候我们有从一个 URL 中提取域名，查询关键字，变量参数值等的需要，而万万没想到可以让浏览器方便地帮我们完成这一任务而不用我们写正则去抓取。方法就在 JS 代码里先创建一个a标签然后将需要解析的 URL 赋值给 a 的 href 属性，然后就得到了一切我们想要的了。 123var a = document.createElement('a');a.href = 'http://www.cnblogs.com/wayou/p/';console.log(a.host); 利用这一原理，稍微扩展一下，就得到了一个更加健壮的解析 URL 各部分的通用方法了 123456789101112131415161718192021222324252627function parseURL(url) &#123; var a = document.createElement('a'); a.href = url; return &#123; source: url, protocol: a.protocol.replace(':',''), host: a.hostname, port: a.port, query: a.search, params: (function()&#123; var ret = &#123;&#125;, seg = a.search.replace(/^\\?/,'').split('&amp;'), len = seg.length, i = 0, s; for (;i&lt;len;i++) &#123; if (!seg[i]) &#123; continue; &#125; s = seg[i].split('='); ret[s[0]] = s[1]; &#125; return ret; &#125;)(), file: (a.pathname.match(/\\/([^\\/?#]+)$/i) || [,''])[1], hash: a.hash.replace('#',''), path: a.pathname.replace(/^([^\\/])/,'/$1'), relative: (a.href.match(/tps?:\\/\\/[^\\/]+(.+)/) || [,''])[1], segments: a.pathname.replace(/^\\//,'').split('/') &#125;;&#125; 页面拥有 ID 的元素会创建全局变量在一张 HTML 页面中，所有设置了 ID 属性的元素会在 JavaScript 的执行环境中创建对应的全局变量，这意味着 document.getElementById 像人的阑尾一样显得多余了。但实际项目中最好老老实实该怎么写就怎么写，毕竟常规代码出乱子的机会要小得多。 1234&lt;div id=\"sample\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; console.log(sample);&lt;/script&gt; 加载 CDN 文件时，可以省掉 HTTP 标识现在很流行的 CDN 即从专门的服务器加载一些通用的 JS 和 CSS 文件，出于安全考虑有的 CDN 服务器使用 HTTPS 方式连接，而有的是传统的 HTTP，其实我们在使用时可以忽略掉这个，将它从 URL 中省去。 1&lt;script src=\"//domain.com/path/to/script.js\"&gt;&lt;/script&gt; 利用 script 标签保存任意信息将 script 标签设置为 type=’text’ 然后可以在里面保存任意信息，之后可以在 JavaScript 代码中很方便地获取。 123&lt;script type=\"text\" id=\"template\"&gt; &lt;h1&gt;This won't display&lt;/h1&gt;&lt;/script&gt; 1var text = document.getElementById('template').innerHTML CSS 篇我的鼠标呢？相信你看完以下代码后能够预料到会出现什么效果。 123*&#123; cursor: none!important;&#125; 简单的文字模糊效果以下两行简单的 CSS3 代码可达到将文字模糊化处理的目的，出来的效果有点像使用 PS 的滤镜，so cool! 1234p &#123; color: transparent; text-shadow: #111 0 0 5px;&#125; 垂直居中当然你可以将容器设置为 display: table，然后将子元素也就是要垂直居中显示的元素设置为 display: table-cell，然后加上 vertical-align: middle 来实现，但此种实现往往会因为 display: table 而破坏整体布局，那还不如直接用 table 标签了呢。下面这个样式利用了 translate 来巧妙实现了垂直居中样式，需 IE9+。 12345.center-vertical &#123; position: relative; top: 50%; transform: translateY(-50%);&#125; 相比而言，水平居中要简单得多，像上面提到的 text-align: center，经常用到的技巧还有 margin: 0 auto。但对于 margin 大法也只在子元素宽度小于容器宽度时管用，当子元素宽度大于容器宽度时此法失效。如法炮制，利用 left 和 transform 同样可实现水平居中，不过意义不大，毕竟 text-align 和 margin 差不多满足需求了。 12345.center-horizontal &#123; position: relative; left: 50%; transform: translateX(-50%); &#125; 多重边框利用重复指定 box-shadow 来达到多个边框的效果 12345678910/* CSS Border with Box-Shadow Example */div &#123; box-shadow: 0 0 0 6px rgba(0, 0, 0, 0.2), 0 0 0 12px rgba(0, 0, 0, 0.2), 0 0 0 18px rgba(0, 0, 0, 0.2), 0 0 0 24px rgba(0, 0, 0, 0.2); height: 200px; margin: 50px auto; width: 400px&#125; 实时编辑 CSS通过设置 style 标签的 display: block 样式可以让页面的 style 标签显示出来，并且加上 contentEditable 属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现的。此技巧在 IE 下无效。拥有此技能者，逆天也！ 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;style style=\"display:block\" contentEditable&gt; body &#123; color: blue &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt; 创建长宽比固定的元素通过设置父级窗口的 padding-bottom 可以达到让容器保持一定的长度比的目的，这在响应式页面设计中比较有用，能够保持元素不变形。 12345&lt;div style=\"width: 100%; position: relative; padding-bottom: 20%;\"&gt; &lt;div style=\"position: absolute; left: 0; top: 0; right: 0; bottom: 0;background-color:yellow;\"&gt; this content will have a constant aspect ratio that varies based on the width. &lt;/div&gt;&lt;/div&gt; CSS 中也可以做简单运算通过 CSS 中的 calc 方法可以进行一些简单的运算，从而达到动态指定元素样式的目的。 123.container&#123; background-position: calc(100% - 50px) calc(100% - 20px);&#125; JavaScript 篇生成随机字符串利用 Math.random 和 toString 生成随机字符串，来自前一阵子看到的一篇博文。这里的技巧是利用了 toString 方法可以接收一个基数作为参数的原理，这个基数从 2 到 36 封顶。如果不指定，默认基数是 10 进制。略屌！ 1234567function generateRandomAlphaNum(len) &#123; var rdmString = \"\"; for (; rdmString.length &lt; len; )&#123; rdmString += Math.random().toString(36).substr(2); &#125; return rdmString.substr(0, len);&#125; 整数的操作JavaScript 中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。|0 和 ~~ 是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的 parseInt, Math.round 要快。在处理像素及动画位移等效果的时候会很有用。性能比较见此。 12var foo = (12.4 / 4.13) | 0; // 结果为3var bar = ~~(12.4 / 4.13); // 结果为3 重写原生浏览器方法以实现新功能下面的代码通过重写浏览器的 alert 让它可以记录弹窗的次数。 123456789(function() &#123; var oldAlert = window.alert, count = 0; window.alert = function(a) &#123; count ++; oldAlert(a + \"\\n You've called alert \" + count + \" times now. Stop, it's evil!\"); &#125;;&#125;)();alert(\"Hello World\"); console 显示图片以及为文字加样式在 Chrome 的开发者工具里，console 可以加样式，可以显示缤纷的颜色，甚至图片。简直爽翻了。具体来说，是可以对输出到 console 控制台的文字进行 CSS 控制。格式如下： 1console.log(\"%c需要输出的信息 \", \"css 代码\"); 下面是一些已经写好的 console 新玩法代码，可以在 chrome 控制台里面实测（关于 console 的更多玩法，推荐 MDN关于console的文档）： 1. 3D Text123console.log(\"%c3D Text\",\" text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em\") 2. Colorful CSS123456789101112131415console.log(\"%cColorful CSS\",\"background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em\") 3. Rainbow Text123console.log('%cRainbow Text ', 'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;'); 4. 输出图片1console.log(\"%c\", \"padding:50px 300px;line-height:120px;background:url('https://ss0.bdstatic.com/5aV1bjqh\\_Q23odCf/static/superman/img/logo/bd\\_logo1_31bdc765.png') no-repeat;\"); 不声明第三个变量的值交换我们都知道交换两个变量值的常规做法，那就是声明一个中间变量来暂存。但鲜有人去挑战不声明中间变量的情况，下面的代码给出了这种实现。蛮有创意的。 12var a = 1, b = 2;a= [b, b = a][0]; 万物皆对象在 JavaScript 的世界，万物皆对象。除了 null 和 undefined，其他基本类型数字，字符串和布尔值都有对应有包装对象。对象的一个特征是你可以在它身上直接调用方法。对于数字基本类型，当试图在其身上调用 toString 方法会失败，但用括号括起来后再调用就不会失败了，内部实现是用相应的包装对象将基本类型转为对象。所以 (1).toString() 相当于 new Number(1).toString()。因此，你的确可以把基本类型数字，字符串，布尔等当对象使用的，只是注意语法要得体。同时我们注意到，JavaScript 中数字是不分浮点和整形的，所有数字其实均是浮点类型，只是把小数点省略了而已，比如你看到的 1 可以写成 1.，这也就是为什么当你试图 1.toString() 时会报错，所以正确的写法应该是这样：1..toString()，或者如上面所述加上括号，这里括号的作用是纠正 JS 解析器，不要把 1 后面的点当成小数点。内部实现如上面所述，是将 1. 用包装对象转成对象再调用方法。 If 语句的变形当你需要写一个 if 语句的时候，不妨尝试另一种更简便的方法，用 JavaScript 中的逻辑操作符来代替。 1234567var day = (new Date).getDay() === 0;//传统if语句if (day) &#123; alert('Today is Sunday!');&#125;;//运用逻辑与代替ifday &amp;&amp; alert('Today is Sunday!'); 比如上面的代码，首先得到今天的日期，如果是星期天，则弹窗，否则什么也不做。我们知道逻辑操作存在短路的情况，对于逻辑与表达式，只有两者都真才结果才为真，如果前面的 day 变量被判断为假了，那么对于整个与表达式来说结果就是假，所以就不会继续去执行后面的 alert 了，如果前面 day 为真，则还要继续执行后面的代码来确定整个表达式的真假。利用这点达到了 if 的效果。 禁止别人以 iframe 加载你的页面下面的代码已经不言自明了，没什么好多说的。 123if (window.location != window.parent.location) &#123; window.parent.location = window.location;&#125; 参考文章 What are the most interesting HTML/JS/DOM/CSS hacks that most web developers don’t know about? 前端不为人知的一面–前端冷知识集锦","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"技巧","slug":"技巧","permalink":"http://merrier.wang/tags/技巧/"},{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://merrier.wang/tags/HTML/"}]},{"title":"前端面试系列（11）——window.onload和document.ready的区别","slug":"前端面试系列（11）——window.onload和document.ready的区别","date":"2017-04-12T09:14:30.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170412/the-difference-between-window.onload-and-document.read.html","link":"","permalink":"http://merrier.wang/20170412/the-difference-between-window.onload-and-document.read.html","excerpt":"","text":"这个问题虽然比较简单，但是依然是前端面试中经常会问到的一道题，所以为了让自己“与众不同”，必须全面了解这两者的区别，才能从众多候选人中脱颖而出 一张表格下面这张表格简单的介绍了两者的区别： /daizhengli/[table id=14 /] jQ 的 document.ready() 实现在 jQuery 脚本加载的时候，会监听 DOMContentLoaded 事件。当事件触发时候，会执行 ready 事件的回调；（document.readyState === “complete” 时相当于 dom 加载完毕由于用的是原生的 DOMContentLoaded 事件，所以目前的 ready 函数仅能用于当前 document，无需选择器 谁更快jQuery 的 document.ready 就一定比 window.onload 快吗？下面是一个例子： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"/&gt;&lt;title&gt;加载时机&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.js\"onload=\"console.log('jquery.js loaded')\"&gt;&lt;/script&gt;&lt;script&gt; console.log('define functions'); function load(type, info)&#123; console.log(type + ' onload ' + (info || \"\"), new Date().getTime()); &#125; $(document).ready(function () &#123; load('document ready'); &#125;); document.onload = function () &#123; load('document'); &#125;; window.onload = function () &#123; load('window'); &#125;; window.addEventListener(\"load\",function()&#123; load('window addEventListener'); &#125;); document.addEventListener( \"DOMContentLoaded\", function () &#123; load('DOMContentLoaded'); &#125;);&lt;/script&gt;&lt;/head&gt; &lt;body onload=\"load('body')\"&gt; &lt;div onload=\"load('text')\"&gt;test&lt;/div&gt; &lt;img onload=\"load('img',1)\" src=\"http://www.deskcar.com/desktop/else/2013714232149/17.jpg\" /&gt; &lt;img onload=\"load('img',2)\" src=\"http://www.deskcar.com/desktop/else/2013714232149/16.jpg\" /&gt; &lt;script onload=\"load('js')\" src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.2.0/react.min.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 执行之后有两种结果：首次加载： 二次加载： 第一种情况非常符合我们的想法，ready 比 onload 快，顺序也比较合理。而第二种情况就有些怪异，应该依照上面 jquery ready 事件的实现，那 ready 应该要 DOMContentLoaded 后面啊。我思来想去，我觉得这是个误会，由于二次加载时利用到缓存，导致文件资源都很快加载，各个事件触发的时间非常相近，顺序也不定，就给人一种 ready 顺序不对之感，大家应该发现这几个事件都是在几十毫秒之内触发。PS：js 执行需要时间，几十毫秒不同的顺序我觉得很正常。另外尝试几次，二次加载顺序确实会有变化，但时间都很相近。所以，jQuery 的 document ready 不一定比 window.onload 快执行。 为什么外部 script 文件放页面内容后面好？script 执行顺序 无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照 &lt;script&gt; 元素在页面中出现的先后顺序对它们依次进行解析。——《JavaScript高级程序设计》 换句话说，在第一个 &lt;script&gt; 元素包含的代码解析完成后，第二个 &lt;script&gt; 包含代码才会被解析，然后才是第三个…..如果在 head 元素里包含所有 JavaScript 文件，就必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能呈现页面的内容（浏览器在遇到 &lt;body&gt; 标签时才开始呈现内容）。在有 JavaScript 文件时候，浏览器呈现页面会出现明显的延迟，延时期间浏览器是一片空白。所以，外部 script 文件放页面内容后面。这样，在解析 JavaScript 代码之前，页面内容将完全呈现出来。 一定是放页面内容后面吗？有种情况是 JavaScript 放哪里都一样的，那就是内容是依赖 JavaScript 的执行渲染时候，放哪都一样。所以我们需要尽量避免在 JS 中对 dom 进行修改，对于性能优化有比较大的帮助。 Load() 方法由于在 $(document).ready() 方法内注册的事件，只要 DOM 就绪就会被执行，因此可能此时元素的关联文件未下载完。例如与图片有关的 html 下载完毕，并且已经解析为 DOM 树了，但很有可能图片还没有加载完毕，所以例如图片的高度和宽度这样的属性此时不一定有效。要解决这个问题，可以使用 Jquery 中另一个关于页面加载的方法—— load() 方法。Load() 方法会在元素的 onload 事件中绑定一个处理函数。如果处理函数绑定给 window 对象，则会在所有内容（包括窗口、框架、对象和图像等）加载完毕后触发，如果处理函数绑定在元素上，则会在元素的内容加载完毕后触发。 其他方法 $(window).load()：等价于 window.onload() $(window).unload()：页面关闭时触发 坑爹的 IE or jQ？最近在改一个嵌入在 iframe 中的页面的时候，使用了 jquery 做效果，而页面本身也绑定了 onload 事件。改完后，Firefox 下测试正常流畅，IE 下就要等个十几秒 jquery 的效果才出现，黄花菜都凉了。起初以为是和本身 onload 加载的方法冲突。网上普遍的说法是 $(document).ready() 是在页面 DOM 解析完成后执行，而 onload 事件是在所有资源都准备完成之后才执行，也就是说 $(document).ready() 是要在 onload 之前执行的，尤其当页面图片较大较多的时候，这个时间差可能更大。可是我这页面分明是图片都显示出来十几秒了，还不见 jquery 的效果出来。 删了 onload 加载的方法试试，结果还是一样，看来没有必要把原本的 onload 事件绑定也改用 $(document).ready() 来写。那是什么原因使得 Firefox 正常而 IE 就能呢？接着调试，发现 IE 下原来绑定的 onload 方法竟然先于 $(document).ready() 的内容执行，而 Firefox 则是先执行 $(document).ready() 的内容，再执行原来的 onload 方法。这个和网上的说法似乎不完全一致啊，走投无路的时候就看看源码，翻翻 jQuery 的源码看看 $(document).ready() 是如何实现的吧： 123456789101112if ( jQuery.browser.msie &amp;&amp; window == top ) (function()&#123; if (jQuery.isReady) return; try &#123; document.documentElement.doScroll(\"left\"); &#125; catch( error ) &#123; setTimeout( arguments.callee, 0 ); return; &#125; // and execute any waiting functions jQuery.ready(); &#125;)(); jQuery.event.add( window, \"load\", jQuery.ready ); 结果很明了了，IE 只有在页面不是嵌入 iframe 中的情况下才和 Firefox 等一样，先执行 $(document).ready() 的内容，再执行原来的 onload 方法。对于嵌入 iframe 中的页面，也只是绑定在 load 事件上执行，所以自然是在原来的 onload 绑定的方法执行之后才轮到。而这个页面中正好在测试环境下有一个访问不到的资源，那十几秒的延迟正是它放大出的时间差。 参考文章 一张表格告诉你windows.onload()与$(document).ready()的区别 jQuery的document ready与 onload事件——你真的思考过吗？","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"}]},{"title":"读书笔记系列（6）——大话数据结构","slug":"读书笔记系列（6）——大话数据结构","date":"2017-04-08T12:50:00.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170408/dahua-data-structure.html","link":"","permalink":"http://merrier.wang/20170408/dahua-data-structure.html","excerpt":"","text":"这本书我是在网上下载的电子版，所以可能会有一些错别字，但是无伤大雅；《大话数据结构》被誉为程序员面试必读书籍，我大概用了 3 天的时间详读了一遍，感觉作者的文笔很好，而且很擅长通过生活中的小故事总结相关知识和算法思路，对于计算机初级童鞋来说是一本很好的数据结构入门读物，而且作者对于代码的讲解很详尽，接近逐行解释了，和其他数据结构的书籍形成了鲜明的对比，总体评价五星吧；不过我是在刷完 Leetcode 的 easy 题才看的这本书，感觉先看这本书再刷题的话会好很多 一、数据结构与算法1、如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子2、数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科3、数据元素的存储结构形式有两种：顺序存储和链式存储 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（谁也别插谁的队） 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的（需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置） 4、算法具有五个基本特性：输入、输出、有穷性、确定性和可行性5、好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征6、推导时间复杂度大 O 阶方法： 用常数 1 取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除与这个项相乘的常数 7、循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数8、常见的时间复杂度所耗费的时间： 9、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别制定，我们提到的运行时间都是最坏情况的运行时间 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间 10、算法的空间复杂度算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数 二、线性表1、描述顺序存储结构需要三个属性： 存储空间的起始位置：数组 data，它的存储位置就是存储空间的存储位置 线性表的最大存储容量：数组长度 MaxSize 线性表的当前长度：length 2、插入算法的思路： 如果插入位置不合理，抛出异常 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置 将要插入元素填入位置 i 处 表长加 1 3、删除算法的思路： 如果删除位置不合理，抛出异常 取出删除元素 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置 表长减 1 4、线性表的顺序存储结构的优缺点：优点： 无须为表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速地存取表中任一位置的元素 缺点： 插入和删除操作需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容量 造成存储空间的“碎片” 5、单链表n 个结点（ai 的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起 有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针： 6、头指针与头结点的异同头指针 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 头指针具有标识作用，所以常用头指针冠以链表的名字 无论链表是否为空，头指针均不为空。头指针式链表的必要元素 头结点 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度） 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了 头结点不一定是链表必须要素 7、获取链表第 i 个数据的算法思路 声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1 若到链表末尾 p 为空，则说明第 i 个元素不存在 否则查找成功，返回结点 p 的数据 8、单链表第 i 个数据插入结点的算法思路 声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1 若到链表末尾 p 为空，则说明第 i 个元素不存在 否则查找成功，在系统中生成一个空结点 s 将数据元素 e 赋值给 s -&gt; data 单链表的插入标准语句 s-&gt;next=p-&gt;next;p-&gt;next=s 返回成功 9、单链表第 i 个数据删除结点的算法思路 声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1 若到链表末尾 p 为空，则说明第 i 个元素不存在 否则查找成功，\b将欲删除的结点 p -&gt; next 赋值给 q 单链表的删除标准语句 p-&gt;next=q-&gt;next 将 q 结点中的数据赋值给 e，作为返回 释放 q 结点 返回成功 10、单链表整表创建的算法思路 声明一结点 p 和计数器变量 i 初始化一空链表 L 让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表 循环： 生成一新结点赋值给 p 随机生成一数字赋值给 p 的数据域 p-&gt;data 将 p 插入到头结点与前一新节点之间 11、单链表的整表删除 声明一结点 p 和 q 将第一个结点赋值给 p 循环： 将下一结点赋值给 q 释放 p 将 q 赋值给 p 12、单链表结构和顺序存储结构做对比 13、所谓的成功男人就是 3 岁时不尿裤子，5 岁能自己吃饭……80 岁能自己吃饭，90 岁能不尿裤子14、循环链表将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）: 循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断 p-&gt;next 是否为空，现在则是 p-&gt;next 不等于头结点，则循环未结束 15、合并两个循环链表 12345p=rearA-&gt;next; /* 保存A表的头结点，即① */rearA-&gt;next=rearB-&gt;next-&gt;next; /* 将本是指向B表的第一个结点（不是头结点） */ /* 赋值给rearA-&gt;next，即 ②*/rearB-&gt;next=p; /* 将原A表的头结点赋值给rearB-&gt;next，即③ */free(p); /* 释放p */ 16、双向链表双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域 17、双向链表的插入假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间需要下面几步： 1234s-&gt;prior=p; /* 把 p 赋值给 s 的前驱，如图中① */s-&gt;next=p-&gt;next; /* 把 p-&gt;next 赋值给 s 的后继，如图中② */p-&gt;next-&gt;prior=s; /* 把 s 赋值给 p-&gt;next 的前驱，如图中③ */p-&gt;next=s; /* 把 s 赋值给 p 的后继，如图中④ */ 18、线性表的总结 三、栈与队列1、栈的定义栈（stack）是限定仅在表尾进行插入和删除操作的线性表，我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈 2、当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定位 top 等于 -1（索引值从 0 开始）3、用一个数组来存储两个栈 数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 n - 1 处。这样，如果两个栈增加元素，就是两端点向中间延伸 两个栈见面之时，也就是两个指针之间相差 1 时，即 top1 + 1 == top2为栈满 4、递归定义一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数；每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出 5、队列定义队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表；允许插入的一端称为队尾，允许删除的一端称为队头 6、队列的链式存储结构队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；队头指针指向链队列的头结点，而队尾指针指向终端结点： 空队列时，front 和 rear 都指向头结点 7、在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列8、栈和队列的存储结构 9、关于栈和队列的人生感悟人生，就像是一个很大的栈演变。出生时你赤条条地来到人世，慢慢地长大，渐渐地变老，最终还得赤条条地离开世间。人生，又仿佛是一天一天小小的栈重现。童年父母每天抱你不断地进出家门，壮年你每天奔波于家与事业之间，老年你每天独自蹒跚于养老院的门里屋前。人生，更需要有进栈出栈精神的体现。在哪里跌倒，就应该在哪里爬起来。无论陷入何等困境，只要抬头能仰望蓝天，就有希望，不断进取，你就可以让出头之日重现。困难不会永远存在，强者才能勇往直前。人生，其实就是一个大大的队列演变。无知童年、快乐少年，稚傲青年，成熟中年，安逸晚年。人生，又是一个又一个小小的队列重现。春夏秋冬轮回年年，早中晚夜循环天天。变化的是时间，不变的是你对未来执着的信念。人生，更需要有队列精神的体现。南极到北极，不过是南纬90度到北纬90度的队列，如果你中途犹豫，临时转向，也许你就只能和企鹅相伴永远。可事实上，无论哪个方向，只要你坚持到底，你都可以到达终点。 四、串（字符串）1、一首回文诗（李禺《两相思》） 枯眼望遥山隔水，往来曾见几心知？壶空怕酌一杯酒，笔下难成和韵诗。途路阻人离别久，讯音无雁寄回迟。孤灯夜守长寥寂，夫忆妻兮父忆儿。 更多回文诗可以戳我一下 2、英语单词中的字符串即使是 lover 也有个 over，即使是 friend 也有个 end，即使是 believe 也有个lie 3、关于字符串的一些概念空格串：是只包含空格的串，空格串是有内容有长度的，而且可以不止一个空格子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串子串在主串中的位置：就是子串的第一个字符在主串中的序号 4、Unicode 和 ASCII 编码\b计算机中的常用字符是使用标准的 ASCII 编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展 ASCII 码由 8 位二进制数表示一个字符，总共可以表示 256 个字符；可是换做全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了 Unicode 编码，比较常用的是由 16 位的二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和 ASCII 码兼容，Unicode 的前 256 个字符与 ASCII 码完全相同 5、两个字符串的比较给定两个串：s=”a1a2……an”，t=”b1b2……bm”，当满足以下条件之一时，s &lt; t n &lt; m，且 ai=bi（i=1，2，……n），例如当 s=”hap”，t=”happy”，就有 s &lt; t。因为 t 比 s 多出了两个字母 存在某个 k ≤ min(m,n)，使得 ai = bi（i=1，2，……，,k-1），ak &lt; bk，例如当 s=”happen”，t=”happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母（k 值），字母 e 的 ASCII 码是 101，而字母 y 的 ASCII 码是 121，显然 e &lt; y，所以 s &lt; t 五、树1、一些概念 结点拥有的子树数称为结点的度（Degree）； 度为 0 的结点称为叶节点（Leaf）或终端结点； 度不为 0 的结点称为非终端结点或分支结点； 除根结点之外，分支结点也成为内部结点树的度是树内各结点的度的最大值 树中结点的最大层次称为树的深度（Depth）或高度 2、线性表与树的结构 3、双亲表示法以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置；由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1： 这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，知道 parent 为 -1 时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，需要遍历整个结构。 4、多重链表表示法由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法；不过，树的每个结点的度，也就是孩子个数是不同的，所以可以设计两种方案来解决： 方案一：指针域的个数就等于树的度（树的度是树各个结点度的最大值） 其中 data 是数据域，child1 到 childd 是指针域，用来指向该结点的孩子结点，这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的 方案二：每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数 这种方法提升了空间利用率，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗 5、孩子表示法把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中： 6、双亲孩子表示法 7、孩子兄弟表示法任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟： data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址，这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树 8、二叉树特点 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点（没有子树或者有一棵子树都是可以的） 左子树和右子树是有顺序的，次序不能任意颠倒 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树 9、二叉树五种基本形态 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 10、特殊二叉树斜树所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树，这两者统称为斜树 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树 完全二叉树对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树： 完全二叉树的特点： 叶子结点只能出现在最下两层 最下层的叶子一定集中在左部连续位置 倒数二层，若有叶子结点，一定都在右部连续位置 如果结点度为 1，则该节点只有左孩子，即不存在只有右子树的情况 同样结点数的二叉树，完全二叉树的深度最小 11、二叉树的性质 在二叉树的第 i 层上至多有 2i-1 个结点（i ≥ 1） 深度为 k 的二叉树至多有 2k-1 个结点（k ≥ 1） 对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的节点数为 n2，则 n0 = n2 + 1（解释见下图） 具有 n 个结点的完全二叉树的深度为 ⌊log2n⌋ + 1（⌊x⌋ 表示不大于 x 的最大整数） 如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log2n⌋+1）的结点按层序编号（从第 1 层到第 ⌊log2n⌋ + 1 层，每层从左到右），对任一结点 i（1≤i≤n）有： 如果 i = 1，则结点i是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 ⌊i / 2⌋ 如果 2i &gt; n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左结点是结点 2i 如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1 12、二叉链表二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表： 其中 data 是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针 13、二叉树遍历方法前序遍历若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树，遍历的顺序为：ABDGHCEIF 中序遍历若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树，遍历的顺序为：GDHBAEICF 后序遍历若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点，遍历的顺序为：GHDBIEFCA 层序遍历若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序堆结点逐个访问，遍历的顺序为：ABCDEFGHI 14、两个二叉树遍历的性质 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 但是已知前序和后序遍历，是不能确定一棵二叉树的 15、线索二叉树指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树 通过上图（空心箭头实线为前驱，虚线黑箭头为后继），可以看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表；所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化；但是，我们并不知道某一结点的 lchild 是指向它的左孩子还是指向前驱，所以需要一个区分标致；因此，我们在每个结点再增设两个标志域 ltag 和 rtag，这两个 tag 只是存放 0 或 1 数字的布尔型变量，其占用的内存空间要小于像 lchild 和 rchild 的指针变量，结点结构如下： ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱 rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择 16、树转换为二叉树 加线，在所有兄弟结点之间加一条连线 去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子 17、森林转换为二叉树 把每个树转换为二叉树 第一棵二叉树不动，从第二棵二叉树开始，以此把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来，当所有的二叉树连接起来后就得到了由森林转换来的二叉树 18、二叉树转换为树 加线，若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接起来 去线，删除原二叉树中所有结点与其右孩子结点的连线 层次调整，使之结构层次分明 19、二叉树转换为森林判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树 再将每棵分离后的二叉树转换为树即可 20、树的遍历 一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树 另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点 21、森林的遍历 前序遍历：先访问森林中第一棵树的根结点，然后再依次先跟遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林 后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林 森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树中的中序遍历结果相同 22、赫夫曼树算法描述 根据给定的n个权值 {w1，w2，···wn} 构成 n 棵二叉树的集合 F={T1，T2，···Tn}，其中每个二叉树 Ti 中只有一个带权为 wi 的根结点，其左右子树均为空。 在 F 中选择两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。 在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。 重复 2 和 3，直到 F 只含一棵树为止。这棵树便是赫夫曼树。 23、赫夫曼编码一般地，设需要编码的字符集为 {d1，d2，···dn}，各个字符在电文中出现的次数或频率集合为 {w1，w2，···wn}，以 d1，d2，···dn 作为叶子结点，以 w1，w2，···wn 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码 六、图1、图的定义图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合 2、关于图的一些定义 无向边：若顶点 vi 到 vj 之间的边没有方向，则称这条边为无向边（Edge），用无需偶对（vi，vj）来表示 有向边：若从顶点 vi 到 vj 的边有方向，则称这条边为有向边，也成为弧（Arc）无向边用小括号 “()” 表示，而有向边则是用尖括号 “&lt;&gt;” 表示 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图 有很少条边或弧的图称为稀疏图，反之称为稠密图 这里稀疏和稠密是模糊的概念，是相对而言的 有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight） 带权的图通常称为网（Network） 假设有两个图 G =（V，{E}）和G’ =（V’，{E’}），如果 V’ ⊆ V 且 E’ ⊆ E，则称 G’ 为 G 的子图（Subgraph） 图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。 若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。 图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量 无向图中连通且n个顶点n-1条边叫生成树。 有向图中一顶点入度为0其余顶点入度为1的叫有向树。 一个有向图由若干棵有向树构成生成森林 由于定义实在太多，就不再叙述了，可以点击这里查看关于图的其他定义 3、图的邻接矩阵图的邻接矩阵（Adiacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息 n 个顶点和 e 条边的无向网图的创建，时间复杂度为 O（n+n2+e），其中对邻接矩阵的初始化需要耗费 O（n2）的时间 4、邻接表数组与链表相结合的存储方法称为邻接表 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息 图中每个顶点 vi 的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点 vi 的边表，有向图则称为顶点 vi 作为弧尾的出边表 若是有向图，邻接表结构是类似的，但我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度，但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点 vi 都建立一个链接为 vi 为弧头的表 对于带权值的网图，可以在边表结点定义中再增加一个 weight 的数据域，存储权值信息即可 5、图的遍历从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph） 6、深度优先遍历（DFS）从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止 7、广度优先遍历（BFS）如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了，如下图所示： 8、图的两种遍历方式的比较两者在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同，可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过，深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况 9、最小生成树我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）找连通网的最小生成树，经典的有两种算法，普利姆算法和克鲁斯卡尔算法 10、普利姆（Prim）算法算法思路：以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树 算法步骤： 输入：一个加权连通图，其中顶点集合为 V，边集合为 E； 初始化：Vnew = {x}，其中 x 为集合 V 中的任一节点（起始点），Enew = {}，为空； 重复下列操作，直到 Vnew = V： 在集合 E 中选取权值最小的边 &lt;u, v&gt;，其中 u 为集合 Vnew 中的元素，而 v 不在 Vnew 集合当中，并且 v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）； 将 v 加入集合 Vnew 中，将 &lt;u, v&gt; 边加入集合 Enew 中； 输出：使用集合 Vnew 和 Enew 来描述所得到的最小生成树。 书中有非常详尽的解释，但是感觉解释的比较繁琐，建议去看一下百度百科中的讲解 11、克鲁斯卡尔（Kruskal）算法算法思路：因为权值是在边上，所以直接去找最小权值的边来构建生成树，只不过构建时要考虑是否会形成环路而已 算法步骤：先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。关于这个算法，百度百科上的讲解就不是很清楚了，如果感兴趣的话可以自行查阅其他资料 12、Prim 算法和 Kruskal 算法的对比对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以堆于稀疏图有很大的优势；而普利姆算法对于稠密图，即边数非常多的情况会更好一些 13、最短路径对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点 主要有两种求最短路径的算法：迪杰斯特拉算法和 14、迪杰斯特拉（Dijkstra）算法算法步骤：G = {V,E} 初始时令 S = {V0}, T = V - S = {其余顶点}，T 中顶点对应的距离值 若存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 &lt;V0,Vi&gt; 弧上的权值 若不存在 &lt;V0,Vi&gt;，d(V0,Vi) 为 ∞ 从 T 中选取一个与 S 中顶点有关联边且权值最小的顶点 W，加入到 S 中 对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值 重复上述步骤 2、3，直到 S 中包含所有顶点，即 W = Vi 为止 15、弗洛伊德（Floyd）算法算法步骤： 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。 把图用邻接矩阵 G 表示出来，如果从 Vi 到 Vj 有路可达，则 G[i][j] = d，d 表示该路的长度；否则 G[i][j] = 无穷大。定义一个矩阵D用来记录所插入点的信息，D[i][j] 表示从 Vi 到 Vj 需要经过的点，初始化 D[i][j] = j。把各个顶点插入图中，比较插点后的距离与原来的距离，G[i][j] = min( G[i][j], G[i][k]+G[k][j])，如果 G[i][j] 的值变小，则 D[i][j] = k。在 G 中包含有两点之间最短道路的信息，而在 D 中则包含了最短通路径的信息。 比如，要寻找从 V5 到 V1 的路径。根据 D，假如 D(5,1) = 3 则说明从 V5 到 V1 经过 V3，路径为 {V5,V3,V1}，如果 D(5,3)=3，说明 V5 与 V3 直接相连，如果 D(3,1) = 1，说明 V3 与 V1 直接相连。 16、拓扑排序在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 AOV 网（Activity On Vertex Network）拓扑序列：设 G = (V,E)是一个具有 n 个顶点的有向图，V 中的顶点序列 V1，V2，……，Vn，满足若从顶点 Vi 到 Vj 有一条路径，则在顶点序列中顶点 Vi 必在顶点 Vj 之前。则我们称这样的顶点序列为一个拓扑序列拓扑排序：其实就是对一个有向图构造拓扑序列的过程；构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的 AOV 网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是 AOV 网。 17、拓扑排序算法对 AOV 网进行拓扑排序的基本思路是：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止 18、关键路径在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为 AOE 网（Activity On Edge Network）；我们把 AOE 网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点；正常情况下，AOE 网只有一个源点一个汇点，我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动 19、关键路径算法原理：我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。为此，我们需要定义如下几个参数： 事件的最早发生时间etv（earliest time of vertex）：即顶点 Vk 的最早发生时间 事件的最晚发生时间ltv（latest time of vertex）：即顶点 Vk 的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期 活动的最早开工时间ete（earliest time of edge）：即弧 ak 的最早发生时间 活动的最晚开工时间lte（latest time of edge）：即弧 ak 的最晚发生时间，也就是不推迟工期的最晚开工时间 我们是由 1 和 2 可以求得 3 和 4，然后再根据 ete[k] 是否与 lte[k] 相等来判断 ak 是否是关键活动 20、世界上最遥远的距离…… 世界上最遥远的距离，不是从南极到北极，而是我在讲解算法为何如此精妙，你却能够安详在课堂上休息。世界上最遥远的距离，不是珠峰与马里亚纳海沟的距离，而是我欲把古人的智慧全盘给你，你却不屑一顾毫不怜惜。世界上最遥远的距离，不是牛 A 与牛 C 之间狭小空隙，而是你们当中，有人在通往牛逼的路上一路狂奔，而有人步入大学校园就学会放弃。 七、查找1、查找概论 查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合 关键字（Key）是数据元素中某个数据项的值，又称为键值 若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（Primary Key） 那些可以识别多个数据元素（或记录）的关键字，我们称为次关键字（Secondary Key） 查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值得数据元素（或记录） 2、查找表操作方式分为两大种：静态查找表和动态查找表 静态查找表（Static Search Table）：只作查找操作的查找表。它的主要操作有： 查询某个“特定的”数据元素是否在查找表中 检索某个“特定的”数据元素和各种属性 动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个： 查找时插入数据元素 查找时删除数据元素 3、顺序查找顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是： 从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。 4、二分查找折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是： 在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止 5、插值查找插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])，对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多 6、斐波那契查找算法算法核心： 当 key = a[mid] 时，查找就成功 当 key &lt; a[mid] 时，新范围是第 low 个到第 mid - 1 个，此时范围个数为 F[k-1] - 1 个 当 key &gt; a[mid] 时，新范围是第 m + 1 个到第 high 个，此时范围个数为 F[k-2] - 1 个 7、三种查找算法的比较折半查找是进行加法与除法运算 (mid = (low + high) / 2)，插值查找进行复杂的四则运算(mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]))，而斐波那契查找只是最简单加减法运算(mid = low + F[k-1] - 1)，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率 8、线性索引索引就是把一个关键字与它对应的记录相关联的过程 所谓线性索引就是将索引项集合组织为线性结构，也称为索引表 三种线性索引：稠密索引、分块索引和倒排索引 9、稠密索引稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项 对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列 索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率 10、分块索引分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件： 块内无序：当然如果能够让块内有序对查找来说更理想 块间有序：只有块间有序，才有可能在查找时带来效率 分块索引的索引项结构分三个数据项： 最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大 存储了块中的记录个数，以便于循环时使用 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历 分块索引表中查找的步骤： 在分块索引表中查找要查关键字所在的块，可以利用折半、插值等算法 根据块首指针找到响应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找 11、倒排索引记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index） 倒排索引的优点就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长 12、二叉排序树二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值 它的左、右子树也分别为二叉排序树 如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。 13、平衡二叉树平衡二叉树（Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于 1；我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor），那么平衡二叉树上所有结点的平衡因子只可能是 -1，0，1 14、最小不平衡子树距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，我们称为最小不平衡子树 如上图所示，当新插入结点 37 时，距离它最近的平衡因子绝对值超过 1 的结点是 58（即它的左子树高度 2 减去右子树高度 0），所以从 58 开始以下的子树为最小不平衡子树 15、平衡二叉树实现算法算法原理：基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应地旋转，使之成为新的平衡子树 右旋操作： 左旋和右旋代码是对称的 16、多路查找树多路查找树（multi-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素 17、2-3 树2-3 树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）。 一个 2 结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似 一个 3 结点包含一小一大两个元素和三个孩子（或没有孩子），左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素 2-3 树中所有的叶子都在同一层次上 18、2-3树的插入实现可分为三种情况： 对于空树，插入一个 2 结点即可，这很容易理解 插入结点到一个 2 结点的叶子上。由于其本身就只有一个元素，所以只需要将其升级为 3 结点即可 要往 3 结点中插入一个新元素。因为 3 结点本身已经是 2-3 树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层 19、2-3-4树就是 2-3 树的概念扩展，包括了 4 结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个 4 结点要么没有孩子，要么具有 4 个孩子。如果某个 4 结点有孩子的话，从左到右按照由小到大的顺序排列 20、B树B树（B-tree）是一种平衡的多路查找树，2-3树和 2-3-4树都是 B树的特例。结点最大的孩子数目称为 B树的阶（order），因此，2-3树是 3 阶 B树，2-3-4树是 4 阶 B树 一个 m 阶的 B 树具有如下属性： 如果根结点不是叶节点，则其至少有两棵子树 每一个非根的分支结点都有 k-1 个元素和k个孩子，其中 ⌈m/2⌉ ≤ k ≤ m。每一个叶子节点 n 都有 k - 1 个元素，其中 ⌈m/2⌉ ≤ k ≤m 所有叶子结点都位于同一层次 所有分支结点包含下列信息数据（n,A0,K1,A1,K2,A2,…,Kn,An），其中：Ki(i=1,2,…,n) 为关键字，且 Ki&lt;Ki+1(i=1,2,…,n-1)；Ai(i=0,2,…,n) 为指向子树根结点的指针，且指针 A(i-1) 所指子树中所有结点的关键字均小于 Ki(i=1,2,…,n),An 所指子树中所有结点的关键字均大于 Kn，n·(⌈m/2⌉-1≤n≤m-1) 为关键字的个数（或 n + 1 为子树的个数） 21、B+树在 B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子节点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针 一棵 m 阶的 B+树和 m 阶的 B树的差异在于： 有 n 棵子树的结点中包含有 n 个关键字 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字 如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是沿着指向下一叶子结点的指针就可遍历所有的关键字 22、散列表（哈希表）散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)，散列技术既是一种存储方法，也是一种查找方法散列技术最适合的求解问题是查找与给定值相等的记录 f称为散列函数，又称为哈希（Hash）函数采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table） 散列过程有两步： 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录 23、散列函数构造方法直接定址法取关键字的某个线性函数值为散列地址 数字分析法如果我们的关键字是位数较多的数字，可以对数字进行翻转、右环位移、左环位移、甚至前两数与后两数叠加等方法，合理地将关键字分配到散列表的各位置 平方取中法假设关键字是 1234，那么它的平方就是 1522756，再抽取中间的 3 位就是 227，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况 折叠法将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况 比如我们的关键字是 9876543210，散列表表长为三位，我们将它分为四组，987|654|321|0，然后将它们叠加求和 987 + 654 + 321 + 0 = 1962，再求后 3 位得到散列地址为 962。 除留余数法对关键字直接取模，也可在折叠、平方取中后再取模，对于散列表长为 m 的散列函数公式为： f(key)=key mod p(p≤m) 根据前辈们的经验，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m）的最小质数或不包含小于 20 质因子的合数 随机数法选择一个随机数，取关键字的随机函数值为它的散列地址 24、采用不同的散列函数应该考虑的因素 计算散列地址所需的时间 关键字的长度 散列表的大小 关键字的分布情况 记录查找的频率 25、处理散列冲突的方法开放定址法一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入，公式是： fi(key)=（f(key)+di）MOD m(di=1,2,3,……,m-1) 这种解决冲突的开放定址法称为线性探测法如果 di 改进为正负两类值，等于是可以双向寻找到可能的空位置，可以不让关键字都聚集在某一块区域。我们称这种方法为二次探测法如果 di 采用随机函数计算得到，我们称之为随机探测法 再散列函数法我们事先准备多个散列函数，每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉 链地址法将所有关键字为同义词的记录存储在一个单链表红，我们称这种表尾同义词子表，在散列表中只存储所有同义词子表的头指针 公共溢出区法凡是冲突的都将它们存储到溢出表中 八、排序关于排序，推荐我的另一篇文章：\b十大排序算法的Javascript实现，这篇文章里有一些常见排序算法的实现步骤以及演示，是一个比较好的排序算法讲解 九、总结1、数据结构和算法数据结构和算法对于程序员的职业人生来说，那就是两个圆圈的交集部分，用心去掌握它，你的编程之路将会是坦途","categories":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://merrier.wang/tags/数据结构/"}]},{"title":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","slug":"读书笔记系列（5）——响应式Web设计-HTML5和CSS3实战","date":"2017-04-06T09:17:52.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170406/html5-and-css3-actual-warfare.html","link":"","permalink":"http://merrier.wang/20170406/html5-and-css3-actual-warfare.html","excerpt":"","text":"1. 一句话概括响应式设计如果要用一句话概括响应式网页设计，我觉得它是针对任意设备对网页内容进行完美布局的一种显示机制.相反，如果需要根据不同设备提供特定的内容和功能，那就需要一个真正的“手机版”网站.这种情况下，手机版网站会提供与桌面版网站完全不同的用户体验. 2. CSS reset 网站 http://meyerweb.com/eric/tools/css/reset/，Eric Meyer的原版，主要针对HTML4 http://meyerweb.com/eric/tools/css/reset/ http://necolas.github.com/normalize.css/，针对HTML5 3. CSS 网格系统 4. 地标角色属性role=”” 针对文档结构的各部分分别有如下的地标角色： application：用来定义用作网页应用的区域； banner：用来定义一个站点级别(而不是某个特定文档的)的区域.如网站的头部和logo； complementary：一个对页面主要区域进行补充说明的区域； contentinfo：与页面主要内容相关的信息区域，例如页脚的网站版权信息区域； form：定义表单，但是如果表单用于搜索，请使用search来替代； main：页面的主体内容； navigation：链向当前文档或相关文档的导航链接； search：一个用于搜索的区域。 5. 导航栏使用 table 显示模式123456789nav&#123; display: table;&#125;nav ul&#123; display: table-row;&#125;nav ul li&#123; display: table-cell;&#125; 这样做可以保证如果有另外的列表项追加进来，同样会自动地调整它们之间的间距。最后，使用 CSS3 选择器将最后一个列表项的文字置为右对齐，将第一个列表项的文字置为左对齐。 123456nav ul li:last-child &#123; text-align: right;&#125;nav ul li:first-child &#123; text-align: left;&#125; 6. 在响应式设计中使用自定义 @font-face 字体的注意事项唯一需要注意的，是在响应式设计中使用该技术时要考虑到字体文件大小。有些字体可能会非常庞大，如果你想保持网站的高性能，请注意控制自定义字体的文件尺寸。 7. 浮雕文字效果1text-shadow: 0 1px 0 hsla(0， 0%， 100%， 0.75); 不要模糊，不要水平阴影，仅在垂直方向设置 1 或 2 像素的”白影”即可。 8. 让整个屏幕飞舞1*&#123; transition: all 1s; &#125; 9. CSS3 实现 3D 变形效果在父级元素上设置透视，这样就开启了 3D 场景1.father&#123; -webkit-perspective: 200; &#125; 透视的值越大，就表示你的视点与 3D 场景之间的景深越大。因此，如果想要一点隐约的 3D 效果，就增大透视值；如果想要非常明显的 3D 效果，则减小透视值。 延续父元素的透视1.son&#123; -webkit-transform-style: perserve-3d; -webkit-transition: 1s; &#125; .father 类中添加的透视声明只会应用到其第一个子元素上。因此，为了延续父元素的透视，我们给 .son 元素设定了 preserve-3d (这样可以设置一个 3D 场景)。 当鼠标悬停在 .father 模块上时，我们给 .son 这个 div 添加一个翻转效果1.father:hover .son&#123; -webkit-transform: rotateY(180deg); &#125; 当海报翻转之后隐藏在其背面内容1.face &#123; position: absolute; -webkit-backface-visibility: hidden; &#125; .face 必须使用绝对定位，这样海报才能盖在 .back 这个 div 的上面 给 .back 加上 rotateY1.back &#123; -webkit-transform: rotateY(180deg); &#125; 不加这句的话，.back 这个 div 就会显示在正面海报之上。最终的 HTML 结构以及 CSS 样式如下: 12345678910&lt;section class=\"Qcontainer\"&gt; &lt;div class=\"film\"&gt; &lt;div class=\"face front\"&gt; &lt;img src=\"img/goonies.jpg\" alt=\"The Goonies\" /&gt; &lt;/div&gt; &lt;div class=\"face back\"&gt; &lt;h5&gt;HOT!&lt;/h5&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 1234567891011121314151617181920212223242526272829303132333435.Qcontainer &#123; height: 100%; width: 28%; position: relative; -webkit-perspective: 800; float: left; margin-right: 2%;&#125;.film &#123; width: 100%; height: 15em; -webkit-transform-style: preserve-3d; -webkit-transition: 1s;&#125;.Qcontainer:hover .film &#123; -webkit-transform: rotateY(180deg);&#125;.face &#123; position: absolute; -webkit-backface-visibility: hidden;&#125;.back &#123; width: 66%; height: 127%; -webkit-transform: rotateY(180deg); background: #3b3b3b; background: -webkit-linear-gradient(top， rgba(0，0，0，0.65) 0%， rgba(0，0，0，0) 100%); padding: 15%;&#125; 10. list(及对应的 datalist 元素)list 属性以及对应的 datalist 元素可以让用户在输入框中开始输入值的时候，显示一组备选值。下面是一个包含在 div 中的使用 list 属性及对应 datalist 元素的代码示例： 123456789101112&lt;div&gt; &lt;label for=\"awardWon\"&gt;Award Won&lt;/label&gt; &lt;input id=\"awardWon\" name=\"awardWon\" type=\"text\" list=\"awards\"&gt; &lt;datalist id=\"awards\"&gt; &lt;select&gt; &lt;option value=\"Best Picture\"&gt;&lt;/option&gt; &lt;option value=\"Best Director\"&gt;&lt;/option&gt; &lt;option value=\"Best Adapted Screenplay\"&gt;&lt;/option&gt; &lt;option value=\"Best Original Screenplay\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/datalist&gt;&lt;/div&gt; list 属性中的值（awards）同时也是 datalist 元素的 id。这样就可以让 datalist 与输入项关联起来。虽然将 option 包裹在 select 中不是必需的，但这样做便于为老版本浏览器提供降级方案。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/categories/笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://merrier.wang/tags/HTML/"},{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","slug":"读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道","date":"2017-04-06T08:42:13.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170406/the-way-to-practice-web-front-end-development.html","link":"","permalink":"http://merrier.wang/20170406/the-way-to-practice-web-front-end-development.html","excerpt":"","text":"1. Web 标准——结构、样式和行为的分离Web 标准由一系列标准组合而成，其核心理念就是将网页的结构，样式和行为分离开来，所以它可以分为三大部分：结构标准，央视标准和行为标准。结构标准包括 XML 标准，XHTML 标准，HTML 标准；样式标准主要是指 CSS 标准；行为标准主要包括 DOM 标准和 ECMAScript 标准。 2. 打造高品质的前端代码，提高代码的可维护性——精简，重用，有序精简的代码可以让文件变小，有利于客户端快速下载；重用可以让代码更易于精简，同时有助于提升开发速度；有序可以让我们更清晰地组织代码，使代码易于维护，有效应对变化。 3. 欲精一行，必先通十行在前端开发领域，不通十行就无法精一行。专精很难，甚至不可能，一专多能才是现实的。在前端开发这个领域，一专多能更是非常必要的。 4.增加代码可读性——注释一个好的代码，注释要占 1/3 的篇幅 5. 磨刀不误砍柴工——前期的构思很重要构思的内容主要包括规范的指定，公共组件的设计和复杂功能的技术方案等。一般来说，前期构思占整个项目 30% ~ 60% 的时间都算是正常的. 6. 标签的语义HTML 标签的设计都是有语义考虑的。下表是部分标签的全称和中文翻译： 其中，div 和 span 其实是没有语义的，它们只是分别用作块级元素和行内元素的区域分隔符。事实上，CSS 布局只是 Web 标准的一部分。在 HTML，CSS，JavaScript 这三大元素中，HTML 才是最重要的，结构才是重点，样式是用来修饰结构的。正确的做法是，先确定 HTML，确定语义的标签，再来选用合适的 CSS。 7. 如何确定你的标签是否语义良好判断网页标签语义是否良好的一个简单方法就是：去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性。除了去样式后的可读性外，值得重点提及的还有 h 标签。h 标签的含义是”标题”，搜索引擎对这个标签比较敏感，尤其是 h1 和 h2。一个语义良好的页面，h 标签应该是完整有序没有断层的。也就是说，要按照 h1，h2，h3，h4 这样依次排列下来，不要出现类似 h1，h2，h3，h4，漏掉 h2 的情况。 8. 常见模块标题和内容当页面内标签无法满足设计需要时，才会适当添加 div 和 span 等无语义标签来辅助实现。 表单12345678&lt;form action=\"\" method=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;登录表单&lt;/legend&gt; &lt;p&gt;&lt;label for=\"name\"&gt;账号：&lt;/label&gt;&lt;input type=\"text\" id=\"name\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"pw\"&gt;密码：&lt;/label&gt;&lt;input type=\"password\" id=\"pw\" /&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"subBtn\" /&gt; &lt;/fieldset&gt;&lt;/form&gt; 一般来说，表单域要用 fieldset 标签包起来，并用 legend 标签说明表单的用途。因为 fieldset 默认有边框，而 legend 也有默认的样式，为满足设计需要，我们可以将 fieldset 的 “border” 设为 “none”，把 legend 的 “display” 设为 “none”，以此来兼顾语义和设计两方面的要求。每个 input 标签对应的说明文本都需要 label1 标签，并且通过为 input 设置 id 属性，在 label 标签中设置 “for=someld” 来让说明文本和相应的 input 关联起来. 表格表格标题要用 caption，表头要用 thead 包围，主体部分用 tbody 包围，尾部要用 tfoot 包围，表头和一般单元格要区分开，表头用 th，一般单元格用 td。 9. 语义化标签应注意的一些其他问题为了保证网页去样式后的可读性，并且又符合 Web 标准，我们应注意以下几点： 尽可能少的使用无语义标签 div 和 span； 在语义不明显，既可以用 p 也可以用 div 的地方，尽量用 p，因为 p 默认情况下有上下间距，去样式后的可读性更好，对兼容特殊终端有利； 不要使用纯样式标签，例如 b，font 和 u 等，改用 CSS 设置。语义上需要强调的文本可以包在 strong 或 em 标签里，strong 和 em 有”强调”的语意，其中 strong 的默认样式是加粗，而 em 的默认样式是斜体。 10. 如何组织 CSS一种组织 CSS 的方法：base.css+common.css+page.css。将网站内的所有样式，按照职能分成三大类：base，common 和 page。 base 层这一层位于三者的最底层，提供 CSS reset 功能和粒度最小的通用类——原子类。这一层会被所有页面引用，是页面样式所需依赖的最底层。这一层与具体 UI 无关，无论何种风格的设计都可以引用它，所以 base 层要力求精简和通用。base 层具有高度可移植性，不同设计风格的网站可以使用同一个 base 层. base 层相对稳定，基本上不需要维护。 common 层这一层位于中间，提供组件级的 CSS 类。我们可以将页面内的元素拆分成一小块一小块功能和样式相对独立的小”模块”，这些”模块”有些是很少重复的，有些是会大量重复的，我们可以将大量重复的”模块”视为一个组件。我们从页面里尽可能多的将组件提取出来，放在 common 层里。common 层就相当于 MVC 模式中的 M(Model，模型)。为了保证重用性和灵活性，M 需要尽可能将内部实现封装，对可能会经常变化的部分提供灵活的接口。common 层是网站级的，不同的网站有不同的 common 层，同一个网站只有一个 common 层。在团队合作中，common 层最好由一个人负责，统一管理。 page 层网站中高度重用的模块，我们把它们视为组件，放在 common 层；非高度重用的模块，可以把它们放在 page 层。page 层位于最高层，提供页面级的样式，对重用性没有要求。base 层基本上不需要维护，common 层修改的幅度不会很大，通常只由一个人负责维护，但到了 page 层，代码可能由多人开发，如何避免冲突是个需要注意的问题。通常我们通过命名规则来避免这种冲突。 11. 推荐的 base.css通常情况下，为了让浮动元素的父容器能够根据浮动元素的高度而自适应高度，有三种做法： 让父容器同时浮动起来，例如：&lt;div class=&quot;fl&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;； 让浮动元素后面紧跟一个用于清楚浮动的空标签，例如 &lt;div&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;div class=&quot;cb&quot;&gt;&lt;/div&gt;&lt;/div&gt;； 给父容器挂一个特殊 class，直接从父容器清除浮动元素的浮动，例如 &lt;div class=&quot;clearfix&quot;&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt; 第一种方法会让父容器也浮动起来，影响父元素后面的元素的布局，有副作用；第二种方法增加了一个空标签，破坏了语义化。第三种方法没有任何副作用，推荐使用。 12345678910.clearfix:after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; display:inline-block;&#125; 12. 拆分模块 模块与模块之间尽量不要包含相同的部分，如果有相同部分，应将它们提取出来，拆分成一个独立的模块. 模块应在保证数量尽可能少的原则下，做到尽可能简单，以提高重用性. ##13. CSS 的命名 推荐使用英语，不要使用汉语拼音。我们可以根据内容来选用合适的英文单词命名 CSS。比如头部用 head，底部用 foot，主体部分用 main，导航用 nav，菜单用 menu 等，page 层 css 命名不可过短，可以将开发人员名字缩写作为前缀，以免发生冲突。 14. 挂多个 class 还是新建 class——多用组合，少用继承在面向对象编程里，有个很重要的原则就是”多用组合，少用继承”. HTML 的 class 与程序中”类”有相同的”味道”，class 可以挂多个，从技术上支持了”组合”的用法。我们在使用 CSS 时，如果能灵活运用这点就可以大大减少类的数量，一方面减少了代码量，提高了可维护性，另一方面时类的职责更单一，弹性更强，增加了类的重用性，提高了开发效率。 15 .组件的 margin如果对相邻的模块同时使用了 margin-top 和 margin-bottom，边距会重合带来不必要的麻烦，所以最好统一使用 margin-top 或者 margin-bottom，不要混合使用，从而降低出现问题的风险。总结：如果不确定模块的上下 margin 特别稳定，最好不要将它写到模块的类里，而是使用类的祝贺，单独为上下 margin 挂用于边距的原子类(例如 mt10，mb20)。模块最好不要混用 margin-top 和 margin-bottom，统一使用 margin-top 或 margin-bottom。 16. 低权重原则——避免滥用子选择器除非确定 HTML 结构非常稳定，一定不会再修改了，否则尽量不要使用子选择器。为了保证样式容易被覆盖，提高可维护性，CSS 选择符需保证权重尽可能低。 17. CSS sprit 技术CSS sprite 技术看似简单，其实不容易掌握，主要有如下原因: 它能合并的只能是用于背景的图片，对于 &lt;img src=&quot;&quot; /&gt; 设置的图片，是不能合并到 CSS sprite 大图中的，如果合并这些图片会影响页面可读性。 对于横向和纵向都平铺的图片，也不能使用 CSS sprite；如果是横向平铺的，只能将所有横向平铺的图合并成一张大图，只能竖直排列，不能水平排列；如果是纵向平铺的，我们只能将所有纵向平铺的图合并成一张大图，只能水平排列，不能竖直排列。 图片如何排列能够尽量紧凑，同时保证不会影响扩展性。这点是 CSS sprite 技术最困难也是最具挑战性的地方。 18. CSS hackIE 条件注释法只在IE下生效123&lt;!--[if IE]&gt;&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;&lt;![endif]--&gt; 只在 IE6 下生效123&lt;!--[if IE 6]&gt;&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;&lt;![endif]--&gt; 只在 IE6 以上版本生效123&lt;!--[if gt IE 6]&gt;&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;&lt;![endif]--&gt; 只在 IE7 上不生效123&lt;!--[if ! IE 6]&gt;&lt;link type=\"text/CSS\" href=\"test.css\" rel=\"stylesheet\" /&gt;&lt;![endif]--&gt; 条件注释和 style 标签12345&lt;!--[if IE 6]&gt;&lt;style type=\"text/CSS\"&gt;.test&#123;&#125;&lt;/style&gt;&lt;![endif]--&gt; 条件注释和 script 标签12345&lt;!--[if IE 6]&gt;&lt;script type=\"text/JavaScript\"&gt;alert(\"我是 IE 6\");&lt;/script&gt;&lt;![endif]--&gt; 选择符前缀法12345&lt;style type=\"text/CSS\"&gt;.test&#123; width: 80px; &#125; /* IE 6,IE 7,IE 8 */*html .test&#123; width: 60px; &#125; /* only for IE 6 */*+html .test&#123; width: 70px; &#125; /* only for IE 7 */&lt;/style&gt; 选择符前缀法相较于 IE 条件注释法来说，可维护性强了很多，但在向后兼容性上存在一点风险。另外，选择符前缀法不能用于内联样式上。 样式属性前缀法样式属性前缀法的原理是在样式的属性名前加前缀，这些前缀只在特定浏览器下才生效.例如 “_” 只在 IE6 下生效，”*” 在 IE6 和 IE7 下生效。 1234567&lt;style type=\"text/CSS\"&gt;.test&#123; width: 80px; *width: 70px; _width: 60px;&#125;&lt;/style&gt; 19. a 标签的四种状态关于 a 标签的四种状态的排序问题，有个简单好记的原则，叫做 love hate 原则，即 l(link)ov(visited)e h(hover)a(active)te 20. hasLayouthasLayout 是 IE 浏览器专有的一个属性，用于 CSS 的解析引擎。有时候在 IE 下一些复杂的 CSS 设置解析起来会出现 Bug，其原因可能与 hasLayout 没有被自动触发有关，我们通过一些技巧，手动触发 hasLayout 属性就可以解决Bug了。 21. 块级元素和行内元素的区别 块级元素会独占一行，默认情况下，其宽度自动填满其父元素宽度，行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化； 块级元素可以设置 width，height 属性。行内元素设置 width，height 属性无效。块级元素即使设置了宽度，仍然是独占一行的； 块级元素可以设置 margin 和 padding 属性。行内元素的 margin 和 padding 属性很奇怪，水平方向的 padding 和 margin 都产生边距效果，但竖直方向的 padding，margin 却不会产生边距效果。 22. display:inline-block它是行内的块级元素，它拥有块级元素的特点，可以设置长宽，可以设置 margin 和 padding 值，但它却不是独占一行，它的宽度并不占满父元素，而是和行内元素一样，可以和其他行内元素排在同一行里. 23. relative，absolute 和 float设置 position: relative 或 position: absolute 都可以让元素激活 left，top，right，bottom 和 z-index 属性(默认情况下，这些属性未激活，设置了也无效) 设置 position:relative 或 position:absolute 会让元素”浮”起来，也就是 z-index 值大于 0，它会改变正常情况下的文档流。float 也能改变文档流，不同的是，float 属性不会让元素”上浮”到另一个 z-index 层，它仍然让元素在 z-index: 0 层排列。另外，不论之前什么类型的元素(display: none 除外)，只要设置了 position: absolute，float: left 或 float: right 中的任意一个，都会让元素以 display: inline-block 的方式显示，可以设置长宽，默认宽度并不占满父元素。就算我们显示地设置 display: inline 或者 display: block，也仍然无效。position: relative 不会隐式改变 display 的类型。 24. 居中水平居中文本，图片等行内元素的水平居中父元素设置text-align:center 确定宽度的块级元素的水平居中margin:0 auto 不确定宽度的块级元素的水平居中 第一种方法：将 ul 包含在 table 标签内，对 table 设置 margin: 0 auto 就可以使 table 水平居中，间接地使 ul 实现了水平居中； 第二种方法：改变块级元素的 display 为 inline 类型，然后使用 text-align: center 来实现居中； 第三种方法：给父元素设置 float，然后父元素设置 position: relative 和 left: 50%，子元素设置 position: relative 和 left: -50% 来实现水平居中 竖直居中父元素高度不确定的文本，图片，块级元素的竖直居中给父容器设置相同上下边距实现的 父元素高度确定的单行文本的竖直居中通过给父元素设置 line-height 来实现的，line-height 值和父元素的高度值相同。 父元素高度确定的多行文本，图片，块级元素的竖直居中块级元素的 display:table-cell，vertical-align:center。 25. 使用匿名函数控制变量的作用域(function(){ var a，c=&quot;abc&quot;; })(); 这种形式很巧妙，先定义一个匿名的 function，然后立即执行它.包在这个匿名 function 里的变量，作用域就不再是 window，而是局限在函数内部。用匿名函数将脚本包起来，可以有效控制全局变量，避免冲突隐患。让 JS 不产生冲突，需要避免全局变量的泛滥，合理使用命名空间以及为代码添加必要的注释。 26. window.onload 和 DOMReadywindow.onload 需要当页面完全加载完成时才会触发，包括图片，Flash 等富媒体，DOMReady 只判断页面内所有的 DOM 节点是否已经全部生成，至于节点的内容是否加载完成，它并不关心. DOMReady 比 window.onload 更适合用来调用初始化函数。值得注意的是，DOMReady 并不是原生 JavaScript 支持的事件，它不能像 window.load 那样直接调用，一般我们都是结合 JS 框架来使用它。 27. CSS 放在页头，JavaScript 放在页尾将 CSS 放在页头，在载入 HTML 元素之前，先载入它们的样式，这样可以避免 HTML 出现无样式状态；将 JavaScript 放在页尾，先将网页呈现给用户，再来加载页面内的脚本，避免 JavaScirpt 阻塞网页的呈现，减少页面空白的时间。 28. 引入编译的概念——文件压缩为了减小网页的大小，缩短网页的下载时间，在正式发布 JavaScript 之前，我们可以先对它进行一下压缩。JS 压缩通常的做法是去掉空格和换行，去掉注释，将复杂变量名替换成简单的变量名。 29. JavaScript 如何分层把 JavaScript 也分成三层，从下往上依次是 base 层，common 层和 page 层 base 层有两个职责，职责一是封装不同浏览器下 JavaScript 的差异，提供统一的接口，我们可以依靠它来完成跨浏览器兼容的工作。职责二是扩展 JavaScript 语言底层提供的接口，让它提供更多更为易用的接口。 common 层依赖于 base 层提供的接口。common 层提供可供复用的组件，它是典型的 mvc 模式中的 m，和页面内的具体功能没有直接关系。common 层的功能是给 page 层提供组件。 page 层这一层和页面里的具体功能需求直接相关，是 mvc 模式中的 c。page 层的功能是完成页面内的功能需求。 30. JavaScript 中的参数如果一个函数内某个因素很不稳定，我们可以将它从函数内部分离出来，以参数的形式传入，从而将不稳定因素和函数解耦。在编程里有一个很出名的规则叫做 DRY——don’t repeat yourself，强调在程序中不要将相同的代码重复编写多次，更好的做法是只写一次，然后在多处引用。 31. JavaScript 与面向对象JavaScript 很奇怪，它没有 Class 关键字，在 JavaScript 中是用函数来充当类的。函数在 JavaScript 中既可以当作普通函数使用，也可以当作类来使用，在充当类的时候，它本身又担负着构造函数的责任。函数作为普通函数使用时，通常直接使用 “()” 进行调用，而作为类使用时，通常使用 new 来实例化。通常情况下，作为函数时我们更倾向于用动词来命名，而作为类时用名词来命名。按照习惯，类名的首字母大写。JavaScript 是基于原型的语言，通过 new 实例化出来的对象，其属性和行为来自于两部分，一部分来自于构造函数，另一部分来自于原型。当我们声明一个类时，其实同时生成了一个对应的原型，例如我们定义 Animal 这个类时，会生成一个与 Animal 类对应的原型，通过 Animal.prototype 可以指向这个原型，原型可以通过 constructor 指向 Animal 类，更确切地说，是指向 Animal 类的构造函数。构造函数中定义的属性和行为的优先级比原型中定义的属性和行为优先级高，如果构造函数和原型定义了同名的属性和行为，构造函数中的属性和行为会覆盖原型中的同名的属性和行为。 this 关键字无论出现在构造函数中，还是出现在原型中，指向的都是实例对象，通过 this 关键字，可以让属性和方法在构造函数和原型间通信。正统的面向对象语言会提供 public，protect，private 等关键字来声明属性和行为的可访问性是公有还是私有。但 JavaScript 并不提供这些关键字，在 JavaScript 中公有还是私有是通过作用域实现的。 把行为写在原型里可以减少内存消耗，没有特殊原因，推荐尽量把行为写在原型里。写在原型中的行为一定是公有的，而且无法访问私有属性。 32. 传值与传址12345678910var a = 10; // 基本数据类型var b = a; // 将变量 a 保存的值复制一份，传给变量 b，a 和 b 各保存一份数据var c = [1，2，3]; // 复杂数据类型var d = c; // 将变量 c 指向的数据的内存地址传给变量d，c 和 b 指向同一份数据b++;d.push(4);alert(a); // 10 alert(b); // 11 变量 b 保存的数据更改不会影响到变量 aalert(c); // 1，2，3，4 变量 c 和 d 指向同一份数据，数据更改会互相影响alert(d); // 1，2，3，4 在原生 JavaScript中，选择传值还是传址是根据数据类型自动判定的，但传址有时候会给我们带来意想不到的麻烦，所以我们需要对复杂类型数据的赋值进行控制，让复杂数据类型也可以进行传值。 33. UML 描述类 PhonebookManager +getTel():string +addItem():void +removeItem():void 一个方框代表一个类，将方框划分成上中下三栏，第一栏填入类名，第二栏填入类的属性，第三栏填入类的行为，其中公有属性和公有行为需要在属性和行为名前加上 “+” 号，而私有属性和私有行为需要在属性和行为名前加上 “-” 号。 34. prototype 和内置类 只要是类就会有原型，不管它是自定义类还是 JavaScript 的内置类，我们可以通过修改内置类的原型，让 JavaScript 基本类型的对象获得一些有趣的功能。无论在类的构造函数中还是在原型中，this 都指向实例化的对象。内置类的方法可以重写，但属性却不能重写。在 JavaScript 中，包括内置类和自定义类，所有类的祖先类都是 Object，所以如果想对所有对象都扩展方法，可以通过修改 Object 类的原型实现。 35. 修改内置类使用自定义类： 123456789101112131415161718function myArray(o)&#123; this.getArray=function()&#123; return o; &#125;;&#125;myArray.prototype=&#123; each:function(fun)&#123; var o=this.getArray(); for(var i=-，n=o.length;i&lt;n;i++)&#123; fun(o\\[i\\]，i); &#125; &#125;&#125;var a=new nyArray(\\[1，2，3\\])，str=\"\";a.each(function(v，k)&#123; str += k+\":\"+v+\"\\\\n\";&#125;);alert(str); // 0:1 1:2 2:3 代替直接修改内置类原型的做法，定义一个自定义类，将内置类的实例作为参数传给构造函数，在自定义类里定义扩展方法。这种做法的思路是将内置类再封装一层，以此保护内置类的原型不被污染。两种方法都各有优缺点，修改内置类的原型非常方便，缺点是可能会带来冲突隐患；自定义类可以保护原型不被修改，但它需要用 new 来实例化自定义类，相对麻烦一点。如果是小应用，不用过多考虑可维护性，推荐使用前者，如果是大中型应用，需要考虑可维护性，推荐使用后者。 36. 自定义属性对于常规属性，统一使用 node.XXX 的方式读取，对于自定义属性，统一使用 node.getAttribute(“XXX”) 读取。将复杂类型的数据转化成字符串，称为数据的序列化，其逆操作叫做数据的反序列化。字符串的反序列化是通过 eval 函数实现的。只要字符串长的像 JavaScript 支持的数据格式，就可以进行反序列化。 1234567891011121314&lt;a id=\"a\" href=\"http://www.adanghome.com\" blogInfo=\"&#123;name:'阿当的博客'，type:'前端开发'&#125;\"&gt;my blog&lt;/a&gt;&lt;script type=\"text/JavaScript\"&gt; var node=document.getElementById(\"a\"); var info=node.getAttribute(\"blogInfo\"); alert(typeof info); //string alert(info.name); //undefined alert(info.type); //undefined info=eval(\"(\" + info + \")\"); alert(typeof info); //object alert(info.name); //阿当的博客 alert(info.type); //前端开发&lt;/script&gt; 37. 代码可维护性好的可维护性可以从四个方面获得： 代码的松耦合，高度模块化，将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从 HTML、CSS、JavaScript 三个层面考虑模块化。 良好的注释。 注意代码的弹性，在性能和弹性的选择上，一般情况下以弹性为优先考虑条件，在保证弹性的基础上，适当优化性能。 严格按照规范编写代码。","categories":[{"name":"前端","slug":"frontend","permalink":"http://merrier.wang/categories/frontend/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"读书笔记系列（3）——精彩绝伦的CSS","slug":"读书笔记系列（3）——精彩绝伦的CSS","date":"2017-04-06T08:13:16.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170406/excellent-css.html","link":"","permalink":"http://merrier.wang/20170406/excellent-css.html","excerpt":"","text":"1. 特殊性特殊性是一个选择器“特殊程度”的数字表示，有 3 样东西经常被用来确定选择器的特殊性： 每个元素描述符贡献 0，0，0，1； 每个类、伪类或者属性描述符贡献 0，0，1，0； 每个 ID 描述符贡献 0，1，0，0. /daizhengli/ 当特殊性相等时后声明的规则会胜出。特殊性标识符第一位的 0 是用于行内样式的，且仅用于行内样式。 123div#header &#123; background: purple; /* 0，1，0，0 */&#125; 1&lt;div id=\"header\" style=\"background: blue;\"&gt; /* 1，0，0，0 */ 2. 重要性任何标记为重要的声明都需要有自己的 !important任何重要的声明都会覆盖非重要的声明 3. 通用选择* 作用是选择文档中的全部元素并对其应用样式div * 作用是选择这个 div 中的全部子元素 4. 简单的属性选择a[href] 会选择所有含有 href 属性的 a 元素a[href=&quot;http://w3.org/&quot;] 选择指向某个特定地址的全部超链接 5. 部分属性值选择a[href*=&quot;w3.org&quot;] 属性值中包含该字符序列，应该区分属性值的大小写。 /daizhengli/ 6. 更多部分属性值选择a[href^=”http”] 选取任何 href 属性值是以 http 开头的链接元素a[href$=”.pdf”] 选择 href 属性值是以 .pdf 结尾的链接元素 /daizhengli/ 7. 兄弟选择h2 + p 紧跟在 h2 后的 p 元素h1 ~ ul 位于 h1 元素后面且与之共享父元素的 ul 元素，不包括直接相邻的兄弟元素 8. 调整字体值的顺序 font: &lt;font-size&gt; &lt;font-family&gt;; 必须同时包含这两个值并且按照既定的顺序进行书写。如果颠倒了顺序，或者漏掉了其中的一个，则任何现代浏览器都会完全忽略这条声明。此外，如果在声明中包含了其他关键字，则它们全部都得放在这两个必备的值前面。 9. 玩转行高 font: 100%/2.5 Helvetica， sans-serif; 为 font 声明添加行高值得操作总是可选的，但是如果已经包含了行高值，则它的放置位置就是固定的了，必须紧跟在字号后面加一个斜杠再加上行高值才行。 10. 无单位的行高值无单位的行高值表示后代元素所使用的一个换算系数（比如一个乘数）所有继承了行高值为 1 的元素会把这个值同它们自身的字号计算值相乘。声明了 font-size: 10px 的列表项元素会有一个 10px 的计算后的行高值。 11. 抑制元素的可见性1span&#123; visibility：hidden； &#125; /* 被设置成 visibility: hidden 的元素仍然参与页面布局 */ 12. 将元素移出屏幕12345678910111213141516171819.hide &#123; position: absolute; top: -10000em; left: -10000em;&#125;``` **已经从页面上移除，但是屏幕阅读器也能识别**## 13. 图像替换使用负的文本缩进把文本移到元素的左侧```cssh1 &#123; height: 140px; text-indent: -9999px; background: url(page-hader.gif);&#125; 我们没有移动元素框的情况下将元素的文本内容移动到了屏幕之外。 14. 打印样式有 3 种方式可以将打印样式关联到页面： &lt;style type=&quot;text/css&quot; media=&quot;print&quot;&gt;...&lt;/style&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot; href=&quot;print.css&quot;&gt; @import url(print.css) print; 几乎所有人都会使用 link 的方式，这是因为在每个页面中都嵌入打印样式表的效率非常低。 15. 凸排列表使列表项的第一行悬挂在左侧，并使其他行保持在原位的一种技术。 1234ul&#123; text-indent: -2em; list-style: none;&#125; list-style: none 这条规则很重要，如果没有这个的话，每个列表项的第一行就不会被凸排，并且文本会跟列表标记重合。因此，不要把凸排和列表标记混着用。 16. 为列表添加标记123ul &#123; list-sytle-image: url(star.gif);&#125; 潜在的缺点是你完全无法掌控图像的放置位置。可以将每个列表项的内容用一个元素包裹一下，这个元素可以是 div 或者 span。就可以定制列表标记的样式。 17. 生成列表标记通过混合凸排和生成内容来实现的。 12345678ul li:before &#123; content: url(star.gif); margin-right: 8px;&#125;ul li &#123; text-indent: -20px; list-style: none;&#125; 18. 用轮廓代替边框1div&#123; outline: 1px dashed red; &#125; 边框是参与布局的，而轮廓并不参与。轮廓必然是环绕着元素的，并且在元素的四周永远保持一致。你不能只设置左轮廓或者上轮廓。轮廓只有两种情况：环绕元素四周的简单轮廓，或者干脆没有轮廓。元素是可以同时具有边框和轮廓的。在这种情况下，轮廓会绘制在边框之外，所有轮廓的内边缘会紧挨着边框的外边缘。如果元素具有外边距的话，则轮廓将绘制在外边距所在区域之上，但是外边距并不会被轮廓改变或者替换掉。 19. 框冲切是一种可以在视觉上将元素框的一部分移除的技术。它仅在单色或固定图像背景上起作用。框冲切的最简单形式就是把一个框放在另一个框的角落里，并确保它的背景与周围的内容一致，而不是与它的父元素一致。 20. CSS 精灵CSS 精灵(CSS sprite) 是一种可以实现快速悬停效果的技术，现在已经演变成了通过将装饰性的图片合并并下载，从而降低服务器负载的技术。CSS 精灵最基本的例子就是包含两种状态的图标，即一个挨着链接的正常显示版本，一个当链接被悬停时的”点亮”版本。 21. 滑动门滑动门是一种可以使文本导航链接变成花哨的选项卡的技术。然而，通常的做法都只适用于效果而不试用于选项卡。 22. CSS 视差CSS 视差是一种很精巧的技术，它能让我们了解基于百分比的背景图像定位可以那么简单而直接地创造出意想不到的效果。首先，考虑一下百分比定位是怎么实现的。假设你把一个背景图像的位置设置为 50% 50%，那么它的中心将与背景区域的中心对齐。类似地，如果设置为 100% 100%，那么它的右下角就会和背景区域的右下角对齐。这就意味着背景图像位置的百分比值实际上被使用了两次。第一次用于找到背景区域中所定义的点，第二次用于找到图像本身中定义的点，然后再把这两个点对齐。 12345678910body&#123; background: url(ice-1.png) -75% 0 repeat-x; width: 100%; padding: 0; margin: 0;&#125;div#main&#123; background: url(ice-2.png) 75% 0 repeat-x; width: 100%;&#125; 通过这样的设置，当浏览器窗口变宽时图片看起来就会使朝着远离窗口中心的方向移动的，这会产生类似”放大”的效果。而当窗口变窄时，图片会朝着窗口的中心移动，类似”缩小”的效果。 23. 图像的框有些关于图像的东西，大多数人至今都没有意识到：它们与其他元素拥有相同的盒模型，这意味着你可以对图像元素应用诸如背景和内边距等样式。你可以为图像设置背景图像，做出一些有趣的组合效果： 内边距也可以很简单地应用在图像上。事实上，通过背景色、边框以及内边距的组合，可以使图像看上去具有深浅不一的双层边框。 再加上轮廓的话，你就会得到类似三层边框的效果了。 24. 受限的图像1img&#123; max-width:100%; &#125; 这条简单的规则会保证图像不会比包含它们的元素更宽，不过在父元素比这些图像宽的情况下，它们会保持原始尺寸。你可以通过把图像在其父元素中居中来进行强化，像这样： 12345img &#123; max-width: 100%; display: block; margin: 0 auto;&#125; 下图展示了将同一个图像放在 3 个不同宽度父元素中的例子，其中两个父元素比图像还窄，一个比图像宽(父元素的边缘已通过边框标出)。 这很明显会使你的图像任由浏览器的缩放操作摆布，因为它们会缩小图像。 25. 表头、主体和脚注HTML 为表格定义了 3 个元素用于对行进行分组，它们是 thead(表头)，tbody(表格主体) 和 tfoot(脚注)。毫不奇怪，这些元素分别代表了表格的表头，主体部分以及脚注部分。 26. 行标题有一个 HTML 属性在当初设计的时候就是用来让你指定一个 th 元素是列标题还是行标题的。表格主体中的每一行都以 th 元素开头，那些就是行标题。 123456789101112131415161718192021&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th scope=\"col\"&gt;Pageviews&lt;/th&gt; &lt;th scope=\"col\"&gt;Visitors&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th scope=\"row\"&gt;January 2010&lt;/th&gt; &lt;td&gt;1367234&lt;/td&gt; &lt;td&gt;326578&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope=\"row\"&gt;February 2010&lt;/th&gt; &lt;td&gt;1491262&lt;/td&gt; &lt;td&gt;349091&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 为 th 元素恰当地添加已赋值的 scope(作用域)属性，相当于明确地告诉浏览器 th 元素与它周围单元格的关系。 27. 多背景CSS3 中真正时髦的东西之一，就是它对于给定元素支持多个背景图像。 1234567.div &#123; background: url(bg01.png) top left no-repeat, url(bg02.png) top right no-repeat, url(bg03.png) bottom right no-repeat, url(bg04.png) bottom left no-repeat; background-color: #fff;&#125; 多背景的应用顺序是从“最高”到“最低”的，即以你观看页面的视角来看，是从最靠你的到离你最远的顺序应用。如果你把颜色放到第一个背景上，它就会位于其他背景的“上面”。这也意味着，如果你想让某种图案背景在所有背景的最后方，那么就需要把它放在最后一个并且确保把任何背景颜色的值也移到这个值中。 28. 二维变换可以通过 transform-origin 改变旋转或缩放的原点 12transform-origin: bottom left;transform-origin: 75% 0;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"读书笔记系列（2）——面向对象的分析与设计","slug":"读书笔记系列（2）——面向对象的分析与设计","date":"2017-04-06T08:09:41.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170406/object-oriented-analysis-and-design.html","link":"","permalink":"http://merrier.wang/20170406/object-oriented-analysis-and-design.html","excerpt":"","text":"1. 简介面向对象不仅是一些具体的软件开发技术与策略，而且是一整套关于如何看待软件系统与现实世界的关系，用什么观点来研究问题并进行求解，以及如何进行系统构造的软件方法学。面向对象方法比以往的方法更接近人类的日常思维方式。 2. 面向对象方法有如下一些主要特点： 从问题域中客观存在的事物出发来构造软件系统，用对象作为对这些事物的抽象表示，并以此作为系统的基本构成单位。 用对象的属性表示事物的静态特征（即可以用一些数据来表达的特征），用对象的操作表示事物的动态特征（即事物的行为） 对象的属性与操作结合在一起构成一个独立的实体，对外屏蔽其内部细节（封装）。 对事物进行分类，把具有相同属性和相同操作的对象归为一类，类是这些对象的抽象描述，每个对象是它的类的一个实例。 通过在不同程度上运用抽象的原则，可以得到较一般的类和较特殊的类。特殊类继承一般类的属性与操作，从而简化了系统的构造过程。 复杂的对象可以用简单的对象作为其构成部分（聚合）。 对象之间通过消息进行通信，以实现对象之间的动态联系。 用关联表达某些类之间对用户业务有特定意义的关系。 3. 每个对象由一组属性和一组操作构成，二者分别描述事物的静态特征和动态特征。4. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，由一个类名、一组属性和一组操作构成。5. 一个对象又称为类的一个实例。我们说同类对象具有相同的属性与操作，是指它们的定义形式相同，而不是说每个对象的属性值都相同。6. 一般类和特殊类也常常习惯地称为父类和子类。 特殊类的每个对象实例也都属于它的一般类，然而一般类含有其特殊类所没有的对象实例。 特殊类拥有其一般类的全部属性与操作，称为特殊类对一般类的继承。 7. 聚合的含义聚合的含义：一个复杂的对象以若干比较简单的对象作为其组成部分。另一方面，聚合也是对象之间的一种关系，即整体对象和部分对象之间的关系。聚合是两个类之间的一个二元关系，它表示一个类的对象实例以另一个类的对象实例作为其组成部分。 8. 用关联来表示两个（或者多个）类的对象实例集合之间的这种关系。9. 消息是向对象发出的服务请求。消息的实现手段，在顺序程序中主要是函数调用，或者其他类似于函数调用的机制。 10. 对象的多态性对象的多态性通常是指一般-特殊结构中的对象所体现的多态性，即：在一般类中定义的属性或操作被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。 11. 功能分解法首先定义各项功能，然后把较大的功能分解为子功能，直到这些功能或子功能的大小比较适当，并能给出明确的定义。 12. 结构化方法研究问题域中数据如何流动以及在各个环节上如何进行处理，从而发现数据流和加工。最终得到的分析模型是数据流图。 13. 数据流从源点开始出现到终点结束，在其他任何结点（加工和文件）之间只能被传输、转换和存储，而不能凭空产生和消失。14. 实体描述问题域中一个事物，它包含一组描述事物数据信息的属性。关系描述问题域中各事物之间在数据方面的联系，它也可以带有自己的属性。15. 信息建模法认识问题域的出发点是问题域中的具体事物，用模型中的实体（对象）与之对应。16. 先以用况的概念进行需求分析，然后以面向对象的概念进行系统分析。17. 面向对象建模方法具有如下优点： 对问题域和系统责任的复杂性具有较强的处理能力； 提供了便于各类相关人员交流的共同语言； 对需求的变化具有较强的适应性； 为实现分析与设计级别的软件复用提供了强有力的支持。 18. UML是一种建模语言，而不是一种建模方法。19. 属性有类属性和实例属性之分，必要时要加以区别。20. 数据抽象是面向对象方法的核心原则。21. 没有任何对象需要单独地编写程序代码，即使一个类只有唯一的对象实例也是如此。22. 消息通信就成了实现对象之间动态联系的唯一渠道。在多数情况下，一个对象向另一个对象发出消息，就意味着前者在行为上依赖后者。因此，通过消息进行通信是面向对象方法处理对象之间行为关系的原则。23. 在面向对象的软件系统中，所有的对象都是通过类描述的。24. 类是具有相同属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，它由一个类名、一组属性和一组操作构成。25. 可用以下 4 句话来概括对象和类这两个概念在面向对象建模中的应用规则： 从对象出发认识问题域，将问题域中的事物抽象为对象； 将具有共同特征的对象抽象为类，用类以及它们之间的关系构成整个系统模型； 模型中不包含实例级的元素，用类来表示属于该类的任何对象实例； 在类的规约中说明这个类将创建哪些对象实例。 26. 如果一个对象只有多个操作，而没有属性，并且每个操作各自只被一个类的对象使用，则可考虑把这些操作分别放到它的使用者（对象）中，从而取消这个对象。27. 属性是用来描述对象静态特征的一个数据项 操作是用来描述对象动态特征（行为）的一个动作序列。28. 确定对象属性的要点是：以系统责任为目标，对问题域中实际事物的特征进行正确的抽象，从而找出对象应有的属性。29. 一个对象的操作直接调用另一个对象的操作，则二者之间的衔接是固定的。通过接口进行衔接，则接口在它的使用者和提供者之间起到了隔离作用，二者可以分别实现，并且可以有多种不同的实现，只要都遵守接口所规定的合约，就可以通过该接口相互衔接。 30. 接口由某些类提供，为另外某些类所需要。31. 接口与对象类相比，有以下几点不同： 类既有属性又有操作；接口只是声明了一组操作，没有属性。 在一个类中定义了一个操作，就要在这个类中真正地实现它的功能；接口中的操作只是一个声明，不需要在接口中加以实现。 类可以创建对象实例；接口则没有任何实例。 32. 对象之间的 4 种重要关系，即继承、聚合、关联和信息。33. 系统中的一般类应该符合下述3个条件之一才有存在的价值： 它有两个或两个以上的特殊类； 需要用它创建对象实例； 它的存在有助于软件复用。 34. 聚合关系的语义是has-a或者is-a-part-of，即”有一个”或者”是……的一部分”。35. 如果部分对象只有一个属性，应考虑把它取消，并把其中所表达的信息收缩（合并）到整体对象中去，变为整体对象的一个属性，除非还有其他理由要求保留这个结构。36. 关联类是一种兼有关联的特征和类的特征的模型元素。关联类既可以被看成是具有类的特征的关联，又可以被看成是具有关联特征的类。37. 消息是向对象发出的服务请求。消息是对象之间在一次交互中所传送的消息。38. 在语法上，一个消息的描述应包括以下内容：消息名，即接收消息的操作名；入口参数（0 到多个），即接收消息的操作要求的输入参数；返回参数（0 到多个），即接收消息的操作提供的输出参数。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"读书笔记系列（1）——HTML5移动Web开发指南","slug":"读书笔记系列（1）——HTML5移动Web开发指南","date":"2017-04-06T07:41:14.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170406/html5-mobile-web-development-guide.html","link":"","permalink":"http://merrier.wang/20170406/html5-mobile-web-development-guide.html","excerpt":"","text":"属性选择器包含匹配选择器包含匹配比完全匹配范围更广。只要元素中的属性包含有指定的字符串，元素就使用该样式。其语法是：[attribute*=value]。 其中 attribute 指的是属性名，value 指的是属性值，包含匹配采用 “ *=” 符号。 首字符匹配选择器首字符匹配就是匹配属性值开头字符，只要开头字符符合匹配，则元素使用该样式。其语法是：[attribute^=value]。 其中 attribute 指的是属性名，value 指的是属性值，首字符匹配采用“ ^=”符号。 尾字符匹配选择器尾字符匹配跟首字符匹配原理一样。尾字符只匹配结尾的字符串，只要结尾字符串符合匹配，则元素使用该样式。其语法是：[attribute$=value]。其中 attribute 指的是属性名，value 指的是属性值，尾字符匹配采用 “ $=”符号。 伪类选择器beforebefore 伪类元素选择器主要的作用是在选择某个元素之前插入内容，一般用于清除浮动。before 选择器的语法是： 123元素标签:before&#123; content:\"插入的内容\"&#125; 例如，在 p 元素之前插入“文字”： 1p.before&#123; content: \"文字\" &#125; afterafter 伪类元素选择器和 before 伪类元素选择器原理一样，但 after 是在选择某个元素之后插入内容。after 选择器的语法是： 123元素标签:after &#123; content: \"插入的内容\"&#125; first-child指定元素列表中第一个元素的样式。语法：li:first-child last-child和 first-child 是同类型的选择器。last-child 指定元素列表中最后一个元素的样式。语法：li:last-child nth-child 和 nth-last-child指定某个元素的样式或从后数起某个元素的样式。 阴影box-shadow box-shadow: &lt;length&gt; &lt;length&gt; &lt;length&gt; || color 第一个 length 值是阴影水平偏移值；第二个 length 值是阴影垂直偏移值；第三个 length 值是阴影模糊值。水平和垂直偏移值都可取正负值。 基于 Webkit 的 Chrome 和 Safari 等浏览器：-webkit-box-shadow Firebox 浏览器：-moz-box-shadow text-shadow text-shadow: &lt;length&gt; &lt;length&gt; &lt;length&gt; || color 第一个 length 值是阴影水平偏移值；第二个 length 值是阴影垂直偏移值；第三个 length 值是阴影模糊值。水平和垂直偏移值都可取正负值。 背景background-size**背景图像的大小 background-clip背景的裁剪区域 background-clip: border-box | padding-box | content-box | no-clip 其中： border-box 是从 border 区域向外裁剪背景； padding-box 是从 padding 区域向外裁剪背景； content-box 是从内容区域向外裁剪背景； no-clip 是从 border 区域向外裁剪背景。 background-originbackground-origin 属性是指定 background-position 属性的参考坐标的起始位置。 background-origin 属性有三种值可以选择，border 值指定从边框的左上角坐标开始；content 值指定从内容区域的左上角坐标开始；padding 值指定从 padding 区域开始。 background可以使用 Webkit 的其中一种特性对背景采用颜色渐变，而非采用图片方式。 -webkit-gradient(&lt;type&gt;, &lt;port&gt;[, &lt;radius&gt;]?,&lt;point&gt; [, &lt;radius&gt;]? [, &lt;stop&gt;]*) type 类型是指采用渐变类型，如线性渐变 linear 或径向渐变 radial。如下代码： 1background: -webkit-gradient(linear, 0 0, 0 100%, form(#FFF), to(#000)); 上述代码的含义是定义一个渐变背景色，该渐变色是线性渐变并且是由白色向黑色渐变的。其中前两个 0 表示的是渐变开始 X 和 Y 坐标位置；0 和 100%表示的是渐变结束 X 和 Y 坐标位置。 Media Queries 移动设备样式viewport设置适应移动设备屏幕大小Android Browser 浏览器的默认值是 800 像素；IE 浏览器的默认值是 974 像素；Opera 浏览器的默认值是 850 像素。viewport 虚拟窗口是在 meta 元素中定义的，其主要作用是设置 Web 页面适应移动设备的屏幕大小。 如以下代码： 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,user-scalable=0\" /&gt; 代码中的 content 属性内共定义三种参数。实际上 content 属性允许设置 6 种不同的 参数，分别如下： width：指定虚拟窗口的屏幕宽度大小。 height：指定虚拟窗口的屏幕高度大小。 initial-scale：指定初始缩放比例。 maximum-scale：指定允许用户缩放的最大比例。 minimum-scale：指定允许用户缩放的最小比例。 user-scalable：指定是否允许手动缩放。 Media Queries 如何工作要实现 Media Queries 样式模块，需要在 head 标签内导入一个 CSS 样式文件，例如，下面代码使用 media 属性定义当前屏幕可视区域的宽度最大值是 600 像素时应用该样式文件。 1&lt;link rel=\"stylesheet\" media=\"screen and(max-width:600px)\" href=\"small.css\"/&gt; 在 small.css 样式文件内，需要定义 media 类型的样式，例如： 123@media screen and (max-width:600px)&#123; .demo&#123; background-color: #CCC; &#125; &#125; 同样也可以判断当移动设备（如 iPad）的方向发生变化时应用该样式。以下代码是当移动设备处于纵向（portrait）模式下时，应用 portrait 样式文件；当移动设备处于横向（landscape）模式下时，应用 landscape 样式文件。 12&lt;link rel=\"stylesheet\" media=\"all and(orientation:portrait)\" href=\"portrait.css\"/&gt; &lt;link rel=\"stylesheet\" media=\"all and(orientation:landscape)\" href=\"landscape.css\"/&gt; Media Queries 语法总结Media Queries 的语法如下所示： @media [media_query] media_type and media_feature 使用 Media Queries 样式模块时都必须以 “@media” 方式开头。media_query 表示查询关键字，在这里可以使用 not 关键字和 only 关键字。not 关键字表示对后面的样式表达式执行取反操作。例如如下代码： 1@media not screen and (max-device-width:480px) only 关键字的作用是，让不支持 Media Queries 的设备但能读取 Media Type 类型的浏览器忽略这个样式。例如如下代码： 1@media only screen and (max-device-width:480px) 对于支持 Media Queries 的移动设备来说，如果存在 only 关键字，移动设备的 Web 浏览器会忽略 only 关键字并直接根据后面的表达式应用样式文件。对于不支持 Media Queries 的设备但能够读取 Media Type 类型的 Web 浏览器，遇到 only 关键字时会忽略这个样式文件。 media_type 参数的作用是指定设备类型，通常称为媒体类型。实际上在 CSS2.1 版本时已经定义了该媒体类型。 all 所有设备 aural 听觉设备 braille 点字触觉设备 handled 便携设备，如手机、平板电脑 print 打印预览图等 projection 投影设备 screen 显示器、笔记本、移动端等设备 tty 如打字机或终端等设备 tv 电视机等设备类型 embossed 盲文打印机 media_feature 的主要作用是定义 CSS 中的设备特性，大部分移动设备特性都允许接受 min/max 的前缀。 例如，min-width 表示指定大于等于该值；max-width 表示指定小于等于该值。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://merrier.wang/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://merrier.wang/tags/HTML/"},{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"读书笔记系列","slug":"读书笔记系列","date":"2017-04-06T07:39:34.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170406/reading-notebook-series.html","link":"","permalink":"http://merrier.wang/20170406/reading-notebook-series.html","excerpt":"","text":"“书中自有黄金屋”，这里汇集了我所读过的书的笔记，在闲下来的时候与其打游戏还不如看会书： HTML5移动Web开发指南 面向对象的分析与设计 精彩绝伦的CSS 编写高质量代码-Web前端开发修炼之道 响应式Web设计-HTML5和CSS3实战 大话数据结构 CSS Secrets 你不知道的JavaScript（上卷）","categories":[{"name":"系列专栏","slug":"series","permalink":"http://merrier.wang/categories/series/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://merrier.wang/tags/笔记/"}]},{"title":"前端面试系列（10）——JS中的闭包","slug":"前端面试系列（10）——JS中的闭包","date":"2017-04-05T13:12:15.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170405/closure-in-js.html","link":"","permalink":"http://merrier.wang/20170405/closure-in-js.html","excerpt":"","text":"闭包这个概念其实并不是 JS 中独有的，很多开发者将其理解为 JS 的特有产物，其实是大错特错的；只不过 JS 中的闭包有着其他语言没有的特性和产生机理，所以对于闭包的理解成为了很多面试官垂青的问题，而真正理解闭包并且知道在什么时候用闭包、在什么时候避免闭包对于前端码农来说是一个不小的挑战，本篇文章就将深入剖析闭包的工作原理，以及如何使用和避免使用闭包 作用域要理解闭包，首先必须理解 Javascript 特殊的变量作用域；在 JS 中，变量的作用域无非就是两种：全局变量和局部变量： 全局变量，顾名思义，在函数内部也可以直接读取全局变量 局部变量，在函数外部是无法读取函数内的局部变量的（函数内声明变量的时候，一定要使用 var / let 命令，否则相当于声明了一个全局变量） 我们有时候需要得到函数内的局部变量，但是从上面的讲解可以看到，正常情况下是办不到的，所以只能变通：在函数的内部，再定义一个函数 123456function f1() &#123; var n = 999; function f2() &#123; alert(n); //999 &#125;&#125; 这里就引出了另外一个概念，就是 Javascript 语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量；援引燕十八老师的话，只要在一对大括号之内声明的变量，在这个大括号里面的任何地方都可以访问到该变量。根据上面的代码，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们就可以在 f1 外部读取它的内部变量了： 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 什么是闭包？上面代码中的 f2 函数，就是闭包。 闭包是 JavaScript（以及其他大多数编程语言）的一个极其强大的属性。正如在 MDN (Mozilla Developer Network) 中定义的那样： 闭包是指能够访问自由变量的函数。换句话说，在闭包中定义的函数可以“记忆”它被创建的环境。 自由变量是既不是在本地声明又不作为参数传递的一类变量。（如果一个作用域中使用的变量并不是在该作用域中声明的，那么这个变量对于该作用域来说就是自由变量），上面例子中的 n 在 f2 中 alert，但是 f2 中并没有声明 n，所以 n 对于 f2 这个大括号形成的作用域来说就是自由变量；更通俗来讲的话，闭包是能够读取其他函数内部变量的函数，所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁 闭包的用途闭包一个非常重要的用途：保留外部作用域对一个变量的私有引用（仅通过唯一途径例如某一个特定函数来访问一个变量），来看一个例子： 1234567891011var result = [];for (var i = 0; i &lt; 5; i++) &#123; result[i] = function () &#123; console.log(i); &#125;;&#125;result[0](); // 5, expected 0result[1](); // 5, expected 1result[2](); // 5, expected 2result[3](); // 5, expected 3result[4](); // 5, expected 4 这里之所以会打印 5 个 “5”，是因为这五个函数的作用域全部相同（var i = 0 这一句可以提到 for 循环外面，对于 5 个函数来说，只有一个 i，就是循环结束时的那个 i）；也就是说，每次变量 i 增加时，作用域都会更新–这个作用域被所有函数共享。一个解决办法就是为每个函数创建一个额外的封闭环境，使得它们各自都有自己的执行上下文 / 作用域： 1234567891011121314var result = [];for (var i = 0; i &lt; 5; i++) &#123; result[i] = (function inner(x) &#123; // additional enclosing context return function() &#123; console.log(x); &#125; &#125;)(i);&#125;result[0](); // 0, expected 0result[1](); // 1, expected 1result[2](); // 2, expected 2result[3](); // 3, expected 3result[4](); // 4, expected 4 另外，因为 ES6 的缘故，所以我们可以使用 let 来代替 var，因为 let 声明的是块级作用域（在 ES5 中，是没有块级作用域的），因此每次迭代都会创建一个新的标示符绑定： 1234567891011var result = [];for (let i = 0; i &lt; 5; i++) &#123; result[i] = function () &#123; console.log(i); &#125;;&#125;result[0](); // 0, expected 0result[1](); // 1, expected 1result[2](); // 2, expected 2result[3](); // 3, expected 3result[4](); // 4, expected 4 再来看一个例子（MDN 给出的一个闭包的例子）： 1234567891011function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 我们定义了一个方法 makeAdder(x)，这个方法只有一个变量 x，然后返回了一个新的方法；返回的方法呢只有一个变量 y，然后 return 的结果是 x + y；所以，makeAdder(x) 就被我们打造成了一个“方法工厂”，在上面的例子中我们利用这个“工厂”生产了两个新的方法，一个返回的结果是 5 加上变量，另外一个返回 10 加上传进来的变量；不出所料，add5 和 add10 这两个方法都是闭包，他们共享同样的方法体定义，但是存储了不同的词法环境（关于词法环境，本文将不详细探讨，感兴趣的可以自行查阅资料，暂时可以简单的理解为变量所在的环境）；在 add5 的词法环境，x 是 5；而在 add10 的词法环境中，x 是 10；通过这个例子，我们可以看到闭包可以用来打造“方法工厂”，而这个特性也成为了我们避免使用闭包的理由 避免使用闭包曾经我被闭包强大的特性所吸引，直到我看到一些关于“避免使用闭包”的博客，才知道闭包带来的麻烦会比其提供的方便更值得重视；JS 的内存释放和 Java 类似，有一个内存回收机制，没有被引用的对象都会被自动释放，而出现闭包的时候会导致变量无法被释放，下面看一个例子： 1234567function closure()&#123; var data = &#123;&#125;; return function()&#123; return data; &#125;&#125;var closure1 = closure(); closure 方法返回的这个方法，在 closure1 方法每次调用的时候，都可以访问 data 对象，所以由此可见，data 对象的引用没有被释放，否则的话 closure1 方法将无法访问到data对象。这里可以明显的看出来闭包是会把局部变量引用起来导致无法释放的“副作用”： 123var closure2 = closure();console.log(closure1 === closure2); // falseconsole.log(closure1() === closure2()); // false 从上面的代码可以看出来，closure 方法执行两次得到两个方法，这两个方法不是一个方法，两个方法可以访问的 data 对象也不是同一个对象。也就是说 closure 执行一次，就有一个新对象 data 产生，同时生成一个新的方法，返回出去。每次 closure 方法的执行就导致内存中多了一个 data 对象，多了一个 function(return data)，很明显这会导致内存的膨胀。使用不当就会导致内存的泄露。 扩展阅读关于闭包就介绍到这里了，但是为了更容易让初学者理解，本文省略掉了很多相关概念的介绍（执行上下文、词法环境、静态作用域），感兴趣的话可以查阅相关资料，如果有机会的话，我会再查阅更多资料，详细的介绍一下和闭包有关的其他概念，下面是我推荐的一些关于闭包讲解的链接： MDN-Lexical scoping 学习Javascript闭包（Closure） 让我们一起学习JavaScript闭包吧 一分钟理解js闭包 理解js闭包是为了避免使用闭包 Stackoverflow-How do JavaScript closures work?","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"}]},{"title":"前端面试系列（9）——JS实现继承","slug":"前端面试系列（9）——JS实现继承","date":"2017-04-05T13:11:07.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170405/js-implements-inheritance.html","link":"","permalink":"http://merrier.wang/20170405/js-implements-inheritance.html","excerpt":"","text":"JS 虽然声称面向对象，但是其很多特性与真正的“面向对象”仍有一定差距；面向对象的一大特性就是可以继承，所以如何在 JS 这种弱类型语言中实现继承就成为了前端面试中的常见问题，下面我就总结一下在 JS 中实现继承的几种方式： 定义父类既然要实现继承，首先得有一个父类： 12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + '正在吃：' + food);&#125;; 1、原型链继承核心：将父类的实例作为子类的原型 123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat('fish'));console.log(cat.sleep());console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法 / 原型属性，子类都能访问到 简单，易于实现 缺点： 要想为子类新增属性和方法，必须要在 new Animal() 这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 推荐指数：★★（3、4 两大致命缺陷） 2、构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 除了 call 方法，也可以用 apply()，由于篇幅原因，就不再详细介绍这两种方法 1234567891011function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了 1 中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性 / 方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 推荐指数：★★（缺点3） 3、实例继承核心：：为父类实例添加新特性，作为子类实例返回 123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管是 new 子类()还是子类()，返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 推荐指数：★★ 4、拷贝继承特点：使用 for in 将父类实例中的方法赋给子类实例 1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到） 推荐指数：★（缺点 1） 5、组合继承核：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 123456789101112function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式 2 的缺陷，可以继承实例属性 / 方法，也可以继承原型属性 / 方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 推荐指数：★★★★（仅仅多消耗了一点内存，也是最常用的一种继承方式） 6、寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法 / 属性，避免的组合继承的缺点 123456789101112131415161718function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 堪称完美 缺点： 实现较为复杂 推荐指数：★★★★（实现复杂，扣掉一颗星） 7、六种继承方式的联系 PS：虚线表示辅助作用，实现表示决定性作用 参考文章 JS继承的实现方式 重新理解JS的6种继承方式","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"}]},{"title":"前端面试系列（8）——TCP的三次握手与四次分手","slug":"前端面试系列（8）——TCP的三次握手与四次分手","date":"2017-04-05T08:07:21.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170405/tce-three-handshakes-and-four-breakups.html","link":"","permalink":"http://merrier.wang/20170405/tce-three-handshakes-and-four-breakups.html","excerpt":"","text":"预备知识OSI七层模型开放系统互连参考模型 (Open System Interconnect 简称 OSI）是国际标准化组织（ISO）和国际电报电话咨询委员会（CCITT）联合制定的开放系统互连参考模型，为开放式互连信息系统提供了一种功能结构的框架。它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每一层的功能是独立的。它利用其下一层提供的服务并为其上一层提供服务，而与其他层的具体实现无关。这里所谓的“服务”就是下一层向上一层提供的通信功能和层之间的会话规定，一般用通信原语实现。两个开放系统中的同等层之间的通信规则和约定称之为协议。通常把1～4层协议称为下层协议，5～7 层协议称为上层协议。 TCP / IPTCP 工作在网络 OSI 的七层模型中的第四层——Transport 层，IP 在第三层——Network 层，ARP 在第二层——Data Link 层；在第二层上的数据，我们把它叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。在 OSI 七层模型中，每一层的作用和对应的协议如下： 数据格式TCP 是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记 TCP 协议中每个字段的含义。 上面就是 TCP 协议头部的格式，下面就将每个字段的信息都详细的说明一下。 Source Port和Destination Port：分别占用 16 位，表示源端口号和目的端口号；用于区别主机中的不同进程，而 IP 地址是用来区分不同的主机的，源端口号和目的端口号配合上 IP 首部中的源 IP 地址和目的 IP 地址就能唯一的确定一个 TCP 连接； Sequence Number：用来标识从 TCP 发端向 TCP 收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题； Acknowledgment Number：32 位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加 1。不过，只有当标志位中的 ACK 标志（下面介绍）为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题； Offset：给出首部中 32 bit 字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占 4bit（最多能表示 15 个 32bit 的的字，即 4*15=60 个字节的首部长度），因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节； TCP Flags：TCP 首部中有 6 个标志比特，它们中的多个可同时被设置为 1，主要是用于操控 TCP 的状态机的，依次为 URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下： URG：此标志表示 TCP 包的紧急指针域（后面马上就要说到）有效，用来保证 TCP 连接不被中断，并且督促中间层设备要尽快处理这些数据； ACK：此标志表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0； PSH：这个标志位表示 Push 操作。所谓 Push 操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队； RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包； SYN：表示同步序号，用来建立连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN = 1，ACK = 0；连接被响应的时候，SYN = 1，ACK = 1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行 TCP 三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行 TCP 的三次握手； FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送 FIN 标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。 Window：窗口大小，也就是有名的滑动窗口，用来进行流量控制；这是一个复杂的问题，这篇博文中并不会进行总结的； 三次握手TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP / IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。这就是面试中经常会被问到的 TCP 三次握手。\b下图很形象的展示了三次握手和四次分手的数据交换： 第一次握手：建立连接。客户端发送连接请求报文段，将 SYN 位置为1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认； 第二次握手：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number + 1)；同时，自己自己还要发送 SYN 请求信息，将 SYN 位置为1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN + ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态； 第三次握手：客户端收到服务器的SYN + ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。 四次分手当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的啊。那对于 TCP 的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机 1（可以是客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机1没有数据要发送给主机 2 了； 第二次分手：主机 2 收到了主机1发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求； 第三次分手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态； 第四次分手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。 至此，TCP 的四次分手就这么愉快的完成了。 为什么要握手三次既然总结了 TCP 的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那 TCP 为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的： 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 在书中同时举了一个例子： “已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。” 总结一下就是为了防止服务器端一直等待而浪费资源。 为什么要分手四次那四次分手又是为何呢？TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 FIN_WAIT_1：这个状态要好好解释一下，其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是：FIN_WAIT_1 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该 SOCKET 即进入到 FIN_WAIT_1 状态。而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。（主动方） FIN_WAIT_2：上面已经详细解释了这种状态，实际上 FIN_WAIT_2 状态下的 SOCKET，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK 信息)，稍后再关闭连接。（主动方） CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 FIN 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 FIN 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。（被动方） LAST_ACK：这个状态还是比较容易好理解的，它是被动关闭一方在发送 FIN 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 CLOSED 可用状态了。（被动方） TIME_WAIT：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。（主动方） CLOSED：表示连接中断。 其他问题1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。 2．为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。 扩展阅读 怎样生动描述TCP的「三次握手」？","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/categories/计算机基础/"}],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/tags/计算机基础/"}]},{"title":"前端面试系列（7）——session&cookie","slug":"前端面试系列（7）——session&cookie","date":"2017-04-04T14:05:42.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170404/session-and-cookie.html","link":"","permalink":"http://merrier.wang/20170404/session-and-cookie.html","excerpt":"","text":"本篇文章参考了一些开发者对于 session 和 cookie 的讲解，对这些内容进行了筛选和合并，同时加入了我的理解，争取用最短的篇幅给大家讲清楚这两个概念，因为在前端面试或笔试中会经常碰到这两个问题，同时在很多项目中也会用到 session 的概念Web 应用程序是使用 HTTP 协议传输数据的。HTTP 协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户 A 购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户 A 的会话还是用户 B 的会话了。要跟踪该会话，必须引入一种机制。当浏览器第一次发送请求时，服务器自动生成了一个 Session 和一个 Session ID 用来唯一标识这个 Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的 Session ID 放在请求中一并发送到服务器上，服务器从请求中提取出 Session ID，并和保存的所有 Session ID 进行对比，找到这个用户对应的 Session。一般情况下，服务器会在一定时间内（默认 30 分钟）保存这个 Session，过了时间限制，就会销毁这个 Session。在销毁之前，程序员可以将用户的一些数据以 Key 和 Value 的形式暂时存放在这个 Session 中。当然，也有使用数据库将这个 Session 序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。 session 的客户端实现形式即 session ID 的保存方法，一般浏览器提供了两种方式来保存，还有一种是程序员使用 html 隐藏域的方式自定义实现： 使用 Cookie 来保存这是最常见的方法，\b比如“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置 Cookie 的方式将 Session ID 发送到浏览器。如果我们不设置这个过期时间，那么这个 Cookie 将不存放在硬盘上，当浏览器关闭的时候，Cookie 就消失了，这个 Session ID 就丢失了。如果我们设置这个时间为若干天之后，那么这个 Cookie 会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同样会发送到服务器上。 使用 URL 附加信息的方式也就是像我们经常看到 JSP 网站会有 aaa.jsp?JSESSIONID=* 一样的。这种方式和第一种方式里面不设置 Cookie 过期时间是一样的。 第三种方式是在页面表单里面增加隐藏域这种方式实际上和第二种方式一样，只不过前者通过 GET 方式发送数据，后者使用 POST 方式发送数据。但是明显后者比较麻烦。 cookie 的局限性Session 是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的 SessionID，用该 SessionID 为标识符来存取服务器端的 Session 存储空间。而 SessionID 这一数据则是保存到客户端，用 Cookie 保存的，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 Session 数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用 Cookie，那么 Session 也会失效。服务器也可以通过 URL 重写的方式来传递 SessionID 的值，因此不是完全依赖 Cookie。如果客户端 Cookie 禁用，则服务器可以自动通过重写URL的方式来保存 Session 的值，并且这个过程对程序员透明。可以试一下，即使不写 Cookie，在使用 request.getCookies(); 时取出的 Cookie 数组的长度也是 1，而这个 Cookie 的名字就是 JSESSIONID，还有一个很长的二进制的字符串，是 SessionID 的值。 cookie 的性质 不可跨域 保存中文只能编码（UTF-8） cookie 的应用 判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除 cookie，则每次登录必须从新填写登录的相关信息。 另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入 cookie，在最后付款时从 cookie 中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。 记录用户访问次数，服务器可以通过操作 Cookie 类对象对客户端 Cookie 进行操作 cookie 和 session 的区别和联系 cookie 数据存放在客户的浏览器上，session 数据放在服务器上。 cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗；考虑到安全应当使用session。 session 会在一定时间内保存在服务器的一个文件里（不是内存）。当访问增多，会比较占用你服务器的性能；考虑到减轻服务器性能方面，应当使用 COOKIE。 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。 session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id） Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。 如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 参考文章 cookie 和session 的区别详解 COOKIE和SESSION有什么区别 浅谈Session与Cookie的区别与联系 Cookie/Session机制详解","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/categories/HTTP/"}],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"}]},{"title":"前端面试系列（6）——HTTP请求的状态码","slug":"前端面试系列（6）——HTTP请求的状态码","date":"2017-04-04T13:38:16.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170404/status-code-of-http-request.html","link":"","permalink":"http://merrier.wang/20170404/status-code-of-http-request.html","excerpt":"","text":"首先说一下 HTTP，超文本传输协议（HTTP）是一种通信协议，它允许将超文本标记语言（HTML）文档从 Web 服务器传送到客户端的浏览器；而状态码在 Response 消息中的第一行（状态行），用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response 类型HTTP/1.1 中定义了 5 类状态码，状态码由三位数字组成，第一个数字定义了响应的类别 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 状态码含义粗体为常见状态码，需要多留意 状态码 英文解释 中文解释 备注 100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分 HTTP 1.1 新 101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议 HTTP 1.1 新 200 OK 一切正常，对GET和POST请求的应答文档跟在后面 201 Created 服务器已经创建了文档，Location头给出了它的URL 202 Accepted 已经接受请求，但处理尚未完成 203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝 HTTP 1.1 新 204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而 Servlet 可以确定用户文档足够新，这个状态代码是很有用的 205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容 HTTP 1.1 新 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它 HTTP 1.1 新 300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明 301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL 302 Found 类似于 301，但新的URL应该被视为临时性的替代，而不是永久性的 在 HTTP1.0 中对应的状态信息是 “Moved Temporatily” 303 See Other 类似于301/302，不同之处在于，如果原来的请求是 POST，Location 头指定的重定向目标文档应该通过 GET 提取 HTTP 1.1 新 304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用 305 Use Proxy 客户请求的文档应该通过 Location 头所指明的代理服务器提取 HTTP 1.1 新 307 Temporary Redirect 和 302 相同。许多浏览器会错误地响应 302 应答进行重定向，即使原来的请求是 POST，即使它实际上只能在 POST 请求的应答是 303 时才能重定向。由于这个原因，HTTP 1.1 新增了 307，以便更加清除地区分几个状态代码：当出现 303 应答时，浏览器可以跟随重定向的 GET 和 POST 请求；如果是 307 应答，则浏览器只能跟随对 GET 请求的重定向 HTTP 1.1 新 400 Bad Request 请求出现语法错误 401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个 WWW-Authenticate 头，浏览器据此显示用户名字/密码对话框，然后在填写合适的 Authorization 头后再次发出请求 403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致 404 Not Found 无法找到指定位置的资源。这也是一个常用的应答 405 Method Not Allowed 请求方法（GET、POST、HEAD、Delete、PUT、TRACE 等）对指定的资源不适用。 HTTP 1.1 新 406 Not Acceptable 指定的资源已经找到，但它的 MIME 类型和客户在 Accpet 头中所指定的不兼容 HTTP 1.1 新 407 Proxy Authentication Required 类似于 401，表示客户必须先经过代理服务器的授权 HTTP 1.1 新 408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求 HTTP 1.1 新 409 Conflict 通常和 PUT 请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功 HTTP 1.1 新 410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址 HTTP 1.1 新 411 Length Required 服务器不能处理请求，除非客户发送一个 Content-Length 头 HTTP 1.1 新 412 Precondition Failed 请求头中指定的一些前提条件失败 HTTP 1.1 新 413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个 Retry-After 头 HTTP 1.1 新 414 Request URI Too Long URI 太长 HTTP 1.1 新 500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求 501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求 502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet 可能在数据库连接池已满的情况下返回503。服务器返回 503 时可以提供一个 Retry-After 头 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答 HTTP 1.1 新 505 HTTP Version Not Supported 服务器不支持请求中所指明的 HTTP 版本 HTTP 1.1 新 扩展阅读 [一篇学习HTTP状态码的神文]（http://www.codeceo.com/article/http-code.html）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/categories/HTTP/"}],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"},{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/tags/HTTP/"}]},{"title":"CSS书写规范","slug":"CSS书写规范","date":"2017-04-04T13:12:45.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170404/css-writing-specification.html","link":"","permalink":"http://merrier.wang/20170404/css-writing-specification.html","excerpt":"","text":"本篇文章转载自 cnblogs，我在看了原文章之后又搜了一些其他相关资料，就有了下面这些对于 CSS 书写规范的总结。CSS 作为前端语言中最好学的一种，很容易造成“不需要规范”的错觉，但其实 CSS 的书写也有很多规范，顺序、命名以及缩写等等，知道并且遵循这些规范不仅可以更容易让别人读懂你的代码，还能方便自己。 CSS 书写顺序 位置属性（position, top, right, z-index, display, float 等） 大小（width, height, padding, margin） 文字系列（font, line-height, letter-spacing, color- text-align 等） 背景（background, border 等） 其他（animation, transition 等） CSS 书写规范使用 CSS 缩写属性CSS 有些属性是可以缩写的，比如 padding, margin, font 等等，这样精简代码同时又能提高用户的阅读体验。 去掉小数点前的 “0” 简写命名很多用户都喜欢简写类名，但前提是要让人看懂你的命名才能简写哦！ 16 进制颜色代码缩写有些颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。 连字符 CSS 选择器命名规范 长名称或词组可以使用中横线来为选择器命名。 不建议使用 “_” 下划线来命名 CSS 选择器，为什么呢？ 输入的时候少按一个 shift 键； 浏览器兼容问题 （比如使用 _tips 的选择器命名，在 IE6 是无效的） 能良好区分 JavaScript 变量命名（JS 变量命名是用 “_”） 这里有一篇破折号与下划线的详细讨论，英文：点击查看 中文篇：点击查看 《CSS Secrets》的译者张鹏对于使用 “_” 还是 “-“ 也阐述了自己的观点，比较了两者的优缺点，可以点击这里查看 不要随意使用 Idid 在 JS 是唯一的，不能多次使用，而使用 class 类选择器却可以重复使用，另外 id 的优先级优先与 class，所以 id 应该按需使用，而不能滥用。 为浏览器添加状态前缀有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下图是添加了 “.is-” 前缀。 CSS 命名规则可以按照功能、位置、结构进行命名，因为命名的出发点就是为了让自己和其他人都能看懂，所以越明白越好： 一律小写; 尽量用英文; 不加中槓和下划线; 尽量不缩写，除非一看就明白的单词。 在译文《CSS命名神马的真心难》中，作者指出可以根据三类情况给定一个 class 名： 功能性（positive-button、important-text、selected-tab） 内容性（submit-button、intro-text、profile-photo） 展示性（green-button、bit-text、sqiggle-border） 其实，在我看来，命名的首要目的就是“语义化”，而“语义化”有两个方面：方便自己和方便别人，所以不一定所有的语义化都需要按照内容进行命名，class 名的语义化不同于 HTML，可以按照其背后的意义和开发者的意图进行命名 最常用主要命名：wrap（外套、最外层）、header（页眉、头部）、nav(导航条)、menu(菜单)、title(栏目标题、一般配合h1\\h2\\h3\\h4标签使用)、content (内容区)、footer(页脚、底部)、logo（标志、可以配合h1标签使用）、banner（广告条，一般在顶部）、copyRight（版权） CSS 样式表文件命名 主要的 master.css 模块 module.css 基本共用 base.css 布局、版面 layout.css 主题 themes.css 专栏 columns.css 文字 font.css 表单 forms.css 补丁 mend.css 打印 print.css 参考文章 推荐大家使用的CSS书写规范、顺序 CSS命名神马的真心难 css命名方式 BEM——一种css命名解决方案 BEM —— 源自Yandex的CSS 命名方法论 CSS设计模式：OOCSS 和 SMACSS","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"}]},{"title":"写给刚接触前端的你","slug":"写给刚接触前端的你","date":"2017-04-03T15:25:04.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170403/to-you-who-just-touched-the-front-end.html","link":"","permalink":"http://merrier.wang/20170403/to-you-who-just-touched-the-front-end.html","excerpt":"","text":"转眼间，我做前端也有两年左右了，从一开始本科毕设用 HDwiki 搭了一个小网站，到现在用 wordpress 搭个人博客；从一开始改 html 的 bug 都得百度一下午，到现在可以试着写一些小插件；从一开始不知道为什么变量不用双引号，到现在将近二十万行的代码量；我承认这两年我进步了很多，但是回想起来还是有很多遗憾和不足，所以在这里想对刚接触前端的你说一些话，以免走弯路。这篇文章只对刚接触前端不到两个月，或者刚从所谓的“速成班”学成归来，对于前端之路比较迷茫的同学有用 前端进阶路线前端学习路线是典型的先易后难，上手很简单，但是一旦深入就会发现比其他任何语言都要难，内容都要多得多，因为前端需要学的东西实在是太多太多，下面是我总结的进阶路线（我当然仍处于初级阶段）： CSS（CSS3） HTML（HTML5） JavaScript（ES6） HTTP 协议 代码优化 性能优化 框架了解和学习 自己封装框架并进行模块化组件开发 全栈 Node.js 接下来我会从以上的方面分别进行总结（有些坑希望你别爬，有些捷径希望你知道），前 5 个阶段我用两年的时间渡过了（代码优化是永久话题，并没有终点），后面的几个阶段我会摘抄一些其他人的总结；如果你没有耐心看下去那么多文字，可以直接看最后的总结O(∩_∩)O CSS如果你学习了一段时间前端，可能会觉得 CSS 好简单，但是 CSS 也有瓶颈期，而且运用得当的话会帮我们省去很多 JavaScript 代码，针对于 css 如何学习，我有以下建议： 只要是前端入门学习，w3c是再好不过的网站，这个网站有大量的实例教程，希望你有时间的话能够过一遍，就算记不住也没关系，有印象即可 MDN上有很多基础知识的文章，CSS入门教程也是 CSS 学习的好材料 CSS3 是一个突破点，因为之前 CSS2 的那些属性大家都已经用烂了，而 CSS3 尚处于开发研究阶段，如果能够熟练使用将会使自己升值不少 在了解了 CSS 的选择器、属性和值之后，再下一步就是 CSS 布局了，这里有一个专门用来学习 CSS布局的网站，里面的教程很全面，相信你可以学到很多新的知识点 至少会用一种 CSS 预处理工具（Sass、Less、Stylus），这些工具会让你的 CSS 书写更加快捷 HTML作为前端界的“领头人”，html 是我们和用户离得最近的代码语言，而 html 也是最容易提升的前端语言了，因为其核心就是语义化和加载速度，而对于前端初学者，我有话要说： html 基础学习依然推荐 w3c和 MDN，这两个网站的风格不同，w3c 更书本化一些，可能需要一些耐心才能看下去，而 MDN 从网站的配色到文字描述风格都更“高大上”一些 HTML5 方案已经实施很久了，各大浏览器基本上都已经实现了兼容（IE 我就不吐槽了），所以对于 h5 的学习也是重点内容，尤其是 canvas、audio &amp; video 以及和性能优化相关的各种标签 一定要从刚写 html 开始就养成“语义化”和减少嵌套的习惯，文本多用 p 标签，代码块多用 pre 标签，表单提交多用 submit…… Javascript如果说 html 是前端界的“领头人”，那 JS 就是前端界的“大高个”，也是最容易拉开差距的一门语言，所以 JS 的学习对于前端初学者来说就显得尤为重要了： 依然推荐 w3c，和 html 与 css 不同的是，w3c 上关于 JS 的教程实在是太多，如果真的时间不充足的话可以看的粗一些，知道概念就可以了 在对 JS 有一些概念之后，如果有比较急得项目需求，我推荐你看一下 jQuery 的相关教程（当然还是 w3c），因为 jQuery 在 JS 框架里属于非常简单的，入门很快，但是能解决大部分项目需求，是一个性价比很高的 js 库 如果你的项目需要用到 React 以及 Vue.js 等框架，可能需要看一下 ES6 的相关知识，推荐阮一峰的 ECMAScript 6 入门 HTTP可能你会比较纳闷，为什么还需要知道 HTTP？请记住，前端是和客户端打交道的（至少目前来看是这样的），所以各种和客户端以及服务器相关的协议一定要了解一些，这对于你的前端水平提升尤为重要，可以让你更容易找到 bug 出在哪里（两年的前端经验使我更加明确这一点） 知道 URL 是怎么回事以及其组成规则 可以上网查一下 HTTP 各种状态码的含义，在调试代码和找 bug 的过程中会经常用到 cookie &amp; session 的知识在某些类型的网站会经常用到（支付、博客） 代码优化对于程序猿来说，代码就像自己的门面，如果代码一团糟，就会让同行笑话甚至会因此丢掉工作，所以代码优化对于程序猿来说就属于必经阶段了： 1. css 减少选择器的叠加层数 少用 !important 注意 CSS 书写顺序 命名规则尽量语义化 少用内联样式 注释、注释、注释！ 具体可以参考我的另一篇文章：CSS书写规范 2. html 减少 div 的嵌套层数 多用语义化标签（h5 标签居多） 少用 id 注释、注释、注释！ 3. JavaScript 按照功能进行命名 尽可能面向对象编程 注释、注释、注释！ 性能优化前端是直接和用户打交道的，而浏览器的响应速度更会直接影响到用户体验，如果一个网站打开需要两秒钟，可能会有百分之 30 的用户直接关掉页面；如果一个网站打开需要五秒钟，可能以后就没有这家网站了，所以性能优化是一个优秀的前端工程师必备技能，同时也是终极目标；关于性能优化，首先你必须看过雅虎军规，没看过可以看看这篇文章-毫秒必争，前端网页性能最佳实践。除此之外，你需要知道，性能优化包括以下几个方面： 针对浏览器渲染页面原理的 CSS、JavaScript 语法层面优化 针对 HTTP 协议特性网络性能优化（合并资源、压缩、多个域名等） 用户体验层面性能优化（懒加载之类） 在现在计算机运行速度下，只要代码写的不是特别过分，第一点对性能优化能做的很少，我们使用了更好的语法也不会对网页提速很多。第二点是必须要做的，而第三点现在主要成了性能优化的主要发力点 框架了解和学习前端和所有计算机工作一样，终极目标都是解决问题，所以千万不要沉迷于框架或者语言的无谓之争上。对于前端来说，各种框架层出不穷，各种知识学都学不完，所以将 html、css 和 js 的基础掌握牢固才能以不变应万变，当然，框架也是为了方便书写代码和优化才产生的，其存在必有其合理之处，如果你已经开始从事前端工作，请听从领导的安排，一句话就是之前用什么框架现在就用什么框架吧。。除非决定要更换框架，否则不要轻易换框架，因为可能代价会比较高 如果你只是在校学生，还有很久的时间用来学习，我希望你能够把更多的精力放在基础学习上，不会因为各种各样的框架而不知道学什么；只要将基础知识掌握牢固，就什么框架都不在话下了，学习起来会很快 自己封装插件并进行模块化组件开发暂无 全栈 Node.js不得不说，Node.js 在前端领域已经火的不要不要的了，因为其具备其他框架没有的特性——用 js 写后台；试想一下，一家公司只需要雇一个前端工程师就能完成前后端的所有工作，这将节省多少成本（有时候，前后端沟通联调也需要很长的时间成本），同时在 Node.js 基础上开发的插件也越来越多，使 Node.js 的功能愈加强大，似有一统前端之势。所以，如果前端基础学习遇到瓶颈或者想去用 Node.js 的公司，可以尝试一下，不仅可以学到 ES6 的各种新知识还可以了解到异步编程、按需加载等比较新的技术 其他推荐书籍 《编写高质量代码–Web前端开发修炼之道》 《JavaScript高级程序设计》 《JavaScript权威指南》 《锋利的jQuery》 《图解HTTP》 《HTTP权威指南》 《精彩绝伦的CSS》 《响应式Web设计：HTML5和CSS3实战》 《Head First HTML与CSS》 《HTML5与CSS3权威指南》 其他需要掌握的技术 git：代码托管工具 Markdown：github 御用格式，语法简单实用，养成多写文档的习惯大有裨益 vi命令：界面简单但是功能强大的编辑器-Vim，知道一些常用命令可以事半功倍 Linux：Linux 即使在今天依然发挥着强大的优势 多看、多想、多做作为前端初学者，一定要多看、多想、多做： 多看：经常浏览一些做得比较好的网站，看他们的 html 结构、页面布局、class 命名以及各种动画设计和实现，会不时地发现新的创意和灵感多想：碰到 bug 一定要多想，多尝试；从我自身而言，我觉得找 bug 是提升最快的一种方式，而很多初学者都很怕找 bug，以至于上次遇到的 bug 这次遇到了还是不会解决，这会严重阻碍你的进步！多做：和所有语言一样，只看不做是不会记得久的，所以在看文字教程和视频教程的同时，一定要多在编辑器里敲一敲代码，同时也要尝试着做一下笔记，对于个人的成长也会很有帮助 忌浮躁不要为框架而烦恼，只要学好了基础，框架就不是难题；但如果基础学不好，用框架的时候也会碰到各种麻烦，所以作为前端工程师，一定要戒骄戒躁，遇到不会的问题先自己思考，实在想不出来了再去询问前辈或者上网找答案，这样才能提升自己的水平 了解一门后台语言最好了解一门后台语言，最起码读得懂后台写的什么，这样会省去很多前后台沟通的时间","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://merrier.wang/categories/杂谈/"}],"tags":[{"name":"指南","slug":"指南","permalink":"http://merrier.wang/tags/指南/"},{"name":"心得","slug":"心得","permalink":"http://merrier.wang/tags/心得/"}]},{"title":"前端面试系列（5）——CSS盒子模型","slug":"前端面试系列（5）——CSS盒子模型","date":"2017-04-03T12:20:11.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170403/the-css-box-model.html","link":"","permalink":"http://merrier.wang/20170403/the-css-box-model.html","excerpt":"","text":"盒子模型是 html + css 最核心的基础知识，理解了这个重要的概念才能更好的排版，进行页面布局；同时在前端面试或笔试中也经常遇到，所以深入理解盒子模型对自身前端水平的提升有很大帮助。 概念介绍css 盒子模型又称为框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素，如图： 图中最内部的框是元素的实际内容，也就是元素框，紧挨着元素框外部的是内边距 padding，其次是边框（border），然后最外层是外边距（margin），整个构成了框模型。通常我们设置的背景显示区域，就是内容、内边距、边框这一块范围。下面是对这四个部分的说明： Margin（外边距） - 边框外围区域。Margin 没有背景颜色，它是完全透明 Border（边框） - 边框周围的填充和内容。边框是受到盒子的背景颜色影响 Padding（内边距） - 清除内容周围的区域。会受到框中填充的背景颜色影响 Content（内容） - 盒子的内容，显示文本和图像 那么，元素框的总宽度 = 元素（element）的 width + padding 的左边距和右边距的值 + margin 的左边距和右边距的值 + border 的左右宽度；元素框的总高度 = 元素（element）的height + padding 的上下边距的值 + margin 的上下边距的值 ＋ border 的上下宽度。所以，在 box-sizing 为 content-box 也就是上面所述盒子模型时，当我们指定了一个 CSS 元素的高度和宽度属性时，只是设置了内容区域的高度和宽度 盒子模型表现1. 外边距合并（叠加）两个上下方向相邻的元素框垂直相遇时，外边距会合并，合并后的外边距的高度等于两个发生合并的外边距中较高的那个边距值，如图： 比较容易理解，所以在页面中有时候遇到实际情况是需要考虑这个因素的。当然外边距合并其实也有存在的意义，如下图： 关于 margin 合并，其实还有很多不为人知的知识和问题，稍晚一些我会再专门针对 margin 合并写一篇文章（其实应该不算是“写”，因为是对张鑫旭的讲解的总结），感兴趣的童鞋可以直接搜索 “\bmargin 合并”查看 box-sizingbox-sizing 属性是用户界面属性里的一种（CSS3），之所以介绍它，是因为这个属性跟盒子模型有关，而且在 css reset 中有可能会用到它。 box-sizing: content-box | border-box | inherit; content-box默认值，可以使设置的宽度和高度值应用到元素的内容框。盒子的 width 只包含内容。 即总宽度 = margin + border + padding + width border-box设置的 width 值其实是除 margin 外的 border + padding + element 的总宽度。盒子的 width 包含 border + padding + 内容 即总宽度 = margin + width，关于 border-box 的使用： 一个 box 宽度为 100%，又想要两边有内间距，这时候用就比较好 全局设置 border-box 很好，首先它符合直觉，其次它可以省去一次又一次的加加减减，它还有一个关键作用——让有边框的盒子正常使用百分比宽度。 inherit规定应从父元素继承 box-sizing 属性的值 下面两张图形象的展示了 box-sizing 为 content-box 和 border-box 时的区别： （1）标准的盒子模型（content-box）： （2）IE盒子模型（border-box）： 盒子模型应用用盒子模型画三角形html 代码： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .triangle &#123; width : 0; height: 0; border : 100px solid transparent; border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"triangle\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 页面显示结果为： 盒子模型产生的问题margin 越界即第一个子元素的 margin-top 和最后一个子元素的 margin-bottom 的越界问题，以第一个子元素的margin-top 为例：当父元素没有边框 border 时，设置第一个子元素的margin-top值的时候，会出现margin-top值加在父元素上的现象，解决方法有四个： 给父元素加边框border （副作用） 给父元素设置padding值 （副作用） 父元素添加 overflow：hidden （副作用） 父元素加前置内容生成。（推荐） 以第4种方法为例： html代码： css代码： .parent { width : 500px; height : 500px; background-color : red;}.parent : before { content : “ “; display : table;} .child { width : 200px; height : 200px; background-color : green; margin-top : 50px;} 2.浏览器间的盒子模型（1）ul标签在Mozilla中默认是有padding值的，而在IE中只有margin有值。 （2）标准盒子模型与IE模型之间的差异： 标准的盒子模型就是上述介绍的那种，而IE模型更像是 box-sizing : border-box; 其内容宽度还包含了border和padding。解决办法就是：在html模板中加doctype声明。但是我自己在项目中已经很少考虑IE了，如果没有特殊要求的话，IE基本上可以完全忽略了 参考链接cnblogs：http://www.cnblogs.com/clearsky/p/5696286.html","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"}]},{"title":"前端面试系列（4）——CSS选择器","slug":"前端面试系列（4）——CSS选择器","date":"2017-04-03T03:43:13.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170403/css-selector.html","link":"","permalink":"http://merrier.wang/20170403/css-selector.html","excerpt":"","text":"写在前面这篇文章主要总结了CSS选择器的相关知识，CSS的选择器是前端面试或者笔试中经常问到和用到的，同时对于开发来说也是必备基础知识 优先级不同级别 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。 作为style属性写在元素内的样式（简称为“内联样式”） id选择器 类选择器 标签选择器 通配符选择器 浏览器自定义 另外，在《精彩绝伦的CSS》这本书中，作者用数字定量了选择器的优先级，具体规则为： 每个元素描述符贡献0，0，0，1 每个类、伪类或者属性描述符贡献0，0，1，0 每个ID描述符贡献0，1，0，0 行内样式或内联样式贡献1，0，0，0 可能看到这里你还比较糊涂，那请看下面这张图片： 其实就是简单的加法，数字越大优先级越高（为何如此计算尚不得知，仅作为额外知识），!important会覆盖任何没有!ip 同一级别同一级别中后写的会覆盖先写的样式 基础选择器这几类是使用频率最高的几种，同时在各个版本的reset.css中也会经常出现 [table id=8 /] 组合选择器这些选择器让我们的样式添加更加灵活，同时需要注意的是不只能写两层，理论上讲只要找得到可以写无限层，但是层数越多越影响性能，同时也会有优先级的麻烦，所以争取用最简短、最准确的选择器才是正道 [table id=9 /] 属性选择器这一类的选择器用的比较少，因为其实用性并不是很高，同时在性能方面也会比较差，所以可以作为了解，如果真需要用属性去选择的时候知道css有属性选择器就可以了 [table id=10 /] 伪类选择器这一类选择器大部分都是CSS3新增类型，可以更方便、更快捷地匹配到目标元素，所以以下这些选择器很重要，需要牢牢记住 [table id=11 /] 伪元素选择器不得不说，:before和:after选择器好用到爆（谁用谁知道），在一些悬停动画、箭头绘制以及clearfix样式里会经常见到 [table id=12 /] 总结CSS的选择器是基础中的基础，而有些选择器使用频率是比较低的，但是一定要知道css的选择器都有哪些，遇到新的需求时会少很多麻烦。同时，不要经常使用多层选择器（尤其是5，6层那种），这会使页面渲染负担加重。 参考链接cnblogs：http://www.cnblogs.com/dolphinX/p/3347713.html w3c：http://www.w3school.com.cn/cssref/css_selectors.asp","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"}]},{"title":"Leetcode的JS实现——Easy篇（上）","slug":"Leetcode的JS实现——Easy篇（上）","date":"2017-03-31T09:24:05.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170331/js-implementation-of-leetcode-easy-part1.html","link":"","permalink":"http://merrier.wang/20170331/js-implementation-of-leetcode-easy-part1.html","excerpt":"","text":"写在前面由于要找实习，所以最近几周一直在刷leetcode（打算先把easy刷完，大概一天10道左右）；而作为一个前端码农，也就只能用js实现算法了，但是众所周知，js在算法实现方面是真的不如其他知名语言（java、python、c++），所以绝大多数题都没有js的标准答案，这让我在刷leetcode的过程变得异常艰难；为了方便和我一样用js刷leetcode的码农，打算写一篇纯干货（代码）的文章，对如何用js实现leetcode算法题进行总结。（鉴于我水平有限和js本身的局限性，有好多题目我虽然看到了，但是最终没有用js实现，如果你知道某些题目的js实现或有更优解法，请点击网站下方链接联系我，O(∩_∩)O谢谢） 介绍leetcode地址：https://leetcode.com/problemset/algorithms/ 本文章不会贴出题目，可以点击标题链接查看原题目 排序方式：按照\b本难度中题目的accepted统计 JS代码实现461-Hamming distance方法一：利用replace()方法 /** * @param {number} x * @param {number} y * @return {number} */var hammingDistance = function(x, y) { return (x^y).toString(2).replace(/0/g,””).length;}; 方法二：利用异或 /** * @param {number} x * @param {number} y * @return {number} */var hammingDistance = function(x, y) { var xor = x ^ y, count = 0; for (var i=0;i&lt;32;i++) count += (xor &gt;&gt; i) &amp; 1; return count;}; 476-Number Complement方法一：利用二进制 /** * @param {number} num * @return {number} */var findComplement = function(num) { return num^(Math.pow(2,(num.toString(2).length))-1);}; 方法二：利用位运算中的移位 /** * @param {number} num * @return {number} */var findComplement = function(num) { var mask = num; mask |= mask &gt;&gt; 1; mask |= mask &gt;&gt; 2; mask |= mask &gt;&gt; 4; mask |= mask &gt;&gt; 8; mask |= mask &gt;&gt; 16; return num ^ mask;}; 500-Keyboard Row暂无 412-Fizz Buzz方法一：各种if /** * @param {number} n * @return {string[]} */var fizzBuzz = function(n) { var arr = []; for(var i=1;i&lt;n+1;i++){ if(i%15 == 0){ arr[i-1] = “FizzBuzz” }else if(i%5 == 0){ arr[i-1] = “Buzz” }else if(i%3 == 0){ arr[i-1] = “Fizz” }else{ arr[i-1] = “” + i } } return arr;}; 344-Reverse String方法一：从后往前遍历 /** * @param {string} s * @return {string} */var reverseString = function(s) { var str = “”; for(var i=1,n=s.length;i&lt;n+1;i++){ str += s[n-i]; } return str;}; 方法二：递归 /** * @param {string} s * @return {string} */var reverseString = function(s) { var length = s.length; if (length &lt;= 1) return s; var leftStr = s.substring(0, length / 2); var rightStr = s.substring(length / 2, length); return reverseString(rightStr) + reverseString(leftStr);}; 496-Next Greater Element I暂无 463-Island Perimeter方法一：每块陆地都加4，遇到有相邻陆地时减2 /** * @param {number[][]} grid * @return {number} */var islandPerimeter = function(grid) { var result=0; for(var i=0,n=grid.length;i&lt;n;i++){ for(var j=0,m=grid[0].length;j&lt;m;j++){ if(grid[i][j] ==1){ result +=4; if(i&gt;0 &amp;&amp; grid[i-1][j] == 1){result -=2} if(j&gt;0 &amp;&amp; grid[i][j-1] ==1 ){result -=2} } } } return result;}; 292-Nim Game方法一：只要数字能被4整除就赢不了 /** * @param {number} n * @return {boolean} */var canWinNim = function(n) { return !!(n%4)}; 485-Max Consecutive Ones方法一：看到0时就将max置为0，否则max加1 /** * @param {number[]} nums * @return {number} */var findMaxConsecutiveOnes = function(nums) { var result = 0; var num = 0; for(var i = 0;i&lt;nums.length;i++){ result = Math.max(result,num =(nums\\[i\\]==0) ? 0: num+1); } return result; }; 136-Single Number方法一：利用位运算中的异或（异或运算可交换位置，且相同数字异或结果为0） /** * @param {number[]} nums * @return {number} */var singleNumber = function(nums) { var result; for(var i=0,n=nums.length;i&lt;n;i++){ result ^= nums[i] } return result}; 448-Find All Numbers Disappeared in an Array方法一：利用哈希表将看到的数字变为负数 /** * @param {number[]} nums * @return {number[]} */var findDisappearedNumbers = function(nums) { var n= nums.length; var result = []; for(var i=0;i&lt;n;i++){ var j = Math.abs(nums[i]) -1; nums[j] = -Math.abs(nums[j]); } for(var k=0; k&lt;n;k++){ if(nums\\[k\\]&gt;0){ result.push(k+1); } } return result; }; 520-Detect Capital方法一：巧用indexOf /** * @param {string} word * @return {boolean} */var detectCapitalUse = function(word) { return !(word.indexOf(word.toUpperCase()) &amp;&amp; word.indexOf(word.toLowerCase()) &amp;&amp; word.indexOf(word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase()))}; 方法二：正则 暂无 104-Maximum Depth of Binary Tree方法一：递归，其实很容易发现规律 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var maxDepth = function(root) { return root === null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;}; 389-Find the Difference方法一：依然是replace() /** * @param {string} s * @param {string} t * @return {character} */var findTheDifference = function(s, t) { for(var i=0,n=s.length;i&lt;n;i++){ t = t.replace(s[i],””); } return t;}; 方法二：位运算 /** * @param {string} s * @param {string} t * @return {character} */var findTheDifference = function(s, t) { var n = t.length,c = t.charCodeAt(n - 1); for (var i = 0; i &lt; n - 1; i++) { c ^= s.charCodeAt(i); c ^= t.charCodeAt(i); } return String.fromCharCode(c);}; 371-Sum of Two Integers方法一：位运算 /** * @param {number} a * @param {number} b * @return {number} */var getSum = function(a, b) { return b==0? a:getSum(a^b, (a&amp;b)&lt;&lt;1);}; 226-Invert Binary Tree方法一：二叉树基本上都是递归，只不过这次规律很容易发现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {TreeNode} */var invertTree = function(root) { if(!root){ return null; } var left = root.left, right = root.right; root.left = invertTree(right); root.right = invertTree(left); return root; }; 492-Construct the Rectangle方法一：越和正方形相似越好，所以需要先求根值确定大致范围 /** * @param {number} area * @return {number[]} */var constructRectangle = function(area) { var w = Math.floor(Math.sqrt(area)); while (area % w !== 0) { w–; } return [area/w,w];}; 283-Move Zeroes方法一：碰到0就先去掉再push进数组 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) { for(var i=0,m=0,n=nums.length;i&lt;n;i++){ if(nums[m] === 0){ nums.splice(m,1); nums.push(0); }else{ m++; } }}; 方法二：类似于冒泡 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) { var j = 0; for(var i = 0; i &lt; nums.length; i++) { if(nums[i] !== 0) { var temp = nums[j]; nums[j] = nums[i]; nums[i] = temp; j++; } }}; 方法三：用一个变量记录当前多少个元素不为0 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) { if (nums === null || nums.length === 0) return; var insertPos = 0; for (var i=0;i&lt;nums.length;i++) { if (nums[i] !== 0) nums[insertPos++] = nums[i]; } while (insertPos &lt; nums.length) { nums[insertPos++] = 0; }}; 530-Minimum Absolute Difference in BST暂无 506-Relative Ranks167-Two Sum II - Input array is sorted方法一：两个指针 /** * @param {number[]} numbers * @param {number} target * @return {number[]} */var twoSum = function(numbers, target) { if (numbers === null || numbers.length &lt; 2) return null; var left = 0, right = numbers.length - 1; while (left &lt; right) { var v = numbers\\[left\\] + numbers\\[right\\]; if (v == target) { return\\[left+1,right+1\\]; } else if (v &gt; target) { right --; } else { left ++; } } return null; }; 方法二：二分查找 /** * @param {number[]} numbers * @param {number} target * @return {number[]} */var twoSum = function(numbers, target) { if(numbers.length&lt;2) return null; for(var i=0; i&lt;numbers.length-1; i++) { var start=i+1, end=numbers.length-1, gap=target-numbers[i]; while(start &lt;= end) { var m = Math.floor(start+(end-start)/2); if(numbers[m] == gap) return [i+1,m+1]; else if(numbers[m] &gt; gap) end=m-1; else start=m+1; } }}; 455-Assign Cookies方法一：Just assign the cookies starting from the child with less greediness to maximize the number of happy children . /** * @param {number[]} g * @param {number[]} s * @return {number} */var findContentChildren = function(g, s) { g.sort(function(a,b){return a-b}); s.sort(function(a,b){return a-b}); var i=0,m=g.length,n=s.length; for(var j=0;j&lt;n&amp;&amp;i&lt;m;j++){ if(g[i]&lt;=s[j]){ i++; } } return i;}; 453-Minimum Moves to Equal Array Elements方法一：每次让n-1个元素+1，其实可以理解为每次让1个元素减1，知道都等于数组中的最小元素为止 /** * @param {number[]} nums * @return {number} */var minMoves = function(nums) { var min = Math.min.apply(null, nums),n=nums.length,result=0; for(i=0;i&lt;n;i++){ result += nums[i] -min; } return result;}; 383-Ransom Note方法一：用一个数组作为字典表（其实应该是哈希表，在js中就是数组） /** * @param {string} ransomNote * @param {string} magazine * @return {boolean} */var canConstruct = function(ransomNote, magazine) { var n = ransomNote.length; for(var i=0;i&lt;n;i++){ var s = ransomNote[i]; if(magazine.indexOf(s) == -1){ return false; }else{ magazine = magazine.replace(s,””); } } return !!(magazine.length + 1);}; 404-Sum of Left Leaves方法一：将叶子节点区分出来就可以了 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var sumOfLeftLeaves = function(root) { if(root === null) {return 0;} var ans = 0; if(root.left !== null) { if(root.left.left === null &amp;&amp; root.left.right === null) { ans += root.left.val; }else { ans += sumOfLeftLeaves(root.left); } } ans += sumOfLeftLeaves(root.right); return ans;}; 349-Intersection of Two Arrays方法一：两个指针进行遍历（哈希表，复杂度为O(n)） /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */var intersection = function(nums1, nums2) { nums1.sort(function(a,b){return a-b}); nums2.sort(function(a,b){return a-b}); var i = 0, j = 0, result = []; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) { if (nums1[i] &lt; nums2[j]) { i++; } else if (nums1[i] &gt; nums2[j]) { j++; } else { if(result.indexOf(nums1[i]) == -1){ result.push(nums1[i]); } i++; j++; } } return result.sort(function(a,b){return a-b});}; 方法二：二分查找（复杂度为O(nlgn)） /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */var intersection = function(nums1, nums2) { var result = []; nums2.sort(function(a,b){return a-b;}); for (var i=0;i&lt;nums1.length;i++) { if (binarySearch(nums2, nums1[i]) &amp;&amp; result.indexOf(nums1[i]) == -1) { result.push(nums1[i]); } } return result;}; var binarySearch = function(nums,target) { var low = 0,high = nums.length - 1; while (low &lt;= high) { var mid = Math.floor(low + (high - low) / 2); if (nums[mid] == target) { return true; } if (nums[mid] &gt; target) { high = mid - 1; } else { low = mid + 1; } } return false;}; 122-Best Time to Buy and Sell Stock II方法一：只要第二天价格比第一天价格高，就卖掉 /** * @param {number[]} prices * @return {number} */var maxProfit = function(prices) { var result=0,n=prices.length; for(var i=0;i&lt;n-1;i++){ if(prices[i]&lt;prices[i+1]){ result += prices[i+1] - prices[i]; } } return result; }; 387-First Unique Character in a String方法一：用一个数组记录字符出现的位置及次数（哈希表） /** * @param {string} s * @return {number} */var firstUniqChar = function(s) { var freq = new Array(26); var a = ‘a’.charCodeAt(); for(var i = 0; i &lt; s.length; i ++) { if (freq [s[i].charCodeAt() - a] === undefined) { freq [s[i].charCodeAt() - a] = 1; } else { freq [s[i].charCodeAt() - a]++; } } for(var k = 0; k &lt; s.length; k ++){ if(freq [s[k].charCodeAt() - a] == 1){ return k; } } return -1;}; 171-Excel Sheet Column Number方法一：很容易发现规律，类似二进制转换成10进制 /** * @param {string} s * @return {number} /var titleToNumber = function(s) { var result = 0; for(var i=0,n=s.length;i&lt;n;i++){ result += Math.pow(26,n-i-1)(s[i].charCodeAt() - 64); } return result;}; 504-Base 7方法一：递归取余，很经典的一道题和解法，用的比较多 /** * @param {number} num * @return {string} */var convertToBase7 = function(num) { return num&gt;=0 ? “” + (num&gt;=7 ? convertToBase7(Math.floor(num/7)) + “” + num%7 : num) : ‘-‘+convertToBase7(-num);}; 237-Delete Node in a Linked List方法一：很智障的一道题 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} node * @return {void} Do not return anything, modify node in-place instead. */var deleteNode = function(node) { node.val = node.next.val; node.next = node.next.next;}; 100-Same Tree方法一：递归，相等的依据除了值相等之外还有不能为null /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */var isSameTree = function(p, q) { if (p === null &amp;&amp; q === null){ return true; } return p !== null &amp;&amp; q !== null &amp;&amp; p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);}; 169-Maiority Element方法一：每找出两个不同的element，就成对删除即count–，最终剩下的一定就是所求的（O(n)） /** * @param {number[]} nums * @return {number} */var majorityElement = function(nums) { var major=nums[0], count = 1; for(var i=1,n=nums.length; i&lt;n;i++){ if(count===0){ count++; major=nums[i]; }else if(major==nums[i]){ count++; }else count–; } return major;}; 方法二：哈希表 /** * @param {number[]} nums * @return {number} */var majorityElement = function(nums) { var counts = [],n = nums.length; for (var i = 0; i &lt; n; i++){ if(counts[nums[i]] === undefined){ counts[nums[i]] = 1; }else{ if(counts[nums[i]] + 1&gt; Math.floor(n / 2)) { return nums[i];} counts[nums[i]]++; } } return nums[0];}; 方法三：Since the majority element appears more than n / 2 times, the n / 2-th element in the sorted nums must be the majority element. /** * @param {number[]} nums * @return {number} */var majorityElement = function(nums) { nums.sort(); return nums[Math.floor(nums.length/2)];}; 方法四：随机挑选一个元素，然后看它是否是多数元素 /** * @param {number[]} nums * @return {number} /var majorityElement = function(nums) { var n = nums.length; while (true) { var idx = Math.floor(Math.random()n),candidate = nums[idx],counts = 0; for (var i = 0; i &lt; n; i++) if (nums[i] == candidate) {counts++;} if (counts &gt; n / 2) return candidate; }}; 方法五：摩尔投票算法 /** * @param {number[]} nums * @return {number} */var majorityElement = function(nums) { var major, counts = 0, n = nums.length; for (var i = 0; i &lt; n; i++) { if (!counts) { major = nums[i]; counts = 1; } else counts += (nums[i] == major) ? 1 : -1; } return major;}; 方法六：位运算，The key lies in how to count the number of 1‘s on a specific bit. Specifically, you need a mask with a 1 on the i-the bit and 0 otherwise to get the i-th bit of each element in nums /** * @param {number[]} nums * @return {number} */var majorityElement = function(nums) { var major = 0, n = nums.length; for (var i = 0, mask = 1; i &lt; 32; i++, mask &lt;&lt;= 1) { var bitCounts = 0; for (var j = 0; j &lt; n; j++) { if (nums[j] &amp; mask) bitCounts++; if (bitCounts &gt; n / 2) { major |= mask; break; } } } return major;}; 242-Valid Anagram方法一：用一个数组作为桶，s中的字符用来加1，t中的字符用来减1；如果最后桶中没有元素就返回true /** * @param {string} s * @param {string} t * @return {boolean} */var isAnagram = function(s, t) { if(s===””&amp;&amp;t===””){return true;} var alphabet = new Array(26); for(var m=0;m&lt;alphabet.length;m++){ alphabet[m] =0; } for (var i = 0; i &lt; s.length; i++) { alphabet[s[i].charCodeAt() - 97]++; } for (var j = 0; j &lt; t.length; j++) { alphabet[t[j].charCodeAt() - 97]–; } for (var k=0;k&lt;alphabet.length;k++) { if (alphabet[k]!== 0) { return false; } } return true;}; 409-Longest Palindrome方法一：将数组中的元素分为偶数和奇数两种情况，因为回文字符串的字符个数有这两种情况 /** * @param {string} s * @return {number} */var longestPalindrome = function(s) { var even = 0,odd = 0,arr = []; for(var i=0,n=s.length;i&lt;n;i++){ var c = s[i].charCodeAt() - 65; if(arr[c] === undefined){ arr[c] = 1; }else{ arr[c]++; } if(arr[c]%2 === 0){ even += 2; odd–; }else{ odd++; } } return even + (odd===0? 0 :1);}; 541-Reverse String II暂无 401-Binary Watch方法一：从结果出发，满足条件时push进数组 /** * @param {number} num * @return {string[]} */var readBinaryWatch = function(num) { var result = []; for(var h=0;h&lt;12;h++){ for(var m=0;m&lt;60;m++){ if((h.toString(2) + m.toString(2)).replace(/0/g,””).length == num){ m = m&gt;9 ? m : “0” + m; item = h + “:” + m; result.push(item); } } } return result;}; 217-Contains Duplicate方法一：哈希表 /** * @param {number[]} nums * @return {boolean} */var containsDuplicate = function(nums) { if(nums.length===0){return false;} var opt = {}; for(var i=0,n=nums.length;i&lt;n;i++){ if(opt[nums[i]]){ return true; }else{ opt[nums[i]] = 1; } } return false;}; 方法二：先将数组排序，然后只需要比较相邻元素 /** * @param {number[]} nums * @return {boolean} */var containsDuplicate = function(nums) { nums.sort(); for(var ind = 1; ind &lt; nums.length; ind++) { if(nums[ind] == nums[ind - 1]) { return true; } } return false;}; 13-Roman to Integer方法一：知道罗马数字的规则之后就好写了 /** * @param {string} s * @return {number} */var romanToInt = function(s) { var opt = {‘M’: 1000,’D’: 500 ,’C’: 100,’L’: 50,’X’: 10,’V’: 5,’I’: 1}, z = 0, n=s.length; for(var i=0;i&lt;n-1;i++){ if(opt[s[i]] &lt; opt[s[i+1]]){ z -= opt[s[i]]; }else{ z += opt[s[i]]; } } return z + opt[s[n-1]];}; 206-Reverse Linked List方法一：反转的条件就是head.next.next = head和head.next = null /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function(head) { if (!head || !(head.next)) {return head;} var node = reverseList(head.next); head.next.next = head; head.next = null; return node;}; 350-Intersection of Two Arrays II方法一：先对nums1遍历，生成哈希表，然后对nums2遍历 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */var intersect = function(nums1, nums2) { var arr = [],result=[]; for(var i=0,n=nums1.length;i&lt;n;i++){ var numi = arr[nums1[i]]; if(numi){ arr[nums1[i]]++; }else{ arr[nums1[i]] = 1; } } for(var j=0,m=nums2.length;j&lt;m;j++){ var numj = arr[nums2[j]]; if(numj){ result.push(nums2[j]); arr[nums2[j]]–; } } return result;}; 方法二：先进行排序，然后用两个指针遍历 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */var intersect = function(nums1, nums2) { nums1.sort(function(a,b){return a-b;}); nums2.sort(function(a,b){return a-b;}); var n1 = nums1.length, n2 = nums2.length,i1 = 0, i2 = 0,res = []; while(i1 &lt; n1 &amp;&amp; i2 &lt; n2){ if(nums1[i1] == nums2[i2]) { res.push(nums1[i1]); i1++; i2++; } else if(nums1[i1] &gt; nums2[i2]){ i2++; } else{ i1++; } } return res;}; 268-Missing Number方法一：因为有且只有一个数字丢失，所以可以先排序再遍历，根据索引值和数值的关系判断 /** * @param {number[]} nums * @return {number} */var missingNumber = function(nums) { var sort = nums.sort(function(a,b){ return a-b; }),n=nums.length; for(var i=0;i&lt;n;i++){ if(sort[i] != i){ return i; } } return n;}; 方法二：位运算，利用异或 /** * @param {number[]} nums * @return {number} */var missingNumber = function(nums) { var xor = 0, i = 0; for (i = 0; i &lt; nums.length; i++) { xor = xor ^ i ^ nums[i]; } return xor ^ i;}; 方法三：因为数值范围确定，所以可以先求和，再减去数组中的元素，剩下的数字就是丢失数字 /** * @param {number[]} nums * @return {number} /var missingNumber = function(nums) { var len = nums.length,sum = (0+len)(len+1)/2; for(var i=0; i&lt;len; i++){ sum-=nums[i]; } return sum;}; 方法四：二分查找 /** * @param {number[]} nums * @return {number} */var missingNumber = function(nums) { nums.sort(function(a,b){return a-b;}); var left = 0, right = nums.length, mid= Math.floor((left + right)/2); while(left&lt;right){ mid = Math.floor((left + right)/2); if(nums[mid]&gt;mid) {right = mid;} else left = mid+1; } return left;}; 447-Number of Boomerangs暂无 543-Diameter of Binary Tree暂无 415-Add Strings方法一：遍历，用一个变量记录当前位进位情况 /** * @param {string} num1 * @param {string} num2 * @return {string} */var addStrings = function(num1, num2) { var carry=0,str = ‘’; for(var i=num1.length-1,j=num2.length-1;i&gt;=0||j&gt;=0||carry==1;i–,j–){ var n1 = num1[i] ? num1[i] - ‘0’ : 0, n2 = num2[j] ? num2[j] - ‘0’ : 0; var sum = (n1 + n2 + carry)%10; carry = Math.floor((n1 + n2 + carry)/10); str = sum + str; } return str;}; 108-Convert Sorted Array to Binary Search Tree暂无 405-Convert a Number to Hexadecimal暂无","categories":[{"name":"算法","slug":"algorithm","permalink":"http://merrier.wang/categories/algorithm/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"算法","slug":"算法","permalink":"http://merrier.wang/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://merrier.wang/tags/leetcode/"}]},{"title":"JS实现复杂数据结构","slug":"JS实现复杂数据结构","date":"2017-03-26T04:51:34.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170326/complex-data-structure-implemented-by-js.html","link":"","permalink":"http://merrier.wang/20170326/complex-data-structure-implemented-by-js.html","excerpt":"","text":"一、哈希表简介javascript里面是没有哈希表的，而在java、C#、C++中会经常用到这一种数据结构，同时在刷Leetcode过程中也会经常用到。细细看来，其实javascript的object的属性其实与哈希表非常类似。我们只需要在其基础上再封装一些HashTable的函数,就能够得到一个精简版的哈希表。 加入函数[table id=3 /] 代码实现function HashTable() { var size = 0; var entry = new Object(); this.add = function (key, value) { if (!this.containsKey(key)) { size++; } entry[key] = value; } this.getValue = function (key) { return this.containsKey(key) ? entry[key] : null; } this.remove = function (key) { if (this.containsKey(key) &amp;&amp; (delete entry[key])) { size–; } } this.containsKey = function (key) { return (key in entry); } this.containsValue = function (value) { for (var prop in entry) { if (entry[prop] == value) { return true; } } return false; } this.getValues = function () { var values = new Array(); for (var prop in entry) { values.push(entry[prop]); } return values; } this.getKeys = function () { var keys = new Array(); for (var prop in entry) { keys.push(prop); } return keys; } this.getSize = function () { return size; } this.clear = function () { size = 0; entry = new Object(); }} 使用示例var manHT = new HashTable();manHT.add(“p1”,”刘备”);manHT.add(“p2”,”关羽”);$(“#div1”).text(manHT.getValue(“p1”)); 参考链接cnblogs：http://www.cnblogs.com/kissdodog/p/4666352.html?utm_source=tuicool 二、栈简介栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。 加入函数[table id=4 /] 代码实现function Stack(){ this.dataStore = [];//保存栈内元素 this.top = 0; this.push=function (element) { this.dataStore[this.top++] = element;//添加一个元素并将top+1 }, this.peek=function () { return this.dataStore[this.top-1];//返回栈顶元素 }, this.pop=function () { return this.dataStore[–this.top];//返回栈顶元素并将top-1 }, this.clear=function () { this.top = 0;//将top归0 }, this.size=function () { return this.top;//返回栈内的元素个数 }, this.isAmpty = function() { return this.dataStore.length === 0;//确定栈是否为空 }; this.print = function(){ console.log(this.dataStore.toString()); }} 使用示例var lk=new Stack();lk.push(“likeke”);lk.push(“zhangsan”);lk.push(“wangwu”);lk.peek();//“wangwu”lk.size();3lk.pop();//“wangwu”lk.peek();//“zhangsan”lk.clear();lk.peek();//undefindlk.size();0 参考链接李可可的博客：http://cobain-li.iteye.com/blog/2335935 脚本之家：http://www.jb51.net/article/79624.htm 三、队列简介队列是一种先进先出的结构。队列也是一种表结构，不同的是队列只能在队尾插入元素，在队首删除元素；在JS中可以用数组来实现队列结构 加入函数[table id=6 /] 代码实现function Queue(){ this.dataStore = [],//队列数据 this.enqueue = function(){ //入队，就是在数组的末尾添加一个元素 this.dataStore.push(element); }, this.dequeue = function(){//出队，就是删除数组的第一个元素 return this.dataStore.shift(); }, this.front = function(){//取出数组的第一个元素 return this.dataStore[0]; }, this.back = function(){//取出数组的最后一个元素 return this.dataStore[this.dataStore.length-1]; }, this.toString = function(){//将数组中的元素以字符串形式输出 var retStr = “”; for (var i=0; i&lt;this.dataStore.length; ++i) { retStr += this.dataStore[i] + “&nbsp;” } return retStr; }, this.empty = function(){//判断数组是否为空 if(this.dataStore.length == 0){ return true; }else{ return false; } }, this.count = function(){//返回数组中元素的个数 return this.dataStore.length; }, this.clear = function(){//清除队列 this.dataStore = []; }} 使用示例var q = new Queue();q.enqueue(“Meredith”);q.enqueue(“Cynthia”);q.enqueue(“Jennifer”);\bconsole.log(q.toString());//Meredith Cynthia Jenniferconsole.log(q.front());//Meredithconsole.log(q.back());//Jennifer 参考链接cnblogs：http://www.cnblogs.com/tylerdonet/p/5837730.html 四、单链表简介单链表是一种链式存取的数据结构。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。 加入函数[table id=7 /] 代码实现function linkNode(_key, _value) {// 链表类的节点类 this.Key = _key; this.Value = _value; this.next = null;}function Link() {// 创建一个链表类 this.root = new linkNode(null, null); //root永远是个空节点 this.end = this.root;}Link.prototype = { count: 0,//key的数量 value: function (_key) {//根据key的值来获取value值 var i = this.root; while (Boolean(i = i.next)) { if (i.Key == _key) return i.Value; } }, add: function (_key, _value) {// 往链表的尾部中加入一个节点 var i = this.root; while (Boolean(i = i.next)) { if (i.Key == _key) return i.Value = _value; } var node = new linkNode(_key, _value); if (this.count == 0) this.root.next = node; else this.end.next = node; this.end = node; this.count++; return _value; }, insert: function (_key, node) {// 从链表类的某节点之后插入新节点node. var i = this.root; while (Boolean(i = i.next)) { if (i.Key == _key) { var tmp = i.next; i.next = node; node.next = tmp; break; } } }, insertBefore: function (_key, node) {// 从链表类的某节点之后插入新节点node. var i = this.root; while (Boolean(i = i.next)) { if (i.next.Key == _key) { var tmp = i.next; i.next = node; node.next = tmp; break; } } }, remove: function (_key) {// 从链表类中移除一个key var i = this.root; do { if (i.next.Key == _key) { if (i.next.next == null) this.end = i; i.next = i.next.next; this.count–; return; } } while (Boolean(i = i.next)) }, removeAt : function (n) {//删除指定位置的节点 if (n &lt;= 0) { return; } var preNode = this.getNodeByIndex(n - 1); preNode.next = preNode.next.next; }, removeAll: function () {// 清空链表类 this.root = new linkNode(null, null); this.end = this.root; this.count = 0; }, exists: function (_key) {// 检查链表类中是否存在一个key var i = this.root; while (Boolean(i = i.next)) if (i.Key == _key) return true; return false; }, getJSON: function () {// 转换成JSON字符串，内部方法，用于递归 var me = this; var getChild = function (node) { var str = “”; str += “{\\“Key\\“:\\“” + node.Key + “\\“,\\“Value\\“:” + me.Obj2str(node.Value); if (node.next != null) str += “,\\“next\\“:” + getChild(node.next); else str += “,\\“next\\“:\\“null\\“”; str += “}”; return str; }; var link = “{\\“root\\“:{\\“Key\\“:\\“null\\“,\\“Value\\“:\\“null\\“,\\“next\\“:”; if (this.count == 0)//如果空表 { return “{\\“root\\“:{\\“Key\\“:\\“null\\“,\\“Value\\“:\\“null\\“,\\“next\\“:\\“null\\“},\\“end\\“:{\\“Key\\“:\\“null\\“,\\“Value\\“:\\“null\\“,\\“next\\“:\\“null\\“},\\“count\\“:\\“0\\“}”; } link += getChild(this.root.next) + “}”; //加上end link += “,\\“end\\“:{\\“Key\\“:\\“” + this.end.Key + “\\“,\\“Value\\“:” + me.Obj2str(this.end.Value) + “,\\“next\\“:\\“null\\“”; link += “},\\“count\\“:\\“” + this.count + “\\“}”; return link; }, getArrayJSON: function () {// 转所有节点的value换成JSON字符串,数组格式 var link = “{\\“link\\“:[“; var i = this.root; while (Boolean(i = i.next)) { link += this.Obj2str(i.Value) + “,”; } link = link.substr(0, link.length - 1); link += “]}”; return link; }, getNodeByIndex: function (n) {//取第N个位置的节点(约定头节点为第0个位置)，N大于链表元素个数时，返回最后一个元素 var p = this.head; var i = 0; while (p.next != null &amp;&amp; i &lt; n) { p = p.next; i++; } return p; }, getNodeByValue: function (v) {//查询值为V的节点，如果链表中有多个相同值的节点，返回第一个找到的 var p = this.head; while (p.next != null) { p = p.next; if (p.data == v) { return p; } } return null; }, print: function () {//打印输出所有节点 var p = this.head; while (p.next != null) { p = p.next; print(p.data + “ “); } println(“”); }, sort: function (fn) {// 对链表进行排序 if (fn != null) { var i = this.root; while (Boolean(i = i.next)) { var j = this.root; while (Boolean(j = j.next)) { if (j.next != null) { if (fn.call(this, j)) { var Key = j.Key; var Value = j.Value; j.Key = j.next.Key; j.Value = j.next.Value; j.next.Key = Key; j.next.Value = Value; } } } this.end = i; } } }};function print(msg) {//打印内容 document.write(msg);} function println(msg) {//换行打印内容 print(msg + ““);} function hasSameValueNode(singleLink) {//测试单链表L中是否有重复元素 var i = singleLink.head; while (i.next != null) { i = i.next; var j = i; while (j.next != null) { j = j.next; if (i.data == j.data) { return true; } } } return false;} function reverseSingleLink(singleLink) {//单链表元素反转 var arr = new Array(); var p = singleLink.head; //先跑一遍，把所有节点放入数组 while (p.next != null) { p = p.next; arr.push(p.data); } var newLink = new SingleLink(); //再从后向前遍历数组,加入新链表 for (var i = arr.length - 1; i &gt;= 0; i–) { newLink.insert(arr[i]); } return newLink;} 使用示例var linkTest = new SingleLink(); linkTest.insert(‘A’); linkTest.insert(‘B’); linkTest.insert(‘C’); linkTest.insert(‘D’); linkTest.print();//A B C D var newLink = reverseSingleLink(linkTest); newLink.print();//D C B A 参考链接cnblogs：http://www.cnblogs.com/yjmyzz/archive/2013/05/21/3091653.html 脚本之家：http://www.jb51.net/article/38870.htm","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/tags/计算机基础/"},{"name":"数据结构","slug":"数据结构","permalink":"http://merrier.wang/tags/数据结构/"}]},{"title":"Leetcode的JS实现——Easy篇（下）","slug":"Leetcode的JS实现——Easy篇（下）","date":"2017-03-26T04:40:52.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170326/js-implementation-of-leetcode-easy-part2.html","link":"","permalink":"http://merrier.wang/20170326/js-implementation-of-leetcode-easy-part2.html","excerpt":"","text":"写在前面这是Leetcode的JS实现——Easy篇的后半部分，前半部分可以点击这里查看 介绍leetcode地址：https://leetcode.com/problemset/algorithms/ 本文章不会贴出题目，可以点击标题链接查看原题目 排序方式：按照\b本难度中题目的accepted统计 JS代码实现121-Best Time to Buy and Sell Stock方法一：动态规划 /** * @param {number[]} prices * @return {number} */var maxProfit = function(prices) { var maxPro = 0; var minPrice = prices[0]; for(var i = 0 ,n = prices.length; i&lt;n;i++){ minPrice = Math.min(minPrice, prices[i]); maxPro = Math.max(maxPro, prices[i] - minPrice); } return maxPro;}; 方法二：Kadane’s Algorithm /** * @param {number[]} prices * @return {number} */var maxProfit = functon(pris) var maxCur = 0, maxSoFar = 0; for(var i = 1,n = prices.length;i&lt;n; i++) { maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]) maxSoFar = Math.max(maxCur, maxSoFar); } return maxSoFar;}; 202-Happy Number方法一：Floyd Cycle detection algorithm /** * @param {number} n * @return {boolean} */var isHappy = function(n) { var slow, fast; slow = fast = n; do { slow = digitSquareSum(slow); fast = digitSquareSum(fast); fast = digitSquareSum(fast); } while(slow != fast); if (slow == 1) {return true;} else {return false;}}; var digitSquareSum = function(n){ var sum = 0, tmp; while (n) { tmp = n % 10; sum += tmp * tmp; n = Math.floor(n / 10); } return sum;}; 方法二：O(1)space，如果快=慢，证明陷入了死循环 /** * @param {number} n * @return {boolean} */var isHappy = function(n) { var x = n,y = n; while(x&gt;1){ x = cal(x) ; if(x==1) {return true;} y = cal(cal(y)); if(y==1) {return true ;} if(x==y) {return false;} } return true;}; var cal = function(n){ var sum = 0, tmp; while (n) { tmp = n % 10; sum += tmp * tmp; n = Math.floor(n / 10); } return sum;}; 方法三：Using fact all numbers in [2, 6] are not happy (and all not happy numbers end on a cycle that hits this interval) /** * @param {number} n * @return {boolean} /var isHappy = function(n) { while(n&gt;6){ var next = 0; while(n){ next+=(n%10)(n%10); n = Math.floor(n/10); } n = next; } return n==1;}; 326-Power of Three方法一：递归 /** * @param {number} n * @return {boolean} */var isPowerOfThree = function(n) { return n&gt;0 &amp;&amp; (n==1 || (n%3===0 &amp;&amp; isPowerOfThree(n/3)));}; 方法二：迭代 /** * @param {number} n * @return {boolean} */var isPowerOfThree = function(n) { if(n&gt;1) while(n%3===0) {n /= 3;} return n==1;}; 方法三：int型数字中最大的3的幂为1162261467 /** * @param {number} n * @return {boolean} */var isPowerOfThree = function(n) { return n &gt; 0 &amp;&amp; (1162261467 % n === 0);}; 方法四：对n取根值 /** * @param {number} n * @return {boolean} */var isPowerOfThree = function(n) { return (Math.log10(n) / Math.log10(3)) % 1 === 0;}; 方法五：正则表达式 /** * @param {number} n * @return {boolean} /var isPowerOfThree = function(n) { var reg = new RegExp(“^10$”,””); return reg.test(n.toString(3));}; 327-Power of Two方法一：Power of 2 means only one bit of n is ‘1’, so use the trick n&amp;(n-1)==0 to judge whether that is the case /** * @param {number} n * @return {boolean} */var isPowerOfTwo = function(n) { if(n&lt;=0) {return false;} return !(n&amp;(n-1));}; 方法二：同样利用二进制数字中只有1个”1”的特性，用replace()方法求二进制数字中1的数目 /** * @param {number} n * @return {boolean} */var isPowerOfTwo = function(n) { return n&gt;0 &amp;&amp; n.toString(2).replace(/0/g,’’).length == 1;}; 方法三：迭代 /** * @param {number} n * @return {boolean} */var isPowerOfTwo = function(n) { if(n===0) {return false;} while(n%2===0) n/=2; return (n==1);}; 方法四：递归 /** * @param {number} n * @return {boolean} */var isPowerOfTwo = function(n) { return n&gt;0 &amp;&amp; (n==1 || (n%2===0 &amp;&amp; isPowerOfTwo(n/2)));}; 方法五：利用int型数字中最大的2的幂 /** * @param {number} n * @return {boolean} */var isPowerOfTwo = function(n) { return n&gt;0 &amp;&amp; (1073741824 % n === 0);}; 83-Remove Duplicates from Sorted List方法一：递归 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var deleteDuplicates = function(head) { if(head === null || head.next === null) {return head;} head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head;}; 70-Climbing Stairs方法一：斐波那契数列 /** * @param {number} n * @return {number} */var climbStairs = function(n) { if(n &lt;= 0) return 0; if(n == 1) return 1; if(n == 2) return 2; var one\\_step\\_before = 2; var two\\_steps\\_before = 1; var all_ways = 0; for(var i=2; i&lt;n; i++){ all\\_ways = one\\_step\\_before + two\\_steps_before; two\\_steps\\_before = one\\_step\\_before; one\\_step\\_before = all_ways; } return all_ways; }; 方法二：从终点向前循环，利用两个指针，a代表到达当前步所有可能方式的个数，b代表到达下一步所有可能方式的个数 /** * @param {number} n * @return {number} */var climbStairs = function(n) { a = b = 1; while (n–) a = (b += a) - a; return a;}; 53-Maximum Subarray方法一：Basically, keep adding each integer to the sequence until the sum drops below 0.If sum is negative, then should reset the sequence. /** * @param {number[]} nums * @return {number} */var maxSubArray = function(nums) { var ans=nums[0],i,j,sum=0; for(i=0;i&lt;nums.length;i++){ sum+=nums[i]; ans=Math.max(sum,ans); sum=Math.max(sum,0); } return ans;}; 方法二：动态规划 /** * @param {number[]} nums * @return {number} */var maxSubArray = function(nums) { var n = nums.length; var dp = [];//dp[i] means the maximum subarray ending with nums[i]; dp[0] = nums[0]; var max = dp[0]; for(var i = 1; i &lt; n; i++){ dp[i] = nums[i] + (dp[i - 1] &gt; 0 ? dp[i - 1] : 0); max = Math.max(max, dp[i]); } return max;}; 437-Path Sum III方法一：用哈希表来建立所有的前缀路径之和跟其个数之间的映射，然后看子路径之和有没有等于给定值的 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} sum * @return {number} */var pathSum = function(root, sum) { var map = []; map[0] = 1; //Default sum = 0 has one count return backtrack(root, 0, sum, map);}; var backtrack = function(root,sum,target,map){ if(root === null) {return 0;} sum += root.val; var res = map[sum-target] === undefined ? 0 : map[sum-target];//See if there is a subarray sum equals to target map[sum] = (map[sum] === undefined ? 0 : map[sum])+1;//Extend to left and right child res += backtrack(root.left, sum, target, map) + backtrack(root.right, sum, target, map); map[sum]–; //Remove the current node so it wont affect other path return res;}; 方法二：利用前序遍历，对于每个遍历到的节点进行处理，维护一个变量pre来记录之前路径之和，然后cur为pre加上当前节点值，如果cur等于sum，那么返回结果时要加1，然后对当前节点的左右子节点调用递归函数求解 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} sum * @return {number} */var pathSum = function(root, sum) { if (root === null) {return 0;} return sumUp(root, 0, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);}; var sumUp = function(node,pre,sum){ if (node === null) {return 0;} var cur = pre + node.val; return (cur == sum) + sumUp(node.left, cur, sum) + sumUp(node.right, cur, sum);}; 501-Find Mode in Binary Search Tree方法一：Morris traversal（二叉树遍历方法，参考链接） /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[]} */var currVal, currCount = 0, maxCount = 0, modeCount = 0, modes = []; var findMode = function(root) { inorder(root); modes = new Array(modeCount); modeCount = 0; currCount = 0; inorder(root); return modes;}; var handleValue = function(val) { if (val != currVal) { currVal = val; currCount = 0; } currCount++; if (currCount &gt; maxCount) { maxCount = currCount; modeCount = 1; } else if (currCount == maxCount) { if (modes !== null) modes[modeCount] = currVal; modeCount++; }}; var inorder = function(root) { var node = root; while (node !== null) { if (node.left === null) { handleValue(node.val); node = node.right; } else { var prev = node.left; while (prev.right !== null &amp;&amp; prev.right != node) prev = prev.right; if (prev.right === null) { prev.right = node; node = node.left; } else { prev.right = null; handleValue(node.val); node = node.right; } } }}; 方法二：先用递归得到有多少个modes，然后再申请空间保证O(1)的空间复杂度 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[]} */var currentModes = 0;var currentValue = 0;var currentCount = 0;var modes = [];var maxCount = 0; var findMode = function(root) { helper(root); modes = new Array(currentModes); currentModes = 0; currentCount = 0; helper(root); return modes;}; var helper = function (root) { if (root === null) return; helper(root.left); if (root.val != currentValue) { currentCount = 1; currentValue = root.val; } else { currentCount++; } if (currentCount &gt; maxCount) { maxCount = currentCount; currentModes = 1; } else if (currentCount == maxCount) { if (modes !== null){ modes[currentModes] = root.val; currentModes++; } } helper(root.right);}; 191-Number of 1 Bits方法一：利用toString(2)和replace() /** * @param {number} n - a positive integer * @return {number} */var hammingWeight = function(n) { return n.toString(2).replace(/0/g,’’).length;}; 方法二：利用n=n&amp;(n-1) /** * @param {number} n - a positive integer * @return {number} */var hammingWeight = function(n) { var count = 0; for (;n!==0;n = n &amp; (n-1)) count++; return count;}; 方法三：位运算 /** * @param {number} n - a positive integer * @return {number} */var hammingWeight = function(n) { var ones = 0; while(n!==0) { ones = ones + (n &amp; 1); n = n&gt;&gt;&gt;1; } return ones;}; 35-Search Insert Position方法一：按部就班遍历 /** * @param {number[]} nums * @param {number} target * @return {number} */var searchInsert = function(nums, target) { for(var i=0,n=nums.length;i&lt;n;i++){ if(target&lt;=nums[i]){ return i; } } return n;}; 方法二：二分查找 /** * @param {number[]} nums * @param {number} target * @return {number} */var searchInsert = function(nums, target) { var low = 0, high = nums.length-1; while(low&lt;=high){ var mid = Math.floor((low+high)/2); if(nums[mid] == target) {return mid;} else if(nums[mid] &gt; target) {high = mid-1;} else {low = mid+1;} } return low;}; 107-Binary Tree Level Order Traversal II暂无 263-Ugly Number方法一：根据丑陋数的定义，我们将给定数除以2、3、5，直到无法整除，也就是除以2、3、5的余数不再为0时停止。这时如果得到1，说明是所有因子都是2或3或5，如果不是1，则不是丑陋数。 /** * @param {number} num * @return {boolean} */var isUgly = function(num) { for (var p of [2, 3, 5]) while (num &amp;&amp; num % p === 0) num /= p; return num == 1;}; 459-Repeated Substring Pattern方法一：The idea is that when we see a character in str that matches the very first character of str, we can start to hoping that str is a built by copies of the substring composed by all characters before the reappearance of the its first character. /** * @param {string} s * @return {boolean} */var repeatedSubstringPattern = function(s) { var l = s.length; if(l == 1) { return false; } var sb = ‘’; var first = s.charAt(0); sb += first; var i = 1; while(i &lt;= l / 2) { var c = s.charAt(i++); if(c == first &amp;&amp; isCopies(s, sb)) { return true; }else { sb += c; } } return false;}; var isCopies = function(str,substr) { if(str.length % substr.length !== 0) { return false; } for(var i = substr.length; i &lt; str.length; i += substr.length){ if(str.substring(i).slice(0,substr.length) !== substr){ return false; } } return true;}; 其他方法仍在思考实现中 21-Merge Two Sorted Lists方法一：递归 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var mergeTwoLists = function(l1, l2) { if(l1 === null) return l2; if(l2 === null) return l1; if(l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l2.next, l1); return l2; }}; 235-Lowest Common Ancestor of a Binary Search Tree方法：递归，因为这是一棵二叉搜索数，所以两个节点分别与共同的祖先节点相减所得的差应该是异号或等于0的，否则就根据节点与当前根节点的大小比较对其左子树或右子树进行递归 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} /var lowestCommonAncestor = function(root, p, q) { while ((root.val - p.val) (root.val - q.val) &gt; 0) root = p.val &lt; root.val ? root.left : root.right; return root;}; 方法二：迭代，和递归类似，只不过代码更加简化 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} /var lowestCommonAncestor = function(root, p, q) { return (root.val - p.val) (root.val - q.val) &lt; 1 ? root : lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);}; 198-House Robber方法一：根据房间数的奇偶进行分类存储最大值，并且有以下规律 f(0) = nums[0] f(1) = max(num[0], num[1]) f(k) = max( f(k-2) + nums[k], f(k-1) ) /** * @param {number[]} nums * @return {number} */var rob = function(nums) { var a = 0, b = 0; for (var i=0; i&lt;nums.length; i++) { if (i%2===0) { a = Math.max(a+nums[i], b); } else { b = Math.max(a, b+nums[i]); } } return Math.max(a, b);}; 342-Power of Four方法一：因为能被4整除的数用二进制表示的话有且只有一个1在奇数位上 /** * @param {number} num * @return {boolean} */var isPowerOfFour = function(num) { return num &gt; 0 &amp;&amp; (num&amp;(num-1)) === 0 &amp;&amp; (num &amp; 0x55555555) !== 0;}; 方法二：很好用的replace().length /** * @param {number} num * @return {boolean} */var isPowerOfFour = function(num) { return num.toString(2).replace(/0/g,’’).length === 1 &amp;&amp; num.toString(2).length%2 ===1;}; 方法三：利用2的倍数减1无法整除3而4的倍数减1可以整除3的特性 /** * @param {number} num * @return {boolean} */var isPowerOfFour = function(num) { return num &gt; 0 &amp;&amp; (num &amp; (num - 1)) === 0 &amp;&amp; (num - 1) % 3 === 0;}; 345-Reverse Vowels of a String方法一：利用二分法和替代数组 /** * @param {string} s * @return {string} */var reverseVowels = function(s) { if(s.length &lt;= 1){return s;} var arr = [‘a’,’e’,’i’,’o’,’u’,’A’,’E’,’I’,’O’,’U’], res = new Array(s.length); left = 0, right = s.length -1; while(left&lt;=right){ if(arr.indexOf(s[left]) &lt; 0){ res[left] = s[left]; left++; } if(arr.indexOf(s[right]) &lt; 0){ res[right] = s[right]; right–; } if(arr.indexOf(s[left]) &gt;=0 &amp;&amp; arr.indexOf(s[right]) &gt;=0){ res[left] = s[right]; res[right] = s[left]; left++; right–; } } return res.join(‘’);}; 367-Valid Perfect Square方法一：完全平方数一定是1+3+5+7……O(sqrt(N)) /** * @param {number} num * @return {boolean} */var isPerfectSquare = function(num) { if (num &lt; 1) {return false;} for (var i = 1; num &gt; 0; i += 2){ num -= i; } return num === 0;}; 方法二：二分查找，O(logN) /** * @param {number} num * @return {boolean} /var isPerfectSquare = function(num) { if (num &lt; 1) {return false;} var left = 1, right = num; while (left &lt;= right) { var mid = Math.floor(left + (right - left) / 2); var t = mid mid; if (t &gt; num) { right = mid - 1; } else if (t &lt; num) { left = mid + 1; } else { return true; } } return false;}; 方法三：牛顿迭代法，O(1) /** * @param {number} num * @return {boolean} /var isPerfectSquare = function(num) { if (num &lt; 1) {return false;} var t = Math.floor(num / 2); while (t t &gt; num) { t = Math.floor((t + num / t) / 2); } return t * t == num || num === 1;}; 27-Remove Element方法一：在获得剩余长度的同时生成新数组 /** * @param {number[]} nums * @param {number} val * @return {number} */var removeElement = function(nums, val) { var cnt = 0; for(var i = 0 ; i &lt; nums.length ; ++i) { if(nums[i] == val) cnt++; else nums[i-cnt] = nums[i]; } return nums.length-cnt;}; 方法二：既短又快 /** * @param {number[]} nums * @param {number} val * @return {number} */var removeElement = function(nums, val) { var l = nums.length; for (var i=0; i&lt;l; i++) { if (nums[i] == val) { nums[i–] = nums[l– -1]; } } return l;}; 101-Symmetric Tree 方法一：通过另外一个方法判断其左右子树是否都是”镜像数” /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {boolean} */var isSymmetric = function(root) { if(root===null) {return true;} return isMirror(root.left,root.right);}; var isMirror = function(p,q){ if(p===null &amp;&amp; q===null) return true; if(p===null || q===null) return false; return (p.val==q.val) &amp;&amp; isMirror(p.left,q.right) &amp;&amp; isMirror(p.right,q.left);}; 方法二：通过队列（在js中通过数组模拟） /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {boolean} */var isSymmetric = function(root) { var q = []; if(root === null) return true; q.push(root.left); q.push(root.right); while(q.length &gt; 1){ var left = q.shift(), right = q.shift(); if(left=== null&amp;&amp; right === null) continue; if(left=== null ^ right === null) return false; if(left.val != right.val) return false; q.push(left.left); q.push(right.right); q.push(left.right); q.push(right.left); } return true;}; 66-Plus One方法一：从n-1开始遍历，然后用一个变量表示前面一位是否进位 /** * @param {number[]} digits * @return {number[]} */var plusOne = function(digits) { var j=0,k; for(var n=digits.length,i=n-1;i&gt;=0;i–){ k = i==n-1 ? 1:0; var old = digits[i]; digits[i] = (old + j + k)%10; j = Math.floor((old + j + k)/10); } if(j == 1){ digits.unshift(1); } return digits;}; 118-Pascal’s Triangle方法一：单独用一个方法生成某一行，再push进数组 /** * @param {number} numRows * @return {number[][]} */var generate = function(numRows) { var arr = []; for(var i=0;i&lt;numRows;i++){ var item = f(i+1); arr.push(item); } console.info(f(1)); return arr;}; var f = function(n){ var a = new Array(n); if(n==1){return [1];} else if(n==2){return [1,1];} else{ var arr = f(n-1); for(var i=0;i&lt;n-1;i++){ a[i+1] = arr[i]+arr[i+1]; } a[0] = a[n-1] = 1; return a; }}; 方法二：直接对二维数组进行赋值 /** * @param {number} numRows * @return {number[][]} */var generate = function(numRows) { var r = []; for(var k=0;k&lt;numRows;k++){ r[k]= []; } for (var i = 0; i &lt; numRows; i++) { r[i][0] = r[i][i] = 1; for (var j = 1; j &lt; i; j++){ r[i][j] = r[i - 1][j - 1] + r[i - 1][j]; } } return r;}; 434. Number of Segments in a String方法一：先去掉首尾空格再将非空格替换成空字符 /** * @param {string} s * @return {number} */var countSegments = function(s) { var str = s.replace(/^\\s+|\\s+$/g,’’); return str.length === 0 ? 0 : str.replace(/\\s+/g,’ ‘).replace(/\\S/g,’’).length +1;}; 方法二：先在首尾加一个空格，然后将非空格替换成空字符 /** * @param {string} s * @return {number} */var countSegments = function(s) { return (“ “ + s + “ “).replace(/\\s+/g,’ ‘).replace(/\\S/g,’’).length - 1;}; 110. Balanced Binary Tree方法一：某节点的高度等于该节点的左子树和右子树的高度中的较大值再加一，O(N^2) /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {boolean} */var isBalanced = function(root) { if (root === null) return true; var left=depth(root.left); var right=depth(root.right); return Math.abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);}; var depth = function(root){ if (root === null) return 0; return Math.max(depth(root.left), depth (root.right)) + 1;}; 方法二：从底部向上遍历，O(N) /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {boolean} */var isBalanced = function(root) { return dfsHeight(root) != -1;}; var dfsHeight = function(root) { if (root === null) return 0; var leftHeight = dfsHeight (root.left); if (leftHeight == -1) return -1; var rightHeight = dfsHeight(root.right); if (rightHeight == -1) return -1; if (Math.abs(leftHeight - rightHeight) &gt; 1) return -1; return Math.max(leftHeight, rightHeight) + 1;}; 257-Binary Tree Paths暂无 441-Arranging Coins方法一：根据公式直接求解(x * ( x + 1)) / 2 &lt;= n /** * @param {number} n * @return {number} /var arrangeCoins = function(n) { return Math.floor(((-1 + Math.sqrt(1 + 8 n)) / 2));}; 方法二：先根据根值确定大致范围，然后二分查找 /** * @param {number} n * @return {number} /var arrangeCoins = function(n) { var start = 0, end = n, mid = 0; while (start &lt;= end){ mid = (start + end) &gt;&gt;&gt; 1; if ((0.5 mid mid + 0.5 mid ) &lt;= n){ start = mid + 1; }else{ end = mid - 1; } } return start - 1;}; 119-Pascal’s Triangle II方法一：递归，直接计算 /** * @param {number} rowIndex * @return {number[]} */var getRow = function(rowIndex) { var A = []; A[0] = 1; for(var i=1; i&lt;rowIndex+1; i++){ for(var j=i; j&gt;=1; j–){ if(isNaN(A[j])){ A[j] = 0; } if(isNaN(A[j-1])){ A[j-1] = 0; } A[j] += A[j-1]; } } return A;}; 方法二：根据公式a(k+1) = a(k) * (n-k)/(k+1)，其中a(0)=1和a(1)=n很容易发现 /** * @param {number} rowIndex * @return {number[]} /var getRow = function(rowIndex) { if(rowIndex === 0) {return [1];} var A=[]; A[0]=1; A[1]=rowIndex; for(var i=2;i&lt;=rowIndex;i++) { A[i]=Math.floor(A[i-1](rowIndex-(i-1))/i); //in case of overflow } return A;}; 232-Implement Queue using Stacks参见我的另外一篇文章：JS实现复杂数据结构 141-Linked List Cycle方法一：一个快指针，一个慢指针 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */var hasCycle = function(head) { if(head===null) return false; var walker = head,runner = head; while(runner.next!==null &amp;&amp; runner.next.next!==null) { walker = walker.next; runner = runner.next.next; if(walker==runner) return true; } return false;}; 26-Remove Duplicates from Sorted Array方法一：遇到不同的元素时才进行赋值 /** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { if (nums.length===0) return 0; var j=0; for (var i=0; i&lt;nums.length; i++) if (nums[i]!=nums[j]) nums[++j]=nums[i]; return ++j;}; 方法二：用一个变量记录当前重复元素数量 /** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { var count = 0; for(var i = 1; i &lt; nums.length; i++){ if(nums[i] == nums[i-1]) count++; else nums[i-count] = nums[i]; } return nums.length-count;}; 172-Factorial Trailing Zeroes方法一：产生0的可能性只有2*5，所以需要计算n！里有几个5，2是足够多的 /** * @param {number} n * @return {number} */var trailingZeroes = function(n) { return n === 0 ? 0 : Math.floor(n / 5) + trailingZeroes(n / 5);}; 9-Palindrome Number方法一：二分查找 /** * @param {number} x * @return {boolean} */var isPalindrome = function(x) { var str = “” + x,left=0,right=str.length-1; while(right-left&gt;=1){ if(str[left] == str[right]){ left++; right–; }else{ return false; } } return true;}; 方法二：比较前一半数字和后一半数字是否相等 /** * @param {number} x * @return {boolean} /var isPalindrome = function(x) { if (xrev){ rev = rev10 + x%10; x = Math.floor(x/10); } return (x==rev || x==Math.floor(rev/10));}; 374-Guess Number Higher or Lower方法一：二分查找（这道题不能用js，所以答案并没有在leetcode上验证） // Forward declaration of guess API.// @param n, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0var guessNumber = function(n){ var low = 1; while(low &lt;= n){ var mid = Math.floor(low + (n-low) / 2); var res = guess(mid); if(res == 0) return mid; else if(res == -1) n = mid - 1; else low = mid + 1; } return -1;} 438-Find All Anagrams in a String暂无 112-Path Sum方法一：知道sum和root.val，看左子树或右子树是否能够满足sum-root.val /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} sum * @return {boolean} */var hasPathSum = function(root, sum) { if (root === null) return false; if (root.val == sum &amp;&amp; root.left === null &amp;&amp; root.right === null) return true; return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);}; 38-Count and Say/** * @param {number} n * @return {string} */var countAndSay = function(n) { if(n == 1) {return ‘1’;} else{ var s = countAndSay(n-1),res=’’,a=1; for(var i=0,len=s.length;i&lt;len;i++){ if(s[i+1] == s[i]){ a++; }else{ res += a + s[i]; a=1; } } return res; }}; 250-Isomorphic Strings方法一：用哈希表判断重复出现的位置 /** * @param {string} s * @param {string} t * @return {boolean} */var isIsomorphic = function(s, t) { return phic(s,t) &amp;&amp; phic(t,s);}; var phic = function(s,t){ var arr = []; for(var i=0,n=s.length;i&lt;n;i++){ var code = s[i].charCodeAt() - 65; if(arr[code] === undefined){ arr[code] = i; }else{ if(t[i] != t[arr[code]]){ return false; } } } return true;}; 方法二：用一个数组保存重复元素第一次出现的位置 /** * @param {string} s * @param {string} t * @return {boolean} */var isIsomorphic = function(s, t) { var m = []; for (var i = 0; i &lt; s.length; i++) { if (m[s.charCodeAt(i)] != m[t.charCodeAt(i)+256]) {return false;} m[s.charCodeAt(i)] = m[t.charCodeAt(i)+256] = i+1; } return true;}; 20-Valid Parentheses/** * @param {string} s * @return {boolean} */var isValid = function(s) { var p = []; for(var i = 0; i &lt; s.length; i++) { var q = “(){}[]“.indexOf(s.substring(i, i + 1)); if(q % 2 == 1) { if(p.length === 0 || p.shift() != q - 1) return false; } else p.unshift(q); } return !p.length;}; 111-Minimum Depth of Binary Tree方法一：We need to add the smaller one of the child depths - except if that’s zero, then add the larger one. /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var minDepth = function(root) { if (!root) return 0; var L = minDepth(root.left), R = minDepth(root.right); return 1 + (Math.min(L, R) || Math.max(L, R));}; 290-Word Pattern/** * @param {string} pattern * @param {string} str * @return {boolean} */var wordPattern = function(pattern, str) { var arr = str.split(“ “),mid = []; for(var i=0,n=pattern.length;i&lt;n;i++){ var char = pattern\\[i\\].charCodeAt() - 97; if(mid\\[char\\] === undefined){ if(inArray(arr\\[i\\],mid)){ return false; }else{ mid\\[char\\] = arr\\[i\\]; } }else{ if(mid\\[char\\] != arr\\[i\\]){ return false; } } } return true &amp;&amp; (pattern.length == arr.length); }; var inArray = function(item,arr) { for(var i=0,n=arr.length;i&lt;n;i++){ if(arr[i] === item){ return true; } } return false;}; 234-Palindrome Linked List/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {boolean} */var isPalindrome = function(head) { if(head === null) { return true; } var p1 = head,p2 = head,p3 = p1.next,pre = p1; //find mid pointer, and reverse head half part while(p2.next !== null &amp;&amp; p2.next.next !== null) { p2 = p2.next.next; pre = p1; p1 = p3; p3 = p3.next; p1.next = pre; } //odd number of elements, need left move p1 one step if(p2.next === null) { p1 = p1.next; } else { //even number of elements, do nothing } //compare from mid to head/tail while(p3 !== null) { if(p1.val != p3.val) { return false; } p1 = p1.next; p3 = p3.next; } return true;}; 1.Two Sum方法一：双层循环（其实应该用哈希表，但是js中没有，需要额外实现） /** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function(nums, target) { for(var i=0,n=nums.length;i&lt;n;i++){ for(var j=i+1;j&lt;n;j++){ if((nums[i] + nums[j]) == target){ return [i,j]; } } } return false;}; 219-Contains Duplicate II方法一：只要读懂题意就差不多了，哈希表及时更新 /** * @param {number[]} nums * @param {number} k * @return {boolean} */var containsNearbyDuplicate = function(nums, k) { var arr = [],res = false; for(var i=0,n=nums.length;i&lt;n;i++){ var item = nums[i]; if(arr[item] === undefined){ arr[item] = i; }else{ if(Math.abs(arr[item] - i) &lt;= k){ return true; } arr[item] = i; } } return false;}; 225-Implement Stack using Queues参考我的另一篇文章JS实现复杂数据结构 88.Merge Sorted Array方法一：模仿归并排序，从后往前比较 /** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) { while(n&gt;0) nums1[m+n-1] = (m===0||nums2[n-1] &gt; nums1[m-1]) ? nums2[–n] : nums1[–m];}; 203-Remove Linked List Elements方法一：递归 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @param {number} val * @return {ListNode} */var removeElements = function(head, val) { if (head === null) return null; head.next = removeElements(head.next, val); return head.val == val ? head.next : head;}; 58.Length of Last Word方法一：利用split，需要提前去掉前后空格 /** * @param {string} s * @return {number} */var lengthOfLastWord = function(s) { return s.replace(/^\\s+|\\s+$/g,’’).split(‘ ‘)[s.replace(/^\\s+|\\s+$/g,’’).split(‘ ‘).length - 1].length;}; 507-Perfect Number方法一：先求根值，因为根值是遍历的界限 /** * @param {number} num * @return {boolean} /var checkPerfectNumber = function(num) { var sqrt = Math.sqrt(num),res = 0; for(var i=1;i&lt;=sqrt;i++){ if(num%i === 0){ res += i+ num/i; } } console.info(res); return num&gt;1 &amp;&amp; res==2num;}; 67-Add Binary方法一：对两个字符串循环遍历，同时用一个变量保存进位情况 /** * @param {string} a * @param {string} b * @return {string} */var addBinary = function(a, b) { var s = “”; var c = 0, i = a.length - 1, j = b.length - 1; while(i &gt;= 0 || j &gt;= 0 || c == 1) { c += i &gt;= 0 ? a[i –] - ‘0’ : 0; c += j &gt;= 0 ? b[j –] - ‘0’ : 0; s = c % 2 + s; c = Math.floor(c / 2); } return s;}; 14-Longest Common Prefix方法一：对数组进行遍历，用indexOf判断字符串的前缀 /** * @param {string[]} strs * @return {string} */var longestCommonPrefix = function(strs) { if(strs === null || strs.length === 0) return “”; var pre = strs[0],i = 1; while(i &lt; strs.length){ while(strs[i].indexOf(pre) !== 0){ pre = pre.substring(0,pre.length-1); } i++; } return pre;}; 160-Intersection of Two Linked Lists方法一：用两个指针进行遍历，循环结束条件为指针相等 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */var getIntersectionNode = function(headA, headB) { var cur1 = headA,cur2 = headB; while(cur1 != cur2){ cur1 = cur1?cur1.next:headB; cur2 = cur2?cur2.next:headA; } return cur1;}; 400-Nth Digit方法一：步骤为：确定数字是几位数-&gt;确定具体数字-&gt;返回这个数字的第几位数 /** * @param {number} n * @return {number} /var findNthDigit = function(n) { n -= 1; var digits = 1, first = 1; while (Math.floor(n / 9 / first / digits) &gt;= 1) { n -= 9 first digits; digits++; first = 10; } return (first + Math.floor(n/digits) + “”).charAt(n%digits) - ‘0’;}; 475. Heaters方法一：在对房子进行循环的过程中移动加热器的指针 /** * @param {number[]} houses * @param {number[]} heaters * @return {number} /var findRadius = function(houses, heaters) { var house = houses.sort(function(a,b){return a-b;}), heater= heaters.sort(function(a,b){return a-b;}), i = 0, res = 0; for (var j=0,n=house.length;j&lt;n;j++) { while (i &lt; heater.length - 1 &amp;&amp; heater[i] + heater[i + 1] &lt;= house[j] 2) { i++; } res = Math.max(res, Math.abs(heater[i] - house[j])); } return res;}; 190-Reverse Bits方法一：利用数组的reverse()进行反转 /** * @param {number} n - a positive integer * @return {number} - a positive integer */var reverseBits = function(n) { var zero = 32- n.toString(2).length; var bit = n.toString(2).split(“”).reverse().join(“”); while(zero&gt;0){ bit += ‘0’; zero–; } return parseInt(bit,2);}; 303-Range Sum Query - Immutable方法一：用一个数组保存前面元素之和 /** * @param {number[]} nums */var NumArray = function(nums) { for(var i = 1; i &lt; nums.length; i++) nums[i] += nums[i - 1]; this.nums = nums; }; /** * @param {number} i * @param {number} j * @return {number} */NumArray.prototype.sumRange = function(i, j) { if(i === 0) {return this.nums[j];} return this.nums[j] - this.nums[i - 1];}; /** * Your NumArray object will be instantiated and called as such: * var obj = Object.create(NumArray).createNew(nums) * var param_1 = obj.sumRange(i,j) */ 28-Implement strStr()方法一：利用js中的indexOf() /** * @param {string} haystack * @param {string} needle * @return {number} */var strStr = function(haystack, needle) { return haystack.indexOf(needle);}; 方法二：老老实实遍历 /** * @param {string} haystack * @param {string} needle * @return {number} */var strStr = function(haystack, needle) { for (var i = 0; ; i++) { for (var j = 0; ; j++) { if (j == needle.length) return i; if (i + j == haystack.length) return -1; if (needle.charAt(j) != haystack.charAt(i + j)) break; } }}; 69-Sqrt(x)方法一：从x/2开始遍历（复杂度高，而且有可能会超时，不建议这种方法） /** * @param {number} x * @return {number} /var mySqrt = function(x) { var t = Math.floor(x/2); while(tt&gt;x &amp;&amp; t&gt;=0){ t–; } return x==1 ? 1 : t;}; 方法二：二分查找 /** * @param {number} x * @return {number} /var mySqrt = function(x) { var begin = 0,end = x,result = 1,mid = 1; while(Math.abs(result-x) &gt; 0.000001){ mid = (begin+end)/2; result = midmid; if(result &gt; x) {end = mid;} else {begin = mid; } } return Math.floor(mid);}; 方法三：牛顿迭代法 /** * @param {number} x * @return {number} /var mySqrt = function(x) { r = x; while (rr &gt; x) r = ((r + x/r) / 2) | 0; return r;}; 155-Min Stack参考我的另一篇文章JS实现复杂数据结构 414-Third Maximum Number方法一：遍历比较 /** * @param {number[]} nums * @return {number} */var thirdMax = function(nums) { var max1 = null,max2 = null,max3 = null; for (var i=0,len=nums.length;i&lt;len;i++) { var n = nums[i]; if (n == max1 || n == max2 || n == max3) continue; if (max1 === null || n &gt; max1) { max3 = max2; max2 = max1; max1 = n; } else if (max2 === null || n &gt; max2) { max3 = max2; max2 = n; } else if (max3 === null || n &gt; max3) { max3 = n; } } return max3 === null ? max1 : max3;}; 方法二：先将数组排序再遍历 /** * @param {number[]} nums * @return {number} */var thirdMax = function(nums) { nums.sort(function(a,b){ return b-a; }); max1 = nums[0],i = 1,j=1; while(nums[i] == max1&amp;&amp;nums[i] !== undefined){ i++; j++; } max2 = nums[i]; while(nums[j] == max2&amp;&amp;nums[j] !== undefined){ j++; } max3 = nums[j]; return max3 === undefined ? max1 : max3;}; 532-K-diff Pairs in an Array方法一：两个指针，一个指针用来遍历，另一个指针用来寻找对应数字 /** * @param {number[]} nums * @param {number} k * @return {number} */var findPairs = function(nums, k) { var ans = 0; nums.sort(function(a,b){ return a-b; }); for (var i = 0, j = 0; i &lt; nums.length; i++) { for (j = Math.max(j, i + 1); j &lt; nums.length &amp;&amp; nums[j] - nums[i] &lt; k; j++) ; if (j &lt; nums.length &amp;&amp; nums[j] - nums[i] == k) ans++; while (i + 1 &lt; nums.length &amp;&amp; nums[i] == nums[i + 1]) {i++;} } return ans;}; 204-Count Primes方法一：质数（素数）判断思路-&gt;对正整数n，如果用2到根号n之间的所有整数去除，均无法整除，则n为质数 /** * @param {number} n * @return {number} /var countPrimes = function(n) { if (n &lt; 3) return 0; var f = [],count = Math.floor(n / 2); for (var i = 3; i i &lt; n; i += 2) { if (f[i]) {continue;} for (var j = i i; j &lt; n; j += 2 i) { if (!f[j]) { –count; f[j] = true; } } } return count;}; 125-Valid Palindrome方法一：二分查找 /** * @param {string} s * @return {boolean} */var isPalindrome = function(s) { if(s === ‘’){return true;} var low = s.replace(/\\W/g,’’).toLowerCase(); console.log(low); var left=0,right=low.length-1; while(left&lt;=right){ if(low[left] != low[right]){ return false; } left++; right–; } return true;}; 168-Excel Sheet Column Title方法一：利用ASCII码进行递归，为了让余数为0-25，需要每次递归前将n减1 /** * @param {number} n * @return {string} */var convertToTitle = function(n) { var res = ‘’; while(n&gt;0){ n–; res = String.fromCharCode(n % 26 + 65)+res; n = Math.floor(n/26); } return res;}; 278-First Bad Version方法一：很常用的二分查找 /** * Definition for isBadVersion() * * @param {integer} version number * @return {boolean} whether the version is bad * isBadVersion = function(version) { * … * }; */ /** * @param {function} isBadVersion() * @return {function} /var solution = function(isBadVersion) { /\\* * @param {integer} n Total versions * @return {integer} The first bad version */ return function(n) { var left = 1,right=n; while(left&lt;right){ min = Math.floor((left+right)/2); if(isBadVersion(min)){ right = min; }else{ left=min+1; } } return left; };}; 7-Reverse Integer方法一：利用数组的reverse()方法，需要注意的是符号位和int型溢出的处理 /** * @param {number} x * @return {number} */var reverse = function(x) { var res = Math.floor((‘’ + Math.abs(x)).split(‘’).reverse().join().replace(/,/g,’’)); if(res &gt; (Math.pow(2,31)-1)){ return 0; } return x&gt;0 ? res : 0- res;}; 方法二：利用数学计算进行反转 /** * @param {number} x * @return {number} /var reverse = function(x) { var rev= 0,pos = Math.abs(x); while( pos !== 0){ rev= rev10 + pos % 10; pos= Math.floor(pos/10); if(Math.abs(rev)&gt;Math.pow(2,31)-1) return 0; } return x&gt;0 ? Math.floor(rev) : 0- Math.floor(rev);}; 189-Rotate Array方法一：利用数组的pop()和unshift()方法 /** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */var rotate = function(nums, k) { var len = nums.length; while(k&gt;0){ nums.unshift(nums.pop()); k–; }}; 方法二：三次反转 /** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */var rotate = function(nums, k) { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1);}; var reverse = function(nums,start,end) { while (start &lt; end) { var temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end–; }}; 方法三：非常巧妙的一种方式，看不懂的可以点击这里看作者的解释 /** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */var rotate = function(nums, k) { if(nums.length &lt;= 1){ return; } //step each time to move var step = k % nums.length; //find GCD between nums length and step var gcd = findGcd(nums.length, step),position, count; //gcd path to finish movie for(var i = 0; i &lt; gcd; i++){ //beginning position of each path position = i; //count is the number we need swap each path count = Math.floor(nums.length / gcd) - 1; for(var j = 0; j &lt; count; j++){ position = (position + step) % nums.length; //swap index value in index i and position nums[i] ^= nums[position]; nums[position] ^= nums[i]; nums[i] ^= nums[position]; } }}; var findGcd = function(a,b){ return (a === 0 || b === 0) ? a + b : findGcd(b, a % b);};","categories":[{"name":"算法","slug":"algorithm","permalink":"http://merrier.wang/categories/algorithm/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"算法","slug":"算法","permalink":"http://merrier.wang/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://merrier.wang/tags/leetcode/"}]},{"title":"罗马数字转换成整数（JS）","slug":"罗马数字转换成整数（JS）","date":"2017-03-24T14:40:12.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170324/roman-numerals-converted-into-integers.html","link":"","permalink":"http://merrier.wang/20170324/roman-numerals-converted-into-integers.html","excerpt":"","text":"写在前面：此文章是在刷Leetcode时碰到的一道题，题目的大致意图就是将罗马数字转换成整数，但是作为即将要研究生毕业的我竟然连罗马数字是什么都不知道，所以就打算直接写一篇关于这道题的文章 题目要求：给定一个罗马数字s，(I&lt;=s&lt;=MMMCMXCIX)（即1到3999），将罗马数字转换成整数。 输入：一个罗马数字 输出：对应的整数 知识储备：首先要来了解一下罗马数字表示法，基本字符有7个：I，V，X，L，C，D，M，分别表示1，5，10，50，100，500，1000。并且在构成数字的时候，有下列规则： 相同的数字连写，所表示的数等于这些数字相加得到的数，如：Ⅲ= 3； 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：Ⅷ= 8；Ⅻ= 12； 小的数字，（限于Ⅰ、X 和C）在大的数字的左边，所表示的数等于大数减小数得到的数，如：Ⅳ=4；Ⅸ=9； 正常使用时，连写的数字重复不得超过三次。 所以，根据以上规则，可以发现其中的规律，就是只需要比较前后元素的大小，如果前面比后面大，这两个罗马字母代表的数字就相加；如果前面比后面小，就后面的减去前面的；如果相等也相加。再把每一对都相加，最后结果就是转换后的整数了（需要注意的是，最后一个字母是肯定要相加的） 代码实现：/** * @param {string} s * @return {number} */var romanToInt = function(s) { var opt = {‘M’: 1000,’D’: 500 ,’C’: 100,’L’: 50,’X’: 10,’V’: 5,’I’: 1}, z = 0, n=s.length; for(var i=0;i&lt;n-1;i++){ if(opt[s[i]] &lt; opt[s[i+1]]){ z -= opt[s[i]]; }else{ z += opt[s[i]]; } } return z + opt[s[n-1]];}; 题目来源Leetcode第13题：https://leetcode.com/problems/roman-to-integer/#/description","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/categories/计算机基础/"}],"tags":[{"name":"罗马数字","slug":"罗马数字","permalink":"http://merrier.wang/tags/罗马数字/"}]},{"title":"JS中数组方法总结","slug":"JS中数组方法总结","date":"2017-03-22T14:12:57.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170322/summary-of-array-method-in-js.html","link":"","permalink":"http://merrier.wang/20170322/summary-of-array-method-in-js.html","excerpt":"","text":"写在前面因为刷leetcode的时候，发现会经常用到数组，因为JS中没有明确的栈和队列，所以需要用数组进行模拟，在刷算法题的过程中碰到了好多关于数组的计算方法，所以就打算对算法中经常用的数组方法进行总结，可能会对刚开始用JS刷Leetcode的码农有好处，如果你有任何补充，请留言评论或直接给我发邮件。 1.JS自带数组方法 concat()=&gt;连接两个或更多的数组，并返回结果。 join()=&gt;把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop()=&gt;删除并返回数组的最后一个元素 push()=&gt;向数组的末尾添加一个或更多元素，并返回新的长度。 reverse()=&gt;颠倒数组中元素的顺序。 shift()=&gt;删除并返回数组的第一个元素 slice()=&gt;从某个已有的数组返回选定的元素 sort()=&gt;对数组的元素进行排序 splice()=&gt;删除元素，并向数组添加新元素。 toSource()=&gt;返回该对象的源代码。 toString()=&gt;把数组转换为字符串，并返回结果。 toLocaleString()=&gt;把数组转换为本地数组，并返回结果。 unshift()=&gt;向数组的开头添加一个或更多元素，并返回新的长度。 valueOf()=&gt;返回数组对象的原始值 2.排序js数组对象排序有内置方法sort()，但是默认以字符串方式排序: 1、简单数组简单排序 var arrSimple=new Array(1,8,7,6); arrSimple.sort(); //[1,6,7,8]2、简单数组自定义排序 var arrSimple2=new Array(1,8,7,6); arrSimple2.sort(function(a,b){return b-a}); //[8,7,6,1] //解释：a,b表示数组中的任意两个元素，若return &gt; 0 b前a后；reutrn &lt; 0 a前b后；a=b时存在浏览器兼容 //简化一下：a-b输出从小到大排序，b-a输出从大到小排序。 3.删除重复的元素只保留一个（两种实现思路）//方法一：遍历要删除的数组arr, 把元素分别放入另一个数组tmp中，在判断该元素在arr中不存在才允许放入tmp中用到两个函数：for …in 和 indexOf()var test = [2,4,4,5,”a”,”a”];function unique1(arr){ // 遍历arr，把元素分别放入tmp数组(不存在才放) var tmp = new Array(); for(var i in arr){ //该元素在tmp内部不存在才允许追加 if(tmp.indexOf(arr[i])==-1){ tmp.push(arr[i]); } } return tmp;}unique1(test); //[2,4,5,”a”] //方法二：把目标数组arr的元素值和键的位置调换 自动就把重复的元素给删除掉了，调换后的样子：array(‘qiang’=&gt;1,’ming’=&gt;1,’tao’=&gt;1)function unique2(arr){ var tmp = new Array(); for(var m in arr){ tmp[arr[m]]=1; } //再把键和值的位置再次调换 var tmparr = new Array(); for(var n in tmp){ tmparr.push(n); } return tmparr;}unique2(test); //[2,4,5,”a”] //方法三：返回新数组，保证类型不变function unique3(a){ var hash=[],arr=[]; for (var i = 0; i &lt; a.length; i++) { hash[a[i]]!=null; if(!hash[a[i]]){ arr.push(a[i]); hash[a[i]]=true; } } console.log(arr);}unique3(test);//[2, 4, 5, “a”] 4.获取数组中的最大值和最小值可以用传统的遍历，也可以用math var arr = [54,65,43,21,12,34,45,58,97,24]; //方法一、字符串拼接法//利用toString和join把数组转换为字符串，再和Math的max和min方法分别进行拼接，最后执行eval方法var maxN = eval(“Math.max(“ + arr.toString() + “)”);var minN = eval(“Math.min(“ + arr.toString() + “)”);//或者var maxN = eval(“Math.max(“ + arr.join() + “)”);var minN = eval(“Math.min(“ + arr.join() + “)”); //方法二、排序法//先把数组从小到大排序，数组第一个即为最小值，最后一个即为最大值arr.sort(function(a,b){return a-b;});var minN = arr[0];var maxN = arr[arr.length-1]; //方法三、假设法//假设数组第一个为最大（或最小值），和后边进行比较，若后边的值比最大值大（或比最小值小），则替换最大值（或最小值）var maxN = arr[0];var minN = arr[0];for(var i=1;i&lt;arr.length;i++){ var cur = arr[i]; cur&gt;maxN ? maxN=cur : null; cur&lt;minN ? minN=cur : null;} //方法四、Math的max和min方法//使用apply方法使数组可以作为传递的参数var maxN = Math.max.apply(null,arr);var minN = Math.min.apply(null,arr);//多维数组可以这样做：var a=[1,2,3,[5,6],[1,4,8]];var ta=a.join(“,”).split(“,”);//转化为一维数组var maxN = Math.max.apply(null,ta);//最大值var minN = Math.min.apply(null,ta);//最小值 //扩展：增加原型方法，同时为了避免其他库也实现了同名的原型方法，可以在生成函数之前进行重名判断if (typeof Array.prototype[‘max’] == ‘undefined’) { Array.prototype.max = function() { return Math.max.apply({},this); }}if (typeof Array.prototype[‘min’] == ‘undefined’) { Array.prototype.min = function() { return Math.min.apply({},this); }} 5.初始化二维数组//方法一：直接定义并且初始化var _TheArray = [[“0-1”,”0-2”],[“1-1”,”1-2”],[“2-1”,”2-2”]] //方法二：未知长度的二维数组var tArray = new Array(); //先声明一维 for(var k=0;k&lt;i;k++){ //一维长度为i,i为变量，可以根据实际情况改变 tArray[k]=new Array(); //声明二维，每一个一维数组里面的一个元素都是一个数组； for(var j=0;j&lt;p;j++){ //一维数组里面每个元素数组可以包含的数量p，p也是一个变量； tArray[k][j]=””; //这里将变量初始化，我这边统一初始化为空，后面在用所需的值覆盖里面的值 }} //以上方法都有问题，推荐方法三var r = [];for(var k=0;k&lt;length;k++){ r[k]= [];} 6.数组随机排序来自关于JavaScript的数组随机排序 //方法一：Fisher–Yates shuffle 算法function shuffle(arr) { var i = arr.length, t, j; while (i) { j = Math.floor(Math.random() * i–); t = arr[i]; arr[i] = arr[j]; arr[j] = t; }}","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"数组","slug":"数组","permalink":"http://merrier.wang/tags/数组/"}]},{"title":"一些位操作的技巧","slug":"一些位操作的技巧","date":"2017-03-21T14:11:27.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170321/some-bit-manipulation-techniques.html","link":"","permalink":"http://merrier.wang/20170321/some-bit-manipulation-techniques.html","excerpt":"","text":"写在前面这篇文章大部分是从英文翻译过来的，是在刷leetcode的时候看到的一个solution，感觉作者讲的很好，只不过英文的读起来有点费劲，在网上搜了一下，发现也没有翻译的版本，于是就想做第一个吃螃蟹的人，然后再加一些其他文章中的位操作技巧进行总结，最终形成了这个版本（文末有原文链接，英文好的可以去看一下，毕竟看原文才不会被误导） 位操作介绍位操作是对少于一个字母的数据段或位数进行算法层面的计算。在计算机工程领域，用到位操作任务有低等级设备控制、误差检测和校正算法，数据压缩、加密算法和优化算法。对于大多数任务而言，现在编程语言允许程序员直接用高级语言而不是位操作。位操作的源码使用位运算：AND、OR、XOR、NOT和移位 由于位操作是可以并行处理的，所以在某些情况下可以减少甚至避免对于某数据结构的循环操作，从而在速度上会有较大提升，但是代码将变得很难书写和理解。 基础知识位操作的核心是位运算符&amp;（和）、|（或）、~（不）、^（异或）以及移位运算符a&lt;&lt;b和a&gt;&gt;b（异或通常缩写为XOR）。 取并集：A | B 取交集：A &amp; B 取补集：A &amp; ~B 所有位数取反：^A 或者~A 设置某位：A | = 1&lt;&lt;bit 清除某位：A &amp; = ~（1&lt;&lt;bit） 检验某位：(A &amp; 1&lt;&lt;bit) != 0 提取最后一位：A &amp; -A 或者 A &amp; ~ (A-1) 或者x ^ (x &amp; (x-1)) 移除最后一位：A &amp; (A-1) 所有位数为1：~0 位操作的基本技巧 用异或操作符^可以删除完全相同的数字然后保存剩余的，或者保存不同位然后移除相同位 用 | 操作符可以留存尽可能多的1 用&amp;可以筛选出指定位 1.检查整数是奇数还是偶数只要整数的最后一位比特是 1 ，那它就是奇数，反之就是偶数。即最低位要么是 1 要么是 0 ，x和 1 与（&amp;）运算，保留了最最低位，如果最低是 1 ，x是奇数，如果最低位是 0 ，x是偶数。 例如43，二进制表示为00101011，注意\b最低位为 1，我们将 43 与 1 做 &amp; 运算： 1 001010112&amp; 00000001 (note: 1 is the same as 00000001)3 ——–4 00000001 2.测试第n位比特只要将与运算的1向左平移相应的位数即可。假设向左平移n位，接下来的与运算就是只保留第n位，其它位都清零了。比如：122的第三位比特是1吗？（从0开始数）可以这样做： 122 &amp; (1&lt;&lt;3)，122的二进制表示是01111010，(1&lt;&lt;3)即1向左平移3比特00001000。 1 011110102&amp; 000010003 ——–4 00001000 3.将第n位设为1或不变和前面的技巧一样，只是把与运算（&amp;）换成了或运算（|）。与1进行或运算将参与运算的位置设为1，与0进行或运算参与预算的位不变。 y = x | (1&lt;&lt;n) 4.将第n位设为0这个方法的关键就是~(1&lt;&lt;n)，它将第n位设为0，其它位全部为1。看下面： y = x &amp; ~(1&lt;&lt;n) 5.将第n位取反这次使用的是异或运算，如果异或运算的两个操作数相同，运算结果是0，两个操作数不同，结果是1。怎样将第n位取反呢？如果第n位比特为1，将它与1进行异或运算结果就是0，如果它是0，那么它与1异或运算的结果就是1。于是这一位就取反了。 y = x ^ (1&lt;&lt;n) 位操作在数字运算中的应用1.计算某二进制数中的1的数量int count_one(int n) { while(n) { n = n&amp;(n-1); count++; } return count;} 2.判断某数字是否为4的n次方(n≥0)，是就返回该数，不是就返回0或falsebool isPowerOfFour(int n) { return !(n&amp;(n-1)) &amp;&amp; (n&amp;0x55555555);} 3.使用^和&amp;来求两个数字的和int getSum(int a, int b) { return b==0? a:getSum(a^b, (a&amp;b)&lt;&lt;1);} 4.寻找丢失数字：给你一个包括从0到n的各不相同的n元数组，从中找出丢失的那个数字，比如给你的数组为[0,1,3]，那么应该返回2（当然，你也可以用数学方法解决）int missingNumber(vector&amp; nums) { int ret = 0; for(int i = 0; i &lt; nums.size(); ++i) { ret ^= i; ret ^= nums[i]; } return ret^=nums.size();} 5.给定一个自然数N，找到小于等于N的2的最大倍数long largest_power(long N) { //将所有右侧位变为1. N = N | (N&gt;&gt;1); N = N | (N&gt;&gt;2); N = N | (N&gt;&gt;4); N = N | (N&gt;&gt;8); N = N | (N&gt;&gt;16); return (N+1)&gt;&gt;1;} 6.将一个32位的无符号数进行反转uint32_t reverseBits(uint32_t n) { unsigned int mask = 1&lt;&lt;31, res = 0; for(int i = 0; i &lt; 32; ++i) { if(n &amp; 1) res |= mask; mask &gt;&gt;= 1; n &gt;&gt;= 1; } return res;}uint32_t reverseBits(uint32_t n) { uint32_t mask = 1, ret = 0; for(int i = 0; i &lt; 32; ++i){ ret &lt;&lt;= 1; if(mask &amp; n) ret |= 1; mask &lt;&lt;= 1; } return ret;} 7.给定一个范围[m,n]，其中0&lt;=m&lt;=n&lt;=2147483647，返回在这个范围内的所有数的按位进行AND操作之后的数字，比如范围为[5,7]，那返回的应该是按位进行计算的5+6+7，结果是4（100）int rangeBitwiseAnd(int m, int n) { int a = 0; while(m != n) { m &gt;&gt;= 1; n &gt;&gt;= 1; a++; } return m&lt;&lt;a;} 8.求一个无符号数的汉明距离（即二进制表示中的1的个数）int hammingWeight(uint32_t n) { int count = 0; while(n) { n = n&amp;(n-1); count++; } return count;}int hammingWeight(uint32_t n) { ulong mask = 1; int count = 0; for(int i = 0; i &lt; 32; ++i){ if(mask &amp; n) count++; mask &lt;&lt;= 1; } return count;} 9.用位操作交换变量a = a ^ b;b = a ^ b; //实际上是(a^b)^b 也就是a异或了b两次，等号右边是a的值a = a ^ b; //此时b里面已经是“果汁”，实际上是(a^b)^a，也就是b异或了a两次，是b 位操作\b更复杂的应用1.查找DNA重复序列：所有的DNA是由一系列简写为A、C、G和T核苷酸组成的，比如”ACGAATTCCG”，当我们研究DNA时，有时候识别DNA中的重复序列是有用的，设计一个方法可以找出所有在DNA分子中出现不止一次的10字母长的序列（或子序列）举个例子： Given s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT” Return: [“AAAAACCCCC”, “CCCCCAAAAA”] class Solution {public: vector findRepeatedDnaSequences(string s) { int sLen = s.length(); vector v; if(sLen &lt; 11) return v; char keyMap[1&lt;&lt;21]{0}; int hashKey = 0; for(int i = 0; i &lt; 9; ++i) hashKey = (hashKey&lt;&lt;2) | (s[i]-‘A’+1)%5; for(int i = 9; i &lt; sLen; ++i) { if(keyMap[hashKey = ((hashKey&lt;&lt;2)|(s[i]-‘A’+1)%5)&amp;0xfffff]++ == 1) v.push_back(s.substr(i-9, 10)); } return v; }}; 2.多数单元：给定一个n元数组，多数单元式在该数组中出现次数多于⌊ n/2 ⌋次的数（一般采用位运算，但是在这里我们也可以采用分组和穆尔投票算法）int majorityElement(vector&amp; nums) { int len = sizeof(int)*8, size = nums.size(); int count = 0, mask = 1, ret = 0; for(int i = 0; i &lt; len; ++i) { count = 0; for(int j = 0; j &lt; size; ++j) if(mask &amp; nums[j]) count++; if(count &gt; size/2) ret |= mask; mask &lt;&lt;= 1; } return ret;} 3.找数字：给定整数数组，每个元素都出现了三次，除了一个元素，找到这个元素（这种问题通过位运算可以迎刃而解）//inspired by logical circuit design and boolean algebra;//counter - unit of 3;//current incoming next//a b c a b//0 0 0 0 0//0 1 0 0 1//1 0 0 1 0//0 0 1 0 1//0 1 1 1 0//1 0 1 0 0//a = a&amp;~b&amp;~c + ~a&amp;b&c;//b = ~a&amp;b&amp;~c + ~a&amp;~b&c;//return a|b since the single number can appear once or twice;int singleNumber(vector&amp; nums) { int t = 0, a = 0, b = 0; for(int i = 0; i &lt; nums.size(); ++i) { t = (a&amp;~b&amp;~nums[i]) | (~a&amp;b&amp;nums[i]); b = (~a&amp;b&amp;~nums[i]) | (~a&amp;~b&amp;nums[i]); a = t; } return a | b;} 4.字符长度的最大积：给定一个包含几个字符串的数组，找到length(word[i])*length(word[j])的最大值，其中这两个字符串没有共同的字符。假定每个字符串的字符均为小写，如果没有这样的两个字符，返回0实例：Example 1: Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”] Return 16 The two words can be “abcw”, “xtfn”. Example 2: Given [“a”, “ab”, “abc”, “d”, “cd”, “bcd”, “abcd”] Return 4 The two words can be “ab”, “cd”. Example 3: Given [“a”, “aa”, “aaa”, “aaaa”] Return 0 No such pair of words. 解题思路：因为我们要非常频繁的用到字符串的长度，并且我们要比较两个字符串中的字符来检测他们是否有相同的字符，所以： 使用一个int型数组来保存每个字符串的长度 因为int型数字有4比特，可以有32位，而字母只有26中，所以我们仅仅使用一位就可以代表字母在字符串中的存在与否 int maxProduct(vector&amp; words) { vector mask(words.size()); vector lens(words.size()); for(int i = 0; i &lt; words.size(); ++i) lens[i] = words[i].length(); int result = 0; for (int i=0; i&lt;words.size(); ++i) { for (char c : words[i]) mask[i] |= 1 &lt;&lt; (c - ‘a’); for (int j=0; j&lt;i; ++j) if (!(mask[i] &amp; mask[j])) result = max(result, lens[i]*lens[j]); } return result;} 二进制在趣味数学中的应用1.一工人工作7天，老板有一段黄金，每天要给工人1/7的黄金作为工资，老板只能切这段黄金2刀，请问怎样切才能每天都给工人1/7的黄金？因为7 &lt; 2^3 = 8，所以只要使用2^0，2^1，2^2三个数，就可以表示1到7之间的所有数。那么我们只要把金条分成三份，比例为1:2:4，也就是第一刀切下金条的七分之一（设为黄金A），第二刀切下金条的七分之二（设为黄金B），剩下的部分刚好为金条的七分之四（设为黄金C）。我们只要按照如下的方法发放工资，就解决问题了： 第一天：给长工黄金A；（1 = 2^0） 第二天：给长工黄金B，并把黄金A拿回来；（2 = 2^1） 第三天：给长工黄金A；（3 = 2^0 + 2^1） 第四天：给长工黄金C，并把黄金A和黄金B拿回来；（4 = 2^2） 第五天：给长工黄金A；（5 = 2^0 + 2^2） 第六天：给长工黄金B，并把黄金A拿回来；（6 = 2^1 + 2^2） 第七天：给长工黄金A。（5 = 2^0 + 2^1 + 2^2） 2.用天平称1~63克整数克重的物品，至少要配备几只多重的砝码（砝码只能放在天平的一端）？ 没有学过二进制的人是很难想到答案的，可是如果你知道二进制数，那就不难了。我们知道二进制中只有0和1两个数字，它的各位数字的权值从小到大依次为2^0，2^1，2^2，2^3。。。。我们用一个数的每位数字乘以其权值所得到的乘积之和来表示这个数。对于一个具有8位的二进制数来说，它可以表示的数据范围是0~2^8。63 = 2^6 – 1 = 2^0 + 2^1 + 2^2 + 2^3 + 2^4 + 2^5所以，我们只需配备2^0 =1，2^1 = 2，2^2 = 4，2^3 = 8，2^4 = 16，2^5 = 32五种不同克数的砝码各一个。 3.药瓶问题一家药店收到运来的某种药品十瓶。每瓶装药丸1000粒。药剂师怀特先生刚把药瓶送上架子，一封电报接踵而来。怀特先生把电报念给药店经理布莱克小姐听。怀特先生：“特急！所有药瓶须检查后方能出售。由于失误，其中有一瓶药丸每粒超重10毫克。请即退回分量有误的那瓶药。怀特先生很气恼。怀特先生：“倒霉极了，我只好从每瓶中取出一粒来称一下。真是胡闹。怀特先生刚要动手，布莱克小姐拦住了他。布莱克小姐：“等一下，没必要称十次，只需称一次就够了。”这怎么可能呢？ 布莱克小姐的妙主意是从第一瓶中取出1粒，从第二瓶中取出2粒，第三瓶中取出3粒，以此类推，直至从第十瓶中取出10粒。把这55粒药丸放在秤上，记下总重量。如果重5510毫克，也就是超过规格10毫克，她当即明白其中只有一粒是超重的，并且是从第一瓶中取出的。如果总重量超过规格20毫克，则其中有2粒超重，并且是从第二瓶中取出的，以此类推进行判断。所以布莱克小姐只要称一次，不是吗？ 六个月后，药店又收到此种药品十瓶。一封加急电报又接踵而至，指出发生了一个更糟糕的错误。这一次，药丸每粒超重仍然是10毫克，但是对超重药丸的瓶数无可奉告，也就是说可能有好几个药瓶超重。怀特先生气恼极了。怀特先生：“布莱克小姐，怎么办？我们上次的方法不中用了。布莱克小姐没有立即回答，她在思索这个问题。布莱克小姐：“不错。但如果把那个方法改变一下，我们仍然只需称一次就能把分量有误的药品识别出来。这回布莱克小姐又有什么好主意？ 为了解决第二个问题，我们必须用一个数字序列把每瓶药单独标上某个数字，且此序列中的每一个子集必须有一个单独的和。有没有这样的序列？有的，最简单的就是下列二重序列：1，2，4，8，16，。。。这些数字是2的连续次幂，这一序列为二进制记数法奠定了基础。在这个问题中，解法是把药瓶排成一行，从第一瓶中取出1粒，从第二瓶中取出2粒，从第三瓶中取出4粒，以此类推。取出的药丸放在秤上称一下。假设总重量超重270毫克，由于每粒分量有误的药丸超重10毫克，所以我们把270除以10，得到27，即为超重药丸的粒数。把27化成二进制数：11011 。在11011中自右至左，第一，二，四，五位上的“1”表示其权值分别为1，2，8，16。因此分量有误的药瓶是第一，二，四，五瓶。 4.简单的扑克魔术请别人把一副牌洗过，然后放进你的口袋，再请人说出一个1至15以内的数字。然后你把手插进你的口袋里，一伸手就取出一组牌，其数值相加正好等于他所说的数字。 此秘密简单的很。在耍魔术之前，预先取出A，2，4，8各一张放入口袋。这副牌缺少区区四张，不大可能为人察觉。洗过的牌放入口袋后，暗中将其排置于原先已经放在口袋中的四张牌的后面。请别人说出一个数字，你用心算将此数表示成2的幂的和。如果是10，那你就应想到：8+2=10，随即伸手入袋，取出2和8的牌示众。 5.心灵感应游戏心灵感应游戏的依据也是二进制原理，准备五张卡片，分别记为A，B，C，D，E，上面写着1~31之间的一些整数。请一位观众想好此范围内的一个数字（例如某个人的年龄），然后请他把所有上面有此数字的卡片都交给你。你随即说出他心中所想的那个数字。卡片如下： A：1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 B：2 3 6 7 10 11 14 15 18 19 22 23 26 27 30 31 C：4 5 6 7 12 13 14 15 20 21 22 23 28 29 30 31 D：8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 E：16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 秘诀就是把每张卡片上2的幂的第一个数字相加。例如，如果把卡片C和E交给你，你只要将上面第一个数字4和16相加，便知道别人心中所想的数字是20。这是为什么呢？ 我们观察卡片上的数字，可以发现这样一个规律： 第一张卡片(A)上的数字如果用五位二进制表示，则分别为00001，00011，00101，00111，01001，01011，01101，01111，10001，10011，10101，10111，11001，11011，11101，11111。 第二张卡片(B)上的数字如果用五位二进制表示，则分别为00010，00011，00110，00111，01010，01011，01110，01111，10010，10011，10110，10111，11010，11011，11110，11111。 第三张卡片(C)上的数字如果用五位二进制表示，则分别为00100，00101，00110，00111，01100，01101，01110，01111，10100，10101，10110，10111，11100，11101，11110，11111。 请大家注意观察，第一张卡片上每个二进制数的右起第一位都是“1”，第二张卡片上每个二进制数的右起第二位都是“1”，第三张卡片上每个二进制数的右起第三位都是“1”。依此类推，我们可以发现第n张卡片上每个二进制数的右起第n位都是“1”。观众所想的数字和卡片的关系只有“有”和“无”两种状态，正好与二进制数码0与1一一对应。“有”我们就记为“1”，“无”我们就记为“0”，这样观众交给我们的卡片组合，就对应一个二进制数，如把卡片 C和E交给你，那卡片组合就是“有无有无无”，对应二进制数为10100”，即十进制数“20”。又如把卡片A，B和E 交给你，那卡片组合就是“有无无有有”，对应二进制数为“10011”，即十进制数“19”。 二进制数的位数越多，能够表示的数值就越大，如果有6张卡片，则表示的数字范围扩大到1~63，7张卡片则可以表示1~127。 转自：https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently扩展阅读Bit Twiddling Hacks Bitwise gems – fast integer math","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/categories/计算机基础/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://merrier.wang/tags/计算机基础/"},{"name":"位操作","slug":"位操作","permalink":"http://merrier.wang/tags/位操作/"}]},{"title":"前端面试系列（3）——HTTP2新特性","slug":"前端面试系列（3）——HTTP2新特性","date":"2017-03-19T13:18:57.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170319/new-features-of-http2.html","link":"","permalink":"http://merrier.wang/20170319/new-features-of-http2.html","excerpt":"","text":"如果你认为前端不需要了解http的话你就大错特错了，根据师兄师姐们的面试经验反馈，前端面试时关于http的问题提问的几率也很大，而且对于更高一层的tcp/ip协议的认知也是前端开发者需要掌握的，所以我打算把关于http2新特性的文章作为前端面试系列的第三篇文章，如果想对http2协议有更深入的了解，可以点击文末的扩展阅读链接。 HTTP2源自SPDY2SPDY 系列协议由谷歌开发，于 2009 年公开。它的设计目标是降低 50% 的页面加载时间。当下很多著名的互联网公司，例如百度、淘宝、UPYUN 都在自己的网站或 APP 中采用了 SPDY 系列协议（当前最新版本是 SPDY/3.1），因为它对性能的提升是显而易见的。主流的浏览器（谷歌、火狐、Opera）也都早已经支持 SPDY，它已经成为了工业标准，HTTP Working-Group 最终决定以 SPDY/2 为基础，开发 HTTP/2。 但是，HTTP/2 跟 SPDY 仍有不同的地方，主要是以下两点： HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT HTTP2的优势1.http是一个二进制协议基于二进制的http2可以使成帧的使用变得更为便捷。在HTTP1.1和其他基于文本的协议中，对帧的起始和结束识别起来相当复杂。而另一方面，这项决议同样使得我们可以更加便捷的从帧结构中分离出那部分协议本身的内容。而在HTTP1中，各个部分相互交织，犹如一团乱麻。 http2会发送有着不同类型的二进制帧，但他们都有如下的公共字段：Type, Length, Flags, Steam Identifier和frame payload；规范中一共定义了10种不同的帧，其中最基础的两种分别对应于HTTP 1.1的DATA和HEADERS。之后我会更详细的介绍它们其中的一部分。 二进制协议的优势显而易见：解析开销更小，描述协议也更高效。 2.多路复用的流流是一个逻辑上的联合，一个独立的，双向的帧序列可以通过一个http2的连接在服务端与客户端之间不断的交换数据。 每个单独的http2连接都可以包含多个并发的流，这些流中交错的包含着来自两端的帧。流既可以被客户端/服务器端单方面的建立和使用，也可以被双方共享，或者被任意一边关闭。在流里面，每一帧发送的顺序非常关键。接收方会按照收到帧的顺序来进行处理。 流的多路复用意味着在同一连接中来自各个流的数据包会被混合在一起。就好像两个（或者更多）独立的“数据列车”被拼凑到了一辆列车上，但它们最终会在终点站被分开。 3.优先级和依赖性每个流都包含一个优先级（也就是“权重”），它被用来告诉对端哪个流更重要。当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流。 借助于PRIORITY帧（关于http2中帧的介绍可以查看文末扩展阅读），客户端同样可以告知服务器当前的流依赖于其他哪个流。该功能让客户端能建立一个优先级“树”，所有“子流”会依赖于“父流”的传输完成情况。 优先级和依赖关系可以在传输过程中被动态的改变。这样当用户滚动一个全是图片的页面的时候，浏览器就能够指定哪个图片拥有更高的优先级。或者是在你切换标签页的时候，浏览器可以提升新切换到的页面所包含流的优先级。 4.头压缩HTTP是一种无状态的协议。简而言之，这意味着每个请求必须要携带服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。因为http2并没有改变这个范式，所以它也需要这样（携带所有细节）。 这也保证了HTTP可重复性。当一个客户端从同一服务器请求了大量资源（例如页面的图片）的时候，所有这些请求看起来几乎都是一致的，而这些大量一致的东西则正好值得被压缩。 当每个页面资源的个数上升的时候，cookies和请求的大小都会增加，而每个请求都会包含的cookie几乎是一模一样的。 HTTP 1.1请求的大小正变得越来越大，有时甚至会大于TCP窗口的初始大小，这会严重拖累发送请求的速度。因为它们需要等待带着ACK的响应回来以后，才能继续被发送。这也是另一个需要压缩的理由。 HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。如果我们约定将常用的请求头的参数用一些特殊的编号来表示，比如 GET /index.html 用一个 1 来表示，POST /index.html 用 2 来表示。那么是不是可以节省很多字节？ 为 HTTP/2 的专门量身打造的 HPACK 便是类似这样的思路延伸。它使用一份索引表来定义常用的 HTTP Header。把常用的 HTTP Header 存放在表里。请求的时候便只需要发送在表里的索引位置即可。例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示。 5.重置HTTP 1.1的有一个缺点是：当一个含有确切值的Content-Length的HTTP消息被送出之后，你就很难中断它了。当然，通常你可以断开整个TCP链接（但也不总是可以这样），但这样导致的代价就是需要通过三次握手来重新建立一个新的TCP连接。 一个更好的方案是只终止当前传输的消息并重新发送一个新的。在http2里面，我们可以通过发送RST_STREAM帧来实现这种需求，从而避免浪费带宽和中断已有的连接。 6.服务器推送这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。 服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否需要中断该推送的流。如果不需要的话，客户端可以通过发送一个RST_STREAM帧来中止。 7.流量控制http2上面每个流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有更多的空间来接受新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。 而只有数据帧会受到流量控制。 8.HTTP/2的基石-FrameFrame 是 HTTP/2 二进制格式的基础，基本可以把它理解为它 TCP 里面的数据包一样。HTTP/2 之所以能够有如此多的新特性，正是因为底层数据格式的改变。 Frame 的基本格式如下（图中的数字表示所占位数，内容摘自 http2-draft-17）: +———————————————–+| Length (24) |+—————+—————+—————+| Type (8) | Flags (8) |+-+————-+—————+——————-+|R| Stream Identifier (31) |+=+=================================================+| Frame Payload (0…) …+—————————————————+ Length: 表示 Frame Payload 部分的长度，另外 Frame Header 的长度是固定的 9 字节（Length + Type + Flags + R + Stream Identifier = 72 bit）。 Type: 区分这个 Frame Payload 存储的数据是属于 HTTP Header 还是 HTTP Body；另外 HTTP/2 新定义了一些其他的 Frame Type，例如，这个字段为 0 时，表示 DATA 类型（即 HTTP/1.x 里的 Body 部分数据） Flags: 共 8 位， 每位都起标记作用。每种不同的 Frame Type 都有不同的 Frame Flags。例如发送最后一个 DATA 类型的 Frame 时，就会将 Flags 最后一位设置 1（flags &amp;= 0x01），表示 END_STREAM，说明这个 Frame 是流的最后一个数据包。 R: 保留位。 Stream Identifier: 流 ID，当客户端和服务端建立 TCP 链接时，就会先发送一个 Stream ID = 0 的流，用来做些初始化工作。之后客户端和服务端从 1 开始发送请求/响应。 Frame 由 Frame Header 和 Frame Payload 两部分组成。不论是原来的 HTTP Header 还是 HTTP Body，在 HTTP/2 中，都将这些数据存储到 Frame Payload，组成一个个 Frame，再发送响应/请求。通过 Frame Header 中的 Type 区分这个 Frame 的类型。由此可见语义并没有太大变化，而是数据的格式变成二进制的 Frame。二者的转换和关系如下图: 9.HTTP/2对web开发的影响到目前为止，http2还没被大范围部署使用，我们也无法确定到底会发生什么变化。 http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking(线头阻塞)的困扰。它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。 所有这些加起来，页面载入时间和站点的响应速度都会更快。简而言之，它们都代表着更好的web体验。 然而这里的问题在于：对于网站的开发者而言，在短期内开发和部署同一套前端来支持HTTP 1.1和http2的客户端访问并获得最大性能将会是一个挑战。考虑到这些问题，彻底发掘http2的潜力还有很长一段路要走。 扩展阅读http2 explained中文翻译：https://bagder.gitbooks.io/http2-explained/content/zh/ HTTP/2 官网：https://http2.github.io/ 官方给出的关于HTTP/性能的例子：https://http2.akamai.com/demo HTTP/2的各种帧定义：http://blog.csdn.net/jianfyun/article/details/48549939","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/categories/HTTP/"}],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"},{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/tags/HTTP/"},{"name":"面试","slug":"面试","permalink":"http://merrier.wang/tags/面试/"}]},{"title":"十大排序算法的Javascript实现","slug":"十大排序算法的Javascript实现","date":"2017-03-18T15:13:55.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170318/javascript-implementation-of-ten-sorting-algorithms.html","link":"","permalink":"http://merrier.wang/20170318/javascript-implementation-of-ten-sorting-algorithms.html","excerpt":"","text":"我是在微信公众号-前端大全上面看到这篇文章的，大概过去半年时间了，之前看过好多关于排序算法的JS版，但是这篇文章是内容最全的，而且还有动图演示，对于算法“白痴”来说理解起来会更容易，所以强烈推荐这篇文章；前端开发者也可以关注一下这个微信公众号，基本上每天都会更新，而且很多原创的文章，其中不乏面试经验以及关于JS和CSS的技巧规范以及前端未来发展趋势等等，是一个很好的前端学习工具。 原作者是伯乐在线专栏作者，而十大排序算法的JS代码在作者的github上也有一个库，想看源码的可以戳这里，配合文章会加深对这些排序算法的理解 排序算法说明（1）对于评述算法优劣术语的说明稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度: 一个算法执行所耗费的时间。 空间复杂度: 运行完一个程序所需内存的大小。 （2）排序算法图片总结 图片名词解释：n：数据规模 k：“桶”的个数 In-place：占用常熟内存，不占用额外内存 Out-place：占用额外内存 （3）排序分类 1.冒泡排序（bubble Sort）（1）算法简介冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 （2）算法具体描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 （3）动画演示 （4）Javascript源代码/* 方法说明：冒泡排序 参数：arr-排序数组 说明：该方法为原始算法*/function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len; i++) { for (var j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr;}var arr1=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort(arr1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] /* 方法说明：冒泡排序 参数：arr-排序数组 说明：该方法为改进算法（设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。）*/function bubbleSort2(arr) { console.time(‘改进后冒泡排序耗时’); var i = arr.length-1; //初始时,最后位置保持不变 while ( i&gt; 0) { var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++) if (arr[j]&gt; arr[j+1]) { pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; } i= pos; //为下一趟排序作准备 } console.timeEnd(‘改进后冒泡排序耗时’); return arr;}var arr2=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort2(arr2));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] /* 方法说明：冒泡排序 参数：arr-排序数组 说明：该方法为改进算法（传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。）*/function bubbleSort3(arr) { var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time(‘2.改进后冒泡排序耗时’); while (low &lt; high) { for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) { tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; } –high; //修改high值, 前移一位 for (j=high; j&gt;low; –j) //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) { tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; } ++low; //修改low值,后移一位 } console.timeEnd(‘2.改进后冒泡排序耗时’); return arr3;}var arr3=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort3(arr3));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] （5）算法复杂度分析 最佳情况：T(n)=O(n)=&gt;当输入的数据已经是正序时 最差情况：T(n)=O(n2)=&gt;当输入的数据是反序时 平均情况：T(n)=O(n2) 2.选择排序（1）算法简介选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 （2）算法具体描述 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 （3）动画演示 （4）Javascript源代码/* 方法说明：选择排序 参数：arr-排序数组 说明：无*/function selectionSort(arr) { var len = arr.length; var minIndex, temp; console.time(‘选择排序耗时’); for (var i = 0; i &lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { //寻找最小的数 minIndex = j; //将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } console.timeEnd(‘选择排序耗时’); return arr;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] （5）算法复杂度排序 最佳情况：T(n)=O(n2) 最差情况：T(n)=O(n2) 平均情况：T(n)=O(n2) 3.插入排序（1）算法简介插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 （2）算法具体描述 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 （3）动画演示 （4）Javascript源代码/* 方法说明：插入排序 参数：array-排序数组 说明：无*/function insertionSort(array) { if (Object.prototype.toString.call(array).slice(8, -1) === ‘Array’) { console.time(‘插入排序耗时：’); for (var i = 1; i &lt; array.length; i++) { var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) { array[j + 1] = array[j]; j–; } array[j + 1] = key; } console.timeEnd(‘插入排序耗时：’); return array; } else { return ‘array is not an Array!’; }}var arr1=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(insertionSort(arr1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] /* 方法说明：插入排序 参数：array-排序数组 说明：改进后的算法（查找插入位置时使用二分查找的方式）*/function binaryInsertionSort(array) { if (Object.prototype.toString.call(array).slice(8, -1) === ‘Array’) { console.time(‘二分插入排序耗时：’); for (var i = 1; i &lt; array.length; i++) { var key = array[i], left = 0, right = i - 1; while (left &lt;= right) { var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) { right = middle - 1; } else { left = middle + 1; } } for (var j = i - 1; j &gt;= left; j–) { array[j + 1] = array[j]; } array[left] = key; } console.timeEnd(‘二分插入排序耗时：’); return array; } else { return ‘array is not an Array!’; }}var arr2=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(binaryInsertionSort(arr2));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] （5）算法复杂度分析 最佳情况：T(n)=O(n)=&gt;输入数组按升序排列 最差情况：T(n)=O(n2)=&gt;输入数组按降序排列 平均情况：T(n)=O(n2) 4.希尔排序（1）算法简介希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。 （2）算法具体描述 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 （3）图示 （4）Javascript源代码/* 方法说明：希尔排序 参数：arr-排序数组 说明：无/function shellSort(arr) { var len = arr.length, temp, gap = 1; console.time(‘希尔排序耗时:’); while(gap &lt; len/5) { //动态定义间隔序列 gap =gap5+1; } for (gap; gap &gt; 0; gap = Math.floor(gap/5)) { for (var i = gap; i &lt; len; i++) { temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } console.timeEnd(‘希尔排序耗时:’); return arr;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] （5）算法复杂度分析 最佳情况：T(n)=O(nlog2n) 最差情况：T(n)=O(nlog2n) 平均情况：T(n)=O(nlogn) 5.归并排序（1）算法简介归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 （2）算法具体描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 （3）动画演示 （4）Javascript源代码/* 方法说明：归并排序 参数：arr-排序数组 说明：无*/function mergeSort(arr) { //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) { return arr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));}function merge(left, right){ var result = []; console.time(‘归并排序耗时’); while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd(‘归并排序耗时’); return result;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr)); （5）算法复杂度分析 最佳情况：T(n)=O(n) 最差情况：T(n)=O(nlogn) 平均情况：T(n)=O(nlogn) 6.快速排序（1）算法简介快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 （2）算法具体描述 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 （3）动画演示 （4）Javascript源代码/* 方法说明：快速排序 参数：arr-排序数组 说明：方法一*/function quickSort(array, left, right) { console.time(‘1.快速排序耗时’); if (Object.prototype.toString.call(array).slice(8, -1) === ‘Array’ &amp;&amp; typeof left === ‘number’ &amp;&amp; typeof right === ‘number’) { if (left &lt; right) { var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) { if (array[j] &lt;= x) { i++; temp = array[i]; array[i] = array[j]; array[j] = temp; } } quickSort(array, left, i - 1); quickSort(array, i - 1, right); } console.timeEnd(‘1.快速排序耗时’); return array; } else { return ‘array is not an Array or left or right is not a number!’; }} /* 方法说明：快速排序 参数：arr-排序数组 说明：方法二*/function quickSort2(arr) { console.time(‘2.快速排序耗时’); if (arr.length &lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } console.timeEnd(‘2.快速排序耗时’); return quickSort2(left).concat([pivot], quickSort2(right));}var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(quickSort(arr, 0, arr.length - 1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] （5）算法复杂度分析 最佳情况：T(n)=O(nlogn) 最差情况：T(n)=O(n2) 平均情况：T(n)=O(nlogn) 7.堆排序（1）算法简介堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 （2）算法具体描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 （3）动画演示 （4）Javascript源代码/* 方法说明：堆排序 参数：array-排序数组 说明：无*/function heapSort(array) { console.time(‘堆排序耗时’); if (Object.prototype.toString.call(array).slice(8, -1) === ‘Array’) { //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i–) { heaping(array, i, heapSize); } //堆排序 for (var j = heapSize - 1; j &gt;= 1; j–) { temp = array[0]; array[0] = array[j]; array[j] = temp; heaping(array, 0, –heapSize); } console.timeEnd(‘堆排序耗时’); return array; } else { return ‘array is not an Array!’; }} /* 方法说明：维护堆的性质 参数：array-排序数组 x-数组下标 len-堆大小 说明：无/function heaping(arr, x, len) { if (Object.prototype.toString.call(arr).slice(8, -1) === ‘Array’ &amp;&amp; typeof x === ‘number’) { var l = 2 x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) { largest = l; } if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) { largest = r; } if (largest != x) { temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heaping(arr, largest, len); } } else { return ‘arr is not an Array or x is not a number!’; }}var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(heapSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] （5）算法复杂度分析 最佳情况：T(n)=O(nlogn) 最差情况：T(n)=O(nlogn) 平均情况：T(n)=O(nlogn) 8.计数排序（1）算法简介计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 （2）算法具体描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 （3）动画演示 （4）Javascript源代码/* 方法说明：计数排序 参数：array-排序数组 说明：无*/function countingSort(array){ var len = array.length, B = [], C = [], min = array[0], max = array[0]; console.time(‘计数排序耗时’); for(var i =0;i&lt;len;i++){ min= min&lt;=array[i] ? min:array[i]; max = max &gt;=array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] +1:1; } for(var j = min; j&lt; max;j++){ C[j+1] = (C[j+1] || 0) + (C[j] || 0); } for(var k = len -1 ;k &gt;=0; k–){ B[C[array[k]] - 1] = array[k]; C[array[k]] –; } console.timeEnd(‘计数排序耗时’); return B;}var arr=[2,2,3,8,7,1,2,2,2,7,3,9,8,2,1,4,2,4,6,9,2];console.log(countingSort(arr));//[1,1,2,2,2,2,2,2,2,2,3,3,4,4,6,7,7,8,8,9,9] （5）算法复杂度分析当输入的元素是n个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n)=O(n+k) 最差情况：T(n)=O(n+k) 平均情况：T(n)=O(n+k) 9.桶排序（1）算法简介桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序。 （2）算法具体描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 （3）图示 （4）Javascript源代码/* 方法说明：桶排序 参数：arr-排序数组 num-桶的数量 说明：无/function bucketSort(array, num) { if (array.length &lt;= 1) { return array; } var len = array.length, buckets = [], result = [], min = array[0], max = array[0], regex = ‘/^[1-9]+[0-9]$/‘, space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time(‘桶排序耗时’); for (var i = 1; i &lt; len; i++) { min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; } space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) { var index = Math.floor((array[j] - min) / space); if (buckets[index]) { //非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) { buckets[index][k + 1] = buckets[index][k]; k–; } buckets[index][k + 1] = array[j]; } else { //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); } } while (n &lt; num) { result = result.concat(buckets[n]); n++; } console.timeEnd(‘桶排序耗时’); return result;}var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(bucketSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] （5）算法复杂度分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n)=O(n+k) 最差情况：T(n)=O(n+k) 平均情况：T(n)=O(n2) 10.基数排序（1）算法简介基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 （2）算法具体描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； （3）动画演示 （4）Javascript源代码/* 方法说明：基数排序 参数：arr-排序数组 maxDigit-最大位数 说明：基数排序适用于： （1）数据范围较小，建议小于1000 （2）每个数值都要大于等于0/function radixSort(arr, maxDigit) { var mod = 10, dev = 1, counter = []; console.time(‘基数排序耗时’); for (var i = 0; i &lt; maxDigit; i++, dev = 10, mod *= 10) { for (var j = 0; j &lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if (counter[bucket] == null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } } var pos = 0; for (var k = 0; k &lt; counter.length; k++) { var value = null; if (counter[k] != null) { while ((value = counter[k].shift()) != null) { arr[pos++] = value; } } } console.timeEnd(‘基数排序耗时’); return arr;}var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] （5）算法复杂度分析 最佳情况：T(n)=O(n*k) 最差情况：T(n)=O(n*k) 平均情况：T(n)=O(n*k)","categories":[{"name":"算法","slug":"algorithm","permalink":"http://merrier.wang/categories/algorithm/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"排序","slug":"排序","permalink":"http://merrier.wang/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://merrier.wang/tags/算法/"}]},{"title":"八大排序算法的python实现","slug":"八大排序算法的python实现","date":"2017-03-18T14:17:57.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170318/python-implementation-of-eight-sorting-algorithms.html","link":"","permalink":"http://merrier.wang/20170318/python-implementation-of-eight-sorting-algorithms.html","excerpt":"","text":"其实我的python的水平相当于初学者，但是由于要找实习，所以刷算法是必然的，而经常刷leetcode的小伙伴应该知道，用javascript实现各种复杂算法的人比较少（排序算法还好，尤其是那些比较知名的排序算法，想看Javascript代码实现排序算法的可以点下面那个链接），所以就导致没有思路的时候也看不到别人是如何用js代码实现的，所以必须要懂其他一种语言才能行，而python同样作为一种脚本语言，其语法简单到丧尽天良，而代码库却很庞大，同时也很适合算法的实现，所以就决定在学习js的同时兼顾python的学习。 这篇文章当然不是我的原创，而是在逛伯乐在线的时候看到的，感觉总结的很好，代码也很规范，故抄至此处，如果作者不允许转载，将及时处理（可以点击来源链接查看原文）；如果没弄明白排序算法的步骤，想理解的更生动的话，可以查看我的另外一篇文章：十大排序算法的Javascript实现。 1.插入排序插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 def insert_sort(lists): # 插入排序 count = len(lists) for i in range(1, count): key = lists\\[i\\] j = i - 1 while j &gt;= 0: if lists\\[j\\] &gt; key: lists\\[j + 1\\] = lists\\[j\\] lists\\[j\\] = key j -= 1 return lists 2.希尔排序希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 def shell_sort(lists): # 希尔排序 count = len(lists) step = 2 group = count / step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lists\\[j\\] while k &gt;= 0: if lists\\[k\\] &gt; key: lists\\[k + group\\] = lists\\[k\\] lists\\[k\\] = key k -= group j += group group /= step return lists 3.冒泡排序它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 def bubble_sort(lists): # 冒泡排序 count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists\\[i\\] &gt; lists\\[j\\]: lists\\[i\\], lists\\[j\\] = lists\\[j\\], lists\\[i\\] return lists 4.快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 def quick_sort(lists, left, right): # 快速排序 if left &gt;= right: return lists key = lists\\[left\\] low = left high = right while left &lt; right: while left &lt; right and lists\\[right\\] &gt;= key: right -= 1 lists\\[left\\] = lists\\[right\\] while left &lt; right and lists\\[left\\] &lt;= key: left += 1 lists\\[right\\] = lists\\[left\\] lists\\[right\\] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return lists 5.直接选择排序基本思想：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。 def select_sort(lists): # 选择排序 count = len(lists) for i in range(0, count): min = i for j in range(i + 1, count): if lists\\[min\\] &gt; lists\\[j\\]: min = j lists\\[min\\], lists\\[i\\] = lists\\[i\\], lists\\[min\\] return lists 6.堆排序堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 def adjust_heap(lists, i, size): lchild = 2 i + 1 rchild = 2 i + 2 max = i if i &lt; size / 2: if lchild &lt; size and lists[lchild] &gt; lists[max]: max = lchild if rchild &lt; size and lists[rchild] &gt; lists[max]: max = rchild if max != i: lists[max], lists[i] = lists[i], lists[max] adjust_heap(lists, max, size) def build_heap(lists, size): for i in range(0, (size/2))[::-1]: adjust_heap(lists, i, size) def heap_sort(lists): size = len(lists) build_heap(lists, size) for i in range(0, size)[::-1]: lists[0], lists[i] = lists[i], lists[0] adjust_heap(lists, 0, i) 7.归并排序归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 def merge(left, right): i, j = 0, 0 result = [] while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return result def merge_sort(lists): # 归并排序 if len(lists) &lt;= 1: return lists num = len(lists) / 2 left = merge_sort(lists\\[:num\\]) right = merge_sort(lists\\[num:\\]) return merge(left, right) 8.基数排序基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。 import mathdef radix_sort(lists, radix=10): k = int(math.ceil(math.log(max(lists), radix))) bucket = [[] for i in range(radix)] for i in range(1, k+1): for j in lists: bucket[j/(radix(i-1)) % (radixi)].append(j) del lists[:] for z in bucket: lists += z del z[:] return lists","categories":[{"name":"算法","slug":"algorithm","permalink":"http://merrier.wang/categories/algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://merrier.wang/tags/python/"},{"name":"排序","slug":"排序","permalink":"http://merrier.wang/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://merrier.wang/tags/算法/"}]},{"title":"前端面试系列（2）——CSS3新特性","slug":"前端面试系列（2）——CSS3新特性","date":"2017-03-18T10:37:57.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170318/new-features-of-css3.html","link":"","permalink":"http://merrier.wang/20170318/new-features-of-css3.html","excerpt":"","text":"CSS3 是 CSS 的升级版本，这套新标准提供了更加丰富且实用的规范，如：盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等等；和HTML5不同，CSS3的新特性基本上得到了广泛应用，而知道并熟练运用这些新特性已经成为前端人员的必修课： 更方便快捷的选择器:nth-child、:nth-last-child、:nth-of-type、:last-child、:only-child、:empty css3新增的选择器有很多，就不一一介绍了，这里有一篇关于css3新增选择器的文章总结的很好：http://www.cnblogs.com/libingql/p/4375354.html 框模型border-radius（圆角）、box-shadow（盒子阴影）、border-image（边框图片） 背景background-size（背景大小）、background-origin（背景的定位）、background-clip（背景的绘制区域）、支持多重背景图片（background-image:url(bg_flower.gif),url(bg_flower_2.gif);） 渐变效果gradient属性可以非常方便的实现渐变色，同时可以设置渐变的方向和渐变方式等，实现各种复杂的效果。文末有一篇讲解gradient的文章我觉得讲的不错，感兴趣的可以去瞅瞅。 文本效果text-shadow（文本阴影）、word-break（规定非中日韩文本的换行规则）、word-wrap（允许对长的不可分割的单词进行分割并换行到下一行）,CSS3的文本属性比较多，还是用一张图片代替吧（来自w3c）： @font-face可以在网页中使用除默认字体之外的其他字体，先定义字体的名称，然后引入字体文件，在需要使用该字体的时候就通过font-family属性引用字体的名称 @font-face { font-family: myFirstFont; src: url('Sansation_Light.ttf'), url('Sansation_Light.eot'); /* IE9+ */ } div { font-family:myFirstFont; } transform我认为这是CSS3最“好用”的特性，也正是因为这个属性（当然，下面那个属性也功不可没），通过CSS3转换就可以能够堆元素进行移动、缩放、转动、拉长或拉伸；同时结合对持续时间和延迟时间的控制，可以“创造”出非常炫的动画效果，大大提升了网页的展示效果。同时分为2D和3D转换，由于内容繁多，就不一一介绍了，感兴趣的小伙伴可以点击文末的链接进行进一步的学习。 transtion当元素从一种样式变换为另一种样式时为元素添加效果，使动画更加“圆润”流畅 @keyframes这是个面试中会经常问到的属性，原因是其应用领域非常广泛，因为如今用户的时间非常宝贵，同时网络上的信息又是鱼龙混杂，如何在有限的时间内抓住用户眼球是一个重要的课题，而@keyframes就可以让自己的网页焕然一新并且与众不同，通过@keyframes规则可以创建动画，再结合animation就可以使元素“动”起来。 多列布局通过column-count（列数）、column-fill（如何填充列）、column-gap（列之间的间隔）、column-width（列的宽度）可以创建多个列来对文本进行布局，就像报纸那样。 用户界面 resize：是否可由用户调整元素尺寸 box-sizing：border-box/content-box，这个属性我也很喜欢，可以改变传统的“盒子模型”，方便进行布局 outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓（轮廓不占用空间并且可能是非矩形，这两点和边框不同） flex弹性布局这个属性让开发者非常头疼的“居中”问题找到了一种十分简便的答案，可以非常方便地实现让一个或多个元素在其父元素中垂直居中，建议大家去看阮一峰对其的讲解，很全面并且简单易懂（链接在文末）。 w3c关于CSS3的讲解：http://www.w3school.com.cn/css3/index.asp 阮一峰对于flex的讲解：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool w3cplus对于gradient的讲解：http://www.w3cplus.com/css3/new-css3-radial-gradient.html","categories":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"}]},{"title":"前端面试系列（1）——HTML5新特性","slug":"前端面试系列（1）——HTML5新特性","date":"2017-03-18T10:32:25.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170318/new-features-of-html5.html","link":"","permalink":"http://merrier.wang/20170318/new-features-of-html5.html","excerpt":"","text":"这道问题被问的比较少，因为在如今前端框架大行其道的趋势下，对于HTML的理解似乎已经变得不那么重要了，况且浏览器对h5（是的，我们通常说的h5其实就是HTML5，5指版本）的支持还不那么完美，但是了解一下还是有助于自己前端水平的提升的，在查阅资料的过程中我发现有些特性我也是第一次知道，不过有些特性已经显示了其强大之处，比如：canvas，高能预警，大量干货： 摒弃了旧特性1.原HTML声明方式将失效，将采用简单的声明方式&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”“http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;!DOCTYPE html&gt; 2.脚本和链接无需type，在HTML5中，你只需要用简化的代码来给你的网页添加CSS和JavaScript文件，而不再需要指定类型属性 新的内容元素1.figure元素：和来语义化地表示带标题的图片” &gt;&lt;img src=”path/to/image” alt=”About image” /&gt; This is an image of something interesting. 2.hgroup：一般在header里面用来将一组标题组合在一起——————————– Recall Fan Page Only for people who want the memory of a lifetime. 3.mark：高亮的作用，比如用户的搜索内容可以在文章中用进行修饰————————————— Search Results They were interrupted, just after Quato said, ”Open your Mind”. 4.output：用来显示计算结果，也有一个和lable一样的for属性5.small：重新定义了，现在被用来表示小的排版，如网站底部的版权声明6.article：定义文章7.footer：定义尾部8.header：定义头部9.nav：定义导航栏10.section：定义section新的属性：1.contenteditable属性：让你的内容可编辑2.placeholder：不必通过javascript就可以显示提示内容了3.input的新type，包括email（如果给input的type设置为email，浏览器就会验证这个输入是否是email类型）、range（可以创建滑块，它接受min，max，step和value属性）、color（颜色选择器）等等4.input的新属性，包括autocomplete（on/off，是否使用输入字段的自动完成功能）、autofocus（规定输入字段在页面加载时是否获得焦点，但不试用于type=”hidden”）、required（指示输入字段的值是必须的）、form（规定输入字段所属的一个或多个表单）-&gt;其实新属性还有很多，可以点击文末w3c官网链接进行查看5.pattern属性：可以在input里直接使用正则表达式验证了&lt;form action=”” method=”post”&gt;Create a Username: &lt;input type=”text” name=”username” id=”username” placeholder=”4 &lt;&gt; 10″ pattern=”[A-Za-z]{4,10}” autofocus required&gt;Go 新的重要的元素1.canvas：使用Javascript在网页上绘制图像，canvas拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法；将在游戏、图表制作、banner广告、模拟器、远程计算机控制、字体设计、图形编辑器、其他可嵌入网站的内容等方面大有可为；SVG 与 Canvas两者间的区别： SVG 是一种使用 XML 描述 2D 图形的语言。Canvas 通过 JavaScript 来绘制 2D 图形。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 下表列出了 canvas 与 SVG 之间的一些不同之处。 2.视频video元素今天，大多数视频是通过插件（比如 Flash）来显示的。然而，并非所有浏览器都拥有同样的插件。通用的视频播放解决方案是flash和flv（flash从9开始支持h.264的mp4）。但是随着iOS设备的流行，flash已经不是万能药了，越来越多的视频网站提供多元的解决方案，而且偏向于html5：也就是说，通过检测agent是否支持html5来决定使用video还是flash。在面对IE8以下的浏览器时，flash几乎是唯一的选择(silverlight的接受度普遍不高)。 3.音频audio元素同理可见video元素 对本地离线存储的更好的支持1.Web worker：是运行在后台的JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。2.Web Storage：将数据存储在本地，而不会和服务器发生任何交互，使得数据操作更加简便 Web Storage与Cookie相比存在不少的优势，概括为以下几点：存储空间更大，能提供5MB的存储空间（不同浏览器的提供的空间不同），Cookie仅4KB 存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送的服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本地，不会与服务器发生任何交互。 更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，使得数据操作更为简便。(开发者的福利) 独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。 3.Application Cache：使用HTML5，通过创建cache manifest文件，可以轻松地创建web应用的离线版本，HTML5引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 地理位置API1.Geolacation API用于获得用户的地理位置，实例： 更新本地信息 显示用户周围的兴趣点 交互式车载导航系统（GPS） 网易用户体验中心对HTML5的动画演示：http://uedc.163.com/wp-content/uploads/2011/07/flash.html w3c对HTML5的讲解：http://www.w3school.com.cn/html5/html_5_intro.asp","categories":[{"name":"HTML","slug":"HTML","permalink":"http://merrier.wang/categories/HTML/"}],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"},{"name":"HTML","slug":"HTML","permalink":"http://merrier.wang/tags/HTML/"},{"name":"面试","slug":"面试","permalink":"http://merrier.wang/tags/面试/"}]},{"title":"JS几种数组遍历方式","slug":"JS几种数组遍历方式","date":"2017-03-18T08:50:29.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170318/several-array-traversal-modes-of-js.html","link":"","permalink":"http://merrier.wang/20170318/several-array-traversal-modes-of-js.html","excerpt":"","text":"这是从Lichun Dai博客中看到的一篇文章，作者对JS中的数组遍历方式进行了总结，同时进行了性能对比。但根据评论者的回答，性能分析需要结合具体环境，单纯在浏览器中进行测试是难下结论的，所以我只会展示实现的方式，至于在浏览器中的性能可以点击文末的链接跳转至原作者的分析工具demo。 第一种：普通for循环for(j = 0; j &lt; arr.length; j++) { } 简要说明：最简单的一种，也是使用频率最高的一种，虽然性能不弱，但仍有优化空间 第二种：优化版for循环for(j = 0,len=arr.length; j &lt; len; j++) { } 简要说明: 使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。 这种方法基本上是所有循环遍历方法中性能最高的一种 第三种：弱化版for循环for(j = 0; arr[j]!=null; j++) { } 简要说明: 这种方法其实严格上也属于for循环，只不过是没有使用length判断，而使用变量本身判断 实际上，这种方法的性能要远远小于普通for循环 第四种：foreach循环arr.forEach(function(e){ }); 简要说明: 数组自带的foreach循环，使用频率较高，实际上性能比普通for循环弱 第五种：foreach变种Array.prototype.forEach.call(arr,function(el){ }); 简要说明: 由于foreach是Array型自带的，对于一些非这种类型的，无法直接使用(如NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有foreach功能。 实际性能要比普通foreach弱 第六种：forin循环for(j in arr) { } 简要说明: 这个循环很多人爱用，但实际上，经分析测试，在众多的循环遍历方式中 它的效率是最低的 第七种：map遍历arr.map(function(n){ }); 简要说明: 这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上foreach 第八种：forof遍历（需要ES6支持）for(let value of arr) { }); 简要说明: 这种方式是es6里面用到的，性能要好于forin，但仍然比不上普通for循环 结论：普通for循环才是最优雅的原文链接：https://dailc.github.io/2016/11/25/baseKnowlenge_javascript_jsarrayGoThrough.html 原作者的分析比较工具：https://dailc.github.io/jsPerformanceAnalysis/html/performanceAnalysis/demo_performanceAnalysis_jsarrayGoThrough.html","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"数组","slug":"数组","permalink":"http://merrier.wang/tags/数组/"},{"name":"数组遍历","slug":"数组遍历","permalink":"http://merrier.wang/tags/数组遍历/"}]},{"title":"前端面试系列","slug":"前端面试系列","date":"2017-03-17T09:19:17.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170317/front-end-interview-series.html","link":"","permalink":"http://merrier.wang/20170317/front-end-interview-series.html","excerpt":"","text":"首先声明一下，这个系列的文章基本上都是摘抄自其他途径的，包括一些大牛小牛的博客、微信公众号或其他人的文章里，而且我会争取持续更新，最后形成一篇对前端基础薄弱的同学也友好的讲解文章，如果该系列中的任何一个知识点能够帮到你（我相信肯定会帮到我的，因为我也要开始找实习了。。），就达到我的目的了；而且该系列文章只会涉及到前端的技术点，像算法和智力题那种是不会涉及的，关于算法的话可以看我的其他文章：算法一点也不难，至于智力题的话，根据我的经验，只能practice makes perfect（如果天生神力或者天生智障就当我没说好了） HTML5新特性 CSS3新特性 HTTP2新特性 CSS选择器 CSS盒子模型 HTTP请求的状态码 session&amp;cookie TCP的三次握手与四次分手 JS实现继承 JS中的闭包 window.onload和document.ready的区别 前端性能优化 其他面试题整理：InterviewMap 前端工程师面试题汇总 前端面试题整理 20个必会的JavaScript面试题 Front End Developer Questions 魔法哥 2013 前端笔试题曝光（附完整解答） 关于4种数据结构的算法面试问题列表 阿里巴巴2018秋招面经之前端岗(1~5面) 阿里-蚂蚁金服三轮面试总结&amp;version=12020710&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=uiS9b%2BZq6IXZNKPVYaiPeJ8Epfijn4%2BTUY8Cx0f3sWQ1IhvOT3k5vYYKk7UtPoeZ) 技术面试宝典：很全面的算法和数据结构知识（含代码实现）&amp;version=12020710&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=uiS9b%2BZq6IXZNKPVYaiPeJ8Epfijn4%2BTUY8Cx0f3sWQ1IhvOT3k5vYYKk7UtPoeZ) 18届校招求职面经及总结","categories":[{"name":"系列专栏","slug":"series","permalink":"http://merrier.wang/categories/series/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://merrier.wang/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"前端面试","slug":"前端面试","permalink":"http://merrier.wang/tags/前端面试/"},{"name":"HTML","slug":"HTML","permalink":"http://merrier.wang/tags/HTML/"},{"name":"面试","slug":"面试","permalink":"http://merrier.wang/tags/面试/"},{"name":"jQuery","slug":"jQuery","permalink":"http://merrier.wang/tags/jQuery/"}]},{"title":"游戏心得&伪攻略","slug":"游戏心得&伪攻略","date":"2017-03-17T08:20:58.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170317/game-experience-and-pseudo-strategy.html","link":"","permalink":"http://merrier.wang/20170317/game-experience-and-pseudo-strategy.html","excerpt":"","text":"自认为玩过了好多游戏，从最开始的英雄联盟、天下3到后来的全民超神、王者荣耀以及各种大型小型RPG、MOBA、CAG、SIM类游戏，当然有时候也会查查攻略看看平民适合什么职业，或者玩过一阵子之后会等新区冲个排名，也会因为队友的菜b操作而心生愤懑。细细算来，自己的游戏生涯也有15年左右了吧，从小学时候的抢滩登陆、美丽的伊苏？（具体名字我忘了，不过记得是一个角色冒险类游戏，还是蛮经典的），到中学时候的DNF（现在有时候还会登一下，都开到90级了啊）、跑跑卡丁车，后来高中流行的穿越火线、QQ炫舞、QQ音乐，再后来大学和舍友们一起玩过的天下3、英雄联盟，到如今的守望先锋、风暴英雄（现在也还是没火起来啊），这些游戏陪伴了我们十几年，基本上见证了我们的青春和成长。淡已经扯够了，进入正题吧： 更新自2017-10-10：我发现竟然有很多人会选择看我的这篇文章，要知道我的个人博客可是技术型的啊~！所以这让我坚定了一个信念，就是——好好打游戏，好好写攻略。 手游：通用套路： 周卡（6元），月卡（30元）-&gt;基本上是目前为止所有手游都会有的吧，不管是什么类型的游戏，但是究竟是从哪个手游开始的呢？ 首冲送好礼-&gt;这个和周卡月卡类似，但是首冲的钱不定 装备升级、升阶、升星-&gt;这个在RPG游戏里会比较常见，当然有些MOBA类游戏也会有（比如说全民超神） 十连抽必中好东西-&gt;这个玩卡牌游戏的人肯定不陌生吧，当然有的游戏十连比较简单，有的游戏十连可就得攒个十天半月了 一丶狂暴之翼（ios） 主线任务会提示百分比，譬如任务：寻找小仙女（90%），这样可以对玩家起到一定的心理暗示 攻略：前言：狂暴之翼就是一款数值游戏,前期数值基本上都比较固定 首先:主线先到17级然后扫荡地图，全身装备精炼到全身到5，再打第三章，第三章通关后扫荡全身精炼到全身到10，以此类推；装备图纸和石头不够的魔晶商店可以购买，只买自己需要的，扫荡卷不够的黑钻买。(注意!有强迫症的孩子就打慢一点,把装备做完在推图,第二章的13节请手动,自动是过不去的) 22级进公会拿升星石公会钻石膜拜每次6个，转4-5只神兽每次10个(注意!打底转4个龙)，全身装备都升1星后，做戒指和项链先到5星，然后在平均精炼升星上去。(注意!一定要戒指和项链升星先到5星) 关于钻石前期幸运转盘是最超值的来源，建议在把装盘的次数耗尽后再开始使用钻石，平民玩家建议在转三次转盘之前都不要花钻石，然后商店和7日目标买体力和升星石头，然后在丹抽一次288钻石的宝藏得4阶装备 二、王者荣耀（ios） 画面比类似游戏要精致，阴影和怪物做的细节都很到位，同时英雄的打击动作也比较真实有料 社交系统蛮不错的，仅仅通过一起打几局游戏就可以结为恋人，相比其他游戏而言真的良心 吐槽一下装备系统，魔抗装备实在太少，这使得大家都比较喜欢玩法师，同时在ban pick中也是绝大部分都是法师，不知道为什么这样设计（更新自2017-9-23：开发者们似乎听到了我内心的呐喊，现在魔抗装备稍微多了点。。） 攻略以下介绍的攻略仅仅限于平民或小资玩家，目的是让你通过这篇攻略可以更快的获取金币、钻石、铭文碎片，从而可以购买更多的英雄，而不是教你怎么快速升王者，因为对于MOBA类游戏来说，“熟能生巧”是唯一真理。 前期首先，王者荣耀的新手任务很简单，可以很快速的获取一定量的金币，所以一定要完成；同时，师徒任务给的奖励很丰厚，最好在开始的时候找个师傅，然后按照师徒任务每天打几局，这样基本上一周之内就完成13个师徒任务了，可以获取大量金币和大量钻石 至于钻石夺宝，我的建议是每周就来个五连抽就行，因为可以领取88钻石的奖励，同时还可以涨幸运度，抽再多次的话就不划算了 活动最好抽时间完成，王者荣耀的活动很频繁，基本上每周都有，而且有时候会有免费英雄兑换活动，这种机会千万不要错过，你要知道这可是钱啊~！ 中期王者荣耀每周通过对战获取金币数是有限制的（如果没有挂机等违规记录的话，每周上限4200），所以最好保证每周把这4200都拿到，如果没有时间对战的话，可以尝试刷冒险（我一般刷精英难度的“稷下战场”，如果铭文比较好的话，可以尝试大师难度的“稷下战场”，具体如何刷可以自行搜索）； 而除了对战获取金币，每天的活跃度奖励也有很多金币、钻石、铭文碎片可以拿到，所以最好保证每天满活跃度以及一周满1000活跃度，其实王者荣耀的活跃度很容易打满，没时间的话可以找个战队的人组队打3局人机，然后把黄色任务完成（黄色任务加30活跃度，击杀10英雄、20助攻、塔伤10000是可以人机完成的，其他类型的任务需要打对战，所以从概率学上讲还是很好完成的） 另外最好和认识的同学或同事一个战队，这样的话活跃度会完成的比较简单。同时别忘了战队商店可以拿活跃度换东西的，我是先换了高渐离，后面一直换铭文碎片大宝箱，一般2-3周就可以换一个宝箱了（500铭文碎片）。每周的战队赛参加4次和获胜1次也有铭文碎片奖励，有时间的话可以参加一下。 后期我是不建议钻石抽铭文碎片的，因为抽到5级铭文的几率太小了，而且王者荣耀有时候会办那种消耗钻石兑换奖励的活动，这时候再消耗钻石的话不仅可以抽东西，还可以间接地参加活动获取奖励（我记得9月份的时候王者荣耀就出了类似的活动，我直接把攒的12000多钻石全抽铭文了） 相信几个月下来，你一定积攒了很多铭文碎片了，这时候可以根据自己的实际情况合成5级铭文了，如果你比较喜欢玩物理系的英雄，可以尝试合成“百穿”，如果你喜欢法师系的英雄，就合成一套法师通用铭文就可以了；当然，我建议不要合成一整套，最好每种颜色的合成5-6个，这样的话万一后面再开出来想要的可以直接换上，不会造成浪费 如果你的排位等级比较靠前同时在线时间比较长，可以加一个排名比较靠前的战队，这样每周、每赛季获取的奖励都会有很多，同时战队赛也更容易组到人。 最后王者荣耀不是一个烧钱的游戏（这条广告没有钱），但是没有铭文和有铭文是两个游戏，所以如果没有钱就花时间吧。。 三、阴阳师（ios） 新服预约活动，这个不算是亮点，但是经常玩手游的人一般是喜欢去新区玩的，这样可以冲一下排名，而在官网有着很明显的新服预约页面可以让玩家省去找新区开服时间的麻烦 一些副本的动画可以快进也可以暂停，这样可以让玩家暂停截图留念，同样对于那些老玩家来说，也可以快进节省时间。 战斗的时间有点太长，如果可以跳过动画或者直接出一个扫荡的选项会节省玩家很多时间 四、全民超神（ios） 活动很良心，会各种送皮肤，玩家只需要在一段时间打一阵子游戏就可以获得，同时钻石获得也很容易，只要花一些时间，就可以购买很多喜欢的英雄 可以向其他游戏学习，当击杀数或助攻数到达一定数量，比如8888，6666，10000的时候进行提示（在游戏中就算了，如果打完游戏正好达到就可以），并生成一张比较有纪念意义的图片，可以提升用户粘性 为什么镜头不能拖拽呢，只能看到自己周围而无法看到其他地方的话会很影响用户体验，可以向王者荣耀学习一下。 希望可以交换英雄，这样可以使玩家更大几率玩到自己喜欢玩的英雄，同时也有助于排位赛的发展 目前对于挂机掉线的惩罚太轻，而且举报之后没有反馈，这一点根本比不上王者荣耀 游戏内聊天系统有问题，连续输入4个汉字时会直接变成英文 五、soul knight（ios、单机） 作为一个单机游戏，却内容很庞大，不仅有成就系统，还有多种多样的武器 摒弃了之前职业差距很大的惯例，多种职业之间的差距仅仅在于大招不同，而每种职业也只有一个技能，但是鉴于此款游戏考验的是玩家的走位，所以技能只有一个也就无伤大雅了 武器之间的差距并不在于颜色，需要玩家在实战中进行实验而且可以考验玩家对武器的理解，因为打小怪和打boss不同类型的武器会有不同的表现 六、龙之谷（ios、腾讯） 在rpg游戏中加入观战系统是个很不错的idea，可以看其他玩家的pvp或者副本攻打策略 七、卧虎藏龙 是我所见过玩过的游戏中3D场景做的最好的 八、英雄战歌（腾讯） 不敢说抄袭，但是玩过炉石传说的人就都知道这游戏该怎么玩了 将卡牌收藏和3D攻击动画特效结合到一起，虽然特效差强人意，但有此心实属不易 惯用的首冲月卡，但是月卡并没有让我有买的冲动，因为月卡带来的福利并不是玩家能够迅速并且明显看到价值的 玩家可以通过每天的对战或者“星星”，然后5个星星就可以获得一个宝箱，宝箱需要时间来解锁，从而获得卡牌，同时每一个宝箱都有相应的积分获得，当积分满足一定条件时就可以或者比较丰厚的奖励，为期一个月，不得不说，我被这个活动吸引了，因为作为一个卡牌收藏游戏，玩家还是希望自己能够有更多“稀有”的卡，这也是卡牌收藏游戏的成就感来源，所以腾讯的这个idea让我有了很多新的思路，就是结合游戏的成就感来源去吸引用户、“黏住”用户，那样才能先保证不亏钱的情况下再赚钱 和炉石不同的是，卡包真的好贵，而且目前来看好的卡牌包只能用点券购买（简直就是个土豪才玩得起的游戏嘛），不知道后面会不会有活动赠送点券，先玩一个月再看","categories":[{"name":"游戏","slug":"游戏","permalink":"http://merrier.wang/categories/游戏/"}],"tags":[{"name":"心得","slug":"心得","permalink":"http://merrier.wang/tags/心得/"},{"name":"游戏","slug":"游戏","permalink":"http://merrier.wang/tags/游戏/"}]},{"title":"记录下我的Leetcode坑爹之路——Easy篇","slug":"记录下我的Leetcode坑爹之路——Easy篇","date":"2017-03-17T07:33:45.000Z","updated":"2019-01-17T13:21:55.958Z","comments":true,"path":"20170317/my-leetcode-easy.html","link":"","permalink":"http://merrier.wang/20170317/my-leetcode-easy.html","excerpt":"","text":"写在前面这篇文章主要记录了我在刷Leetcode的过程中的思路以及对答案的理解；但由于我是拿JS刷的，所以绝大部分题目的答案对于我来说都会理解起来有困难，所以对答案的理解可能会有一些偏差，请谅解；本文并不会列出题目的JS答案，JS实现在我的另一篇文章：Leetcode的JS实现——Easy篇中；截止到2017年3月31日，我基本上刷完了Leetcode的Easy部分，如果有可能的话，我会继续将Leetcode上的剩余题目刷完，所以可能又会有Medium篇、Hard篇…… 2017-3-16461-Hamming distance我的想法：一开始还想怎么取余，后来才发现js里也有取余运算符，就是”^”，然后我就想是不是可以将取余之后的数遍历相加，其实结果是正确的，但是有点太死板了 理想答案：将0用””replace，然后取新字符串的长度；同时学到的是，原来js的toString()方法中的参数是进制，之前一直都不知道我擦。。java解法：戳我一下 2017-3-17476-Number Complement我的想法：这道题看上去很简单，主要思路依然是取余操作，以数字5为例，二进制表示为“101”，其结果应该为“101”^“111”，也就是数字和相同位数的“全1”二进制数的取余，然后问题就是如何确定这个位数，我的想法是用Math.ceil(Math.log(num)/Math.log(2))，这样就可以取到位数了，但是取到位数之后还要取2得对数，这怎么求？ 理想答案：其实取位数不需要那么复杂，直接num.toString(2).length就可以了，然后查了一下，js中Math有pow(x,y)方法，可以计算x为底，y为幂的指数，这样就可以了。 339-Nested List Weight Sum加锁了，没钱 500-Keyboard Row我的想法：一开始打算设置三个数组，然后再写个方法，对数组中的每个元素遍历执行该方法，但是想想都麻烦啊靠 理想答案：果不其然，正则表达式万能无敌出人意料和意料之中 2017-3-21359-Logger Rate Limiter加锁了 412-Fizz Buzz其实这道题在日常写代码中经常碰到，就是整除的问题，然而如何更快更简单的得出答案却很难，如果用js的话，我确实没想到什么好的办法 我的想法：先声明一个空数组，然后对空数组进行循环赋值，对i的值进行判断，当能整除15时就是”FizzBuzz”，以此类推，但是需要注意的是数组下标从零开始，某些值可能会需要-1或者+1 理想答案：没有找到关于js的理想答案，但是看排名第一的java答案，发现其实可以不用”%”也可以 关于这一经典问题，还有一些扩展问题，可以点击这里查看） 344-Reverse String字符串翻转问题 我的想法：因为字符串在js中也有一些数组的属性，所以很容易进行遍历赋值 理想答案：没找到关于js的 346-Moving Average from Data Stream加锁了 496-Next Greater Element I我的想法：就是按照题目所说的进行遍历判断，然而我看提示是stack，但是我仍然没有想到更好的用stack实现的方案，而看过网上的解法之后感觉js好像没有办法实现线性复杂度的解法 理想答案：使用栈，从后往前遍历nums[i]，每当栈不为空的时候，一直出栈直到遇到比nums[i]大的数字停止。设立一个map&lt;int, int&gt; m，存储nums中每一个元素以及它对应的下一个最大元素构成的映射。如果停止后栈为空就将m[nums[i]]标记为-1，否则就写栈的栈顶元素；最后将findNums中出现的每一个元素对应的map的值放入result数组中返回 463-Island Perimeter我的想法：直接遍历，然后考虑所有情况进行判断加几，应该可以求出来，只不过并没有发现其中的规律 理想答案：其实规律很好发现，可以将“陆地”加入的过程分解开一步一步看，就会发现其中的规律，可以根据陆地的上面一格和左边一格有没有陆地来进行区分，如果有，就是在加了4条边的基础上再减去两条边，因为有两条边重合了，导致减少了两条边 266-Palindrome Permutation为什么加锁的题这么多 292-Nim Game我承认这是我第一次和理想答案一样，所以就不分开描述了，其实举几个例子就能发现其中的规律了，因为这道题的前提是你先走，而且你和对方都可以走1到3步，所以加入像他说的那样，最后剩4个了然后你先走的话，你肯定不会赢；而迭代之后就是，只要n不是4的倍数，你就可以在行动完之后让剩下的棋子是4的倍数然后让对方先走，这样你就可以保证最后剩下4个棋子的时候让对方先走。所以，只要一开始棋子的个数就是4的倍数的话，你就没有办法赢，因为对方也会采取最优策略。 485-Max Consecutive Ones这个应该是简化版的最长子序列问题吧 我的想法：有一个存储结果值的变量result（初始值为0），还有一个变量相当于计数器num（初始值为0），对数组进行遍历，遇到1就将计数器加1，遇到0的话先将结果值赋值为Math.max(result,num)；最后需要注意的是返回的仍然是Math.max(result,num)，因为需要考虑输入为单纯的1或0时； 理想答案：果然java大神多啊，其实思路差不多，只不过可以将其简化一下而已 293-Flip Game锁 136-Single Number重点是线性复杂度，不能有额外内存占用 我的想法：我的想法过于复杂（复杂度应该是指数级的），看提示是哈希表和二进制，但是二进制我想到的是异或，哈希表就不知道怎么用js实现了 理想答案：知道答案的我泪流满面，因为异或运算是可交换的，而且A XOR A = 0，所以对于实例{2,1,4,5,2,4,1}就会有这样的结果： (2^1^4^5^2^4^1) =&gt; ((2^2)^(1^1)^(4^4)^(5)) =&gt; (0^0^0^5) =&gt; 5 就把只出现了一次的元素给找出来了，算法复杂度为O(n)，且不需要额外空间 448-Find All Numbers Disappeared in an Array依然是线性复杂度，不能有额外内存占用 我的想法：用一个全部数字都有的数组进行匹配，如果在完整数组里面有这个数字，就把它移除，最后剩下的就是丢失的数字；然而复杂度太高，而且占用了额外内存 理想答案：利用nums[nums[i] -1] = -nums[nums[i]-1]，这样可以将出现过的数字所在位置的数字变为负数，最后判断哪个位置是正的，就是从来没出现过的数字，对于实例[2,3,1,3]来说，出现过的数字为1，2，3；所以就需要将数组中索引值为0，1，2的数字变成负的，所以处理后的结果是[-2,-3,-1,3]，再对这个数组进行遍历判断，如果大于零就说明没出现过，所以第四个数字是3（正数），所以就是4没出现过 520-Detect Capital我的想法：一开始觉得正则表达式肯定可以做，但是不会写；看完python的答案后，感觉js的indexOf和toUpperCase()、toLowerCase()应该可以做 理想答案：java基本上使用正则表达式，python有现成的方法，而js按照我那个思路应该是最佳答案 104-Maximum Depth of Binary Tree我的想法：首先，我都不知道js如何实现一个二叉树，然后感觉这应该是深度优先遍历能解决的问题，所以就去看了答案 理想答案：用栈缓存最大高度，希望有人能够用js实现以下深度优先遍历 243-Shortest Word Distance锁 389-Find the Difference看到有些答案是用异或做的，而我的想法是遍历短字符串，然后将新字符串中的对应字母替换成空字符，最后返回替换完毕之后的字符串，这个想法是由几天前那个妙用replace()方法的js答案想到的 371-Sum of Two Integers题目最容易读懂，但是基本上一点思路都没有，想到用计算机理解的那样去做，也就是位操作，但是具体怎么做就不知道了；应该是计算机基础没学好，否则应该很容易想出来吧（关于位操作的更多总结，可以查看我的另一篇文章：一些位操作的技巧） 2017-3-22226-Invert Binary Tree看见这种二叉树的算法题就头疼，做了几道关于二叉树的题后发现，掌握二叉树的遍历方法之后解类似的问题会变得很简单，而且要逐渐培养自己的递归思维和动态规划思维（从leetcode的tags可以看到，动态规划思维可以解答很多问题） 我的想法：没找到什么规律，然后看提示是Math，还是没有什么想法 理想答案：主要思路是对9取余，因为用到了一个很重要的定理，九余数定理：一个数N 各位数字的和 对9 取余等于 这个数对 9取余 492-Construct the Rectangle我的想法：一开始打算求根值，然后在根值附近找整数，但是好像对于质数来说根本行不通 理想答案：我的想法太狭隘了，应该再多想一步，就是从根值开始向下找，直到找到能整除的那个数字 283-Move Zeroes我的想法：遍历数组，如果碰到0，就把这个0从数组中删除，然后再push一个0到尾部，需要注意的是需要有一个变量用来存储有几个不是0的元素被遍历到了，因为这会影响到下一次循环的判断 理想答案：看了java的1ms答案，他的思路是遍历数组，然后当遍历到一个不是0的值得时候就进行交换，而交换的位置需要进行存储，并且每次碰到不是0的值就将该值加1，因为交换会使0的位置加1 530-Minimum Absolute Difference in BST求最小临近距离，看java的答案是先赋一个int型最大值，然后再用Math.min方法，然而js怎么做就不知道了；关于二叉树算法题的js实现有点麻烦，而且网上的代码有点繁杂并且思路很乱，有时间的话我会总结一篇关于二叉树的各种算法题的js实现和解释的。 506-Relative Ranks我的想法：我最先想到的就是先把整个数组排序，然后进行替换取值，但是难点是如何记住一开始每个数值的位置，可能还需要开辟额外的空间来存储index 理想答案：看java的答案，好像java有现成的数组排序方法， js可以用array的sort方法，然后用二维数组分别存储数值和index（python更简单，内置方法很适合算法实现），在写js答案的过程中发现js初始化一个二维数组真的好麻烦。 function arraySort(nums){ var nums_new = [], n = nums.length; for(var a=0;a&lt;n;a++){ nums_new\\[a\\]=\\[\\[\\],\\[\\]\\]; } for(var i=0;i&lt;n;i++){ nums_new\\[i\\]\\[0\\] = nums\\[i\\]; nums_new\\[i\\]\\[1\\] = i; for(var j=0;j&lt;n-1-i;j++){ if(nums\\_new\\[j\\]\\[0\\]&gt;nums\\_new\\[j+1\\]\\[0\\]){ var temp = nums_new\\[j+1\\]; nums\\_new\\[j+1\\] = nums\\_new\\[j\\]; nums_new\\[j\\] = temp; } } } return nums_new; } var findRelativeRanks = function(nums) { var nums_new = arraySort(nums), result = new Array(nums.length); for(var k=0,n=nums_new.length;k&lt;n;k++){ if(k===0){ result\\[nums_new\\[0\\]\\[1\\]\\] = &quot;Gold Medal&quot;; }else if(k==1){ result\\[nums_new\\[1\\]\\[1\\]\\] = &quot;Silver Medal&quot;; }else if(k==2){ result\\[nums_new\\[2\\]\\[1\\]\\] = &quot;Bronze Medal&quot;; }else{ result\\[nums_new\\[k\\]\\[1\\]\\] = k+1 + &quot;&quot;; } } return result; }; 167-Two Sum II - Input array is sorted我的想法：从最右边找到比target得数，然后从这个数的index值开始向左进行数组遍历，看两个数的和与target相比如何，如果相加大于target，就将index值–，再进行遍历 理想答案：利用二分查找，left=0，right=numbers.length-1；然后分别进行向左和向右的遍历 455-Assign Cookies我的想法：一开始打算遍历小孩数组，然后再判断cookie的size能不能满足小孩的需要；后来感觉还是应该以cookie为第一层遍历，然后满足了某个小孩之后再将小孩的指针+1（这都是在两个数组排好序的前提下，js需要用sort方法） 理想答案：和我的想法差不多（不知道为什么总是提示Time Limit Exceeded，js代码如下） var findContentChildren = function(g, s) { var i=0,m=g.length,n=s.length; for(var j=0;j&lt;n,i&lt;m;j++){ if(g\\[i\\]&lt;=s\\[j\\]){ i++; } } return i; }; 453-Minimum Moves to Equal Array Elements我的想法：我承认一开始被这道题骗了，我还在傻呵呵的列式子，后来才感觉不对劲，因为其实可以将这个过程逆过来，因为每次都将n-1项加1，其实就相当于从最终结果开始每次都将1项-1，直到所有项都等于数组中的最小值 理想答案：好像和我的思路一样，只不过js中求数组中的最小值需要用到一些技巧（Math.min.apply(null,arr)） 383-Ransom Note我的想法：我又想到了replace方法，首先对ransomNote进行遍历，如果ransomNote中的字母在magazine中不存在的话，就直接返回false；如果找到了，就将找到的那个字母替换为””，并赋给magazine（因为replace不会改变原数组），这样的话，如果遍历完毕之后magazine的长度大于等于0（等于0也可以满足，此时ransomNote和magazine长度相同并且所含字母的种类和个数相同），此时就应该返回true 理想答案：依然没有js实现方案，看其他语言好像和我的思路大同小异 404-Sum of Left Leaves这不知道是我第几道不会做的二叉树题了，思路是有，就是递归嘛，但是就是不会写。看完java的答案后写了一下js的版本（主要是要找到叶子节点）： var sumOfLeftLeaves = function(root) { if(root === null) {return 0;} var ans = 0; if(root.left !== null) { if(root.left.left === null &amp;&amp; root.left.right === null) { ans += root.left.val; }else { ans += sumOfLeftLeaves(root.left); } } ans += sumOfLeftLeaves(root.right); return ans;}; 349-Intersection of Two Arrays我的想法：既然找相同的数字，我觉得应该先把两个数组排序吧，然后再双层遍历？感觉用二分查找应该能简化，但是两个数组如何进行二分查找呢？ 理想答案：看别人的答案的话我只看懂了用两个指针的方法，复杂度为O(nlogn)，用哈希表那个方法没看懂什么意思，所以就用js实现一下两个指针的方法吧（果然需要先将两个数组排序，而且重点是删除重复元素）；而且这个题还有个bug就是题目明明说result可以以任何顺序，但是不是升序的答案根本提交不了…… var intersection = function(nums1, nums2) { var nums1_n = nums1.sort(), nums2_n = nums2.sort(), i = 0, j = 0, result = []; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) { if (nums1_n[i] &lt; nums2_n[j]) { i++; } else if (nums1_n[i] &gt; nums2_n[j]) { j++; } else { if(result.indexOf(nums1_n[i]) == -1){ result.push(nums1_n[i]); } i++; j++; } } return result.sort();}; 252-Meeting Rooms锁 122-Best Time to Buy and Sell Stock II知道了原理之后就很好做了，假如价格数组为[3,1,4,6,2,5,8]，从中可以发现，如果今天的价格比明天的价格便宜，我就今天买然后明天卖掉就可以了，只需要这一个判断就可以，因为不需要在手中呆多过1天1，拿数组中的[2,5,8]举例，你就会发现这个规律 387-First Unique Character in a String我的想法：遍历两次，实在想不出好方法了 理想答案：看有一个人用java可以实现18ms的速度，用两个指针-&gt;slow来只想当前字符，fast来浏览整个字符串，但是最后还是没看懂；后来看到了用ASCII码记录下出现的字母，然后在进行比较的方法，用js实现如下： /** * @param {string} s * @return {number} */var firstUniqChar = function(s) { var freq = new Array(26), a = ‘a’.charCodeAt(); for(var i = 0; i &lt; s.length; i ++) { if (freq [s[i].charCodeAt() - a] === undefined) { freq [s[i].charCodeAt() - a] = 1; } else { freq [s[i].charCodeAt() - a]++; } } for(var k = 0; k &lt; s.length; k ++){ if(freq [s[k].charCodeAt() - a] == 1){ return k; } } return -1;}; 2017-3-23171-Excel Sheet Column Number我的想法：这道题其实蛮简单的，学过多进制的人很容易就想到了，很类似于多进制转换（比如十六进制转换成十进制），同时结合ASCII码就可以很快得出答案： /** * @param {string} s * @return {number} /var titleToNumber = function(s) { var result = 0; for(var i=0,n=s.length;i&lt;n;i++){ result += Math.pow(26,n-i-1)(s[i].charCodeAt() - 64); } return result;}; 256-Paint House锁 504-Base 7我的想法：这种多进制的转换道理我都懂，可是如何用式子表达出来就不会了，包括循环的结束条件以及正负号的处理 理想答案：看完答案的我哭晕在厕所，因为其实js中的toString()方法已经解决了所有关于进制转换的问题；当然，也可以用递归去解，用js实现如下（需要注意在某些地方需要将数字转换成字符串，否则就会是两个数字相加，结果肯定不对，在js里数字转换成字符串最简单的方法就是将数字和””相加）： /** * @param {number} num * @return {string} */var convertToBase7 = function(num) { return num&gt;=0 ? “” + (num&gt;=7 ? convertToBase7(Math.floor(num/7)) + “” + num%7 : num) : ‘-‘+convertToBase7(-num);}; 237-Delete Node in a Linked List我的想法：这应该是是我碰到的第一道链表算法题，但是我竟然连题都没弄懂，因为参数只给了一个node，这个node到底是链表本体呢还是要删的那个元素的value呢，反正也是第一道题，我就直接看答案了 理想答案：因为题目已假设删除的不是尾部的元素，所以只需要将值和next与下一个节点相等就可以了（由于这道题过于简单，就不贴代码了，简单到有人说这道题实在太蠢了） 100-Same Tree我的想法：题目很简短，应该可以递归做，就是假如根节点值相同，就看root.left和root.right是否都相同 理想答案：需要先判断两个数都为null时应该返回true 169-Maiority Element我的想法：这道题有种似曾相识的感觉，好像曾经做过一道类似的题，应该还是用二维数组来做，一维用来存储数字，另一维用来计数，然后进行按计数值得排序就可以得到”多单元”了（看答案还有另一种思路，就是因为该元素出现次数不少于n/2次，所以如果将数组排序，第n/2个元素肯定是该元素了） 理想答案：有一个人的想法很巧妙，因为题目中规定”多单元”是出现不少于n/2次的元素，所以可以先将指针设为num[0]，同时有一个计数变量，然后对数组中剩下的n-1个元素进行遍历，如果该元素和”多单元”相同，就将计数器++，否则–；当计数器为0时，证明之前的那些元素都不是”\b多单元”，就将指针指向当前元素，同时将count++，相当于开始新一轮检测=&gt;穆尔投票算法（有一个网友总结了6种c++方法，并进行了解释，有兴趣的同学可以点击题目去瞅瞅） 242-Valid Anagram我的想法：一开始打算将字符串进行排序之后比较，然而不知道怎么更快速的对字符串进行排序 理想答案：其中一个思路是将字母转换成数字（ASCII码），然后用一个新的数组进行存储s数组的数字，然后在相同的位置减去t数组的数字；当这些都完成后，再对新数组进行遍历，当遇到一个不是0的数字时就说明有一处不同，就直接返回false；最后假如没有不是0的数字就返回true 409-Longest Palindrome我的想法：应该可以先统计某一字母个数为偶数和某一字母个数为奇数的数量，然后偶数字母个数加上是否有奇数字母个数（没有就加0，有就加1） 理想答案：由于没有js的标准答案，所以只能看其他语言的大概思路，基本上思路和我的想法相同，只不过是简化代码的问题。 541-Reverse String II我的想法：既然交换元素是和k有关，而且移动的步数也和k有关，所以可以进行循环交换，每次移动2k步，然后判断条件就是不能移动出数组 理想答案：有的思路是再写一个交换元素的函数，其实交换可以在遍历过程中进行，主要是循环结束的判断可能需要画个草图进行确定。 2017-3-24401-Binary Watch我的想法：可以把十个灯看做一个数组的十个元素，然后有几盏灯亮，就是数组相应位置上的元素值为1，其余元素为0，再然后对此二进制数组遍历取值，需要排除掉一些元素，因为时间不可能超过11:59；关键是如何实现将指定数目的1分配给数组中的随机元素。 理想答案：有的答案是从结果出发，对h从0-11和m从0-59这些所有的情况进行遍历，然后如果满足给定参数，就添加进数组；还有就是写出来所有的可能情况，然后就行匹配（这种答案简直无耻，而且速度还非常酷啊）；还有一种思路和我的比较像，就是从1的分配出发，先将数值求出来，然后假如h&lt;12并且m&lt;60，就将其加入数组中； 217-Contains Duplicate我的想法：这个可以用哈希表这种数据结构来做（之前做过类似的题太多了），然后对数组遍历的过程中就将哈希表更新一次，同时进行判断，如果哈希表以该数组元素为键值的地方有value，证明之前出现过改元素，就返回true；最后返回false，因为数组遍历结束还没有发现有元素出现过两次 理想答案：我的想法也可以是一种思路，还有一种思路就是先将数组排序，然后只需要比较相邻元素就可以了 13-Roman to Integer我的想法：看完题之后的第一感觉是：什么是罗马数字？然后我上网搜了一下，发现了罗马数字为什么没有广泛应用的原因，真的是太麻烦了！所以，最后我选择直接看答案 理想答案：原来罗马数字的构成还是满足一定规则的，但是这倒算法题未免过于局限了，可以去我的另一篇文章-罗马数字转换成整数去看构成规则和代码实现 2017-3-25206-Reverse Linked List我的想法：题目只有短短的一行，就是翻转一个单链表，而学过其他语言比如C、java、C++的人应该对链表这种数据结构很熟悉，但是在js里很难用到（反正我基本上没碰见过必须用链表这种数据结构才能解决的问题），所以虽然题目很简单，但是需要首先知道在js里，链表是如何构建的 理想答案：其实画一张草图就可以很清楚的知道这道题的答案了，就是head.next.next = head,head=null；然后对整个链表进行遍历 350-Intersection of Two Arrays II我的想法：之前有过一道类似的题，只不过那道题只需要找出相同的元素；这道题需要找出所有重复的元素，所以需要用哈希表来对重复的元素进行计数 理想答案：我的想法在两个数组未排序时是可以的；而如果先对两个数组进行排序或已经排好序的情况下，可以采用两个指针的方案，然后对两个数组中的元素进行比较，如果相等就push进新数组，不相等就移动指针 268-Missing Number我的想法：早在刷Leetcode之前就听说过这道题，我觉得应该先将数组排序，然后对数组进行遍历，对数组的值和索引值进行比较，不相等时就说明找到了，直接返回（\b需要注意的是js中的sort方法会默认按照字符串进行排序所以10会比2小，具体写法可以看下面代码；最后需要return n；因为循环索引值只会到n-1；如果遍历结束都没找到，证明是最大的那个数） 理想答案：除了我的想法（可以用二分查找进行优化），还可以用位运算中的异或，因为只有一个数丢失了，所以根据异或操作的性质，可以很容易找出来那个数字；还有一种方法是用求和的方式，先求出应该的和，然后减去数组中的所有数字，差就是那个丢失的数字 var missingNumber = function(nums) { var sort = nums.sort(function(a,b){ return a-b; }),n=nums.length; for(var i=0;i&lt;n;i++){ if(sort[i] != i){ return i; } } return n;}; 447-Number of Boomerangs我的想法：一开始没什么想法，就看了提示（Hash Table），如果要用哈希表的话，那应该把每个元素的大小记录下来吧，然后对其进行排序，对排好序的哈希表进行二分查找？ 理想答案：我是真的蠢，两个点之间的距离并不等于两个点距离原点距离大小之和，所以我那个想法是行不通的，看答案感觉这道题只能按照很普通的方法来解：首先将所有点到其他所有点的距离的平方作为key保存到map容器中，key相同就累加value，然后计算每个元素的value*(value-1)，并累加到返回结果中，最终就得到符合条件的点序列数，时间复杂度为O(n^2) 543-Diameter of Binary Tree我的想法：这种求最大值的应该用栈可以解决，但是如何递归我没有想清楚 理想答案：对于每个节点来说，传过它的最长的路径是它的左子树的最大深度和它的右子树的最大深度；而一个节点的最大深度是它的左子树的深度和右子树的深度中的较大值加一 415-Add Strings我的想法：根据我之前的经验，在字符串前加一个”+”号是可以直接将字符串转换成数字的，但是在提交之后会发现，当字符串中的数字过大时，转换将出现误差。 理想答案：最关键的一点是将字符串减去”0”或数字0，是可以将字符串转换成数字的；但是还是不明白我的想法为什么会出现误差，而且提示是Math，看答案基本上都是用字符串减去”0”，好像并没有用到Math的哪些方法 108-Convert Sorted Array to Binary Search Tree我的想法：首先得知道什么是平衡二叉树，然后需要了解如何用js构造一棵二叉树，才会有这道题的思路；因为根节点肯定是中值，所以可以先将根节点确定，然后左子树和右子树的根节点可以递归求得 理想答案：和我的思路一样，但是我用js实现之后提交总是出错，跪求有大神用js解出这道题 405-Convert a Number to Hexadecimal我的想法：我能想到两种思路，一种是先将整数转换成二进制，然后再对二进制的字符串进行遍历；还有一种是取余 理想答案：基本上就是这两种思路，但是将二进制数转换成16进制数不需要进行遍历，可以利用位运算”&amp;15”，同时”&gt;&gt;4”可以将二进制数字向右移4位，可以很方便的进行计算赋值 2017-3-26121-Best Time to Buy and Sell Stock我的想法：既然是求最大值，那可以先将数组排序，然后双指针进行判断，如果right的索引值小于left的索引值，就直接返回差值；循环结束仍没有返回就返回0，此时不存在最优化策略 理想答案：可以将数组元素中的最小值缓存下来，然后最大利润就是使得当前元素减去最小值之后差最大的值（动态规划的思想） 202-Happy Number我的想法：如果最后以和为1结束，那应该只有几种情况：1，10，100，1000……而某两个整数加起来的平方是这些数就是倒数第二步中的那个数，但是如何求出这两个数是个问题，也许会有某些定理？ 理想答案：一种思路是按照题目中所说的求平方，然后假如陷入了死循环（之前出现过该值）就直接返回false；还有一种思路就利用弗洛伊德循环检测算法（Floyd Cycle detection algorithm）=&gt;将求平方的过程分为快和慢两个过程，慢过程一次只求一次平方和，快过程一次求两次平方和，如果快过程所得结果和慢过程所得结果相等，就证明进入了死循环，就返回false 326-Power of Three我的想法：既然不让用循环，那我觉得可能需要用位运算，但是写了几个数字之后没有发现规律 理想答案：果然这道题是到智力题，虽然不让循环，但是可以用某些很简单的方法，比如让这个数字一直除以3（并没有进行循环，而是不断调用方法），或者用js的toString()方法，然后进行正则匹配…… 327-Power of Two我的想法：吸取了上一题的教训，我打算直接看答案了 理想答案：可以通过位运算，也可以通过上一题那些方法 246-Strobogrammatic Number锁 83-Remove Duplicates from Sorted List我的想法：其实是一道很简单的题，但是由于js和链表这种数据结构打交道很少，所以在看答案之前并不知道用js如何实现 理想答案：直接比较就可以了，相等就删除 70-Climbing Stairs我的想法：如果有n步，可以把这n步分成n个1步，然后对相邻的1进行随机组合（可以组合成需要1个两步、2个两步、3个两步……），然后将所有的可能性相加 理想答案：有网友指出这是个斐波那契数列；还有种方法就是从终点往前用两个指针进行循环 53-Maximum Subarray我的想法：这道题确实一点想法都没有（感觉后面的题会越来越难） 理想答案：用动态规划的思想去解，maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i];意思是从0开始到i的数组中的最大子数组和从0开始到i-1的数组中的最大子数组有关；一直相加知道和比0小，如果和是负的，就将序列重置 437-Path Sum III我的想法：本来打算从根节点开始向下相加，如果大于sum，就不去右子树，同时另一路重置节点，但是这种二叉树的遍历我是真的一点都不会；或者从树的结构发现，对于某个节点来说，这个路径的数量等于左子树符合的路径和右子树符合的路径个数之和再加上当前节点的值是否正好等于目标数字 理想答案：可以用哈希表来建立所有的前缀路径之和和其个数之间的映射，然后看子路径之和有没有等于给定值的；或者利用前序遍历，维护一个变量pre来记录之前路径之和，然后cur为pre加上当前节点值，如果cur等于sum，那返回结果时要加1（有点类似于我的想法） 501-Find Mode in Binary Search Tree我的想法：这道题比较简单，用一个哈希表用来存储数字和其出现的个数就可以，然后遍历比较的同时更新哈希表 理想答案：为了保证O(1)的空间复杂度，可以先得到modes的个数，然后再申请空间，但是可能leetcode对js的编译存在bug，run code时是正确的答案在提交时就无法通过 191-Number of 1 Bits我的想法：在js中，可以用toString(2)将数字转换成二进制字符串，然后利用replace将字符串中的0替换为空字符串，最后求替换后的字符串长度就可以了 理想答案：除了我的想法，还可以用位运算 35-Search Insert Position我的想法：对数组进行遍历，如果发现当前元素大于等于目标数字，就返回index；最后返回数组长度，因为此时证明目标数字比数组中的所有元素都大 理想答案：其实可以用二分查找简化遍历 107-Binary Tree Level Order Traversal II我的想法：关键是如何知道当前元素属于哪一层，应该用一个变量对当前遍历到的层数进行存储 理想答案：可以用链表或栈，但是用js如何实现还不知道 263-Ugly Number我的想法：既然2，3，5是互质的，就直接用3个while分别除以2，3，5；直到无法整除时再判断余数是否为0就可以了 理想答案：大体上就是我的思路，只不过可以更加简化 270-Closest Binary Search Tree Value锁 459-Repeated Substring Pattern我的想法：总感觉这道题会有很简单的解法，但是肯定要遍历到所有的元素，而如何确定循环字母的个数以及如何进行遍历是个难题 理想答案：方法有很多，主要区别在于对子序列的确定和判断上 21-Merge Two Sorted Lists我的想法：就是从前往后对两个链表遍历，需要注意的是对于头和尾的处理 理想答案：如果l1为null，就返回l2；如果l2为null，就返回l1；之后就是递归的过程 235-Lowest Common Ancestor of a Binary Search Tree我的想法：两个节点的祖先肯定也是其各自左子树与右子树的祖先，而最小祖先的话应该是从根节点出发，然后看两个节点在什么时候在某个节点的两侧或其中一个节点是另一个节点的祖先节点 理想答案：根据我所说的那两种情况，又因为这是一棵二叉搜索数，所以两个节点分别与共同的祖先节点相减所得的差应该是异号或等于0的，否则就根据节点与当前根节点的大小比较对其左子树或右子树进行递归 198-House Robber我的想法：看这种题目就应该是动态规划，但是想了半天还是想不到子问题是什么，因为这种相邻的元素会传染啊 理想答案：其实应该从房间数为1时开始找规律，当房间数为2时，需要比较的是a[0]和a[1]，而当房间数为3时，需要比较的是a[1]和a[0]+a[2]……这样就能够发现需要把房间数的奇偶作为判断标准，同时对最大值进行存储 342-Power of Four我的想法：首先可以判断二进制数字中1的个数，当有且只有1个1且位于偶数位上时，就是可以整除4；或者可以利用位运算 理想答案：除了上面说的两种思路，还有一种是利用2的倍数减1无法整除3而4的倍数减1可以整除3的特性 2017-3-27345-Reverse Vowels of a String我的想法：既然是交换字母，那应该用二分查找是没问题的，而需要注意的是在js中是无法对字符串重新赋值的，因为字符串是类数组并不是真正的数组，所以需要先用一个array将字符串存储进来并在数组中完成交换；最后再通过join方法将数组转换成字符串 理想答案：其他语言是可以对字符串重新赋值的，而js的话应该只能按照我那种方式 367-Valid Perfect Square我的想法：既然不让用sqrt，那应该是模拟计算机在求根值的时候是如何处理的，所以可能是位运算吧，但是到底如何运用没有思路 理想答案：有一个定理就是完全平方数一定等于1+3+5+7……所以可以通过迭代判断；其实可以通过二分查找；最后可以通过牛顿迭代法判断 27-Remove Element我的想法：本来还打算继续用replace的，但是正则表达式不能带引号，而将变量和字符串相加之后会出现引号，我目前还不知道怎么去掉；还可以先将数组排序，然后用二分查找 理想答案：大体上思路都差不多，不过我很诧异为什么没有用二分查找的，难道先排序会让时间复杂度变高吗？ 101-Symmetric Tree我的想法：对于这种数的遍历我是真不会写，思路应该是对于某个节点来说，它是否是个”镜像树”取决于它的左子树和右子树是否都是个”镜像树” 理想答案：可以再写一个方法，然后判断其左右子树是否都是”镜像树” 66-Plus One我的想法：本来想通过一些简单的方式将它变成数字再变成数字组成的数组的，但是最后的结果数组是一个字符串数组，所以就放弃了，老老实实遍历原数组了 理想答案：答案都是从n-1开始遍历，难点只有对于进位的处理了 2017-3-28118-Pascal’s Triangle我的想法：鉴于是一个数组组成的数组，而且数组中的每个元素只与前一个元素有关，所以可以先用一个方法生成某一行的数组元素，然后再通过循环将这些数组push进数组中返回 理想答案：除了单独写一个方法之外，其实完全可以用一个函数就解决了，只不过这时候的赋值是对二维数组赋值 434. Number of Segments in a String我的想法：首先需要去掉首尾空格，因为会影响判断长度的判断，然后再将连续的空格替换成一个空格，再然后将非空字符替换成””，最后返回空格的长度+1 理想答案：除了我的想法之外，可以先在首尾分别加一个空格，然后再将多个空格替换成1个空格，最后返回空格数量-1 110. Balanced Binary Tree我的想法：又是一道二叉树的题，这种根据高度判断的题用深度优先遍历就可以了吧，但是我用js依然不会（感觉我的下一篇文章就会是js实现二叉树的各种遍历） 理想答案：某节点的高度等于该节点的左子树和右子树的高度中的较大值再加一，所以知道这个公式之后就可以递归求解了，其实是一道很简单的题 257-Binary Tree Paths我的想法：首先需要明确的是路径的数量是叶子节点的数量，所以对于某个节点来说，如果其左右子节点不为null的话，就需要有两条路径 理想答案：我没有想到的是，其实最终返回的是一个链表群组，而对于本身就有链表这种数据结构的语言来说是很简单的，而对于js来说，需要用数组模拟链表 422-Valid Word Square锁 441-Arranging Coins我的想法：因为求和的公式是能算出来的，所以本来打算先求根值确定大致范围，结果试了几次之后发现总是有一些时候是不对的，所以就看答案了 理想答案：因为公式是可以算出来的，所以直接根据公式求出解就行了，然后用Math.floor就可以了； 119-Pascal’s Triangle II我的想法：规律我找到了，就是各种和n(n+1)有关，但是如何用代码表现出来还是不太知道；如果用之前的方案解的话就是再单独写一个方法 理想答案：递归，相当于第一层循环是生成之前一层的元素，第二层是生成当前层的元素；根据公式a(k+1) = a(k) (n-k)/(k+1) 232-Implement Queue using Stacks我的想法：其实在js中实现队列也没办法用栈，因为js中就没有栈嘛，所以还是用数组就可以了，然后具体如何实现大家可以参考的我的另外一篇文章：JS实现复杂数据结构，这篇文章里面有一些复杂数据结构（比如栈、队列、单链表等）的实现以及方法的定义 理想答案：基本上都是自带方法，没什么好说的 141-Linked List Cycle我的想法：如果判断是否有环，那应该是遍历时出现了同一元素，所以用哈希表应该可以做 理想答案：之前有道题用到了两个指针，一个移动的快，一个移动的慢，而这道题也可以用那种解法，当快指针和慢指针遇到一起时，证明存在环，否则就不存在 26-Remove Duplicates from Sorted Array我的想法：既然只需要返回长度，那就遍历时如果碰到前后元素相等就原长度-1，最后返回剩余长度 理想答案：同样是对数组进行遍历，设置一个变量用来记录当前没有重复数字的数组长度，当遇到不相等元素时就将变量加一，同时进行赋值；或者用一个变量记录当前数组中重复元素的数量，最后用总长度减去重复元素数量 172-Factorial Trailing Zeroes我的想法：某个数的阶乘是有现成的公式的，如果直接套用公式的话就会很好求，但是如果不套用公式又要保证复杂度是对数级的话可能要用二分查找？（事实证明，我题都没读懂） 理想答案：和我理解的题意不同，题目所要求的是n的阶乘小数点前面有几个0，而0产生的情况只可能是5*2，所以就可以简化为n！里有几个5，因为2是有足够多的 9-Palindrome Number我的想法：看到回文数字，我的第一反应就是二分查找，用left和right指针进行判断 理想答案：应为js可以很轻松的将数字转换成字符串，所以用二分查找比较方便；还可以用前一半数字是否等于后一半数字来判断 374-Guess Number Higher or Lower我的想法：这个游戏在某些购物类电视节目里经常遇到，因为数字的挑选是随机的，所以可以看做等概率的，所以一直取中间数是个正确的策略 理想答案：竟然只能用java、python、c++，所以只能看答案了 276-Paint Fence锁 438-Find All Anagrams in a String我的想法：和著名的KMP算法一样，可以用一个指针来记录可能存在的index索引值，然后对当前字符和之前的字符进行判断 理想答案：这道题可以用著名的滑动窗口算法来解，这样可以将复杂度控制在O(N) 112-Path Sum我的想法：对于一个节点来说，其到叶子节点的路径之和等于左子树的所有可能路径加上右子树所有可能路径的和再加上当前节点的val，所以重点是如何确定左子树和右子树有多少条路径 理想答案：二叉树真的是太强大了，既然我们不好确定多少条路径，不如将其简化为如果知道目标值sum和当前节点的val，就看左子树和右子树能否满足sum-root.val就可以了 2017-3-2938-Count and Say我的想法：首先需要读懂题目，这道题的题目我认为是很难理解的，所以我就搜了一下，规则如下：n=1时输出字符串1；n=2时，数上次字符串中的数值个数，因为上次字符串有1个1，所以输出11；n=3时，由于上次字符是11，有2个1，所以输出21；n=4时，由于上次字符串是21，有1个2和1个1，所以输出1211，所以这是个典型的递归问题 理想答案：大家对这道题的抱怨很多，原因是题意很难读懂，而且我一开始没有注意到需要返回字符串，还以为是数字；但是题目很简单，典型的递归问题 250-Isomorphic Strings我的想法：我觉得题目说的有歧义，因为其实并不是单向的替换，而是说s和t是可以交换的，所以需要同时判断两个字符串，我采取了最笨的一种方法，就是用另外一种方法来判断能否替换，然后将s和t交换之后再判断一遍 理想答案：可以通过另外一个数组来保存s和t中的元素分别在其字符串中的位置，如果不相等，就证明其中一个字符串中出现了重复字符串，而另外一个没有出现，此时就返回false 20-Valid Parentheses我的想法：首先需要分清楚哪些情况是无效的，哪些情况是有效的，首先是符号必须闭合，其次是符号之间必须是包含关系，所以直观上来看应该可以用栈来解决 理想答案：栈是公用的思路，区别在于如何确定哪两个标签是一对儿，indexOf或许是个不错的选择 111-Minimum Depth of Binary Tree我的想法：这道题是比较简单的二叉树递归题，主要是注意当root的左子树或右子树为null时，并不能单纯的用Math.min，因为最小高度是不会把null算在内的 理想答案：只要分辨出来叶子节点和非叶子节点就可以确定递归方程，详情可见我的另一篇文章：Leetcode的JS实现（有个大神总结了各种语言的各种实现方案，可以点击题目链接查看solutions） 290-Word Pattern我的想法：之前有一道类似的题，这道题将其扩展了一下，从字母组合变成了字符串组合，所以增加了一些难度（也有可能是减少了？），还是觉得用哈希表会好一些 理想答案：其他语言的复杂数据结构都有好多自带的方法，而JS连哈希表都没有，所以只能先定义一下会用到的方法，再通过哈希表进行判断，只要把可能情况考虑全这道题就没有什么问题 234-Palindrome Linked List我的想法：因为题目中的链表是单向的，所以我感觉可以先将链表遍历一遍，然后将值推进栈中在进行二分查找，不过这样复杂度可能会有点高 理想答案：果然不能按照我的思路，可以通过两个指针（slow和fast）对链表进行遍历，fast跑到链表结尾时slow正好走到中间，然后开始反转，比较前一半和后一半是否形成回文，可见下图 1.Two Sum我的想法：我一开始以为这是一道非常简单的题，就直接排序之后二分查找就可以了，但是这样返回的索引值不一定是未排序之前的数组的索引值，所以可能又需要哈希表？ 理想答案：确实需要用到哈希表，但是由于是两个数相加的和，所以可以遍历时将差值推进哈希表，当循环到下一元素时，只需要看哈希表中有没有这个数字就可以了（但是js没有哈希表啊，所以需要自己提前写好方法） 219-Contains Duplicate II我的想法：这道题和上面那道题有点相似，同样是只包含数字的数组，同样是求满足条件的两个数字的索引值，所以应该可以用哈希表 理想答案：我竟然题目都没弄清楚，原来题目的真正要求是查看数组内是否有重复元素且相邻重复元素索引间隔不大于K，虽然题目理解错了，但是用哈希表依然能够解决 225-Implement Stack using Queues我的想法：看到这个题目我就笑了，用队列实现栈，在js里这两个都不存在，所以只能先定义好队列，再通过数组的一些方法实现栈（想想就好蠢） 理想答案：参考我的另一篇文章JS实现复杂数据结构 88.Merge Sorted Array我的想法：其实合并两个数组并没有什么难度，但是题目要求是in-place，也就是不占用额外空间，所以需要在其中一个数组上完成合并，而不能新声明一个数组 理想答案：其实之前意识到这道题和归并排序有点像，但是我当时想的是从前往后比较，看了答案之后才发现应该从后往前比较，这样就可以提前把nums1扩展到m+n长度，然后从索引值为m+n-1的地方开始赋值 203-Remove Linked List Elements我的想法：这道题其实很简单，因为对于单链表来说，只有next这样一个指针，所以只能单向进行遍历，而因为不能直接比较next的val，所以需要递归；其次就是需要当第一个元素就是val时注意返回值的改变 理想答案：基本上就是我的思路 58.Length of Last Word我的想法：又到了replace大显身手的时候了，在js中，字符串变成数组是非常简单的（split），所以只需要将其转换成数组之后返回数组最后一个元素的长度就可以了，需要注意的是需要用正则表达式去掉原字符串中的前后空格 理想答案：这次js只用一行就解决了，而别的语言是肯定不行的 507-Perfect Number我的想法：既然是它的因子相加，那就需要确定其根值，然后从根值开始进行遍历，如果能够整除，就将该数字和其商都加进结果中，需要注意的是0和1都需要返回false 理想答案：除了我的思路还可以把所有的“完美数字”列出来，然后看num是不是在其中（这个肯定复杂度最低吧，因为在int范围内的“完美数字”只有5个） 2017-3-3067-Add Binary我的想法：虽然题目很简短，但是解决起来却不是那么简单，其实实现的就是二进制的加法，应该是用位运算吧，因为模拟的是计算机内部的处理（或者当做数字字符串来循环处理） 理想答案：答案里面没有用位运算的，都是对a和b进行循环处理，难点在于对进位的处理，需要用一个变量保存进位情况 14-Longest Common Prefix我的想法：既然是求最长公共前缀，所以需要对数组中的字符串进行遍历，同时需要有一个指针来进行前缀字符串的选取 理想答案：我没有写出来的原因是被判断字符串的前缀是否为某一字符串困住了，看完答案之后发现其实用indexOf就可以解决了 160-Intersection of Two Linked Lists我的想法：如果在某个点合并为一个链表，特点就是a.next==b.next，难点在于对于循环的控制，因为对于单链表来说你只知道next和当前的val 理想答案：用两个指针进行遍历，遍历结束条件是两个指针相等，而如果遍历A的指针到达了A的终点，就将指针重新只想B的起点，这样就可以保证两个指针最终会指向同一点（如果两个链表有交集的话），因为相当于两个指针同时走了A+B的长度 400-Nth Digit我的想法：我觉得应该先确定大致范围，就是在哪个数字中，然后再判断具体是这个数字的第几位；难点在于确定其大致范围 理想答案：比我的思路更进一步，其实可以分成三步：首先确定这个数字有几位，然后确定这个数字是多少，最后确定需要返回这个数字的第几位 475. Heaters我的想法：既然是求最小角度，就应该同时考虑房子和加热器的位置，所以可以将其分成几种情况单独讨论，房子在加热器的左边或右边和房子在两个加热器的中间 理想答案：在对房子进行遍历的基础上移动加热器的指针，当房子的位置的2倍大于左右热水器的位置和的时候，说明此时的房子应该被右边的加热器加热，此时就应该移动加热器的指针，同时有一个变量保存热水器的加热范围，其应该是加热器和房子距离的最大值 190-Reverse Bits我的想法：其实在js中这类处理是很简单的，就是对一些自带的方法进行组合调用，不过需要注意的是题目要求在32位的前提下，所以需要进行“补0”，（toString(2)的结果是不够32位的） 理想答案：js的答案没有看到，看其他语言的答案，基本上都是用位运算来解决，但是我试了一下，在js里有符号不对的问题，到现在也没有解决 303-Range Sum Query - Immutable我的想法：这道题其实本身并没有什么难度，但是看完input之后就不知道题目到底想干什么？可能是想让你实现NumArray的原型，然后在原型上扩展sumRange方法吧 理想答案：最后将别人写的java答案改写成了js的，但是总感觉这道题的意义不大 408-Valid Word Abbreviation锁 28-Implement strStr()我的想法：看完对strStr()的描述之后，我首先想到的是js中的indexOf()方法，然后试了一下成功Accepted…… 理想答案：好多提交的答案是老老实实进行遍历，还有的是利用KMP算法（复杂度会大大降低） 69-Sqrt(x)我的想法：既然是求根值，那可以从二分之一处开始循环判断，但是总感觉会有更简便的方法（比如位运算？） 理想答案：果然我的思路是属于最慢最容易想到的，比较好的方法是二分查找和牛顿迭代法 155-Min Stack我的想法：这种题对于js来说意义不大，因为只会考察到数组的相关方法，不过我在多次sumbit的失败中知道了array.sort()方法是会改变原数组的，具体如何用js解这道题参考我的另一篇文章：JS实现复杂数据结构 414-Third Maximum Number我的想法：复杂度要求是O(n)，所以肯定需要对之前的值进行保存，所以可以用三个变量分别保存目前为止最大、第二大和第三大的数是多少，然后进行比较替换（但是这样感觉复杂度会比O(n)大） 理想答案：大部分答案我都没看懂，所以只能按照自己理解的去写；一种方法是逐个比较，另一种方法是先将数组排序，然后再进行遍历 532-K-diff Pairs in an Array我的想法：本来打算先将数组排序后进行遍历，但是考虑到复杂度太高，所以就打算用哈希表了，不过由于js中没有哈希表，所以可能复杂度也不会低多少 理想答案：通过两个指针进行判断，其中一个指针进行遍历，另外一个指针用来寻找和当前遍历到的元素配对的数字，需要注意的是相同的数字只能算一次 204-Count Primes我的想法：既然是求素数的个数，那肯定得知道如何求素数，但是我并不知道如何判断一个数是不是素数，所以我就打算看答案了 理想答案：质数（素数）判断思路-&gt;对正整数n，如果用2到根号n之间的所有整数去除，均无法整除，则n为质数 2017-3-31125-Valid Palindrome我的想法：既然不考虑空格或其他符号以及忽略大小写，所以可能需要对字符串进行预处理（正则表达式），然后可以像单链表一样用两个指针进行遍历判断（一个fast，一个slow）；或者用二分查找来判断；需要注意的是空字符串也算作回文字符串 理想答案：大部分都是用二分查找，各种语言之间的二分查找基本上都是大同小异的；或者将字符串反转之后比较是否完全相同（感觉这个方法不太好） 168-Excel Sheet Column Title我的想法：很容易发现的规律是基本上26个一循环，就像进制转换一样，所以可能需要递归 理想答案：为了能够使余数和索引值相匹配（0-25），所以需要用(n-1)来进行取余和除法运算，具体思路可见下图 278-First Bad Version我的想法：感觉这道题和购物猜价格类似，用二分查找应该会比较快 理想答案：确实是用二分法，不过注意二分法的写法（还是要多想多写） 7-Reverse Integer我的想法：在js里可以利用数组的reverse()方法间接性的对数字进行反转，只不过要注意符号位的处理，还有int型溢出时要返回0 理想答案：除了js，其他语言是通过数学计算进行直接反转，主要思路是递归取余，但是如果将这种方法用js实现的话还是需要注意符号位和int溢出的处理 189-Rotate Array我的想法：题目提示至少有3种方法去解决这个问题，但是我只能想到两种比较好做的，比如先截取数组的一部分然后进行拼接或者先将两个完整的数组合并再截取（但是这两种好像都不是O(1)空间复杂度） 理想答案：","categories":[{"name":"算法","slug":"algorithm","permalink":"http://merrier.wang/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://merrier.wang/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://merrier.wang/tags/leetcode/"}]},{"title":"Wordpress开发行动指南","slug":"Wordpress开发行动指南","date":"2017-03-15T15:26:18.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170315/wordpress-development-action-guide.html","link":"","permalink":"http://merrier.wang/20170315/wordpress-development-action-guide.html","excerpt":"","text":"本人玩wordpress到目前为止也只有3天，但是发现wordpress是异常庞大的，可能在开发的过程中会遇到各种各样的bug，同时也会运用到各种小技巧和“黑科技”，所以就索性写篇文章用来记录我在这个过程中的收获与教训吧。 1.wordpress的插件wordpress的插件使wordpress的功能得到了无限扩展，所以想用wordpress搭建网站或者开发插件的话，一定要多用它的插件，并且多了解一些插件的功能，其中我在做博客的过程中用到的一些好用的插件都在我的另一篇文章里了，可以点击查看-&gt;：wordpress插件推荐 2.自动为WordPress文章设置特色图像代码这里有一段很实用的代码，可以自动将文章中的第一张图片设置为特色图像，如果你手动设置了特色图像，可以覆盖这段代码。将下面的代码丢到当前主题的functions.php里，以后就不用担心忘记设置特色图像了。（这个到底有什么用呢，反正我没用= =） function autoset_featured() { global $post; $already_has_thumb = has_post_thumbnail($post-&gt;ID); if (!$already_has_thumb) { $attached_image = get_children( “post_parent=$post-&gt;ID&amp;post_type=attachment&amp;post_mime_type=image&amp;numberposts=1” ); if ($attached_image) { foreach ($attached_image as $attachment_id =&gt; $attachment) { set_post_thumbnail($post-&gt;ID, $attachment_id); } } } } //end functionadd_action(‘the_post’, ‘autoset_featured’);add_action(‘save_post’, ‘autoset_featured’);add_action(‘draft_to_publish’, ‘autoset_featured’);add_action(‘new_to_publish’, ‘autoset_featured’);add_action(‘pending_to_publish’, ‘autoset_featured’);add_action(‘future_to_publish’, ‘autoset_featured’); 3.为某篇文章添加特定的样式或js代码将下面代码添加到你的WordPress主题模板的functions.php 中： /为特定文章添加特定css最简单的方式. //添加自定义CSS的meta box/add_action(‘admin_menu’, ‘cwp_add_my_custom_css_meta_box’);/保存自定义CSS的内容/add_action(‘save_post’, ‘cwp_save_my_custom_css’);/将自定义CSS添加到特定文章(适用于Wordpress中文章、页面、自定义文章类型等)的头部/add_action(‘wp_head’,’cwp_insert_my_custom_css’);function cwp_add_my_custom_css_meta_box() {add_meta_box(‘my_custom_css’, ‘自定义CSS’, ‘cwp_output_my_custom_css_input_fields’, ‘post’, ‘normal’, ‘high’);add_meta_box(‘my_custom_css’, ‘自定义CSS’, ‘cwp_output_my_custom_css_input_fields’, ‘page’, ‘normal’, ‘high’);}function cwp_output_my_custom_css_input_fields() {global $post;echo ‘‘;echo ‘‘.get_post_meta($post-&gt;ID,’_my_custom_css’,true).’‘;}function cwp_save_my_custom_css($post_id) {if (!wp_verify_nonce($_POST[‘my_custom_css_noncename’], ‘custom-css’)) return $post_id;if (defined(‘DOING_AUTOSAVE’) &amp;&amp; DOING_AUTOSAVE) return $post_id;$my_custom_css = $_POST[‘my_custom_css’];update_post_meta($post_id, ‘_my_custom_css’, $my_custom_css);}function cwp_insert_my_custom_css() {if (is_page() || is_single()) {if (have_posts()) : while (have_posts()) : the_post();echo ‘‘.get_post_meta(get_the_ID(), ‘_my_custom_css’, true).’‘;endwhile; endif;rewind_posts();}} 然后在文章的编辑页面就会出现如下输入框： 是在字数统计的下面，我一开始没注意到，以为没生效呢，差点就把这段代码否定了，不过这个方法只能用来定义特定CSS样式，如果想插入特定js代码的话，可以考虑用下面一个方法： 首先还是要将下面代码添加到你的WordPress主题模板的functions.php 中 add_action(“wp_head”,”ruikeedu_custom_head”);function ruikeedu_custom_head(){ if (is_single() || is_page()) { global $post; $custom_head = get_post_meta($post-&gt;ID, ‘custom_head’, true); echo $custom_head; }} 然后在文章的编辑页面设置显示自定义栏目： 然后在文章编辑的后面会出现自定义栏目的输入框，名称为custom_head，值就是你想插入的css代码或js代码（css代码需要有，js代码同理，因为该方法不会自动添加标签） 总结：网上虽然关于这个问题的回答很多，但是基本上都是抄来抄去，而且有的方法亲测不可用，所以推荐以上这两种方法一起用，既可以添加css代码又可以添加js代码。 4.允许分类描述添加 html 代码出于安全等因素考虑，WordPress 后台的文本框一般是不允许添加 html 代码的（也就是被过滤掉）。所以如果有WP用户需要在分类描述中添加 html 代码，下面这个实现方法就可以实现。直接将下面的代码添加到当前主题的 functions.php 文件即可： /*** 允许分类描述添加html代码* https://www.wpdaxue.com/category-description-support-html.html*/remove_filter(‘pre_term_description’, ‘wp_filter_kses’);remove_filter(‘term_description’, ‘wp_kses_data’); 如果你还想让 链接描述和备注、用户描述 也一样支持 html 代码，可以试试下面的代码，同样是添加到functions.php： // Disables Kses only for textarea savesforeach (array(‘pre_term_description’, ‘pre_link_description’, ‘pre_link_notes’, ‘pre_user_description’) as $filter) {remove_filter($filter, ‘wp_filter_kses’);}// Disables Kses only for textarea admin displaysforeach (array(‘term_description’, ‘link_description’, ‘link_notes’, ‘user_description’) as $filter) {remove_filter($filter, ‘wp_kses_data’);} 如果你需要进一步了解实现原理，可以自己阅读以下文档： http://codex.wordpress.org/Function_Reference/wp_filter_kses http://codex.wordpress.org/Function_Reference/wp_kses_data 5.在文章中插入动图wordpress对于文章中的图片是默认进行缩略处理的，而文章中的gif动图在经过处理后就变成了静态文件，就不会“动”了，所以需要插入动图之后对其进行编辑，然后选择完整尺寸就可以了，如果在编辑文章时，该gif动图就已经“动”了起来，那证明已经成功了。 6.编辑文章上传图片时提示HTTP错误这个错误发生在我刚把项目从本地部署到服务器之后，然后我就上网搜了一下，有的人说是因为图片太长或太大了，但是我将图片压缩之后还是提示这个错误，所以又尝试了一些其他方法： （1）如果使用的是服务器，那应该是安全设置问题，修改服务器的httpd.conf文件，删除里面关于mod_security部分就可以了 （2）如果使用的是虚拟主机，在.htaccess文件里面加上一行（这个方法亲测有效） SetEnvIfNoCase Request_URI /wp-admin/async-upload.php$ MODSEC_ENABLE=Off （3）如果上述方法都不能解决，有可能你的图片确实是太长或者太大了，还是压缩一下再上传试一下吧，网站导航里有好多图片在线压缩工具 7.更改新域名这个问题的故事是这样的：因为想给自己的网站备案，所以就买了一个可以备案的域名merrier.wang，而之前是merrier.online，在买完域名并解析之后，在wordpress后台将域名配置成merrier.wang之后就出现问题了，因为merrier.wang是没有备案的，所以就无法访问： 但是访问之前的merrier.online又会重定向到merrier.wang（应该是wordpress自带的重定向功能吧），所以就相当于连后台也访问不了了，只能修改域名。在这里顺便提醒一下，如果你也给域名申请备案中，先不要在后台修改wordpress的域名，因为备案不成功是访问不了的；接下来总结一下网上的几种更改新域名的方法： 方法一：修改wp-config.php在wp-config.php中，添加以下两行内容： define(‘WP_HOME’,’http://\byourwebsite’);define(‘WP_SITEURL’,’http://yourwebsite&#39;); 然后登录后台，在 “常规 -> 设置”重新配置新博客地址（HOME）和安装地址（SITEURL），成功后一定记得删除上面添加的内容。 方法二：修改functions.phpfunctions.php位于当前博客主题目录内，在其中添加以下两行内容： update_option(‘siteurl’,’http://yourwebsite&#39;);update_option(‘home’,’http://yourwebsite&#39;); 然后登录后台，在 “常规 -> 设置”重新配置新博客地址（HOME）和安装地址（SITEURL），成功后一定记得删除上面添加的内容。 方法三：修改wp-config.php（自动更新地址）在wp-config.php中，添加下面一行内容 define(‘RELOCATE’,true); 然后登录后台地址，WP将自动更新安装地址（SITEURL），手动修改博客地址（HOME）地址即可，成功后一定要记得删除上面添加的内容 方法四：修改数据库通过某些方法（phpmyadmin等）登陆到数据库，找到wp_options表，将表中的siteurl和home字段修改为当前的新域名 8.页面下开启评论框我在更新了一些页面（比如标签云、读者墙、网址导航）之后，发现这些页面下没有评论框，非常的不爽，就上网查了一下，然后大部分答案都是修改代码，我试了之后发现还是不行，后来在wordpress吧发现了问题出在了哪里： 首先，在后台的页面设置界面，显示讨论栏目： 然后再文章的下面开启允许评论： 经过这两个步骤之后刷新页面（别忘了更新），就会发现评论框出现了！ 9.wordpress后台安装主题或插件时需要FTP帐号怎么办在我把代码部署到服务器上之后发现在更新插件或者安装插件的时候需要输入FTP用户名和密码，去阿里云控制台也没有找到，所以就上网找了一些解决教程，试了一下下面的解决方法，实测有效： 主要原因是wordpress主目录的权限所有者不属于apache造成的； 第一步：找到apache服务所使用的用户名和用户组，具体做法为打开终端，输入： ps -aux 找到/usr/sbin/apach （或/usr/sbin/httpd）的用户名，它就是apache的所有者，我这里是apache 第二部：终端输入： sudo chown \bapache:apache -R /var/www/ 这里的/var/www/是我的web主目录也是wordpress主目录； 好了，这样就OK了，再进入wordpress后台安装主题和插件不在需要FTP帐户和密码了！！ 10.WordPress数据库及各表结构转载自csdn，相信知道这些数据表的结构之后，可以对自己的wordpress网站进行更加个性化的设置，当然如果你的英文还可以的话，推荐WordPress官方文档，官方已经给出了比较详细的表格 11.建立数据库连接时出错某一天，我心血来潮想搞个https，结果刷新网页的时候发现显示“建立数据库连接时出错”，后来在服务器上重启mysql就没问题了= =。。 12. 升级至HTTPS时图片路径仍然为HTTP前几天把网站升级至HTTPS了，不过随之而来的就是一堆bug报错，首先就是文章中的图片路径，仍然是HTTP的话浏览器会报Mixed Content错，但是我通过修改数据库的方式仍然不管用，后来不知不觉把两个插件禁用了，然后就好了，这两个插件就是七牛云的相关插件：WPJAM BASIC、WPJAM 七牛镜像存储，不过禁用掉之后就用不了七牛云了，后续有时间我再深入研究一下= = 13. WordPress：基于 JWT 的身份验证如果你想基于 WordPress 去创建前端 App 或者移动端 App，解决用户的身份验证可以使用 JWT 这种方法，它是一种基于 Token 的验证身份的方法。","categories":[{"name":"wordpress","slug":"wordpress","permalink":"http://merrier.wang/categories/wordpress/"}],"tags":[{"name":"指南","slug":"指南","permalink":"http://merrier.wang/tags/指南/"},{"name":"wordpress","slug":"wordpress","permalink":"http://merrier.wang/tags/wordpress/"}]},{"title":"前端优秀插件推荐","slug":"前端优秀插件推荐","date":"2017-03-15T12:36:38.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170315/recommendation-of-excellent-front-end-plugins.html","link":"","permalink":"http://merrier.wang/20170315/recommendation-of-excellent-front-end-plugins.html","excerpt":"","text":"这里集中了一些我在项目中或平常看到听到的好的插件，前期我只会把他们展列出来，后期我会做一些小demo供大家调试，话不多说，直接干货： [table id=1 /]","categories":[{"name":"总结","slug":"总结","permalink":"http://merrier.wang/categories/总结/"}],"tags":[{"name":"推荐","slug":"推荐","permalink":"http://merrier.wang/tags/推荐/"}]},{"title":"一些实用的JS和jQuery方法","slug":"一些实用的JS和jQuery方法","date":"2017-03-15T07:56:27.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170315/some-practical-js-and-jquery-methods.html","link":"","permalink":"http://merrier.wang/20170315/some-practical-js-and-jquery-methods.html","excerpt":"","text":"写在前面这里总结了一些常用的JS/jQuery方法，都是一些在项目中经常遇到的功能需求，如果你有更多的建议，欢迎留言 更新于2018-02-11：在我的github（common-js）上对一些常用的方法进行了总结，都是一些短小精悍但是颇为实用的封装函数，欢迎star或fork:)1、简单的图片预览这个方法就是普通的上传图片并预览功能，不包含进度条以及大小和格式的判断 //——————获取图片url地址—————function getObjectURL(file) { var url = null; if (window.createObjectURL!=undefined) { // basic url = window.createObjectURL(file) ; } else if (window.URL!=undefined) { // mozilla(firefox) url = window.URL.createObjectURL(file) ; } else if (window.webkitURL!=undefined) { // webkit or chrome url = window.webkitURL.createObjectURL(file) ; } return url ;}; //—————上传图片按钮点击————$(“.btn_upload_file”).change(function(){ var picurl = getObjectURL(this.files[0]); if(picurl){ $(“.div_show_pic”).show().attr(“src”,picurl); }}); 2、实现sleep函数很多语言都有sleep函数，显然js没有，所以需要其他的方法“模拟”实现sleep函数 方法一：通过比较当前时间 function sleep(numberMillis) { var now = new Date(); var exitTime = now.getTime() + numberMillis; while (true) { now = new Date(); if (now.getTime() &gt; exitTime) return; }} 方法二：jQuery中的$.delay()方法，下面这个例子：在slideUp()和.fadeIn()之间延时800毫秒 $(‘#foo’).slideUp(300).delay(800).fadeIn(400); 方法三：setTimeout，假设有三个步骤，步骤之间需要暂停一段时间；可以采用如下的方法： function firstStep() {//do somethingsetTimeout(“secondStep()”, 1000);}function secondStep() {//do somethingsetTimeout(“thirdStep()”, 1000);}function thirdStep() {//do something} 方法四：ES6的promise async function test() { console.log(‘Hello’) await sleep(1000) console.log(‘world!’)} function sleep(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms))} test() 3、复制内容后面附加额外内容复制网页上面内容时，自动在剪切板内容后面加上网站信息，这样也利于SEO优化： document.body.oncopy = function () { setTimeout(function (){ var text = clipboardData.getData(“text”); if (text) { text = text + “\\r\\n本篇文章来源于 www.地址.COM 原文链接：”+location.href; clipboardData.setData(“text”, text); } }, 100)} 4、很简单的省略字数$(“.omit_word_class”).each(function(){ var ntext = $(this).text(); var nlen = $(this).text().length; if(nlen&gt; 7){ $(this).text(ntext.substring(0,7) + “…”); }}); 5、JS的动画帧关于requestAnimationFrame，我对它的理解也很浅层，推荐这篇张鑫旭对于requestAnimationFrame的讲解 window.requestAnimFrame = (function(){ return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function( callback ){ window.setTimeout(callback, 1000 / 60); };})(); 6、JS判断字符串长度方法一，给String的prototype添加方法 String.prototype.gblen = function() { var len = 0; for (var i=0; i&lt;this.length; i++) { if (this.charCodeAt(i)&gt;127 || this.charCodeAt(i)==94) { len += 2; } else { len ++; } } return len;} 方法二，利用ASCII码 function strlen(str){ var len = 0; for (var i=0; i&lt;str.length; i++) { var c = str.charCodeAt(i); //单字节加1 if ((c &gt;= 0x0001 &amp;&amp; c &lt;= 0x007e) || (0xff60&lt;=c &amp;&amp; c&lt;=0xff9f)) { len++; }else { len+=2; } } return len;} 方法三：把双字节的替换成两个单字节的然后再获得长度 getBLen = function(str) { if (str == null) return 0; if (typeof str != “string”){ str += “”; } return str.replace(/[^\\x00-\\xff]/g,”01”).length;} 7、jQuery控制超出规定长度显示省略号给需要显示省略号的标签设置class为displayPart，然后设置自定义属性displayLength，该属性为可显示长度（不包含…），该方法会区分中英文，中文字符相当于两个字节 $.fn.extend({ displayPart:function () { var displayLength = 100; displayLength = this.attr(“displayLength”) || displayLength; var text = this.text(); if (!text) return “”; var result = &quot;&quot;; var count = 0; for (var i = 0; i &lt; displayLength; i++) { var _char = text.charAt(i); if (count &gt;= displayLength) break; if (/\\[^x00-xff\\]/.test(_char)) count++; //双字节字符，//\\[u4e00-u9fa5\\]中文 result += _char; count++; } if (result.length &lt; text.length) { result += &quot;...&quot;; } this.text(result); }}); $(“.displayPart”).each(function(){ $(this).displayPart();}); 8、去除字符串首尾的空白字符如果引入了jQuery，可以直接利用$.trim()方法，如果没有就需要用到下面的正则表达式 function trim(ostr){ return ostr.replace(/^\\s+|\\s+$/g,””);} 9、判断数组中是否包含某个元素var arr = [ “xml”, “html”, “css”, “js” ]; 1. $.inArray(“js”, arr); //返回 3, 2. 如果不包含在数组中,则返回 -1; 10、获取日期并格式化(function getDateStr(AddDayCount){ var dd = new Date(); dd.setDate(dd.getDate()+AddDayCount);//获取AddDayCount天后的日期 var y = dd.getFullYear(); var m = dd.getMonth()+1;//获取当前月份的日期 var d = dd.getDate(); return y+”-“+m+”-“+d;})(-2); 11、根据屏幕宽度改变html的font-size大小结合rem可以很轻松的实现移动端的响应式大小效果 (function(win) { function setUnitA() { document.documentElement.style.fontSize = document.documentElement.clientWidth / 16 + “px”; } var h = null; window.addEventListener(“resize”, function() { clearTimeout(h); h = setTimeout(setUnitA, 300); }, false); setUnitA();})(window); 12、JS/jQuery获取url参数//—————javaseript获取url中的参数—————-//* 用法：//* var args = getArgs( ); // 从 URL 解析出参数//* var q = args.q || “”; // 如果定义了某参数，则使用其值，否则给它一个默认值//* var n = args.n ? parseInt(args.n) : 10;//*/var getArgs = function (){ var args = new Object( ); //声明一个空对象 var query = window.location.search.substring(1); // 取查询字符串，如从 http://www.snowpeak.org/testjs.htm?a1=v1&amp;a2=&amp;a3=v3#anchor 中截出 a1=v1&amp;a2=&amp;a3=v3。 var pairs = query.split(“&amp;”); // 以 &amp; 符分开成数组 for(var i = 0; i &lt; pairs.length; i++) { var pos = pairs[i].indexOf(‘=’); // 查找 “name=value” 对 if (pos == -1) continue; // 若不成对，则跳出循环继续下一对 var argname = pairs[i].substring(0,pos); // 取参数名 var value = pairs[i].substring(pos+1); // 取参数值 value = decodeURIComponent(value); // 若需要，则解码 args[argname] = value; // 存成对象的一个属性 } return args; // 返回此对象}; 13、返回一个最小值与最大值中间的随机值function random(min,max){ return min + (max - min) * Math.random();} 14、限制上传文件格式和大小function fileChange(target) { var name=target.value; var fileType = name.substring(name.lastIndexOf(“.”)+1).toLowerCase(); //获取文件格式 var fileArr=name.split(“\\\\”); var fileName=fileArr[fileArr.length-1]; //获取文件名称 if(fileType !=”jpg” &amp;&amp; fileType !=”png”){ alert(“请选择jpg或者png格式图片文件上传！”); target.value=””; return false; }else{ var fileSize = target.files[0].size/1024; //获取文件大小，单位为kb console.log(fileSize); if (fileSize &gt; 40) { alert(“图片文件大小不得超过40kb!”); target.value=””; return false; }else{ var url=getObjectURL(target.files[0]); //获取图片url console.log(url); $(“.modal_brand .upload_img”).attr(“src”,url); //显示上传图片 console.log($(“.modal_brand .upload_img”).attr(“src”)); $(“.modal_brand .img_name p”).text(fileName); //显示上传图片文件名 } }} 15、一个HTML转义函数function escapeHTML(text) { var replacements= {“&lt;”: “&lt;”, “&gt;”: “&gt;”,”&amp;”: “&amp;”, “\\“”: “””}; return text.replace(/[&lt;&gt;&amp;”]/g, function(character) { return replacements[character]; });}","categories":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://merrier.wang/tags/JS/"},{"name":"jQuery","slug":"jQuery","permalink":"http://merrier.wang/tags/jQuery/"}]},{"title":"HTTP的各种状态码响应参数返回值","slug":"HTTP的各种状态码响应参数返回值","date":"2017-03-15T07:31:54.000Z","updated":"2019-01-17T13:21:55.950Z","comments":true,"path":"20170315/various-status-codes-of-http.html","link":"","permalink":"http://merrier.wang/20170315/various-status-codes-of-http.html","excerpt":"","text":"由于无法找到该文章的原创作者,在此无法注明出处,请作者见谅.如有问题或侵害到您的利益,请与我联系. 1：请求收到，继续处理 2：操作成功收到，分析、接受 3：完成此请求必须进一步处理 4：请求包含一个错误语法或不能完成 5**：服务器执行一个完全有效请求失败 状态代码 状态信息 含义 100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新） 200 OK 一切正常，对GET和POST请求的应答文档跟在后面。 201 Created 服务器已经创建了文档，Location头给出了它的URL。 202 Accepted 已经接受请求，但处理尚未完成。 203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。 204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。 300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。 出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。 注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user（缺少了后面的斜杠），有的服务器返回301，有的则返回302。 严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。 304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。 307 Temporary Redirect 和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请 求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。（HTTP 1.1新） 400 Bad Request 请求出现语法错误。 401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。 403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 404 Not Found 无法找到指定位置的资源。这也是一个常用的应答。 405 Method Not Allowed 请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新） 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新） 409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。（HTTP 1.1新） 411 Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新） 412 Precondition Failed 请求头中指定的一些前提条件失败（HTTP 1.1新）。 413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。 414 Request URI Too Long URI太长（HTTP 1.1新）。 416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） 500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。 502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新） 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新） 英文版： 100：Continue 101：Switching Protocols 102：Processing 200：OK 201：Created 202：Accepted 203：Non-Authoriative Information 204：No Content 205：Reset Content 206：Partial Content 207：Multi-Status 300：Multiple Choices 301：Moved Permanently 302：Found 303：See Other 304：Not Modified 305：Use Proxy 306：(Unused) 307：Temporary Redirect 400：Bad Request 401：Unauthorized 402：Payment Granted 403：Forbidden 404：File Not Found 405：Method Not Allowed 406：Not Acceptable 407：Proxy Authentication Required 408：Request Time-out 409：Conflict 410：Gone 411：Length Required 412：Precondition Failed 413：Request Entity Too Large 414：Request-URI Too Large 415：Unsupported Media Type 416：Requested range not satisfiable 417：Expectation Failed 422：Unprocessable Entity 423：Locked 424：Failed Dependency 500：Internal Server Error 501：Not Implemented 502：Bad Gateway 503：Service Unavailable 504：Gateway Timeout 505：HTTP Version Not Supported 507：Insufficient Storage","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://merrier.wang/tags/HTTP/"}]},{"title":"Wordpress插件推荐","slug":"Wordpress插件推荐","date":"2017-03-14T12:54:24.000Z","updated":"2019-01-17T13:21:55.954Z","comments":true,"path":"20170314/wordpress-plugin-recommendation.html","link":"","permalink":"http://merrier.wang/20170314/wordpress-plugin-recommendation.html","excerpt":"","text":"这可能是我的唯一一篇纯wordpress文章了吧，但是毫不虚假的说，我用wordpress也已经有两天了（感觉屏幕前的你已经握拳了），但是个人博客可能会用很久，毕竟会凝聚自己很多年的心血，所以在搭建完善的过程中可能会遇到wordpress的各种坑，或者某一天的某个时间发现了某个好玩或好用的东西，就索性写篇文章作为过程中的总结吧，如果对你能够起到一丝丝的帮助就是极好的了。话不多说，直入主题： 1.Easy WP SMTP这个插件是我在看慕课网的wordpress教程的时候看到的，主要用来解决wordpress发送邮件会被屏蔽的bug，从wordpress安装插件的界面可以看到这款插件活跃安装有10W+，所以从一定角度说明了这个插件有多强大。但是，仅仅安装是不够的，还需要设置一些SMTP相关内容，关于此插件如何设置，慕课网上的相关视频已经讲的很清楚了，点击上面那个按钮即可。 2.WP User Avatar这个插件同样是在看慕课网的wordpress教程的时候看到的。。讲师说是用来解决头像问题，他的视频中头像是带一个×号的（就和网页中加载图片失败后显示的样子差不多），而我这里在未安装这款插件的时候的默认头像是一个灰底的白色小人，所以应该是wordpress后来更新了这个bug，但是不安装插件的话其他用户还是没有办法上传并修改头像的，所以这款插件还是很有必要安装的，具体的setting讲解看慕课网的视频即可。 3.Wp-syntax这个插件是我在写文章的时候发现的，因为想在文章中插入代码（作为一个码农，这个需求应该再正常不过了），然后我发现后台自带的编辑器是没办法高亮显示的，所以就baidu了一下，然后就搜到了这款插件，在wordpress里搜索到它有10000+活跃安装，所以应该还可以，而且看介绍支持的语言简直覆盖了整个代码界，所以如果你也有同样需求的话，这款插件应该不容错过（话不多说，我去试用了 = =） 可是，这个插件用的并不顺利，启用之后按照网上的格式进行了编辑，然而有一个莫名其妙的bug出现了，先上图： 可以看到标签里面的双引号竟然是中文的，而且一半是中文，一半是英文，我在后台编辑的时候试了各种方法打出英文双引号，但是在后台编辑器里是””，但是到了前端页面就不是了，到目前为止我仍然不知道为什么……不知道是我的问题还是这款插件的bug，所以只能换个插件了（其实已经解决了双引号的bug，但是这款插件的效果依然没有看到，所以代码高亮只能用其他插件了，可以向下看）。 4.Jetpack这款插件在推荐里是第二位，然后我就去查了一下，果然有代码块的功能，果断安装试用，然而，我在连接的时候遇到了下面一个error： 翻译过来就是说我的根目录下的xmlrpc.php里面有空格，可能是别的插件或主题引起的，然后让我去一个网址看解决方案，我打开了那个网址： 确实给出了解决方案，然而我按照那个方案里说的把所有插件都禁用，并且主题更换为默认主题之后还是报错，然后去wp-config.php查看，第一个&lt;?php前面根本就没有空格，所以，这个问题就搁置在这里了，如果我找到解决方案了，我再回来更新吧…… 5.Quotmarks Replacerwordpress有一个bug，就是英文的双引号””会被强制转换成中文双引号“”，这个我在上面已经提到过了，然后我就查了一下，发现网上的回答基本上都是这样的： 按照第二个方法的解释，我去formatting.php里查找了一下，可能因为我所用的wordpress的版本比较高，所以并没有找到同样的代码（第一个static strings找到了，注释掉之后类似于’’’这样的仍然会被强制转换为’‘’）；然后尝试了第一种方法，也就是此款插件，虽然活跃安装很少，只有600+，但是完美的解决了我的问题，值得推荐一把；至于第三种方法，我并没有去试，因为我的问题已经解决了呀~！ 6.Pure-Highlightjs在试过了好多插件之后，终于找到一个可以用的代码高亮插件了，这款插件是一个长期玩wordpress的同学介绍的，在wordpress自带的插件库里搜索不到，我就直接给个现在下载链接好了，点我下载，下载之后上传启用，然后回到后台文章编辑的页面，就可以看到工具条里多了一个”&lt;&gt;”符号，点击之后就可以插入代码了： 可以插入多种类型的代码，效果还是蛮不错的。 更新：我最后采用的是后面那款插件，感觉更加强大，满分推荐！ 7.TablePress这款插件只能用一个词来描述，就是“太强大了”，作为一个表格管理的插件，不仅可以创建表单，还可以将创建的表单导入导出，供给多个wordpress网站使用；TablePress 所制作的表单，样式精美，具有翻页功能，搜索功能等非常强大的功能，全简体中文操作，简单易懂，活跃安装50W+，已经可以说明一切了，五星好评推荐，我在另一篇文章中用到了这款插件，戳我一下，下面一张功能列表镇楼： 8.Easy Add Thumbnail其实，这款插件的实用性仍然有待商议，它的功能是如果你没有给文章设置特色图片，就将你文章中的第一张图片设置为特色图片。。如果有喜欢这个功能的朋友可以尝试一下，1W+的活跃安装不容小觑。 9.Crayon Syntax Highlighter这款插件是在别人的博客中看到的（所以说，多看别人的网站是多么的有用~），被它朴实大方的样式吸引的我果断安装，5W+的活跃安装也算是扬名在外了，果不其然，这款插件提供的功能和上面那款表格插件一样多： 这个主题是指代码块的样式，默认是Classic，然而充满个性气质的我果断换了名叫Github的主题（这款主题为什么叫Github？？） 鉴于移动端的汹涌态势，工具栏始终显示还是值得考虑的，因为移动端没有hover事件啊（默认是鼠标放上去才显示，但是这样移动端的交互就不太好了） 这个默认语言设置还是蛮关键的，因为一般的个人博客可能只会发某种语言的文章，设置好默认语言之后可能会省去很多设置语言的时间。这款插件的功能还有很多，在这里就不一一介绍了，自己安装之后去看就好了。 10.Akismet是Wordpress官方推荐的一款WordPress防垃圾评论插件，是默认已安装的插件，但是需要到后台去启用一下。不过从后台看的话，该插件的名字叫做Akismet Anti-Spam，而且需要配置一下，步骤比较简单，就不一一截图了 11.Google XML SitemapsGoogle XML Sitemaps 是一个使用非常广泛的XML网站地图插件，通过它，你可以很轻松为你的 WordPress 博客生成 Sitemap，方便搜索引擎抓取你博客的文章。（不过中国的互联网环境大家懂得，如果没有特殊需求的话我建议你考虑下面那个插件，在国内作用会更大一点） 12.Baidu Sitemap Generator同样是生成sitemap XML文件的插件，这款插件是国人柳城制作的，对于国内的用户会更加友好，安装启用之后还要进行一些设置，可以点击这里查看如何设置。 13.DB Cache Reloaded Fix + Hyper Cache两个都是缓存插件，主要用于减少对数据库的请求次数和缓存404页等功能，但已经好久没更新了，不放心的还是慎用吧，安装启用之后还需要一些额外的设置，都是很简单的英文，自己去看好了。 14.EWWW Image Optimizer这款插件是我在逛知乎的时候看到的，无损压缩 JPEG 和 PNG 图像，支持压缩已有的图像，可以加快访问者加载图片的速度。同时支持 JPEG 的渐进式加载。正常情况下，网速低时，图片是一点点从上往下加载，而使用渐进式加载，则是先加载这个图片的低分辨率版本，然后逐渐变得清晰。40W+的活跃安装简直无敌，不过是收费的，330张图片1美元大概，如果网站访问量很大的话还是很有必要买的。 15.Wordfence安全防御插件，可限制密码尝试次数防止暴力破解，可为你的 WordPress 增加 WAF 功能，查看实时访问。安装完之后发现确实很庞大，但是缺点是都是英文，而且需要配置的内容比较繁杂，英语不好的人看着有点累（比如我），但是具体好不好用还是自己试用之后再说吧。 16.WP Fastest Cache开启缓存也是一个能快速提升WordPress网站访问速度的方法，立竿见影，这里推荐一个插件，有免费版的，我们用免费的足够了。需要自己设置一下，主要是设置压缩css文件和js文件。 17.a3 Lazy Load图片懒加载也就是图片延时加载，简单点说就是只加载页面上能看到的图片，从而减短页面的等待时间，当访客需要看其他的图片的时候再加载相应的图片。但是当我启用这个插件之后，首页上的图片半天都不显示，所以我最后并没有启用这个插件。 18.WPJAM这个插件是我在配置七牛云存储的时候看到的，因为安装七牛云插件必须先安装这款插件，所以我只能尝试着安装了，这款软件的活跃安装只有4000+，但是安装完之后发现还是挺强大的，下面是它的功能截图（其实还有一些功能，但是一张图片截不下了）： 可以看到其提供的功能还是蛮多的，推荐一下 19.七牛云在之前做外包的时候碰到一个项目，它把所有的大型图片都放在了七牛云上，当时我根本不知道七牛是什么，但是感觉肯定是个牛逼的东西；后来我在自己探索wordpress插件的时候发现wordpress也有“七牛云”插件，于是抱着一颗好奇心尝试了一下，感觉速度的确有所提升，具体操作流程如下： 配置七牛云空间首先，到七牛云官网申请一个账号，然后申请一个公开的空间，你可以将七牛云上的空间理解为网盘，七牛云会将你网站的静态资源存储到你申请的空间中，然后将空间和域名进行绑定，见下图： 加速的域名需要先备案，然后才可以用，毕竟七牛也不想担责任 安装“七牛镜像存储 WordPress插件”后台搜索即可，安装过程应该不会遇到什么问题，安装之后进入设置页面开始进行配置 配置七牛云存储插件需要配置的有域名、空间名、ACCESS KEY和SECRET KEY，前两个是自己在七牛云网站上设置的，直接填进去就行了；后面两个密钥在个人面板中的密钥管理中可以看到，然后保存之后就可以了，就是如此简单粗暴！ 20.DisqusDisqus是一家社会化评论系统，主要为网站主提供评论托管服务；说白了，就是让你网站的评论系统更加社交化，同时Disqus也为网站主提供了很多功能，所以Disqus其实不仅仅可以在wordpress中使用，在许多其他类型的网站上都可以使用；在这里我主要介绍一下在wordpress中如何使用Disqus，首先是安装Disqus插件（直接搜索”Disqus”，活跃安装最多的那个就是），然后需要去Disqus官网注册一个账号，安装完插件之后配置Disqus（由于是个国外的插件，所以可能会安装失败，多试几次就好了）：此时需要在Disqus的配置界面验证你刚才注册的账号密码，然后就配置完成了，下面是配置完成之后我的博客的评论界面： 从上面的截图中可以看到，Disqus评论系统的整体风格还是很简单大方的，同时提供了分享功能、推荐功能以及自定义排序功能，是一款目前为止我认为最好的社会化评论系统（国内的多说已经关闭了，真希望Disqus早日打通中国市场，不要被墙啊！）；我的介绍不太详细，其实官网还需要配置一些东西，具体可参见：wordpress如何使用评论插件Disqus 21.wumii关联推荐无觅关联推荐，援引它的官网中的一句话“来自前亚马逊推荐引擎团队，利用大数据分析带给你网站最精准的关联推荐服务，只需1分钟就可以看到效果”。通俗点来说，它可以智能的分析出你博客中的文章内容，当用户在看你的文章时，可以推荐相关联的文章。安装其实很简单，按照它的指引一步步安装就行了，我试用了一下，功能还是很强大的： 其实除了图上这些，它还提供了其他多种功能，一张图截不下了，感兴趣的童鞋可以试用一下，反正不花钱~ 22.WP-PostViews这款插件是用来显示文章浏览次数/查看次数的，因为我用的wordpress主题Dux自带这个功能，所以就没有用这个插件，但是看其他人推荐过这款插件，就也向大家推荐一下吧，但是具体好用与否真的不得而知了，因为现在大部分wordpress用户都会选择一些比较“高大上”的主题，而这些主题往往自带这种功能，所以用处并不是很大。。这款插件的具体用法参见WordPress显示文章浏览次数/查看次数 23.Disable Google Fonts禁用 WordPress 上所有的谷歌字体，为什么要用这款插件呢，你懂得~ 24.TinyMCE Advanced为 WordPress 自带编辑器 TinyMCE 提供进阶功能设置和选项。非常好用的一款插件，强烈推荐使用，不过我是在博客上线一年多以后才发现的，很难受啊。。 Yoast SEO 真正的多合一 WordPress SEO 插件，该插件会检测你的网站在SEO方面有哪些不足以及如何优化。不过可能广告比较多。推荐配合下面这款插件进行使用 26. Remove Yoast SEO Comments移除 Yoast 的广告信息。功能就是如此的单一，就问你怕不怕 27. 蜜蜂采集这是一个微信公众号文章导入插件，通过粘贴公众号文章链接即可实现一键导入公众号文章到自己的网站，并且支持批量导入、自动采集、设置特色图片等功能，减少繁琐的操作，支持知乎专栏文章、简书文章、今日头条导入等，不过免费版的有次数限制，介意的话就算了- -","categories":[{"name":"wordpress","slug":"wordpress","permalink":"http://merrier.wang/categories/wordpress/"}],"tags":[{"name":"推荐","slug":"推荐","permalink":"http://merrier.wang/tags/推荐/"},{"name":"wordpress","slug":"wordpress","permalink":"http://merrier.wang/tags/wordpress/"}]}]}