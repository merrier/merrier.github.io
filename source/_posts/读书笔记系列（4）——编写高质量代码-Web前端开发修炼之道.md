---
title: 读书笔记系列（4）——编写高质量代码-Web前端开发修炼之道
urlname: the-way-to-practice-web-front-end-development
id: 509
categories:
  - 前端
tags:
  - 笔记
date: 2017-04-06 16:42:13
---

1.Web标准----结构、样式和行为的分离
======================

Web标准由一系列标准组合而成,其核心理念就是将网页的结构,样式和行为分离开来,所以它可以分为三大部分:结构标准,央视标准和行为标准.结构标准包括XML标准,XHTML标准,HTML标准;样式标准主要是指CSS标准;行为标准主要包括DOM标准和ECMAScript标准.

2.打造高品质的前端代码,提高代码的可维护性----精简,重用,有序
==================================

精简的代码可以让文件变小,有利于客户端快速下载;重用可以让代码更易于精简,同时有助于提升开发速度;有序可以让我们更清晰地组织代码,使代码易于维护,有效应对变化.

3.欲精一行,必先通十行
============

在前端开发领域,不通十行就无法精一行. 专精很难,甚至不可能,一专多能才是现实的.在前端开发这个领域,一专多能更是非常必要的.

4.增加代码可读性----注释
===============

一个好的代码,注释要占1/3的篇幅

5.磨刀不误砍柴工----前期的构思很重要
=====================

构思的内容主要包括规范的指定,公共组件的设计和复杂功能的技术方案等.一般来说,前期构思占整个项目30%~60%的时间都算是正常的.

6.标签的语义
=======

HTML标签的设计都是有语义考虑的.下表是部分标签的全称和中文翻译. ![](http://note.youdao.com/yws/res/3382/5685DC4101B64652B9FE17320553DEE3) ![](http://note.youdao.com/yws/res/3384/0D3EB178FE6944E3BE7FE579E48D3110) 其中,**div和span其实是没有语义的**,它们只是分别用作块级元素和行内元素的区域分隔符. 事实上,CSS布局只是Web标准的一部分.在HTML,CSS,JavaScript这三大元素中,HTML才是最重要的,结构才是重点,样式是用来修饰结构的.正确的做法是,先确定HTML,确定语义的标签,再来选用合适的CSS.

7.如何确定你的标签是否语义良好
================

判断网页标签语义是否良好的一个简单方法就是:**去掉样式,看网页结构是否组织良好有序,是否仍然有很好的可读性**. 除了去样式后的可读性外,值得重点提及的还有h标签.h标签的含义是"标题",搜索引擎对这个标签比较敏感,尤其是h1和h2.一个语义良好的页面,h标签应该是完整有序没有断层的.也就是说,**要按照h1,h2,h3,h4这样依次排列下来,不要出现类似h1,h2,h3,h4,漏掉h2的情况**.

8.常见模块
======

(1)标题和内容
--------

当页面内标签无法满足设计需要时,才会适当添加div和span等无语义标签来辅助实现.

(2)表单
-----

<form action="" method="">
  <fieldset>
    <legend>登录表单</legend>
    <p><label for="name">账号：</label><input type="text" id="name" /></p>
    <p><label for="pw">密码：</label><input type="password" id="pw" /></p>
    <input type="submit" value="登录" class="subBtn" />
  </fieldset>
</form>

一般来说,表单域要用fieldset标签包起来,并用legend标签说明表单的用途.因为fieldset默认有边框,而legend也有默认的样式,为满足设计需要,我们可以将fieldset的"border"设为"none",把legend的"display"设为"none",以此来兼顾语义和设计两方面的要求.每个input标签对应的说明文本都需要label1标签,并且通过为input设置id属性,在label标签中设置"for=someld"来让说明文本和相应的input关联起来.

(3)表格
-----

表格标题要用caption,表头要用thead包围,主体部分用tbody包围,尾部要用tfoot包围,表头和一般单元格要区分开,表头用th,一般单元格用td.

9.语义化标签应注意的一些其他问题
=================

为了保证网页去样式后的可读性,并且又符合Web标准,我们应注意以下几点:

*   尽可能少的使用无语义标签div和span;
*   在语义不明显,既可以用p也可以用div的地方,尽量用p,因为p默认情况下有上下间距,去样式后的可读性更好,对兼容特殊终端有利;
*   不要使用纯样式标签,例如b,font和u等,改用CSS设置.语义上需要强调的文本可以包在strong或em标签里,strong和em有"强调"的语意,其中strong的默认样式是加粗,而em的默认样式是斜体.

10.如何组织CSS
==========

一种组织CSS的方法:**base.css+common.css+page.css**.将网站内的所有样式,按照职能分成三大类:base,common和page.

(1)base层
--------

这一层位于三者的最底层,提供CSS reset功能和粒度最小的通用类----原子类.这一层会被所有页面引用,是页面样式所需依赖的最底层.这一层与具体UI无关,无论何种风格的设计都可以引用它,所以base层要力求精简和通用.base层具有高度可移植性,不同设计风格的网站可以使用同一个base层. base层相对稳定,基本上不需要维护.

(2)common层
----------

这一层位于中间,提供组件级的CSS类.我们可以将页面内的元素拆分成一小块一小块功能和样式相对独立的小"模块",这些"模块"有些是很少重复的,有些是会大量重复的,我们可以将大量重复的"模块"视为一个组件.我们从页面里尽可能多的将组件提取出来,放在common层里.common层就相当于MVC模式中的M(Model,模型).为了保证重用性和灵活性,M需要尽可能将内部实现封装,对可能会经常变化的部分提供灵活的接口. common层是网站级的,不同的网站有不同的common层,同一个网站只有一个common层.在团队合作中,common层最好由一个人负责,统一管理.

(3)page层
--------

网站中高度重用的模块,我们把它们视为组件,放在common层;非高度重用的模块,可以把它们放在page层.page层位于最高层,提供页面级的样式,对重用性没有要求. base层基本上不需要维护,common层修改的幅度不会很大,通常只由一个人负责维护,但到了page层,代码可能由多人开发,如何避免冲突是个需要注意的问题.通常我们通过命名规则来避免这种冲突.

11.推荐的base.css
==============

通常情况下,为了让浮动元素的父容器能够根据浮动元素的高度而自适应高度,有三种做法:

*   让父容器同时浮动起来,例如:"<div class="fl"><div class="fl"></div></div>";
*   让浮动元素后面紧跟一个用于清楚浮动的空标签,例如"<div><div class="fl"></div><div class="cb"></div></div>"
*   **给父容器挂一个特殊class,直接从父容器清除浮动元素的浮动,例如"<div class="clearfix"><div class="fl"></div></div>"** **第一种方法会让父容器也浮动起来,影响父元素后面的元素的布局,有副作用.第二种方法增加了一个空标签,破坏了语义化.第三种方法没有任何副作用,推荐使用.**

.clearfix:after{ content:".";display:block;height:0;clear:both;visibility:hidden } .clearfix{ display:inline-block }

12.拆分模块
=======

*   模块与模块之间尽量不要包含相同的部分,如果有相同部分,应将它们提取出来,拆分成一个独立的模块.
*   模块应在保证数量尽可能少的原则下,做到尽可能简单,以提高重用性.

13.CSS的命名
=========

推荐使用英语,不要使用汉语拼音.我们可以根据内容来选用合适的英文单词命名CSS.比如头部用head,底部用foot,主体部分用main,导航用nav,菜单用menu等，page层css命名不可过短,可以将开发人员名字缩写作为前缀,以免发生冲突.

14.挂多个class还是新建class----多用组合,少用继承
=================================

在面向对象编程里,有个很重要的原则就是"多用组合,少用继承". HTML的class与程序中"类"有相同的"味道",class可以挂多个,从技术上支持了"组合"的用法.我们在使用CSS时,如果能灵活运用这点就可以大大减少类的数量,一方面减少了代码量,提高了可维护性,另一方面时类的职责更单一,弹性更强,增加了类的重用性,提高了开发效率.

15.组件的margin
============

如果对相邻的模块同时使用了margin-top和margin-bottom,边距会重合带来不必要的麻烦,所以最好统一使用margin-top或者margin-bottom,不要混合使用,从而降低出现问题的风险. 总结:如果不确定模块的上下margin特别稳定,最好不要将它写到模块的类里,而是使用类的祝贺,单独为上下margin挂用于边距的原子类(例如mt10,mb20).模块最好不要混用margin-top和margin-bottom,统一使用margin-top或margin-bottom

16.低权重原则----避免滥用子选择器
====================

除非确定HTML结构非常稳定,一定不会再修改了,否则尽量不要使用子选择器.为了保证样式容易被覆盖,提高可维护性,CSS选择符需保证权重尽可能低.

17.CSS sprite技术
===============

CSS sprite技术看似简单,其实不容易掌握,主要有如下原因:

*   它能合并的只能是用于背景的图片,对于<img src="" />设置的图片,是不能合并到CSS sprite大图中的,如果合并这些图片会影响页面可读性.
*   对于横向和纵向都平铺的图片,也不能使用CSS sprite;如果是横向平铺的,只能将所有横向平铺的图合并成一张大图,只能竖直排列,不能水平排列;如果是纵向平铺的,我们只能将所有纵向平铺的图合并成一张大图,只能水平排列,不能竖直排列.
*   图片如何排列能够尽量紧凑,同时保证不会影响扩展性.这点是CSS sprite技术最困难也是最具挑战性的地方.

18.CSS hack
===========

(1)IE条件注释法
----------

![](http://note.youdao.com/yws/res/3594/24ECD13AD5254129A6610ADFDEFEC0F1) ![](http://note.youdao.com/yws/res/3596/DAE3A0E0CE0248E495A77FFBAF992C3C) ![](http://note.youdao.com/yws/res/3599/26DD281A85CA4E24BC8208E8B6421E43)

(2)选择符前缀法
---------

![](http://note.youdao.com/yws/res/3605/540FF04AC1214576BA5394A0A5D49E87) 选择符前缀法相较于IE条件注释法来说,可维护性强了很多,但在向后兼容性上存在一点风险.另外,选择符前缀法不能用于内联样式上.

(3)样式属性前缀法
----------

样式属性前缀法的原理是在样式的属性名前加前缀,这些前缀只在特定浏览器下才生效.例如"_"只在IE6下生效,"*"在IE6和IE7下生效. ![](http://note.youdao.com/yws/res/3620/8A867DC3820049C79E01C937E2A84353)

19.a标签的四种状态
===========

关于a标签的四种状态的排序问题,有个简单好记的原则,叫做love hate原则,即l(link)ov(visited)e h(hover)a(active)te

20.hasLayout
============

hasLayout是IE浏览器专有的一个属性,用于CSS的解析引擎.有时候在IE下一些复杂的CSS设置解析起来会出现Bug,其原因可能与hasLayout没有被自动触发有关,我们通过一些技巧,手动触发hasLayout属性就可以解决Bug了. ![](http://note.youdao.com/yws/res/3637/0069E89A1F754506B4FE9F26157ACB50) ![](http://note.youdao.com/yws/res/3639/62B437C152A448F99327328E8F40807C)

21.块级元素和行内元素的区别
===============

*   块级元素会独占一行,默认情况下,其宽度自动填满其父元素宽度,行内元素不会独占一行,相邻的行内元素会排列在同一行里,知道一行排不下,才会换行,其宽度随元素的内容而变化.
*   块级元素可以设置width,height属性.行内元素设置width,height属性无效.块级元素即使设置了宽度,仍然是独占一行的.
*   块级元素可以设置margin和padding属性.行内元素的margin和padding属性很奇怪,水平方向的padding和margin都产生边距效果,但竖直方向的padding,margin却不会产生边距效果.

22.display:inline-block
=======================

它是行内的块级元素,它拥有块级元素的特点,可以设置长宽,可以设置margin和padding值,但它却不是独占一行,它的宽度并不占满父元素,而是和行内元素一样,可以和其他行内元素排在同一行里.

23.relative,absolute和float
==========================

设置position:relative或position:absolute都可以让元素激活left,top,right,bottom和z-index属性(默认情况下,这些属性未激活,设置了也无效) 设置position:relative或position:absolute会让元素"浮"起来,也就是z-index值大于0,它会改变正常情况下的文档流. float也能改变文档流,不同的是,float属性不会让元素"上浮"到另一个z-index层,它仍然让元素在z-index:0层排列. 另外,不论之前什么类型的元素(display:none除外),只要设置了position:absolute,float:left或float:right中的任意一个,都会让元素以display:inline-block的方式显示:可以设置长宽,默认宽度并不占满父元素.就算我们显示地设置display:inline或者display:block,也仍然无效. position:relative不会隐式改变display的类型.

24.居中
=====

(1)水平居中
-------

### a.文本,图片等行内元素的水平居中

父元素设置text-align:center

### b.确定宽度的块级元素的水平居中

margin:0 auto

### c.不确定宽度的块级元素的水平居中

*   第一种方法:将ul包含在table标签内,对table设置margin:0 auto就可以使table水平居中,间接地使ul实现了水平居中.
*   第二种方法:改变块级元素的display为inline类型，然后使用text-align：center来实现居中.
*   第三种方法:给父元素设置float,然后父元素设置position:relative和left:50%,子元素设置position:relative和left:-50%来实现水平居中

(2)竖直居中
-------

### a.父元素高度不确定的文本,图片,块级元素的竖直居中

给父容器设置相同上下边距实现的

### b.父元素高度确定的单行文本的竖直居中

通过给父元素设置line-height来实现的,line-height值和父元素的高度值相同.

### c.父元素高度确定的多行文本,图片,块级元素的竖直居中

块级元素的display:table-cell,vertical-align:center.

25.使用匿名函数控制变量的作用域
=================

(function(){ var a，c="abc"; })(); 这种形式很巧妙,先定义一个匿名的function,然后立即执行它.包在这个匿名function里的变量,作用域就不再是window,而是局限在函数内部.用匿名函数将脚本包起来,可以有效控制全局变量,避免冲突隐患.让JS不产生冲突,需要避免全局变量的泛滥,合理使用命名空间以及为代码添加必要的注释.

26.window.onload和DOMReady
=========================

window.onload需要当页面完全加载完成时才会触发,包括图片,Flash等富媒体,DOMReady只判断页面内所有的DOM节点是否已经全部生成,至于节点的内容是否加载完成,它并不关心. DOMReady比window.onload更适合用来调用初始化函数. 值得注意的是,DOMReady并不是原生JavaScript支持的事件,它不能像window.load那样直接调用,一般我们都是结合JS框架来使用它.

27.CSS放在页头,JavaScript放在页尾
=========================

将CSS放在页头,在载入HTML元素之前,先载入它们的样式,这样可以避免HTML出现无样式状态; 将JavaScript放在页尾,先将网页呈现给用户,再来加载页面内的脚本,避免JavaScirpt阻塞网页的呈现,减少页面空白的时间.

28.引入编译的概念----文件压缩
==================

为了减小网页的大小,缩短网页的下载时间,在正式发布JavaScript之前,我们可以先对它进行一下压缩. JS压缩通常的做法是去掉空格和换行,去掉注释,将复杂变量名替换成简单的变量名.

29.JavaScript如何分层
=================

**把JavaScript也分成三层,从下往上依次是base层,common层和page层**

(1)base层
--------

有两个职责,职责一是封装不同浏览器下JavaScript的差异,提供统一的接口,我们可以依靠它来完成跨浏览器兼容的工作.职责二是扩展JavaScript语言底层提供的接口,让它提供更多更为易用的接口.

(2)common层
----------

依赖于base层提供的接口.common层提供可供复用的组件,它是典型的mvc模式中的m,和页面内的具体功能没有直接关系.common层的功能是给page层提供组件.

(3)page层
--------

这一层和页面里的具体功能需求直接相关,是mvc模式中的c.page层的功能是完成页面内的功能需求.

30.JavaScript中的参数
=================

如果一个函数内某个因素很不稳定,我们可以将它从函数内部分离出来,以参数的形式传入,从而将不稳定因素和函数解耦. 在编程里有一个很出名的规则叫做DRY----don't repeat yourself,强调在程序中不要将相同的代码重复编写多次,更好的做法是只写一次,然后在多处引用.

31.JavaScript与面向对象
==================

JavaScript很奇怪,它没有Class关键字,在JavaScript中是用函数来充当类的.函数在JavaScript中既可以当作普通函数使用,也可以当作类来使用,在充当类的时候,它本身又担负着构造函数的责任. 函数作为普通函数使用时,通常直接使用"()"进行调用,而作为类使用时,通常使用new来实例化. 通常情况下,作为函数时我们更倾向于用动词来命名,而作为类时用名词来命名.按照习惯,类名的首字母大写. JavaScript是基于原型的语言,通过new实例化出来的对象,其属性和行为来自于两部分,一部分来自于构造函数,另一部分来自于原型. 当我们声明一个类时,其实同时生成了一个对应的原型,例如我们定义Animal这个类时,会生成一个与Animal类对应的原型,通过Animal.prototype可以指向这个原型,原型可以通过constructor指向Animal类,更确切地说,是指向Animal类的构造函数. 构造函数中定义的属性和行为的优先级比原型中定义的属性和行为优先级高,如果构造函数和原型定义了同名的属性和行为,构造函数中的属性和行为会覆盖原型中的同名的属性和行为. this关键字无论出现在构造函数中,还是出现在原型中,指向的都是实例对象,通过this关键字,可以让属性和方法在构造函数和原型间通信. 正统的面向对象语言会提供public,protect,private等关键字来声明属性和行为的可访问性是公有还是私有.但JavaScript并不提供这些关键字,在JavaScript中公有还是私有是通过作用域实现的. ![](http://note.youdao.com/yws/res/3879/868F3F08407E42389EB69FFF7F3AF11A) 把行为写在原型里可以减少内存消耗,没有特殊原因,推荐尽量把行为写在原型里.写在原型中的行为一定是公有的,而且无法访问私有属性。

32.传值与传址
========

var a=10;             //基本数据类型
var b=a;              //将变量a保存的值复制一份，传给变量b，a和b各保存一份数据
var c=\[1,2,3\];        //复杂数据类型
var d=c;              //将变量c指向的数据的内存地址传给变量d，c和b指向同一份数据
b++;
d.push(4);
alert(a);     //10 
alert(b);     //11      变量b保存的数据更改不会影响到变量a
alert(c);     //1,2,3,4 变量c和d指向同一份数据，数据更改会互相影响
alert(d);     //1,2,3,4

在原生JavaScript中，选择传值还是传址是根据数据类型自动判定的，但传址有时候会给我们带来意想不到的麻烦，所以我们需要对复杂类型数据的赋值进行控制，让复杂数据类型也可以进行传值。

33.UML描述类
=========

![](http://note.youdao.com/yws/res/3898/5302B16A4D7146E5A51741C2A2A5B64D) 一个方框代表一个类，将方框划分成上中下三栏，第一栏填入类名，第二栏填入类的属性，第三栏填入类的行为，其中公有属性和公有行为需要在属性和行为名前加上“+”号，而私有属性和私有行为需要在属性和行为名前加上“-”号。

34.prototype和内置类
================

![](http://note.youdao.com/yws/res/3909/58B78541AA594906B671615FC74295CF) 只要是类就会有原型，不管它是自定义类还是JavaScript的内置类，我们可以通过修改内置类的原型，让JavaScript基本类型的对象获得一些有趣的功能。 无论在类的构造函数中还是在原型中，this都指向实例化的对象。 内置类的方法可以重写，但属性却不能重写。 在JavaScript中，包括内置类和自定义类，所有类的祖先类都是Object，所以如果想对所有对象都扩展方法，可以通过修改Object类的原型实现。

35.修改内置类
========

使用自定义类：

function myArray(o){
  this.getArray=function(){
    return o;
  };
}
myArray.prototype={
  each:function(fun){
    var o=this.getArray();
    for(var i=-,n=o.length;i<n;i++){
      fun(o\[i\],i);
    }
  }
}
var a=new nyArray(\[1,2,3\]),str="";
a.each(function(v,k){
  str += k+":"+v+"\\n";
});
alert(str);    //0:1 1:2 2:3

代替直接修改内置类原型的做法，定义一个自定义类，将内置类的实例作为参数传给构造函数，在自定义类里定义扩展方法。这种做法的思路是将内置类再封装一层，以此保护内置类的原型不被污染。 两种方法都各有优缺点，修改内置类的原型非常方便，缺点是可能会带来冲突隐患；自定义类可以保护原型不被修改，但它需要用new来实例化自定义类，相对麻烦一点。如果是小应用，不用过多考虑可维护性，推荐使用前者，如果是大中型应用，需要考虑可维护性，推荐使用后者。

36.自定义属性
========

对于常规属性，统一使用node.XXX的方式读取，对于自定义属性，统一使用node.getAttribute（“XXX”）读取。 将复杂类型的数据转化成字符串，称为数据的序列化，其逆操作叫做数据的反序列化。 字符串的反序列化是通过eval函数实现的。只要字符串长的像JavaScript支持的数据格式，就可以进行反序列化。

<a id="a" href="http://www.adanghome.com" blogInfo="{name:'阿当的博客',
type:'前端开发'}">my blog</a>

<script type="text/JavaScript">
  var node=document.getElementById("a");
  var info=node.getAttribute("blogInfo");
  alert(typeof info);    //string
  alert(info.name);      //undefined
  alert(info.type);      //undefined
  info=eval("(" + info + ")");
  alert(typeof info);    //object
  alert(info.name);      //阿当的博客
  alert(info.type);      //前端开发
</script>

37.代码可维护性
=========

好的可维护性可以从四个方面获得：

*   代码的松耦合，高度模块化，将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从HTML、CSS、JavaScript三个层面考虑模块化。
*   良好的注释。
*   注意代码的弹性，在性能和弹性的选择上，一般情况下以弹性为优先考虑条件，在保证弹性的基础上，适当优化性能。
*   严格按照规范编写代码。