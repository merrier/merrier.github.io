<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Merrier说">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://merrier.wang">
    <!--SEO-->

<meta name="description" content="Merrier的个人博客">



<meta name="keywords" content="merrier 博客 前端 北邮人">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
<meta name="google-site-verification" content="UkMBUrF2qTuMWfmPXWFFmc_pnqCRAxHQY1ndE0Zu1p0">
    <!--Title-->


<title>Leetcode的JS实现——Easy篇（下） | Merrier说</title>


    <link rel="alternate" href="/atom.xml" title="Merrier说" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1264342320 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1264342320%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="Merrier">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 叩首问路，码梦为生 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://merrier.wang">Merrier说</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/frontend/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/algorithm/"><i class="fa "></i>算法</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/series/"><i class="fa "></i>系列专栏</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>文章归档</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Leetcode的JS实现——Easy篇（下）">
            
	            Leetcode的JS实现——Easy篇（下）
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/算法">
            算法
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/JS" title="JS">
                        JS
                    </a>
                
                    <a href="/tags/算法" title="算法">
                        算法
                    </a>
                
                    <a href="/tags/leetcode" title="leetcode">
                        leetcode
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2017/03/26</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这是Leetcode的JS实现——Easy篇的后半部分，前半部分可以<a href="https://merrier.wang/?p=371">点击这里</a>查看</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>leetcode地址：<a href="https://leetcode.com/problemset/algorithms/" target="_blank" rel="noopener">https://leetcode.com/problemset/algorithms/</a> 本文章不会贴出题目，可以点击标题链接查看原题目 排序方式：按照本难度中题目的accepted统计</p>
<h1 id="JS代码实现"><a href="#JS代码实现" class="headerlink" title="JS代码实现"></a>JS代码实现</h1><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121-Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description" target="_blank" rel="noopener">121-Best Time to Buy and Sell Stock</a></h2><p>方法一：动态规划</p>
<p>/**<br> * @param {number[]} prices<br> * @return {number}<br> */<br>var maxProfit = function(prices) {<br>    var maxPro = 0;<br>    var minPrice = prices[0];<br>    for(var i = 0 ,n = prices.length; i&lt;n;i++){<br>        minPrice = Math.min(minPrice, prices[i]);<br>        maxPro = Math.max(maxPro, prices[i] - minPrice);<br>    }<br>    return maxPro;<br>};</p>
<p>方法二：Kadane’s Algorithm</p>
<p>/**<br> * @param {number[]} prices<br> * @return {number}<br> */<br>var maxProfit = functon(pris)<br>    var maxCur = 0, maxSoFar = 0;<br>    for(var i = 1,n = prices.length;i&lt;n; i++) {<br>        maxCur = Math.max(0, maxCur += prices[i] - prices[i-1])<br>        maxSoFar = Math.max(maxCur, maxSoFar);<br>    }<br>    return maxSoFar;<br>};</p>
<h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202-Happy Number"></a><a href="https://leetcode.com/problems/happy-number/#/description" target="_blank" rel="noopener">202-Happy Number</a></h2><p>方法一：Floyd Cycle detection algorithm</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isHappy = function(n) {<br>    var slow, fast;<br>    slow = fast = n;<br>    do {<br>        slow = digitSquareSum(slow);<br>        fast = digitSquareSum(fast);<br>        fast = digitSquareSum(fast);<br>    } while(slow != fast);<br>    if (slow == 1) {return true;}<br>    else {return false;}<br>};</p>
<p>var digitSquareSum = function(n){<br>    var sum = 0, tmp;<br>    while (n) {<br>        tmp = n % 10;<br>        sum += tmp * tmp;<br>        n = Math.floor(n / 10);<br>    }<br>    return sum;<br>};</p>
<p>方法二：O(1)space，如果快=慢，证明陷入了死循环</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isHappy = function(n) {<br>    var x = n,y = n;<br>    while(x&gt;1){<br>        x = cal(x) ;<br>        if(x==1) {return true;}<br>        y = cal(cal(y));<br>        if(y==1) {return true ;}<br>        if(x==y) {return false;}<br>    }<br>    return true;<br>};</p>
<p>var cal = function(n){<br>    var sum = 0, tmp;<br>    while (n) {<br>        tmp = n % 10;<br>        sum += tmp * tmp;<br>        n = Math.floor(n / 10);<br>    }<br>    return sum;<br>};</p>
<p>方法三：Using fact all numbers in [2, 6] are not happy (and all not happy numbers end on a cycle that hits this interval)</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> <em>/<br>var isHappy = function(n) {<br>    while(n&gt;6){<br>        var next = 0;<br>        while(n){<br>            next+=(n%10)</em>(n%10);<br>            n = Math.floor(n/10);<br>        }<br>        n = next;<br>    }<br>    return n==1;<br>};</p>
<h2 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326-Power of Three"></a><a href="https://leetcode.com/problems/power-of-three/#/description" target="_blank" rel="noopener">326-Power of Three</a></h2><p>方法一：递归</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfThree = function(n) {<br>    return n&gt;0 &amp;&amp; (n==1 || (n%3===0 &amp;&amp; isPowerOfThree(n/3)));<br>};</p>
<p>方法二：迭代</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfThree = function(n) {<br>    if(n&gt;1)<br>        while(n%3===0) {n /= 3;}<br>    return n==1;<br>};</p>
<p>方法三：int型数字中最大的3的幂为1162261467</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfThree = function(n) {<br>    return n &gt; 0 &amp;&amp; (1162261467 % n === 0);<br>};</p>
<p>方法四：对n取根值</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfThree = function(n) {<br>    return (Math.log10(n) / Math.log10(3)) % 1 === 0;<br>};</p>
<p>方法五：正则表达式</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> <em>/<br>var isPowerOfThree = function(n) {<br>    var reg = new RegExp(“^10</em>$”,””);<br>    return reg.test(n.toString(3));<br>};</p>
<h2 id="327-Power-of-Two"><a href="#327-Power-of-Two" class="headerlink" title="327-Power of Two"></a><a href="https://leetcode.com/problems/power-of-two/#/description" target="_blank" rel="noopener">327-Power of Two</a></h2><p>方法一：Power of 2 means only one bit of n is ‘1’, so use the trick n&amp;(n-1)==0 to judge whether that is the case</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfTwo = function(n) {<br>    if(n&lt;=0) {return false;}<br>    return !(n&amp;(n-1));<br>};</p>
<p>方法二：同样利用二进制数字中只有1个”1”的特性，用replace()方法求二进制数字中1的数目</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfTwo = function(n) {<br>    return n&gt;0 &amp;&amp; n.toString(2).replace(/0/g,’’).length == 1;<br>};</p>
<p>方法三：迭代</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfTwo = function(n) {<br>    if(n===0) {return false;}<br>    while(n%2===0) n/=2;<br>    return (n==1);<br>};</p>
<p>方法四：递归</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfTwo = function(n) {<br>    return n&gt;0 &amp;&amp; (n==1 || (n%2===0 &amp;&amp; isPowerOfTwo(n/2)));<br>};</p>
<p>方法五：利用int型数字中最大的2的幂</p>
<p>/**<br> * @param {number} n<br> * @return {boolean}<br> */<br>var isPowerOfTwo = function(n) {<br>    return n&gt;0 &amp;&amp; (1073741824 % n === 0);<br>};</p>
<h2 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83-Remove Duplicates from Sorted List"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/#/description" target="_blank" rel="noopener">83-Remove Duplicates from Sorted List</a></h2><p>方法一：递归</p>
<p>/**<br> * Definition for singly-linked list.<br> * function ListNode(val) {<br> *     this.val = val;<br> *     this.next = null;<br> * }<br> */<br>/**<br> * @param {ListNode} head<br> * @return {ListNode}<br> */<br>var deleteDuplicates = function(head) {<br>    if(head === null || head.next === null) {return head;}<br>    head.next = deleteDuplicates(head.next);<br>    return head.val == head.next.val ? head.next : head;<br>};</p>
<h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70-Climbing Stairs"></a><a href="https://leetcode.com/problems/climbing-stairs/#/description" target="_blank" rel="noopener">70-Climbing Stairs</a></h2><p>方法一：斐波那契数列</p>
<p>/**<br> * @param {number} n<br> * @return {number}<br> */<br>var climbStairs = function(n) {<br>    if(n &lt;= 0) return 0;<br>    if(n == 1) return 1;<br>    if(n == 2) return 2;</p>
<pre><code>var one\_step\_before = 2;
var two\_steps\_before = 1;
var all_ways = 0;

for(var i=2; i&lt;n; i++){
    all\_ways = one\_step\_before + two\_steps_before;
    two\_steps\_before = one\_step\_before;
    one\_step\_before = all_ways;
}
return all_ways;
</code></pre><p>};</p>
<p>方法二：从终点向前循环，利用两个指针，a代表到达当前步所有可能方式的个数，b代表到达下一步所有可能方式的个数</p>
<p>/**<br> * @param {number} n<br> * @return {number}<br> */<br>var climbStairs = function(n) {<br>    a = b = 1;<br>    while (n–)<br>        a = (b += a) - a;<br>    return a;<br>};</p>
<h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53-Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray/#/description" target="_blank" rel="noopener">53-Maximum Subarray</a></h2><p>方法一：Basically, keep adding each integer to the sequence until the sum drops below 0.If sum is negative, then should reset the sequence.</p>
<p>/**<br> * @param {number[]} nums<br> * @return {number}<br> */<br>var maxSubArray = function(nums) {<br>    var ans=nums[0],i,j,sum=0;<br>    for(i=0;i&lt;nums.length;i++){<br>        sum+=nums[i];<br>        ans=Math.max(sum,ans);<br>        sum=Math.max(sum,0);<br>    }<br>    return ans;<br>};</p>
<p>方法二：动态规划</p>
<p>/**<br> * @param {number[]} nums<br> * @return {number}<br> */<br>var maxSubArray = function(nums) {<br>    var n = nums.length;<br>    var dp = [];//dp[i] means the maximum subarray ending with nums[i];<br>    dp[0] = nums[0];<br>    var max = dp[0];<br>    for(var i = 1; i &lt; n; i++){<br>        dp[i] = nums[i] + (dp[i - 1] &gt; 0 ? dp[i - 1] : 0);<br>        max = Math.max(max, dp[i]);<br>    }<br>    return max;<br>};</p>
<h2 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437-Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii/#/description" target="_blank" rel="noopener">437-Path Sum III</a></h2><p>方法一：用哈希表来建立所有的前缀路径之和跟其个数之间的映射，然后看子路径之和有没有等于给定值的</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @param {number} sum<br> * @return {number}<br> */<br>var pathSum = function(root, sum) {<br>    var map = [];<br>    map[0] = 1;  //Default sum = 0 has one count<br>    return backtrack(root, 0, sum, map);<br>};</p>
<p>var backtrack = function(root,sum,target,map){<br>    if(root === null) {return 0;}<br>    sum += root.val;<br>    var res = map[sum-target] === undefined ? 0 : map[sum-target];//See if there is a subarray sum equals to target<br>    map[sum] = (map[sum] === undefined ? 0 : map[sum])+1;//Extend to left and right child<br>    res += backtrack(root.left, sum, target, map) + backtrack(root.right, sum, target, map);<br>    map[sum]–;   //Remove the current node so it wont affect other path<br>    return res;<br>};</p>
<p>方法二：利用前序遍历，对于每个遍历到的节点进行处理，维护一个变量pre来记录之前路径之和，然后cur为pre加上当前节点值，如果cur等于sum，那么返回结果时要加1，然后对当前节点的左右子节点调用递归函数求解</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @param {number} sum<br> * @return {number}<br> */<br>var pathSum = function(root, sum) {<br>    if (root === null) {return 0;}<br>    return sumUp(root, 0, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);<br>};</p>
<p>var sumUp = function(node,pre,sum){<br>    if (node === null) {return 0;}<br>    var cur = pre + node.val;<br>    return (cur == sum) + sumUp(node.left, cur, sum) + sumUp(node.right, cur, sum);<br>};</p>
<h2 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501-Find Mode in Binary Search Tree"></a><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/#/description" target="_blank" rel="noopener">501-Find Mode in Binary Search Tree</a></h2><p>方法一：Morris traversal（二叉树遍历方法，<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="noopener">参考链接</a>）</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @return {number[]}<br> */<br>var currVal,<br>    currCount = 0,<br>    maxCount = 0,<br>    modeCount = 0,<br>    modes = []; </p>
<p>var findMode = function(root) {<br>    inorder(root);<br>    modes = new Array(modeCount);<br>    modeCount = 0;<br>    currCount = 0;<br>    inorder(root);<br>    return modes;<br>};</p>
<p>var handleValue = function(val) {<br>    if (val != currVal) {<br>        currVal = val;<br>        currCount = 0;<br>    }<br>    currCount++;<br>    if (currCount &gt; maxCount) {<br>        maxCount = currCount;<br>        modeCount = 1;<br>    } else if (currCount == maxCount) {<br>        if (modes !== null)<br>            modes[modeCount] = currVal;<br>        modeCount++;<br>    }<br>};</p>
<p>var inorder = function(root) {<br>    var node = root;<br>        while (node !== null) {<br>            if (node.left === null) {<br>                handleValue(node.val);<br>                node = node.right;<br>            } else {<br>                var prev = node.left;<br>                while (prev.right !== null &amp;&amp; prev.right != node)<br>                    prev = prev.right;<br>                if (prev.right === null) {<br>                    prev.right = node;<br>                    node = node.left;<br>                } else {<br>                    prev.right = null;<br>                    handleValue(node.val);<br>                    node = node.right;<br>                }<br>            }<br>        }<br>};</p>
<p>方法二：先用递归得到有多少个modes，然后再申请空间保证O(1)的空间复杂度</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @return {number[]}<br> */<br>var currentModes = 0;<br>var currentValue = 0;<br>var currentCount = 0;<br>var modes = [];<br>var maxCount = 0;</p>
<p>var findMode = function(root) {<br>    helper(root);<br>    modes = new Array(currentModes);<br>    currentModes = 0;<br>    currentCount = 0;<br>    helper(root);<br>    return modes;<br>};</p>
<p>var helper = function (root) {<br>    if (root === null) return;<br>    helper(root.left);<br>    if (root.val != currentValue) {<br>        currentCount = 1;<br>        currentValue = root.val;<br>    } else {<br>        currentCount++;<br>    }<br>    if (currentCount &gt; maxCount) {<br>        maxCount = currentCount;<br>        currentModes = 1;<br>    } else if (currentCount == maxCount) {<br>        if (modes !== null){<br>            modes[currentModes] = root.val;<br>            currentModes++;<br>        }<br>    }<br>    helper(root.right);<br>};</p>
<h2 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191-Number of 1 Bits"></a><a href="https://leetcode.com/problems/number-of-1-bits/#/description" target="_blank" rel="noopener">191-Number of 1 Bits</a></h2><p>方法一：利用toString(2)和replace()</p>
<p>/**<br> * @param {number} n - a positive integer<br> * @return {number}<br> */<br>var hammingWeight = function(n) {<br>    return n.toString(2).replace(/0/g,’’).length;<br>};</p>
<p>方法二：利用n=n&amp;(n-1)</p>
<p>/**<br> * @param {number} n - a positive integer<br> * @return {number}<br> */<br>var hammingWeight = function(n) {<br>    var count = 0;<br>    for (;n!==0;n = n &amp; (n-1))<br>        count++;<br>    return count;<br>};</p>
<p>方法三：位运算</p>
<p>/**<br> * @param {number} n - a positive integer<br> * @return {number}<br> */<br>var hammingWeight = function(n) {<br>    var ones = 0;<br>    while(n!==0) {<br>        ones = ones + (n &amp; 1);<br>        n = n&gt;&gt;&gt;1;<br>    }<br>    return ones;<br>};</p>
<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35-Search Insert Position"></a><a href="https://leetcode.com/problems/search-insert-position/#/description" target="_blank" rel="noopener">35-Search Insert Position</a></h2><p>方法一：按部就班遍历</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} target<br> * @return {number}<br> */<br>var searchInsert = function(nums, target) {<br>    for(var i=0,n=nums.length;i&lt;n;i++){<br>        if(target&lt;=nums[i]){<br>            return i;<br>        }<br>    }<br>    return n;<br>};</p>
<p>方法二：二分查找</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} target<br> * @return {number}<br> */<br>var searchInsert = function(nums, target) {<br>    var low = 0, high = nums.length-1;<br>    while(low&lt;=high){<br>        var mid = Math.floor((low+high)/2);<br>        if(nums[mid] == target) {return mid;}<br>        else if(nums[mid] &gt; target) {high = mid-1;}<br>        else {low = mid+1;}<br>    }<br>    return low;<br>};</p>
<h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107-Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/#/description" target="_blank" rel="noopener">107-Binary Tree Level Order Traversal II</a></h2><p>暂无</p>
<h2 id="263-Ugly-Number"><a href="#263-Ugly-Number" class="headerlink" title="263-Ugly Number"></a><a href="https://leetcode.com/problems/ugly-number/#/description" target="_blank" rel="noopener">263-Ugly Number</a></h2><p>方法一：根据丑陋数的定义，我们将给定数除以2、3、5，直到无法整除，也就是除以2、3、5的余数不再为0时停止。这时如果得到1，说明是所有因子都是2或3或5，如果不是1，则不是丑陋数。</p>
<p>/**<br> * @param {number} num<br> * @return {boolean}<br> */<br>var isUgly = function(num) {<br>    for (var p of [2, 3, 5])<br>    while (num &amp;&amp; num % p === 0)<br>        num /= p;<br>    return num == 1;<br>};</p>
<h2 id="459-Repeated-Substring-Pattern"><a href="#459-Repeated-Substring-Pattern" class="headerlink" title="459-Repeated Substring Pattern"></a><a href="https://leetcode.com/problems/repeated-substring-pattern/#/description" target="_blank" rel="noopener">459-Repeated Substring Pattern</a></h2><p>方法一：The idea is that when we see a character in <em>str</em> that matches the very first character of <em>str</em>, we can start to hoping that <em>str</em> is a built by copies of the substring composed by all characters before the reappearance of the its first character.</p>
<p>/**<br> * @param {string} s<br> * @return {boolean}<br> */<br>var repeatedSubstringPattern = function(s) {<br>    var l = s.length;<br>    if(l == 1) {<br>        return false;<br>    }<br>    var sb = ‘’;<br>    var first = s.charAt(0);<br>    sb += first;<br>    var i = 1;<br>    while(i &lt;= l / 2) {<br>        var c = s.charAt(i++);<br>        if(c == first &amp;&amp; isCopies(s, sb)) {<br>            return true;<br>        }else {<br>            sb += c;<br>        }<br>    }<br>    return false;<br>};</p>
<p>var isCopies = function(str,substr) {<br>    if(str.length % substr.length !== 0) {<br>        return false;<br>    }<br>    for(var i = substr.length; i &lt; str.length; i += substr.length){<br>        if(str.substring(i).slice(0,substr.length) !== substr){<br>            return false;<br>        }<br>    }<br>    return true;<br>};</p>
<p>其他方法仍在思考实现中</p>
<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21-Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/#/solutions" target="_blank" rel="noopener">21-Merge Two Sorted Lists</a></h2><p>方法一：递归</p>
<p>/**<br> * Definition for singly-linked list.<br> * function ListNode(val) {<br> *     this.val = val;<br> *     this.next = null;<br> * }<br> */<br>/**<br> * @param {ListNode} l1<br> * @param {ListNode} l2<br> * @return {ListNode}<br> */<br>var mergeTwoLists = function(l1, l2) {<br>    if(l1 === null) return l2;<br>    if(l2 === null) return l1;<br>    if(l1.val &lt; l2.val) {<br>        l1.next = mergeTwoLists(l1.next, l2);<br>        return l1;<br>    } else {<br>        l2.next = mergeTwoLists(l2.next, l1);<br>        return l2;<br>    }<br>};</p>
<h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235-Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/#/description" target="_blank" rel="noopener">235-Lowest Common Ancestor of a Binary Search Tree</a></h2><p>方法：<strong>递归</strong>，因为这是一棵二叉搜索数，所以两个节点分别与共同的祖先节点相减所得的差应该是异号或等于0的，否则就根据节点与当前根节点的大小比较对其左子树或右子树进行递归</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @param {TreeNode} p<br> * @param {TreeNode} q<br> * @return {TreeNode}<br> <em>/<br>var lowestCommonAncestor = function(root, p, q) {<br>    while ((root.val - p.val) </em> (root.val - q.val) &gt; 0)<br>        root = p.val &lt; root.val ? root.left : root.right;<br>    return root;<br>};</p>
<p>方法二：迭代，和递归类似，只不过代码更加简化</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @param {TreeNode} p<br> * @param {TreeNode} q<br> * @return {TreeNode}<br> <em>/<br>var lowestCommonAncestor = function(root, p, q) {<br>    return (root.val - p.val) </em> (root.val - q.val) &lt; 1 ? root :<br>           lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);<br>};</p>
<h2 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198-House Robber"></a><a href="https://leetcode.com/problems/house-robber/#/description" target="_blank" rel="noopener">198-House Robber</a></h2><p>方法一：根据房间数的奇偶进行分类存储最大值，并且有以下规律</p>
<blockquote>
<p>f(0) = nums[0] f(1) = max(num[0], num[1]) f(k) = max( f(k-2) + nums[k], f(k-1) )</p>
</blockquote>
<p>/**<br> * @param {number[]} nums<br> * @return {number}<br> */<br>var rob = function(nums) {<br>    var a = 0,<br>        b = 0;<br>    for (var i=0; i&lt;nums.length; i++)<br>    {<br>        if (i%2===0)<br>        {<br>            a = Math.max(a+nums[i], b);<br>        }<br>        else<br>        {<br>            b = Math.max(a, b+nums[i]);<br>        }<br>    }<br>    return Math.max(a, b);<br>};</p>
<h2 id="342-Power-of-Four"><a href="#342-Power-of-Four" class="headerlink" title="342-Power of Four"></a><a href="https://leetcode.com/problems/power-of-four/#/description" target="_blank" rel="noopener">342-Power of Four</a></h2><p>方法一：因为能被4整除的数用二进制表示的话有且只有一个1在奇数位上</p>
<p>/**<br> * @param {number} num<br> * @return {boolean}<br> */<br>var isPowerOfFour = function(num) {<br>    return num &gt; 0 &amp;&amp; (num&amp;(num-1)) === 0 &amp;&amp; (num &amp; 0x55555555) !== 0;<br>};</p>
<p>方法二：很好用的replace().length</p>
<p>/**<br> * @param {number} num<br> * @return {boolean}<br> */<br>var isPowerOfFour = function(num) {<br>    return num.toString(2).replace(/0/g,’’).length === 1 &amp;&amp; num.toString(2).length%2 ===1;<br>};</p>
<p>方法三：利用2的倍数减1无法整除3而4的倍数减1可以整除3的特性</p>
<p>/**<br> * @param {number} num<br> * @return {boolean}<br> */<br>var isPowerOfFour = function(num) {<br>    return num &gt; 0 &amp;&amp; (num &amp; (num - 1)) === 0 &amp;&amp; (num - 1) % 3 === 0;<br>};</p>
<h2 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345-Reverse Vowels of a String"></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/#/solutions" target="_blank" rel="noopener">345-Reverse Vowels of a String</a></h2><p>方法一：利用二分法和替代数组</p>
<p>/**<br> * @param {string} s<br> * @return {string}<br> */<br>var reverseVowels = function(s) {<br>    if(s.length &lt;= 1){return s;}<br>    var arr = [‘a’,’e’,’i’,’o’,’u’,’A’,’E’,’I’,’O’,’U’],<br>        res = new Array(s.length);<br>        left = 0,<br>        right = s.length -1;<br>    while(left&lt;=right){<br>        if(arr.indexOf(s[left]) &lt; 0){<br>            res[left] = s[left];<br>            left++;<br>        }<br>        if(arr.indexOf(s[right]) &lt; 0){<br>            res[right] = s[right];<br>            right–;<br>        }<br>        if(arr.indexOf(s[left]) &gt;=0 &amp;&amp; arr.indexOf(s[right]) &gt;=0){<br>            res[left] = s[right];<br>            res[right] = s[left];<br>            left++;<br>            right–;<br>        }<br>    }<br>    return res.join(‘’);<br>};</p>
<h2 id="367-Valid-Perfect-Square"><a href="#367-Valid-Perfect-Square" class="headerlink" title="367-Valid Perfect Square"></a><a href="https://leetcode.com/problems/valid-perfect-square/#/description" target="_blank" rel="noopener">367-Valid Perfect Square</a></h2><p>方法一：完全平方数一定是1+3+5+7……O(sqrt(N))</p>
<p>/**<br> * @param {number} num<br> * @return {boolean}<br> */<br>var isPerfectSquare = function(num) {<br>    if (num &lt; 1) {return false;}<br>    for (var i = 1; num &gt; 0; i += 2){<br>        num -= i;<br>    }<br>    return num === 0;<br>};</p>
<p>方法二：二分查找，O(logN)</p>
<p>/**<br> * @param {number} num<br> * @return {boolean}<br> <em>/<br>var isPerfectSquare = function(num) {<br>    if (num &lt; 1) {return false;}<br>    var left = 1, right = num;<br>    while (left &lt;= right) {<br>        var mid = Math.floor(left + (right - left) / 2);<br>        var t = mid </em> mid;<br>        if (t &gt; num) {<br>          right = mid - 1;<br>        } else if (t &lt; num) {<br>          left = mid + 1;<br>        } else {<br>          return true;<br>        }<br>    }<br>    return false;<br>};</p>
<p>方法三：<a href="https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division" target="_blank" rel="noopener">牛顿迭代法</a>，O(1)</p>
<p>/**<br> * @param {number} num<br> * @return {boolean}<br> <em>/<br>var isPerfectSquare = function(num) {<br>    if (num &lt; 1) {return false;}<br>    var t = Math.floor(num / 2);<br>    while (t </em> t &gt; num) {<br>        t = Math.floor((t + num / t) / 2);<br>    }<br>    return t * t == num || num === 1;<br>};</p>
<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27-Remove Element"></a><a href="https://leetcode.com/problems/remove-element/#/description" target="_blank" rel="noopener">27-Remove Element</a></h2><p>方法一：在获得剩余长度的同时生成新数组</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} val<br> * @return {number}<br> */<br>var removeElement = function(nums, val) {<br>    var cnt = 0;<br>    for(var i = 0 ; i &lt; nums.length ; ++i) {<br>        if(nums[i] == val)<br>            cnt++;<br>        else<br>            nums[i-cnt] = nums[i];<br>    }<br>    return nums.length-cnt;<br>};</p>
<p>方法二：既短又快</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} val<br> * @return {number}<br> */<br>var removeElement = function(nums, val) {<br>    var l = nums.length;<br>    for (var i=0; i&lt;l; i++) {<br>        if (nums[i] == val) {<br>            nums[i–] = nums[l– -1];<br>        }<br>    }<br>    return l;<br>};</p>
<h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101-Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/#/description" target="_blank" rel="noopener">101-Symmetric Tree</a></h2><p>  方法一：通过另外一个方法判断其左右子树是否都是”镜像数”</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @return {boolean}<br> */<br>var isSymmetric = function(root) {<br>    if(root===null) {return true;}<br>    return isMirror(root.left,root.right);<br>};</p>
<p>var isMirror = function(p,q){<br>    if(p===null &amp;&amp; q===null) return true;<br>    if(p===null || q===null) return false;<br>    return (p.val==q.val) &amp;&amp; isMirror(p.left,q.right) &amp;&amp; isMirror(p.right,q.left);<br>};</p>
<p>方法二：通过队列（在js中通过数组模拟）</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @return {boolean}<br> */<br>var isSymmetric = function(root) {<br>    var q = [];<br>    if(root === null) return true;<br>    q.push(root.left);<br>    q.push(root.right);<br>    while(q.length &gt; 1){<br>        var left = q.shift(),<br>            right = q.shift();<br>        if(left=== null&amp;&amp; right === null) continue;<br>        if(left=== null ^ right === null) return false;<br>        if(left.val != right.val) return false;<br>        q.push(left.left);<br>        q.push(right.right);<br>        q.push(left.right);<br>        q.push(right.left);<br>    }<br>    return true;<br>};</p>
<h2 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66-Plus One"></a><a href="https://leetcode.com/problems/plus-one/#/description" target="_blank" rel="noopener">66-Plus One</a></h2><p>方法一：从n-1开始遍历，然后用一个变量表示前面一位是否进位</p>
<p>/**<br> * @param {number[]} digits<br> * @return {number[]}<br> */<br>var plusOne = function(digits) {<br>    var j=0,k;<br>    for(var n=digits.length,i=n-1;i&gt;=0;i–){<br>        k = i==n-1 ? 1:0;<br>        var old = digits[i];<br>        digits[i] = (old + j + k)%10;<br>        j = Math.floor((old + j + k)/10);<br>    }<br>    if(j == 1){<br>        digits.unshift(1);<br>    }<br>    return digits;<br>};</p>
<h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118-Pascal’s Triangle"></a><a href="https://leetcode.com/problems/pascals-triangle/#/description" target="_blank" rel="noopener">118-Pascal’s Triangle</a></h2><p>方法一：单独用一个方法生成某一行，再push进数组</p>
<p>/**<br> * @param {number} numRows<br> * @return {number[][]}<br> */<br>var generate = function(numRows) {<br>    var arr = [];<br>    for(var i=0;i&lt;numRows;i++){<br>        var item = f(i+1);<br>        arr.push(item);<br>    }<br>    console.info(f(1));<br>    return arr;<br>};</p>
<p>var f = function(n){<br>    var a = new Array(n);<br>    if(n==1){return [1];}<br>    else if(n==2){return [1,1];}<br>    else{<br>        var arr = f(n-1);<br>        for(var i=0;i&lt;n-1;i++){<br>            a[i+1] = arr[i]+arr[i+1];<br>        }<br>        a[0] = a[n-1] = 1;<br>        return a;<br>    }<br>};</p>
<p>方法二：直接对二维数组进行赋值</p>
<p>/**<br> * @param {number} numRows<br> * @return {number[][]}<br> */<br>var generate = function(numRows) {<br>    var r = [];<br>    for(var k=0;k&lt;numRows;k++){<br>        r[k]= [];<br>    }<br>    for (var i = 0; i &lt; numRows; i++) {<br>        r[i][0] = r[i][i] = 1;<br>        for (var j = 1; j &lt; i; j++){<br>            r[i][j] = r[i - 1][j - 1] + r[i - 1][j];<br>        }<br>    }<br>    return r;<br>};</p>
<h2 id="434-Number-of-Segments-in-a-String"><a href="#434-Number-of-Segments-in-a-String" class="headerlink" title="434. Number of Segments in a String"></a><a href="https://leetcode.com/problems/number-of-segments-in-a-string/#/description" target="_blank" rel="noopener">434. Number of Segments in a String</a></h2><p>方法一：先去掉首尾空格再将非空格替换成空字符</p>
<p>/**<br> * @param {string} s<br> * @return {number}<br> */<br>var countSegments = function(s) {<br>    var str = s.replace(/^\s+|\s+$/g,’’);<br>    return str.length === 0 ? 0 : str.replace(/\s+/g,’ ‘).replace(/\S/g,’’).length +1;<br>};</p>
<p>方法二：先在首尾加一个空格，然后将非空格替换成空字符</p>
<p>/**<br> * @param {string} s<br> * @return {number}<br> */<br>var countSegments = function(s) {<br>    return (“ “ + s + “ “).replace(/\s+/g,’ ‘).replace(/\S/g,’’).length - 1;<br>};</p>
<h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree/#/description" target="_blank" rel="noopener">110. Balanced Binary Tree</a></h2><p>方法一：某节点的高度等于该节点的左子树和右子树的高度中的较大值再加一，O(N^2)</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @return {boolean}<br> */<br>var isBalanced = function(root) {<br>    if (root === null) return true;<br>    var left=depth(root.left);<br>    var right=depth(root.right);<br>    return Math.abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>};</p>
<p>var depth = function(root){<br>    if (root === null) return 0;<br>    return Math.max(depth(root.left), depth (root.right)) + 1;<br>};</p>
<p>方法二：从底部向上遍历，O(N)</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @return {boolean}<br> */<br>var isBalanced = function(root) {<br>    return dfsHeight(root) != -1;<br>};</p>
<p>var dfsHeight = function(root) {<br>    if (root === null) return 0;<br>    var leftHeight = dfsHeight (root.left);<br>    if (leftHeight == -1) return -1;<br>    var rightHeight = dfsHeight(root.right);<br>    if (rightHeight == -1) return -1;<br>    if (Math.abs(leftHeight - rightHeight) &gt; 1)  return -1;<br>    return Math.max(leftHeight, rightHeight) + 1;<br>};</p>
<h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257-Binary Tree Paths"></a><a href="https://leetcode.com/problems/binary-tree-paths/#/description" target="_blank" rel="noopener">257-Binary Tree Paths</a></h2><p>暂无</p>
<h2 id="441-Arranging-Coins"><a href="#441-Arranging-Coins" class="headerlink" title="441-Arranging Coins"></a><a href="https://leetcode.com/problems/arranging-coins/#/description" target="_blank" rel="noopener">441-Arranging Coins</a></h2><p>方法一：根据公式直接求解(x * ( x + 1)) / 2 &lt;= n</p>
<p>/**<br> * @param {number} n<br> * @return {number}<br> <em>/<br>var arrangeCoins = function(n) {<br>    return Math.floor(((-1 + Math.sqrt(1 + 8 </em>n)) / 2));<br>};</p>
<p>方法二：先根据根值确定大致范围，然后二分查找</p>
<p>/**<br> * @param {number} n<br> * @return {number}<br> <em>/<br>var arrangeCoins = function(n) {<br>    var start = 0,<br>        end = n,<br>        mid = 0;<br>    while (start &lt;= end){<br>        mid = (start + end) &gt;&gt;&gt; 1;<br>        if ((0.5 </em> mid <em> mid + 0.5 </em> mid ) &lt;= n){<br>            start = mid + 1;<br>        }else{<br>            end = mid - 1;<br>        }<br>    }<br>    return start - 1;<br>};</p>
<h2 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119-Pascal’s Triangle II"></a><a href="https://leetcode.com/problems/pascals-triangle-ii/#/description" target="_blank" rel="noopener">119-Pascal’s Triangle II</a></h2><p>方法一：递归，直接计算</p>
<p>/**<br> * @param {number} rowIndex<br> * @return {number[]}<br> */<br>var getRow = function(rowIndex) {<br>    var A = [];<br>    A[0] = 1;<br>    for(var i=1; i&lt;rowIndex+1; i++){<br>        for(var j=i; j&gt;=1; j–){<br>            if(isNaN(A[j])){<br>                A[j] = 0;<br>            }<br>            if(isNaN(A[j-1])){<br>                A[j-1] = 0;<br>            }<br>            A[j] += A[j-1];<br>        }<br>    }<br>    return A;<br>};</p>
<p>方法二：根据公式a(k+1) = a(k) * (n-k)/(k+1)，其中a(0)=1和a(1)=n很容易发现</p>
<p>/**<br> * @param {number} rowIndex<br> * @return {number[]}<br> <em>/<br>var getRow = function(rowIndex) {<br>    if(rowIndex === 0) {return [1];}<br>    var A=[];<br>    A[0]=1;<br>    A[1]=rowIndex;<br>    for(var i=2;i&lt;=rowIndex;i++) {<br>        A[i]=Math.floor(A[i-1]</em>(rowIndex-(i-1))/i); //in case of overflow<br>    }<br>    return A;<br>};</p>
<h2 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232-Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/#/description" target="_blank" rel="noopener">232-Implement Queue using Stacks</a></h2><p>参见我的另外一篇文章：<a href="https://merrier.wang/?p=319">JS实现复杂数据结构</a></p>
<h2 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141-Linked List Cycle"></a><a href="https://leetcode.com/problems/linked-list-cycle/#/description" target="_blank" rel="noopener">141-Linked List Cycle</a></h2><p>方法一：一个快指针，一个慢指针</p>
<p>/**<br> * Definition for singly-linked list.<br> * function ListNode(val) {<br> *     this.val = val;<br> *     this.next = null;<br> * }<br> */</p>
<p>/**<br> * @param {ListNode} head<br> * @return {boolean}<br> */<br>var hasCycle = function(head) {<br>    if(head===null) return false;<br>    var walker = head,runner = head;<br>    while(runner.next!==null &amp;&amp; runner.next.next!==null) {<br>        walker = walker.next;<br>        runner = runner.next.next;<br>        if(walker==runner) return true;<br>    }<br>    return false;<br>};</p>
<h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26-Remove Duplicates from Sorted Array"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/#/description" target="_blank" rel="noopener">26-Remove Duplicates from Sorted Array</a></h2><p>方法一：遇到不同的元素时才进行赋值</p>
<p>/**<br> * @param {number[]} nums<br> * @return {number}<br> */<br>var removeDuplicates = function(nums) {<br>    if (nums.length===0) return 0;<br>    var j=0;<br>    for (var i=0; i&lt;nums.length; i++)<br>        if (nums[i]!=nums[j]) nums[++j]=nums[i];<br>    return ++j;<br>};</p>
<p>方法二：用一个变量记录当前重复元素数量</p>
<p>/**<br> * @param {number[]} nums<br> * @return {number}<br> */<br>var removeDuplicates = function(nums) {<br>    var count = 0;<br>    for(var i = 1; i &lt; nums.length; i++){<br>        if(nums[i] == nums[i-1]) count++;<br>        else nums[i-count] = nums[i];<br>    }<br>    return nums.length-count;<br>};</p>
<h2 id="172-Factorial-Trailing-Zeroes"><a href="#172-Factorial-Trailing-Zeroes" class="headerlink" title="172-Factorial Trailing Zeroes"></a><a href="https://leetcode.com/problems/factorial-trailing-zeroes/#/description" target="_blank" rel="noopener">172-Factorial Trailing Zeroes</a></h2><p>方法一：产生0的可能性只有2*5，所以需要计算n！里有几个5，2是足够多的</p>
<p>/**<br> * @param {number} n<br> * @return {number}<br> */<br>var trailingZeroes = function(n) {<br>    return n === 0 ? 0 : Math.floor(n / 5) + trailingZeroes(n / 5);<br>};</p>
<h2 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9-Palindrome Number"></a><a href="https://leetcode.com/problems/palindrome-number/#/description" target="_blank" rel="noopener">9-Palindrome Number</a></h2><p>方法一：二分查找</p>
<p>/**<br> * @param {number} x<br> * @return {boolean}<br> */<br>var isPalindrome = function(x) {<br>    var str = “” + x,left=0,right=str.length-1;<br>    while(right-left&gt;=1){<br>        if(str[left] == str[right]){<br>            left++;<br>            right–;<br>        }else{<br>            return false;<br>        }<br>    }<br>    return true;<br>};</p>
<p>方法二：比较前一半数字和后一半数字是否相等</p>
<p>/**<br> * @param {number} x<br> * @return {boolean}<br> <em>/<br>var isPalindrome = function(x) {<br>    if (x<0 ||="" (x!="=0" &&="" x%10="==0))" return="" false;="" var="" rev="0;" while="" (x="">rev){<br>        rev = rev</0></em>10 + x%10;<br>        x = Math.floor(x/10);<br>    }<br>    return (x==rev || x==Math.floor(rev/10));<br>};</p>
<h2 id="374-Guess-Number-Higher-or-Lower"><a href="#374-Guess-Number-Higher-or-Lower" class="headerlink" title="374-Guess Number Higher or Lower"></a><a href="https://leetcode.com/problems/guess-number-higher-or-lower/#/description" target="_blank" rel="noopener">374-Guess Number Higher or Lower</a></h2><p>方法一：二分查找（这道题不能用js，所以答案并没有在leetcode上验证）</p>
<p>// Forward declaration of guess API.<br>// @param n, your guess<br>// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0<br>var guessNumber = function(n){<br>    var low = 1;<br>    while(low &lt;= n){<br>        var mid = Math.floor(low + (n-low) / 2);<br>        var res = guess(mid);<br>        if(res == 0)<br>            return mid;<br>        else if(res == -1)<br>            n = mid - 1;<br>        else<br>        low = mid + 1;<br>    }<br>    return -1;<br>}</p>
<h2 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438-Find All Anagrams in a String"></a><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/#/description" target="_blank" rel="noopener">438-Find All Anagrams in a String</a></h2><p>暂无</p>
<h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112-Path Sum"></a><a href="https://leetcode.com/problems/path-sum/#/description" target="_blank" rel="noopener">112-Path Sum</a></h2><p>方法一：知道sum和root.val，看左子树或右子树是否能够满足sum-root.val</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @param {number} sum<br> * @return {boolean}<br> */<br>var hasPathSum = function(root, sum) {<br>    if (root === null) return false;<br>    if (root.val == sum &amp;&amp; root.left === null &amp;&amp; root.right === null) return true;<br>    return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);<br>};</p>
<h2 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38-Count and Say"></a><a href="https://leetcode.com/problems/count-and-say/#/description" target="_blank" rel="noopener">38-Count and Say</a></h2><p>/**<br> * @param {number} n<br> * @return {string}<br> */<br>var countAndSay = function(n) {<br>    if(n == 1) {return ‘1’;}<br>    else{<br>        var s = countAndSay(n-1),res=’’,a=1;<br>        for(var i=0,len=s.length;i&lt;len;i++){<br>            if(s[i+1] == s[i]){<br>                a++;<br>            }else{<br>                res += a + s[i];<br>                a=1;<br>            }<br>        }<br>        return res;<br>    }<br>};</p>
<h2 id="250-Isomorphic-Strings"><a href="#250-Isomorphic-Strings" class="headerlink" title="250-Isomorphic Strings"></a><a href="https://leetcode.com/problems/isomorphic-strings/#/solutions" target="_blank" rel="noopener">250-Isomorphic Strings</a></h2><p>方法一：用哈希表判断重复出现的位置</p>
<p>/**<br> * @param {string} s<br> * @param {string} t<br> * @return {boolean}<br> */<br>var isIsomorphic = function(s, t) {<br>    return phic(s,t) &amp;&amp; phic(t,s);<br>};</p>
<p>var phic = function(s,t){<br>    var arr = [];<br>    for(var i=0,n=s.length;i&lt;n;i++){<br>        var code = s[i].charCodeAt() - 65;<br>        if(arr[code] === undefined){<br>            arr[code] = i;<br>        }else{<br>            if(t[i] != t[arr[code]]){<br>                return false;<br>            }<br>        }<br>    }<br>    return true;<br>};</p>
<p>方法二：用一个数组保存重复元素第一次出现的位置</p>
<p>/**<br> * @param {string} s<br> * @param {string} t<br> * @return {boolean}<br> */<br>var isIsomorphic = function(s, t) {<br>    var m = [];<br>    for (var i = 0; i &lt; s.length; i++) {<br>        if (m[s.charCodeAt(i)] != m[t.charCodeAt(i)+256]) {return false;}<br>        m[s.charCodeAt(i)] = m[t.charCodeAt(i)+256] = i+1;<br>    }<br>    return true;<br>};</p>
<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20-Valid Parentheses"></a><a href="https://leetcode.com/problems/valid-parentheses/#/description" target="_blank" rel="noopener">20-Valid Parentheses</a></h2><p>/**<br> * @param {string} s<br> * @return {boolean}<br> */<br>var isValid = function(s) {<br>    var p = [];<br>    for(var i = 0; i &lt; s.length; i++) {<br>        var q = “(){}[]“.indexOf(s.substring(i, i + 1));<br>        if(q % 2 == 1) {<br>            if(p.length === 0 || p.shift() != q - 1) return false;<br>        } else p.unshift(q);<br>    }<br>    return !p.length;<br>};</p>
<h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111-Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/#/description" target="_blank" rel="noopener">111-Minimum Depth of Binary Tree</a></h2><p>方法一：We need to add the smaller one of the child depths - except if that’s zero, then add the larger one.</p>
<p>/**<br> * Definition for a binary tree node.<br> * function TreeNode(val) {<br> *     this.val = val;<br> *     this.left = this.right = null;<br> * }<br> */<br>/**<br> * @param {TreeNode} root<br> * @return {number}<br> */<br>var minDepth = function(root) {<br>    if (!root) return 0;<br>    var L = minDepth(root.left), R = minDepth(root.right);<br>    return 1 + (Math.min(L, R) || Math.max(L, R));<br>};</p>
<h2 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="290-Word Pattern"></a><a href="https://leetcode.com/problems/word-pattern/#/description" target="_blank" rel="noopener">290-Word Pattern</a></h2><p>/**<br> * @param {string} pattern<br> * @param {string} str<br> * @return {boolean}<br> */<br>var wordPattern = function(pattern, str) {<br>    var arr = str.split(“ “),mid = [];</p>
<pre><code>for(var i=0,n=pattern.length;i&lt;n;i++){
    var char = pattern\[i\].charCodeAt() - 97;
    if(mid\[char\] === undefined){
        if(inArray(arr\[i\],mid)){
            return false;
        }else{
            mid\[char\] = arr\[i\];
        }
    }else{
        if(mid\[char\] != arr\[i\]){
            return false;
        }
    }
}
return true &amp;&amp; (pattern.length == arr.length);
</code></pre><p>};</p>
<p>var inArray = function(item,arr) {<br>    for(var i=0,n=arr.length;i&lt;n;i++){<br>        if(arr[i] === item){<br>            return true;<br>        }<br>    }<br>    return false;<br>};</p>
<h2 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234-Palindrome Linked List"></a><a href="https://leetcode.com/problems/palindrome-linked-list/#/description" target="_blank" rel="noopener">234-Palindrome Linked List</a></h2><p>/**<br> * Definition for singly-linked list.<br> * function ListNode(val) {<br> *     this.val = val;<br> *     this.next = null;<br> * }<br> */<br>/**<br> * @param {ListNode} head<br> * @return {boolean}<br> */<br>var isPalindrome = function(head) {<br>    if(head === null) {<br>        return true;<br>    }<br>    var p1 = head,p2 = head,p3 = p1.next,pre = p1;<br>    //find mid pointer, and reverse head half part<br>    while(p2.next !== null &amp;&amp; p2.next.next !== null) {<br>        p2 = p2.next.next;<br>        pre = p1;<br>        p1 = p3;<br>        p3 = p3.next;<br>        p1.next = pre;<br>    }<br>    //odd number of elements, need left move p1 one step<br>    if(p2.next === null) {<br>        p1 = p1.next;<br>    }<br>    else {   //even number of elements, do nothing<br>    }<br>    //compare from mid to head/tail<br>    while(p3 !== null) {<br>        if(p1.val != p3.val) {<br>            return false;<br>        }<br>        p1 = p1.next;<br>        p3 = p3.next;<br>    }<br>    return true;<br>};</p>
<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a><a href="https://leetcode.com/problems/two-sum/#/description" target="_blank" rel="noopener">1.Two Sum</a></h2><p>方法一：双层循环（其实应该用哈希表，但是js中没有，需要额外实现）</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} target<br> * @return {number[]}<br> */<br>var twoSum = function(nums, target) {<br>    for(var i=0,n=nums.length;i&lt;n;i++){<br>        for(var j=i+1;j&lt;n;j++){<br>            if((nums[i] + nums[j]) == target){<br>                return [i,j];<br>            }<br>        }<br>    }<br>    return false;<br>};</p>
<h2 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="219-Contains Duplicate II"></a><a href="https://leetcode.com/problems/contains-duplicate-ii/#/description" target="_blank" rel="noopener">219-Contains Duplicate II</a></h2><p>方法一：只要读懂题意就差不多了，哈希表及时更新</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} k<br> * @return {boolean}<br> */<br>var containsNearbyDuplicate = function(nums, k) {<br>    var arr = [],res = false;<br>    for(var i=0,n=nums.length;i&lt;n;i++){<br>        var item = nums[i];<br>        if(arr[item] === undefined){<br>            arr[item] = i;<br>        }else{<br>            if(Math.abs(arr[item] - i) &lt;= k){<br>                return true;<br>            }<br>            arr[item] = i;<br>        }<br>    }<br>    return false;<br>};</p>
<h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225-Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/#/description" target="_blank" rel="noopener">225-Implement Stack using Queues</a></h2><p>参考我的另一篇文章<a href="https://merrier.wang/?p=319">JS实现复杂数据结构</a></p>
<h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88.Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array/#/description" target="_blank" rel="noopener">88.Merge Sorted Array</a></h2><p>方法一：模仿归并排序，从后往前比较</p>
<p>/**<br> * @param {number[]} nums1<br> * @param {number} m<br> * @param {number[]} nums2<br> * @param {number} n<br> * @return {void} Do not return anything, modify nums1 in-place instead.<br> */<br>var merge = function(nums1, m, nums2, n) {<br>    while(n&gt;0) nums1[m+n-1] = (m===0||nums2[n-1] &gt; nums1[m-1]) ? nums2[–n] : nums1[–m];<br>};</p>
<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203-Remove Linked List Elements"></a><a href="https://leetcode.com/problems/remove-linked-list-elements/#/solutions" target="_blank" rel="noopener">203-Remove Linked List Elements</a></h2><p>方法一：递归</p>
<p>/**<br> * Definition for singly-linked list.<br> * function ListNode(val) {<br> *     this.val = val;<br> *     this.next = null;<br> * }<br> */<br>/**<br> * @param {ListNode} head<br> * @param {number} val<br> * @return {ListNode}<br> */<br>var removeElements = function(head, val) {<br>    if (head === null) return null;<br>    head.next = removeElements(head.next, val);<br>    return head.val == val ? head.next : head;<br>};</p>
<h2 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58.Length of Last Word"></a><a href="https://leetcode.com/problems/length-of-last-word/#/description" target="_blank" rel="noopener">58.Length of Last Word</a></h2><p>方法一：利用split，需要提前去掉前后空格</p>
<p>/**<br> * @param {string} s<br> * @return {number}<br> */<br>var lengthOfLastWord = function(s) {<br>    return  s.replace(/^\s+|\s+$/g,’’).split(‘ ‘)[s.replace(/^\s+|\s+$/g,’’).split(‘ ‘).length - 1].length;<br>};</p>
<h2 id="507-Perfect-Number"><a href="#507-Perfect-Number" class="headerlink" title="507-Perfect Number"></a><a href="https://leetcode.com/problems/perfect-number/#/solutions" target="_blank" rel="noopener">507-Perfect Number</a></h2><p>方法一：先求根值，因为根值是遍历的界限</p>
<p>/**<br> * @param {number} num<br> * @return {boolean}<br> <em>/<br>var checkPerfectNumber = function(num) {<br>    var sqrt = Math.sqrt(num),res = 0;<br>    for(var i=1;i&lt;=sqrt;i++){<br>        if(num%i === 0){<br>            res += i+ num/i;<br>        }<br>    }<br>    console.info(res);<br>    return num&gt;1 &amp;&amp; res==2</em>num;<br>};</p>
<h2 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67-Add Binary"></a><a href="https://leetcode.com/problems/add-binary/#/description" target="_blank" rel="noopener">67-Add Binary</a></h2><p>方法一：对两个字符串循环遍历，同时用一个变量保存进位情况</p>
<p>/**<br> * @param {string} a<br> * @param {string} b<br> * @return {string}<br> */<br>var addBinary = function(a, b) {<br>    var s = “”;<br>    var c = 0, i = a.length - 1, j = b.length - 1;<br>    while(i &gt;= 0 || j &gt;= 0 || c == 1)<br>    {<br>        c += i &gt;= 0 ? a[i –] - ‘0’ : 0;<br>        c += j &gt;= 0 ? b[j –] - ‘0’ : 0;<br>        s = c % 2 + s;<br>        c = Math.floor(c / 2);<br>    }<br>    return s;<br>};</p>
<h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14-Longest Common Prefix"></a><a href="https://leetcode.com/problems/longest-common-prefix/#/description" target="_blank" rel="noopener">14-Longest Common Prefix</a></h2><p>方法一：对数组进行遍历，用indexOf判断字符串的前缀</p>
<p>/**<br> * @param {string[]} strs<br> * @return {string}<br> */<br>var longestCommonPrefix = function(strs) {<br>    if(strs === null || strs.length === 0)    return “”;<br>    var pre = strs[0],i = 1;<br>    while(i &lt; strs.length){<br>        while(strs[i].indexOf(pre) !== 0){<br>            pre = pre.substring(0,pre.length-1);<br>        }<br>        i++;<br>    }<br>    return pre;<br>};</p>
<h2 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160-Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/#/description" target="_blank" rel="noopener">160-Intersection of Two Linked Lists</a></h2><p>方法一：用两个指针进行遍历，循环结束条件为指针相等</p>
<p>/**<br> * Definition for singly-linked list.<br> * function ListNode(val) {<br> *     this.val = val;<br> *     this.next = null;<br> * }<br> */</p>
<p>/**<br> * @param {ListNode} headA<br> * @param {ListNode} headB<br> * @return {ListNode}<br> */<br>var getIntersectionNode = function(headA, headB) {<br>    var cur1 = headA,cur2 = headB;<br>    while(cur1 != cur2){<br>        cur1 = cur1?cur1.next:headB;<br>        cur2 = cur2?cur2.next:headA;<br>    }<br>    return cur1;<br>};</p>
<h2 id="400-Nth-Digit"><a href="#400-Nth-Digit" class="headerlink" title="400-Nth Digit"></a><a href="https://leetcode.com/problems/nth-digit/#/description" target="_blank" rel="noopener">400-Nth Digit</a></h2><p>方法一：步骤为：确定数字是几位数-&gt;确定具体数字-&gt;返回这个数字的第几位数</p>
<p>/**<br> * @param {number} n<br> * @return {number}<br> <em>/<br>var findNthDigit = function(n) {<br>    n -= 1;<br>    var digits = 1, first = 1;<br>    while (Math.floor(n / 9 / first / digits) &gt;= 1) {<br>        n -= 9 </em> first <em> digits;<br>        digits++;<br>        first </em>= 10;<br>    }<br>    return (first + Math.floor(n/digits) + “”).charAt(n%digits) - ‘0’;<br>};</p>
<h2 id="475-Heaters"><a href="#475-Heaters" class="headerlink" title="475. Heaters"></a><strong><a href="https://leetcode.com/problems/heaters/#/description" target="_blank" rel="noopener">475. Heaters</a></strong></h2><p>方法一：在对房子进行循环的过程中移动加热器的指针</p>
<p>/**<br> * @param {number[]} houses<br> * @param {number[]} heaters<br> * @return {number}<br> <em>/<br>var findRadius = function(houses, heaters) {<br>    var house = houses.sort(function(a,b){return a-b;}),<br>        heater= heaters.sort(function(a,b){return a-b;}),<br>        i = 0,<br>        res = 0;<br>    for (var j=0,n=house.length;j&lt;n;j++) {<br>        while (i &lt; heater.length - 1 &amp;&amp; heater[i] + heater[i + 1] &lt;= house[j] </em> 2) {<br>            i++;<br>        }<br>        res = Math.max(res, Math.abs(heater[i] - house[j]));<br>    }<br>    return res;<br>};</p>
<h2 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190-Reverse Bits"></a><a href="https://leetcode.com/problems/reverse-bits/#/description" target="_blank" rel="noopener">190-Reverse Bits</a></h2><p>方法一：利用数组的reverse()进行反转</p>
<p>/**<br> * @param {number} n - a positive integer<br> * @return {number} - a positive integer<br> */<br>var reverseBits = function(n) {<br>    var zero = 32- n.toString(2).length;<br>    var bit = n.toString(2).split(“”).reverse().join(“”);<br>    while(zero&gt;0){<br>        bit += ‘0’;<br>        zero–;<br>    }<br>    return parseInt(bit,2);<br>};</p>
<h2 id="303-Range-Sum-Query-Immutable"><a href="#303-Range-Sum-Query-Immutable" class="headerlink" title="303-Range Sum Query - Immutable"></a><a href="https://leetcode.com/problems/range-sum-query-immutable/#/description" target="_blank" rel="noopener">303-Range Sum Query - Immutable</a></h2><p>方法一：用一个数组保存前面元素之和</p>
<p>/**<br> * @param {number[]} nums<br> */<br>var NumArray = function(nums) {<br>    for(var i = 1; i &lt; nums.length; i++)<br>        nums[i] += nums[i - 1];</p>
<pre><code>this.nums = nums;
</code></pre><p>};</p>
<p>/**<br> * @param {number} i<br> * @param {number} j<br> * @return {number}<br> */<br>NumArray.prototype.sumRange = function(i, j) {<br>    if(i === 0) {return this.nums[j];}<br>    return this.nums[j] - this.nums[i - 1];<br>};</p>
<p>/**<br> * Your NumArray object will be instantiated and called as such:<br> * var obj = Object.create(NumArray).createNew(nums)<br> * var param_1 = obj.sumRange(i,j)<br> */</p>
<h2 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28-Implement strStr()"></a><a href="https://leetcode.com/problems/implement-strstr/#/description" target="_blank" rel="noopener">28-Implement strStr()</a></h2><p>方法一：利用js中的indexOf()</p>
<p>/**<br> * @param {string} haystack<br> * @param {string} needle<br> * @return {number}<br> */<br>var strStr = function(haystack, needle) {<br>    return haystack.indexOf(needle);<br>};</p>
<p>方法二：老老实实遍历</p>
<p>/**<br> * @param {string} haystack<br> * @param {string} needle<br> * @return {number}<br> */<br>var strStr = function(haystack, needle) {<br>    for (var i = 0; ; i++) {<br>    for (var j = 0; ; j++) {<br>      if (j == needle.length) return i;<br>      if (i + j == haystack.length) return -1;<br>      if (needle.charAt(j) != haystack.charAt(i + j)) break;<br>    }<br>  }<br>};</p>
<h2 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69-Sqrt(x)"></a><a href="https://leetcode.com/problems/sqrtx/#/description" target="_blank" rel="noopener">69-Sqrt(x)</a></h2><p>方法一：从x/2开始遍历（复杂度高，而且有可能会超时，不建议这种方法）</p>
<p>/**<br> * @param {number} x<br> * @return {number}<br> <em>/<br>var mySqrt = function(x) {<br>    var t = Math.floor(x/2);<br>    while(t</em>t&gt;x &amp;&amp; t&gt;=0){<br>        t–;<br>    }<br>    return x==1 ? 1 : t;<br>};</p>
<p>方法二：二分查找</p>
<p>/**<br> * @param {number} x<br> * @return {number}<br> <em>/<br>var mySqrt = function(x) {<br>    var begin = 0,end = x,result = 1,mid = 1;<br>    while(Math.abs(result-x) &gt; 0.000001){<br>        mid = (begin+end)/2;<br>        result = mid</em>mid;<br>        if(result &gt; x)   {end = mid;}<br>        else {begin = mid; }<br>    }<br>    return Math.floor(mid);<br>};</p>
<p>方法三：<a href="https://www.zhihu.com/question/20690553" target="_blank" rel="noopener">牛顿迭代法</a></p>
<p>/**<br> * @param {number} x<br> * @return {number}<br> <em>/<br>var mySqrt = function(x) {<br>    r = x;<br>    while (r</em>r &gt; x)<br>        r = ((r + x/r) / 2) | 0;<br>    return r;<br>};</p>
<h2 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155-Min Stack"></a><a href="https://leetcode.com/problems/min-stack/#/description" target="_blank" rel="noopener">155-Min Stack</a></h2><p>参考我的另一篇文章<a href="https://merrier.wang/?p=319">JS实现复杂数据结构</a></p>
<h2 id="414-Third-Maximum-Number"><a href="#414-Third-Maximum-Number" class="headerlink" title="414-Third Maximum Number"></a><a href="https://leetcode.com/problems/third-maximum-number/#/description" target="_blank" rel="noopener">414-Third Maximum Number</a></h2><p>方法一：遍历比较</p>
<p>/**<br> * @param {number[]} nums<br> * @return {number}<br> */<br>var thirdMax = function(nums) {<br>    var max1 = null,max2 = null,max3 = null;<br>    for (var i=0,len=nums.length;i&lt;len;i++) {<br>        var n = nums[i];<br>        if (n == max1 || n == max2 || n == max3) continue;<br>        if (max1 === null || n &gt; max1) {<br>            max3 = max2;<br>            max2 = max1;<br>            max1 = n;<br>        } else if (max2 === null || n &gt; max2) {<br>            max3 = max2;<br>            max2 = n;<br>        } else if (max3 === null || n &gt; max3) {<br>            max3 = n;<br>        }<br>    }<br>    return max3 === null ? max1 : max3;<br>};</p>
<p>方法二：先将数组排序再遍历</p>
<p>/**<br> * @param {number[]} nums<br> * @return {number}<br> */<br>var thirdMax = function(nums) {<br>    nums.sort(function(a,b){<br>        return b-a;<br>    });<br>    max1 = nums[0],i = 1,j=1;<br>    while(nums[i] == max1&amp;&amp;nums[i] !== undefined){<br>        i++;<br>        j++;<br>    }<br>    max2 = nums[i];<br>    while(nums[j] == max2&amp;&amp;nums[j] !== undefined){<br>        j++;<br>    }<br>    max3 = nums[j];<br>    return max3 === undefined ? max1 : max3;<br>};</p>
<h2 id="532-K-diff-Pairs-in-an-Array"><a href="#532-K-diff-Pairs-in-an-Array" class="headerlink" title="532-K-diff Pairs in an Array"></a><a href="https://leetcode.com/problems/k-diff-pairs-in-an-array/#/description" target="_blank" rel="noopener">532-K-diff Pairs in an Array</a></h2><p>方法一：两个指针，一个指针用来遍历，另一个指针用来寻找对应数字</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} k<br> * @return {number}<br> */<br>var findPairs = function(nums, k) {<br>    var ans = 0;<br>    nums.sort(function(a,b){<br>        return a-b;<br>    });<br>    for (var i = 0, j = 0; i &lt; nums.length; i++) {<br>        for (j = Math.max(j, i + 1); j &lt; nums.length &amp;&amp; nums[j] - nums[i] &lt; k; j++) ;<br>        if (j &lt; nums.length &amp;&amp;  nums[j] - nums[i] == k) ans++;<br>        while (i + 1 &lt; nums.length &amp;&amp; nums[i] == nums[i + 1]) {i++;}<br>    }<br>    return ans;<br>};</p>
<h2 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204-Count Primes"></a><a href="https://leetcode.com/problems/count-primes/#/description" target="_blank" rel="noopener">204-Count Primes</a></h2><p>方法一：质数（素数）判断思路-&gt;对正整数n，如果用2到根号n之间的所有整数去除，均无法整除，则n为质数</p>
<p>/**<br> * @param {number} n<br> * @return {number}<br> <em>/<br>var countPrimes = function(n) {<br>    if (n &lt; 3) return 0;<br>    var f = [],count = Math.floor(n / 2);<br>    for (var i = 3; i </em> i &lt; n; i += 2) {<br>        if (f[i]) {continue;}<br>        for (var j = i <em> i; j &lt; n; j += 2 </em> i) {<br>            if (!f[j]) {<br>                –count;<br>                f[j] = true;<br>            }<br>        }<br>    }<br>    return count;<br>};</p>
<h2 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125-Valid Palindrome"></a><a href="https://leetcode.com/problems/valid-palindrome/#/description" target="_blank" rel="noopener">125-Valid Palindrome</a></h2><p>方法一：二分查找</p>
<p>/**<br> * @param {string} s<br> * @return {boolean}<br> */<br>var isPalindrome = function(s) {<br>    if(s === ‘’){return true;}<br>    var low = s.replace(/\W/g,’’).toLowerCase();<br>    console.log(low);<br>    var left=0,right=low.length-1;<br>    while(left&lt;=right){<br>        if(low[left] != low[right]){<br>            return false;<br>        }<br>        left++;<br>        right–;<br>    }<br>    return true;<br>};</p>
<h2 id="168-Excel-Sheet-Column-Title"><a href="#168-Excel-Sheet-Column-Title" class="headerlink" title="168-Excel Sheet Column Title"></a><a href="https://leetcode.com/problems/excel-sheet-column-title/#/description" target="_blank" rel="noopener">168-Excel Sheet Column Title</a></h2><p>方法一：利用ASCII码进行递归，为了让余数为0-25，需要每次递归前将n减1</p>
<p>/**<br> * @param {number} n<br> * @return {string}<br> */<br>var convertToTitle = function(n) {<br>    var res = ‘’;<br>    while(n&gt;0){<br>        n–;<br>        res =  String.fromCharCode(n % 26 + 65)+res;<br>        n = Math.floor(n/26);<br>    }<br>    return res;<br>};</p>
<h2 id="278-First-Bad-Version"><a href="#278-First-Bad-Version" class="headerlink" title="278-First Bad Version"></a><a href="https://leetcode.com/problems/first-bad-version/#/description" target="_blank" rel="noopener">278-First Bad Version</a></h2><p>方法一：很常用的二分查找</p>
<p>/**<br> * Definition for isBadVersion()<br> *<br> * @param {integer} version number<br> * @return {boolean} whether the version is bad<br> * isBadVersion = function(version) {<br> *     …<br> * };<br> */</p>
<p>/**<br> * @param {function} isBadVersion()<br> * @return {function}<br> <em>/<br>var solution = function(isBadVersion) {<br>    /\</em>*<br>     * @param {integer} n Total versions<br>     * @return {integer} The first bad version<br>     */<br>    return function(n) {<br>        var left = 1,right=n;<br>        while(left&lt;right){<br>            min = Math.floor((left+right)/2);<br>            if(isBadVersion(min)){<br>                right = min;<br>            }else{<br>                left=min+1;<br>            }<br>        }<br>        return left;<br>    };<br>};</p>
<h2 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7-Reverse Integer"></a><a href="https://leetcode.com/problems/reverse-integer/#/description" target="_blank" rel="noopener">7-Reverse Integer</a></h2><p>方法一：利用数组的reverse()方法，需要注意的是符号位和int型溢出的处理</p>
<p>/**<br> * @param {number} x<br> * @return {number}<br> */<br>var reverse = function(x) {<br>    var res = Math.floor((‘’ + Math.abs(x)).split(‘’).reverse().join().replace(/,/g,’’));<br>    if(res &gt; (Math.pow(2,31)-1)){<br>        return 0;<br>    }<br>    return x&gt;0 ? res : 0- res;<br>};</p>
<p>方法二：利用数学计算进行反转</p>
<p>/**<br> * @param {number} x<br> * @return {number}<br> <em>/<br>var reverse = function(x) {<br>    var rev= 0,pos = Math.abs(x);<br>    while( pos !== 0){<br>        rev= rev</em>10 + pos % 10;<br>        pos= Math.floor(pos/10);<br>        if(Math.abs(rev)&gt;Math.pow(2,31)-1) return 0;<br>    }<br>    return x&gt;0 ? Math.floor(rev) : 0- Math.floor(rev);<br>};</p>
<h2 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189-Rotate Array"></a><a href="https://leetcode.com/problems/rotate-array/#/description" target="_blank" rel="noopener">189-Rotate Array</a></h2><p>方法一：利用数组的pop()和unshift()方法</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} k<br> * @return {void} Do not return anything, modify nums in-place instead.<br> */<br>var rotate = function(nums, k) {<br>    var len = nums.length;<br>    while(k&gt;0){<br>        nums.unshift(nums.pop());<br>        k–;<br>    }<br>};</p>
<p>方法二：三次反转</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} k<br> * @return {void} Do not return anything, modify nums in-place instead.<br> */<br>var rotate = function(nums, k) {<br>    k %= nums.length;<br>    reverse(nums, 0, nums.length - 1);<br>    reverse(nums, 0, k - 1);<br>    reverse(nums, k, nums.length - 1);<br>};</p>
<p>var reverse = function(nums,start,end) {<br>    while (start &lt; end) {<br>        var temp = nums[start];<br>        nums[start] = nums[end];<br>        nums[end] = temp;<br>        start++;<br>        end–;<br>    }<br>};</p>
<p>方法三：非常巧妙的一种方式，看不懂的可以<a href="https://discuss.leetcode.com/topic/11349/my-three-way-to-solve-this-problem-the-first-way-is-interesting-java" target="_blank" rel="noopener">点击这里</a>看作者的解释</p>
<p>/**<br> * @param {number[]} nums<br> * @param {number} k<br> * @return {void} Do not return anything, modify nums in-place instead.<br> */<br>var rotate = function(nums, k) {<br>    if(nums.length &lt;= 1){<br>        return;<br>    }<br>    //step each time to move<br>    var step = k % nums.length;<br>    //find GCD between nums length and step<br>    var gcd = findGcd(nums.length, step),position, count;<br>    //gcd path to finish movie<br>    for(var i = 0; i &lt; gcd; i++){<br>        //beginning position of each path<br>        position = i;<br>        //count is the number we need swap each path<br>        count = Math.floor(nums.length / gcd) - 1;<br>        for(var j = 0; j &lt; count; j++){<br>            position = (position + step) % nums.length;<br>            //swap index value in index i and position<br>            nums[i] ^= nums[position];<br>            nums[position] ^= nums[i];<br>            nums[i] ^= nums[position];<br>        }<br>    }<br>};</p>
<p>var findGcd = function(a,b){<br>    return (a === 0 || b === 0) ? a + b : findGcd(b, a % b);<br>};</p>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="/images/alipay_simple.png"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="/images/wepay_simple.png"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="//merrier.wang" target="_blank">Merrier说</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/20170326/complex-data-structure-implemented-by-js.html" class="pre-post btn btn-default" title="JS实现复杂数据结构">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">JS实现复杂数据结构</span>
        </a>
    
    
        <a href="/20170324/roman-numerals-converted-into-integers.html" class="next-post btn btn-default" title="罗马数字转换成整数（JS）">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">罗马数字转换成整数（JS）</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
  <script id="dsq-count-scr" src="https://merrier.disqus.com/count.js" async></script>


<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

<script type="text/javascript">
  if (document.getElementById('disqus_thread')) {
    var disqus_config = function () {
      this.page.url = 'http://merrier.wang/20170326/js-implementation-of-leetcode-easy-part2.html';
      this.page.identifier = '20170326/js-implementation-of-leetcode-easy-part2.html';
      this.page.title = 'Leetcode的JS实现——Easy篇（下）';
    };
    (function(){
      var d = document,
          s = d.createElement('script');
      s.async = true;
      s.src = 'https://merrier.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
</script>




    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#写在前面"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS代码实现"><span class="toc-text">JS代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="toc-text">121-Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#202-Happy-Number"><span class="toc-text">202-Happy Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#326-Power-of-Three"><span class="toc-text">326-Power of Three</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#327-Power-of-Two"><span class="toc-text">327-Power of Two</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-Remove-Duplicates-from-Sorted-List"><span class="toc-text">83-Remove Duplicates from Sorted List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-Climbing-Stairs"><span class="toc-text">70-Climbing Stairs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-Maximum-Subarray"><span class="toc-text">53-Maximum Subarray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-Path-Sum-III"><span class="toc-text">437-Path Sum III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#501-Find-Mode-in-Binary-Search-Tree"><span class="toc-text">501-Find Mode in Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#191-Number-of-1-Bits"><span class="toc-text">191-Number of 1 Bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-Search-Insert-Position"><span class="toc-text">35-Search Insert Position</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107-Binary-Tree-Level-Order-Traversal-II"><span class="toc-text">107-Binary Tree Level Order Traversal II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#263-Ugly-Number"><span class="toc-text">263-Ugly Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#459-Repeated-Substring-Pattern"><span class="toc-text">459-Repeated Substring Pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Merge-Two-Sorted-Lists"><span class="toc-text">21-Merge Two Sorted Lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-text">235-Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-House-Robber"><span class="toc-text">198-House Robber</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#342-Power-of-Four"><span class="toc-text">342-Power of Four</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#345-Reverse-Vowels-of-a-String"><span class="toc-text">345-Reverse Vowels of a String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#367-Valid-Perfect-Square"><span class="toc-text">367-Valid Perfect Square</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Remove-Element"><span class="toc-text">27-Remove Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-Symmetric-Tree"><span class="toc-text">101-Symmetric Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-Plus-One"><span class="toc-text">66-Plus One</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-Pascal’s-Triangle"><span class="toc-text">118-Pascal’s Triangle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#434-Number-of-Segments-in-a-String"><span class="toc-text">434. Number of Segments in a String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-Balanced-Binary-Tree"><span class="toc-text">110. Balanced Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#257-Binary-Tree-Paths"><span class="toc-text">257-Binary Tree Paths</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#441-Arranging-Coins"><span class="toc-text">441-Arranging Coins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#119-Pascal’s-Triangle-II"><span class="toc-text">119-Pascal’s Triangle II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#232-Implement-Queue-using-Stacks"><span class="toc-text">232-Implement Queue using Stacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-Linked-List-Cycle"><span class="toc-text">141-Linked List Cycle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Remove-Duplicates-from-Sorted-Array"><span class="toc-text">26-Remove Duplicates from Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#172-Factorial-Trailing-Zeroes"><span class="toc-text">172-Factorial Trailing Zeroes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Palindrome-Number"><span class="toc-text">9-Palindrome Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#374-Guess-Number-Higher-or-Lower"><span class="toc-text">374-Guess Number Higher or Lower</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-Find-All-Anagrams-in-a-String"><span class="toc-text">438-Find All Anagrams in a String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-Path-Sum"><span class="toc-text">112-Path Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-Count-and-Say"><span class="toc-text">38-Count and Say</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#250-Isomorphic-Strings"><span class="toc-text">250-Isomorphic Strings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Valid-Parentheses"><span class="toc-text">20-Valid Parentheses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="toc-text">111-Minimum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#290-Word-Pattern"><span class="toc-text">290-Word Pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-Palindrome-Linked-List"><span class="toc-text">234-Palindrome Linked List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Two-Sum"><span class="toc-text">1.Two Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#219-Contains-Duplicate-II"><span class="toc-text">219-Contains Duplicate II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#225-Implement-Stack-using-Queues"><span class="toc-text">225-Implement Stack using Queues</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-Merge-Sorted-Array"><span class="toc-text">88.Merge Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#203-Remove-Linked-List-Elements"><span class="toc-text">203-Remove Linked List Elements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-Length-of-Last-Word"><span class="toc-text">58.Length of Last Word</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#507-Perfect-Number"><span class="toc-text">507-Perfect Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-Add-Binary"><span class="toc-text">67-Add Binary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Longest-Common-Prefix"><span class="toc-text">14-Longest Common Prefix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="toc-text">160-Intersection of Two Linked Lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#400-Nth-Digit"><span class="toc-text">400-Nth Digit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#475-Heaters"><span class="toc-text">475. Heaters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#190-Reverse-Bits"><span class="toc-text">190-Reverse Bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#303-Range-Sum-Query-Immutable"><span class="toc-text">303-Range Sum Query - Immutable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Implement-strStr"><span class="toc-text">28-Implement strStr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-Sqrt-x"><span class="toc-text">69-Sqrt(x)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-Min-Stack"><span class="toc-text">155-Min Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#414-Third-Maximum-Number"><span class="toc-text">414-Third Maximum Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#532-K-diff-Pairs-in-an-Array"><span class="toc-text">532-K-diff Pairs in an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#204-Count-Primes"><span class="toc-text">204-Count Primes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125-Valid-Palindrome"><span class="toc-text">125-Valid Palindrome</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#168-Excel-Sheet-Column-Title"><span class="toc-text">168-Excel Sheet Column Title</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#278-First-Bad-Version"><span class="toc-text">278-First Bad Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Reverse-Integer"><span class="toc-text">7-Reverse Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-Rotate-Array"><span class="toc-text">189-Rotate Array</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2018
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




    <script src="/assets/tagcanvas.min.js?rev=2.9"></script>
    <script>
        var tagOption = {
            textColour: '#444', // 字体颜色
            outlineMethod: 'block', // 选中模式
            outlineColour: '#FFDAB9', // 选中模式的颜色
            interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
            textHeight: 13,
            outlineRadius: 3,
            freezeActive: true || '', // 选中的标签是否继续滚动
            frontSelect: true || '', // 不选标签云后部的标签
            initial: [0.1, -0.1],
            depth: 0.5,
            decel: 0.95,
            maxSpeed: 0.03,
            reverse: true || '', // 是否反向触发
            fadeIn: 500, // 进入动画时间
            wheelZoom: true || '' // 是否启用鼠标滚轮
        }
        TagCanvas.Start('tag-cloud-3d','',tagOption);
    </script>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>